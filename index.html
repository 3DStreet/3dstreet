<!DOCTYPE html>
<html>

<head>
  <!-- aframe -->

  <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
  <!-- 3dstreet -->
  <script src="./dist/aframe-street-component.js"></script>

  <!-- mapbox -->
  <script src="./dist/aframe-mapbox-component.min.js"></script>

  <!-- viewer controls - vr teleport -->
  <script src="https://cdn.jsdelivr.net/npm/aframe-blink-controls@0.4.3/dist/aframe-blink-controls.min.js"></script>

  <title>3DStreet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/x-icon" href="ui_assets/favicon.ico">
  <link rel="stylesheet" href="./dist/viewer-styles.css">
<script>
        AFRAME.registerComponent('cloud-shader', {
            schema: {
                translateSpeed: { type: 'number', default: 0.02 },
                evolutionSpeed: { type: 'number', default: 0.01 },
                scale: { type: 'number', default: 4.0 },
                coverage: { type: 'number', default: 0.85 }
            },

            init: function () {
                this.startTime = performance.now() / 1000;
                this.setupShader();
            },

            // Better Perlin noise implementation
            fade: function(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            },

            lerp: function(a, b, t) {
                return a + t * (b - a);
            },

            grad: function(hash, x, y) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            },

            setupShader: function () {
                const vertexShader = `
                    varying vec2 vUv;
                    
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;

                const fragmentShader = `
                    uniform float time;
                    uniform float translateSpeed;
                    uniform float evolutionSpeed;
                    uniform float scale;
                    uniform float coverage;
                    varying vec2 vUv;

                    // Hash functions for noise
                    float hash(vec2 p) {
                        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                    }

                    float hash(vec3 p) {
                        return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);
                    }

                    vec3 hash33(vec3 p) {
                        p = vec3(dot(p, vec3(127.1, 311.7, 74.7)),
                                dot(p, vec3(269.5, 183.3, 246.1)),
                                dot(p, vec3(113.5, 271.9, 124.6)));
                        return fract(sin(p) * 43758.5453123);
                    }

                    // Improved gradient noise
                    float gradientNoise(vec3 x) {
                        vec3 p = floor(x);
                        vec3 w = fract(x);
                        
                        vec3 u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);
                        
                        vec3 ga = hash33(p + vec3(0.0, 0.0, 0.0));
                        vec3 gb = hash33(p + vec3(1.0, 0.0, 0.0));
                        vec3 gc = hash33(p + vec3(0.0, 1.0, 0.0));
                        vec3 gd = hash33(p + vec3(1.0, 1.0, 0.0));
                        vec3 ge = hash33(p + vec3(0.0, 0.0, 1.0));
                        vec3 gf = hash33(p + vec3(1.0, 0.0, 1.0));
                        vec3 gg = hash33(p + vec3(0.0, 1.0, 1.0));
                        vec3 gh = hash33(p + vec3(1.0, 1.0, 1.0));
                        
                        // Normalize gradients
                        ga = normalize(ga - 0.5);
                        gb = normalize(gb - 0.5);
                        gc = normalize(gc - 0.5);
                        gd = normalize(gd - 0.5);
                        ge = normalize(ge - 0.5);
                        gf = normalize(gf - 0.5);
                        gg = normalize(gg - 0.5);
                        gh = normalize(gh - 0.5);
                        
                        float va = dot(ga, w - vec3(0.0, 0.0, 0.0));
                        float vb = dot(gb, w - vec3(1.0, 0.0, 0.0));
                        float vc = dot(gc, w - vec3(0.0, 1.0, 0.0));
                        float vd = dot(gd, w - vec3(1.0, 1.0, 0.0));
                        float ve = dot(ge, w - vec3(0.0, 0.0, 1.0));
                        float vf = dot(gf, w - vec3(1.0, 0.0, 1.0));
                        float vg = dot(gg, w - vec3(0.0, 1.0, 1.0));
                        float vh = dot(gh, w - vec3(1.0, 1.0, 1.0));
                        
                        return va + 
                               u.x * (vb - va) + 
                               u.y * (vc - va) + 
                               u.z * (ve - va) + 
                               u.x * u.y * (va - vb - vc + vd) + 
                               u.y * u.z * (va - vc - ve + vg) + 
                               u.z * u.x * (va - vb - ve + vf) + 
                               u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);
                    }

                    // Worley noise
                    float worleyNoise(vec3 uv) {    
                        vec3 id = floor(uv);
                        vec3 p = fract(uv);
                        
                        float minDist = 10000.0;
                        for (float x = -1.0; x <= 1.0; ++x) {
                            for(float y = -1.0; y <= 1.0; ++y) {
                                for(float z = -1.0; z <= 1.0; ++z) {
                                    vec3 offset = vec3(x, y, z);
                                    vec3 h = hash33(id + offset) * 0.5 + 0.5;
                                    h += offset;
                                    vec3 d = p - h;
                                    minDist = min(minDist, dot(d, d));
                                }
                            }
                        }
                        
                        return 1.0 - minDist;
                    }

                    // FBM for Perlin noise
                    float perlinfbm(vec3 p, int octaves) {
                        float G = exp2(-0.85);
                        float amp = 1.0;
                        float noise = 0.0;
                        for (int i = 0; i < 7; ++i) {
                            if (i >= octaves) break;
                            noise += amp * gradientNoise(p);
                            p *= 2.0;
                            amp *= G;
                        }
                        return noise;
                    }

                    // Worley FBM
                    float worleyFbm(vec3 p) {
                        return worleyNoise(p) * 0.625 +
                               worleyNoise(p * 2.0) * 0.25 +
                               worleyNoise(p * 4.0) * 0.125;
                    }

                    float remap(float x, float a, float b, float c, float d) {
                        return (((x - a) / (b - a)) * (d - c)) + c;
                    }

                    void main() {
                        vec2 uv = vUv;
                        uv -= translateSpeed * time; // Translation movement
                        
                        // Create 3D coordinates with time for animation
                        vec3 pos = vec3(uv * scale, time * evolutionSpeed); // Evolution through 3D volume
                        
                        // Generate noise with time evolution
                        float pfbm = mix(1.0, perlinfbm(pos, 7), 0.5);
                        pfbm = abs(pfbm * 2.0 - 1.0); // billowy perlin noise
                        
                        // Generate worley noise components
                        float worley1 = worleyFbm(pos);
                        float worley2 = worleyFbm(pos * 2.0);
                        float worley3 = worleyFbm(pos * 4.0);
                        
                        // Combine worley components
                        float wfbm = worley1 * 0.625 + worley2 * 0.25 + worley3 * 0.125;
                        
                        // Create perlin-worley combination
                        float perlinWorley = remap(pfbm, 0.0, 1.0, worley1, 1.0);
                        
                        // Final cloud shape
                        float cloud = remap(perlinWorley, wfbm - 1.0, 1.0, 0.0, 1.0);
                        cloud = remap(cloud, coverage, 1.0, 0.0, 1.0);
                        cloud = max(0.0, cloud);
                        
                        gl_FragColor = vec4(cloud, cloud, cloud, 1.0);
                    }
                `;

                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        translateSpeed: { value: this.data.translateSpeed },
                        evolutionSpeed: { value: this.data.evolutionSpeed },
                        scale: { value: this.data.scale },
                        coverage: { value: this.data.coverage }
                    },
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    transparent: true
                });

                this.el.getObject3D('mesh').material = material;
                this.material = material;
            },

            tick: function () {
                if (this.material) {
                    const currentTime = performance.now() / 1000;
                    this.material.uniforms.time.value = currentTime - this.startTime;
                }
            },

            update: function (oldData) {
                if (this.material) {
                    this.material.uniforms.translateSpeed.value = this.data.translateSpeed;
                    this.material.uniforms.evolutionSpeed.value = this.data.evolutionSpeed;
                    this.material.uniforms.scale.value = this.data.scale;
                    this.material.uniforms.coverage.value = this.data.coverage;
                }
            }
        });
    </script>
</head>

<body>
  <img id="screenshot-img" src="ui_assets/3DStreet-Viewer-Start-Editor.svg" alt="Invisible Image" style="display:none;">
  <!-- loading animation start -->
  <div class="loader__wrapper">
    <div class="loader">
      <div class="road">Loading 3DStreet</div>
    </div>
  </div>
  <!-- viewer ui start -->
  <!-- <div class="viewer-header-wrapper m-4">
    <button class="viewer-logo-start-editor-button" onclick="startEditor()">
      <img class="viewer-logo-img" alt="3DStreet Viewer" src="ui_assets/3D-St-stacked-128.png">
    </button>
  </div> -->

  <!-- maps copyright start -->
  <div id="map-data-attribution" style="visibility: hidden;">
    <div id="map-logo">Map Attribution:</div>
    <span id="map-copyright"></span>
  </div>

  <!-- <div class="right-fixed">
    <ul class="right-menu">
      <li onclick="buttonScreenshotTock()"> <a class="camera" href="#"> <span> Capture image as PNG </span> <img
            src="ui_assets/camera-icon.svg"> </a></li>
      <li onclick="STREET.utils.inputStreetmix()"> <a class="load" href="#"> <span> Load Streetmix URL </span> <img
            src="ui_assets/streetmix-logo.svg"> </a></li>
      <li onclick="inputJSON()"> <a class="load"  href="#"> <span> Load JSON String </span> <img src="assets/ui_assets/upload-icon.svg"> </a></li>
      <li><a class="load"> <label for="inputfile" style="display: inherit; align-items: center; cursor: pointer"> <input
              type="file" id="inputfile" style="display:none" accept=".js, .json, .txt"> <span> Load JSON File </span>
            <img src="ui_assets/upload-icon.svg"></label></a></li>
    </ul>
  </div> -->

  <a-scene
    renderer="colorManagement: true; physicallyCorrectLights: true; anisotropy: 16; logarithmicDepthBuffer: true;"
    loading-screen="enabled: false" notify metadata
    reflection device-orientation-permission-ui="enabled: false"
    webxr="requiredFeatures:hit-test,local-floor;referenceSpaceType:local-floor;" xr-mode-ui="XRMode: ar"
    css2d-renderer>
    <a-assets>
      <!-- TODO: Add this to repo documentation  -->
      <!-- you can specify a custom asset path using below syntax  -->

      <!-- uncomment the line below to load assets from local github submodule -->
      <!-- <street-assets url="./assets/"></street-assets>   -->

      <!-- you can specify a subset of categories of objects to load using below syntax  -->

      <!-- uncomment the line below to load all possible asset categories -->
      <!-- <street-assets categories="sidewalk-props people people-rigged vehicles vehicles-rigged buildings intersection-props segment-textures segment-colors lane-separator stencils vehicles-transit dividers sky grounds"></street-assets>   -->

      <!-- a reduced set of assets for non-animated streetmix streets without intersections -->
      <!-- <street-assets categories="loud-bicycle sidewalk-props people vehicles vehicles-rigged buildings segment-textures segment-colors lane-separator stencils vehicles-transit dividers sky grounds"></street-assets> -->

    </a-assets>

    <a-entity id="street-container" data-layer-name="User Layers" data-no-transform>
      <a-entity id="default-street" street streetmix-loader set-loader-from-hash></a-entity>
        <a-plane 
            position="0 0 0" 
            rotation="-90 0 0"
            width="40" 
            height="40" 
            cloud-shader="speed: 0.2; scale: 1; coverage: 0.85">
        </a-plane>
    </a-entity>

    <a-entity id="reference-layers" data-layer-name="Geospatial Layers" data-no-transform></a-entity>

    <a-entity id="environment" data-layer-name="Environment" street-environment="preset: day;" data-no-transform></a-entity>

    <a-entity id="cameraRig" class="ph-no-capture" data-layer-name="Viewer" data-no-transform
      cursor-teleport="cameraRig: #cameraRig; cameraHead: #camera;"
      movement-controls="camera: #camera; fly: true">
      <a-entity id="camera" data-layer-name="Camera" position="0 1.6 0" camera look-controls="reverseMouseDrag: true" class="autocreated"></a-entity>
      <a-entity id="leftHand" hand-controls="hand: left;" data-layer-name="Left Controls" class="autocreated" data-no-transform=""
        blink-controls="cameraRig: #cameraRig; teleportOrigin: #camera; rotateOnTeleport:false;"></a-entity>
      <a-entity id="rightHand" hand-controls="hand: right" data-layer-name="Right Controls" class="autocreated" data-no-transform=""
        blink-controls="cameraRig: #cameraRig; teleportOrigin: #camera; rotateOnTeleport:false;"></a-entity>
      <a-entity
        id="screenshot"
        data-layer-name="Focus Animation"
        data-no-pause=""
        data-no-transform=""
        focus-animation
        screentock
        visible="false"
        class="autocreated"
      ></a-entity>
    </a-entity>

  </a-scene>
</body>
<script>
  /* loading animation script */
  document.addEventListener('DOMContentLoaded', function () {
    const scene = document.querySelector('a-scene');
    const splash = document.querySelector('.loader__wrapper');
    scene.addEventListener('loaded', function (e) {
      setTimeout(() => {
        splash.style.display = 'none';
      }, 1000);
    });
  });
</script>

</html>
