/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("THREE"));
	else if(typeof define === 'function' && define.amd)
		define(["THREE"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("THREE")) : factory(root["THREE"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, (__WEBPACK_EXTERNAL_MODULE_three__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/three-loader-3dtiles.js":
/*!**************************************!*\
  !*** ./dist/three-loader-3dtiles.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Loader3DTiles\": () => (/* binding */ _B),\n/* harmony export */   \"PointCloudColoring\": () => (/* binding */ _c),\n/* harmony export */   \"Shading\": () => (/* binding */ Dn)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three/examples/jsm/loaders/KTX2Loader.js */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n\n\nasync function He(e, t, n, s) {\n  return s._parse(e, t, n, s);\n}\n\nfunction U(e, t) {\n  if (!e) throw new Error(t || \"loader assertion failed.\");\n}\n\nconst Ln = !!(typeof process != \"object\" || String(process) !== \"[object process]\" || process.browser),\n      Pr = typeof process < \"u\" && process.version && /v([0-9]*)/.exec(process.version);\nPr && parseFloat(Pr[1]);\n\nfunction kc(e, t) {\n  return vo(e || {}, t);\n}\n\nfunction vo(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  if (n > 3) return t;\n  const s = { ...e\n  };\n\n  for (const [r, i] of Object.entries(t)) i && typeof i == \"object\" && !Array.isArray(i) ? s[r] = vo(s[r] || {}, t[r], n + 1) : s[r] = t[r];\n\n  return s;\n}\n\nconst Kc = \"latest\";\n\nfunction zc() {\n  var e;\n  return (e = globalThis._loadersgl_) !== null && e !== void 0 && e.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = \"4.1.1\"), globalThis._loadersgl_.version;\n}\n\nconst Do = zc();\n\nfunction Nt(e, t) {\n  if (!e) throw new Error(t || \"loaders.gl assertion failed.\");\n}\n\nconst Et = typeof process != \"object\" || String(process) !== \"[object process]\" || process.browser,\n      nr = typeof importScripts == \"function\",\n      Wc = typeof window < \"u\" && typeof window.orientation < \"u\",\n      Nr = typeof process < \"u\" && process.version && /v([0-9]*)/.exec(process.version);\nNr && parseFloat(Nr[1]);\n\nclass Xc {\n  constructor(t, n) {\n    this.name = void 0, this.workerThread = void 0, this.isRunning = !0, this.result = void 0, this._resolve = () => {}, this._reject = () => {}, this.name = t, this.workerThread = n, this.result = new Promise((s, r) => {\n      this._resolve = s, this._reject = r;\n    });\n  }\n\n  postMessage(t, n) {\n    this.workerThread.postMessage({\n      source: \"loaders.gl\",\n      type: t,\n      payload: n\n    });\n  }\n\n  done(t) {\n    Nt(this.isRunning), this.isRunning = !1, this._resolve(t);\n  }\n\n  error(t) {\n    Nt(this.isRunning), this.isRunning = !1, this._reject(t);\n  }\n\n}\n\nclass qn {\n  terminate() {}\n\n}\n\nconst Yn = /* @__PURE__ */new Map();\n\nfunction Qc(e) {\n  Nt(e.source && !e.url || !e.source && e.url);\n  let t = Yn.get(e.source || e.url);\n  return t || (e.url && (t = qc(e.url), Yn.set(e.url, t)), e.source && (t = Lo(e.source), Yn.set(e.source, t))), Nt(t), t;\n}\n\nfunction qc(e) {\n  if (!e.startsWith(\"http\")) return e;\n  const t = Yc(e);\n  return Lo(t);\n}\n\nfunction Lo(e) {\n  const t = new Blob([e], {\n    type: \"application/javascript\"\n  });\n  return URL.createObjectURL(t);\n}\n\nfunction Yc(e) {\n  return `try {\n  importScripts('${e}');\n} catch (error) {\n  console.error(error);\n  throw error;\n}`;\n}\n\nfunction Go(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0,\n      n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = n || /* @__PURE__ */new Set();\n\n  if (e) {\n    if (Ur(e)) s.add(e);else if (Ur(e.buffer)) s.add(e.buffer);else if (!ArrayBuffer.isView(e)) {\n      if (t && typeof e == \"object\") for (const r in e) Go(e[r], t, s);\n    }\n  }\n\n  return n === void 0 ? Array.from(s) : [];\n}\n\nfunction Ur(e) {\n  return e ? e instanceof ArrayBuffer || typeof MessagePort < \"u\" && e instanceof MessagePort || typeof ImageBitmap < \"u\" && e instanceof ImageBitmap || typeof OffscreenCanvas < \"u\" && e instanceof OffscreenCanvas : !1;\n}\n\nconst $n = () => {};\n\nclass Ds {\n  static isSupported() {\n    return typeof Worker < \"u\" && Et || typeof qn < \"u\" && !Et;\n  }\n\n  constructor(t) {\n    this.name = void 0, this.source = void 0, this.url = void 0, this.terminated = !1, this.worker = void 0, this.onMessage = void 0, this.onError = void 0, this._loadableURL = \"\";\n    const {\n      name: n,\n      source: s,\n      url: r\n    } = t;\n    Nt(s || r), this.name = n, this.source = s, this.url = r, this.onMessage = $n, this.onError = i => console.log(i), this.worker = Et ? this._createBrowserWorker() : this._createNodeWorker();\n  }\n\n  destroy() {\n    this.onMessage = $n, this.onError = $n, this.worker.terminate(), this.terminated = !0;\n  }\n\n  get isRunning() {\n    return !!this.onMessage;\n  }\n\n  postMessage(t, n) {\n    n = n || Go(t), this.worker.postMessage(t, n);\n  }\n\n  _getErrorFromErrorEvent(t) {\n    let n = \"Failed to load \";\n    return n += `worker ${this.name} from ${this.url}. `, t.message && (n += `${t.message} in `), t.lineno && (n += `:${t.lineno}:${t.colno}`), new Error(n);\n  }\n\n  _createBrowserWorker() {\n    this._loadableURL = Qc({\n      source: this.source,\n      url: this.url\n    });\n    const t = new Worker(this._loadableURL, {\n      name: this.name\n    });\n    return t.onmessage = n => {\n      n.data ? this.onMessage(n.data) : this.onError(new Error(\"No data received\"));\n    }, t.onerror = n => {\n      this.onError(this._getErrorFromErrorEvent(n)), this.terminated = !0;\n    }, t.onmessageerror = n => console.error(n), t;\n  }\n\n  _createNodeWorker() {\n    let t;\n\n    if (this.url) {\n      const s = this.url.includes(\":/\") || this.url.startsWith(\"/\") ? this.url : `./${this.url}`;\n      t = new qn(s, {\n        eval: !1\n      });\n    } else if (this.source) t = new qn(this.source, {\n      eval: !0\n    });else throw new Error(\"no worker\");\n\n    return t.on(\"message\", n => {\n      this.onMessage(n);\n    }), t.on(\"error\", n => {\n      this.onError(n);\n    }), t.on(\"exit\", n => {}), t;\n  }\n\n}\n\nclass $c {\n  static isSupported() {\n    return Ds.isSupported();\n  }\n\n  constructor(t) {\n    this.name = \"unnamed\", this.source = void 0, this.url = void 0, this.maxConcurrency = 1, this.maxMobileConcurrency = 1, this.onDebug = () => {}, this.reuseWorkers = !0, this.props = {}, this.jobQueue = [], this.idleQueue = [], this.count = 0, this.isDestroyed = !1, this.source = t.source, this.url = t.url, this.setProps(t);\n  }\n\n  destroy() {\n    this.idleQueue.forEach(t => t.destroy()), this.isDestroyed = !0;\n  }\n\n  setProps(t) {\n    this.props = { ...this.props,\n      ...t\n    }, t.name !== void 0 && (this.name = t.name), t.maxConcurrency !== void 0 && (this.maxConcurrency = t.maxConcurrency), t.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = t.maxMobileConcurrency), t.reuseWorkers !== void 0 && (this.reuseWorkers = t.reuseWorkers), t.onDebug !== void 0 && (this.onDebug = t.onDebug);\n  }\n\n  async startJob(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (i, o, a) => i.done(a),\n        s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (i, o) => i.error(o);\n    const r = new Promise(i => (this.jobQueue.push({\n      name: t,\n      onMessage: n,\n      onError: s,\n      onStart: i\n    }), this));\n    return this._startQueuedJob(), await r;\n  }\n\n  async _startQueuedJob() {\n    if (!this.jobQueue.length) return;\n\n    const t = this._getAvailableWorker();\n\n    if (!t) return;\n    const n = this.jobQueue.shift();\n\n    if (n) {\n      this.onDebug({\n        message: \"Starting job\",\n        name: n.name,\n        workerThread: t,\n        backlog: this.jobQueue.length\n      });\n      const s = new Xc(n.name, t);\n      t.onMessage = r => n.onMessage(s, r.type, r.payload), t.onError = r => n.onError(s, r), n.onStart(s);\n\n      try {\n        await s.result;\n      } catch (r) {\n        console.error(`Worker exception: ${r}`);\n      } finally {\n        this.returnWorkerToQueue(t);\n      }\n    }\n  }\n\n  returnWorkerToQueue(t) {\n    !Et || this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency() ? (t.destroy(), this.count--) : this.idleQueue.push(t), this.isDestroyed || this._startQueuedJob();\n  }\n\n  _getAvailableWorker() {\n    if (this.idleQueue.length > 0) return this.idleQueue.shift() || null;\n\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const t = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new Ds({\n        name: t,\n        source: this.source,\n        url: this.url\n      });\n    }\n\n    return null;\n  }\n\n  _getMaxConcurrency() {\n    return Wc ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n\n}\n\nconst Zc = {\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  reuseWorkers: !0,\n  onDebug: () => {}\n};\n\nclass Lt {\n  static isSupported() {\n    return Ds.isSupported();\n  }\n\n  static getWorkerFarm() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    return Lt._workerFarm = Lt._workerFarm || new Lt({}), Lt._workerFarm.setProps(t), Lt._workerFarm;\n  }\n\n  constructor(t) {\n    this.props = void 0, this.workerPools = /* @__PURE__ */new Map(), this.props = { ...Zc\n    }, this.setProps(t), this.workerPools = /* @__PURE__ */new Map();\n  }\n\n  destroy() {\n    for (const t of this.workerPools.values()) t.destroy();\n\n    this.workerPools = /* @__PURE__ */new Map();\n  }\n\n  setProps(t) {\n    this.props = { ...this.props,\n      ...t\n    };\n\n    for (const n of this.workerPools.values()) n.setProps(this._getWorkerPoolProps());\n  }\n\n  getWorkerPool(t) {\n    const {\n      name: n,\n      source: s,\n      url: r\n    } = t;\n    let i = this.workerPools.get(n);\n    return i || (i = new $c({\n      name: n,\n      source: s,\n      url: r\n    }), i.setProps(this._getWorkerPoolProps()), this.workerPools.set(n, i)), i;\n  }\n\n  _getWorkerPoolProps() {\n    return {\n      maxConcurrency: this.props.maxConcurrency,\n      maxMobileConcurrency: this.props.maxMobileConcurrency,\n      reuseWorkers: this.props.reuseWorkers,\n      onDebug: this.props.onDebug\n    };\n  }\n\n}\n\nLt._workerFarm = void 0;\n\nfunction tu(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  const n = t[e.id] || {},\n        s = Et ? `${e.id}-worker.js` : `${e.id}-worker-node.js`;\n  let r = n.workerUrl;\n\n  if (!r && e.id === \"compression\" && (r = t.workerUrl), t._workerType === \"test\" && (Et ? r = `modules/${e.module}/dist/${s}` : r = `modules/${e.module}/src/workers/${e.id}-worker-node.ts`), !r) {\n    let i = e.version;\n    i === \"latest\" && (i = Kc);\n    const o = i ? `@${i}` : \"\";\n    r = `https://unpkg.com/@loaders.gl/${e.module}${o}/dist/${s}`;\n  }\n\n  return Nt(r), r;\n}\n\nfunction eu(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Do;\n  Nt(e, \"no worker provided\");\n  const n = e.version;\n  return !(!t || !n);\n}\n\nconst nu = {},\n      su = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  default: nu\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      Zn = {};\n\nasync function Xt(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,\n      n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},\n      s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n  return t && (e = ru(e, t, n, s)), Zn[e] = Zn[e] || iu(e), await Zn[e];\n}\n\nfunction ru(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},\n      s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n  if (!n.useLocalLibraries && e.startsWith(\"http\")) return e;\n  s = s || e;\n  const r = n.modules || {};\n  return r[s] ? r[s] : Et ? n.CDN ? (Nt(n.CDN.startsWith(\"http\")), `${n.CDN}/${t}@${Do}/dist/libs/${s}`) : nr ? `../src/libs/${s}` : `modules/${t}/src/libs/${s}` : `modules/${t}/dist/libs/${s}`;\n}\n\nasync function iu(e) {\n  if (e.endsWith(\"wasm\")) return await au(e);\n  if (!Et) try {\n    return su && void 0;\n  } catch (n) {\n    return console.error(n), null;\n  }\n  if (nr) return importScripts(e);\n  const t = await cu(e);\n  return ou(t, e);\n}\n\nfunction ou(e, t) {\n  if (!Et) return;\n  if (nr) return eval.call(globalThis, e), null;\n  const n = document.createElement(\"script\");\n  n.id = t;\n\n  try {\n    n.appendChild(document.createTextNode(e));\n  } catch {\n    n.text = e;\n  }\n\n  return document.body.appendChild(n), null;\n}\n\nasync function au(e) {\n  return await (await fetch(e)).arrayBuffer();\n}\n\nasync function cu(e) {\n  return await (await fetch(e)).text();\n}\n\nfunction uu(e, t) {\n  return !Lt.isSupported() || !Et && !(t != null && t._nodeWorkers) ? !1 : e.worker && (t == null ? void 0 : t.worker);\n}\n\nasync function lu(e, t, n, s, r) {\n  const i = e.id,\n        o = tu(e, n),\n        c = Lt.getWorkerFarm(n).getWorkerPool({\n    name: i,\n    url: o\n  });\n  n = JSON.parse(JSON.stringify(n)), s = JSON.parse(JSON.stringify(s || {}));\n  const u = await c.startJob(\"process-on-worker\", hu.bind(null, r));\n  return u.postMessage(\"process\", {\n    input: t,\n    options: n,\n    context: s\n  }), await (await u.result).result;\n}\n\nasync function hu(e, t, n, s) {\n  switch (n) {\n    case \"done\":\n      t.done(s);\n      break;\n\n    case \"error\":\n      t.error(new Error(s.error));\n      break;\n\n    case \"process\":\n      const {\n        id: r,\n        input: i,\n        options: o\n      } = s;\n\n      try {\n        const a = await e(i, o);\n        t.postMessage(\"done\", {\n          id: r,\n          result: a\n        });\n      } catch (a) {\n        const c = a instanceof Error ? a.message : \"unknown error\";\n        t.postMessage(\"error\", {\n          id: r,\n          error: c\n        });\n      }\n\n      break;\n\n    default:\n      console.warn(`parse-with-worker unknown message ${n}`);\n  }\n}\n\nfunction fu(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;\n  return typeof e == \"string\" ? e.slice(0, t) : ArrayBuffer.isView(e) ? Hr(e.buffer, e.byteOffset, t) : e instanceof ArrayBuffer ? Hr(e, 0, t) : \"\";\n}\n\nfunction Hr(e, t, n) {\n  if (e.byteLength <= t + n) return \"\";\n  const s = new DataView(e);\n  let r = \"\";\n\n  for (let i = 0; i < n; i++) r += String.fromCharCode(s.getUint8(t + i));\n\n  return r;\n}\n\nfunction du(e) {\n  try {\n    return JSON.parse(e);\n  } catch {\n    throw new Error(`Failed to parse JSON from data starting with \"${fu(e)}\"`);\n  }\n}\n\nfunction mu(e, t, n) {\n  if (n = n || e.byteLength, e.byteLength < n || t.byteLength < n) return !1;\n  const s = new Uint8Array(e),\n        r = new Uint8Array(t);\n\n  for (let i = 0; i < s.length; ++i) if (s[i] !== r[i]) return !1;\n\n  return !0;\n}\n\nfunction gu() {\n  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];\n\n  return Au(t);\n}\n\nfunction Au(e) {\n  const t = e.map(i => i instanceof ArrayBuffer ? new Uint8Array(i) : i),\n        n = t.reduce((i, o) => i + o.byteLength, 0),\n        s = new Uint8Array(n);\n  let r = 0;\n\n  for (const i of t) s.set(i, r), r += i.byteLength;\n\n  return s.buffer;\n}\n\nfunction sr(e, t, n) {\n  const s = n !== void 0 ? new Uint8Array(e).subarray(t, t + n) : new Uint8Array(e).subarray(t);\n  return new Uint8Array(s).buffer;\n}\n\nfunction Je(e, t) {\n  return U(e >= 0), U(t > 0), e + (t - 1) & ~(t - 1);\n}\n\nfunction pu(e, t, n) {\n  let s;\n  if (e instanceof ArrayBuffer) s = new Uint8Array(e);else {\n    const r = e.byteOffset,\n          i = e.byteLength;\n    s = new Uint8Array(e.buffer || e.arrayBuffer, r, i);\n  }\n  return t.set(s, n), n + Je(s.byteLength, 4);\n}\n\nasync function yu(e) {\n  const t = [];\n\n  for await (const n of e) t.push(n);\n\n  return gu(...t);\n}\n\nfunction Jr() {\n  let e;\n  if (typeof window < \"u\" && window.performance) e = window.performance.now();else if (typeof process < \"u\" && process.hrtime) {\n    const t = process.hrtime();\n    e = t[0] * 1e3 + t[1] / 1e6;\n  } else e = Date.now();\n  return e;\n}\n\nclass Vr {\n  constructor(t, n) {\n    this.name = void 0, this.type = void 0, this.sampleSize = 1, this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this.name = t, this.type = n, this.reset();\n  }\n\n  reset() {\n    return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this;\n  }\n\n  setSampleSize(t) {\n    return this.sampleSize = t, this;\n  }\n\n  incrementCount() {\n    return this.addCount(1), this;\n  }\n\n  decrementCount() {\n    return this.subtractCount(1), this;\n  }\n\n  addCount(t) {\n    return this._count += t, this._samples++, this._checkSampling(), this;\n  }\n\n  subtractCount(t) {\n    return this._count -= t, this._samples++, this._checkSampling(), this;\n  }\n\n  addTime(t) {\n    return this._time += t, this.lastTiming = t, this._samples++, this._checkSampling(), this;\n  }\n\n  timeStart() {\n    return this._startTime = Jr(), this._timerPending = !0, this;\n  }\n\n  timeEnd() {\n    return this._timerPending ? (this.addTime(Jr() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this;\n  }\n\n  getSampleAverageCount() {\n    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;\n  }\n\n  getSampleAverageTime() {\n    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;\n  }\n\n  getSampleHz() {\n    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;\n  }\n\n  getAverageCount() {\n    return this.samples > 0 ? this.count / this.samples : 0;\n  }\n\n  getAverageTime() {\n    return this.samples > 0 ? this.time / this.samples : 0;\n  }\n\n  getHz() {\n    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;\n  }\n\n  _checkSampling() {\n    this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0);\n  }\n\n}\n\nclass Po {\n  constructor(t) {\n    this.id = void 0, this.stats = {}, this.id = t.id, this.stats = {}, this._initializeStats(t.stats), Object.seal(this);\n  }\n\n  get(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"count\";\n    return this._getOrCreate({\n      name: t,\n      type: n\n    });\n  }\n\n  get size() {\n    return Object.keys(this.stats).length;\n  }\n\n  reset() {\n    for (const t of Object.values(this.stats)) t.reset();\n\n    return this;\n  }\n\n  forEach(t) {\n    for (const n of Object.values(this.stats)) t(n);\n  }\n\n  getTable() {\n    const t = {};\n    return this.forEach(n => {\n      t[n.name] = {\n        time: n.time || 0,\n        count: n.count || 0,\n        average: n.getAverageTime() || 0,\n        hz: n.getHz() || 0\n      };\n    }), t;\n  }\n\n  _initializeStats() {\n    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach(n => this._getOrCreate(n));\n  }\n\n  _getOrCreate(t) {\n    const {\n      name: n,\n      type: s\n    } = t;\n    let r = this.stats[n];\n    return r || (t instanceof Vr ? r = t : r = new Vr(n, s), this.stats[n] = r), r;\n  }\n\n}\n\nconst Bu = \"Queued Requests\",\n      Cu = \"Active Requests\",\n      Eu = \"Cancelled Requests\",\n      Tu = \"Queued Requests Ever\",\n      bu = \"Active Requests Ever\",\n      _u = {\n  id: \"request-scheduler\",\n  throttleRequests: !0,\n  maxRequests: 6\n};\n\nclass wu {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    this.props = void 0, this.stats = void 0, this.activeRequestCount = 0, this.requestQueue = [], this.requestMap = /* @__PURE__ */new Map(), this.deferredUpdate = null, this.props = { ..._u,\n      ...t\n    }, this.stats = new Po({\n      id: this.props.id\n    }), this.stats.get(Bu), this.stats.get(Cu), this.stats.get(Eu), this.stats.get(Tu), this.stats.get(bu);\n  }\n\n  scheduleRequest(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => 0;\n    if (!this.props.throttleRequests) return Promise.resolve({\n      done: () => {}\n    });\n    if (this.requestMap.has(t)) return this.requestMap.get(t);\n    const s = {\n      handle: t,\n      priority: 0,\n      getPriority: n\n    },\n          r = new Promise(i => (s.resolve = i, s));\n    return this.requestQueue.push(s), this.requestMap.set(t, r), this._issueNewRequests(), r;\n  }\n\n  _issueRequest(t) {\n    const {\n      handle: n,\n      resolve: s\n    } = t;\n    let r = !1;\n\n    const i = () => {\n      r || (r = !0, this.requestMap.delete(n), this.activeRequestCount--, this._issueNewRequests());\n    };\n\n    return this.activeRequestCount++, s ? s({\n      done: i\n    }) : Promise.resolve({\n      done: i\n    });\n  }\n\n  _issueNewRequests() {\n    this.deferredUpdate || (this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0));\n  }\n\n  _issueNewRequestsAsync() {\n    this.deferredUpdate = null;\n    const t = Math.max(this.props.maxRequests - this.activeRequestCount, 0);\n\n    if (t !== 0) {\n      this._updateAllRequests();\n\n      for (let n = 0; n < t; ++n) {\n        const s = this.requestQueue.shift();\n        s && this._issueRequest(s);\n      }\n    }\n  }\n\n  _updateAllRequests() {\n    const t = this.requestQueue;\n\n    for (let n = 0; n < t.length; ++n) {\n      const s = t[n];\n      this._updateRequest(s) || (t.splice(n, 1), this.requestMap.delete(s.handle), n--);\n    }\n\n    t.sort((n, s) => n.priority - s.priority);\n  }\n\n  _updateRequest(t) {\n    return t.priority = t.getPriority(t.handle), t.priority < 0 ? (t.resolve(null), !1) : !0;\n  }\n\n}\n\nlet Ru = \"\";\nconst jr = {};\n\nfunction Mu(e) {\n  for (const t in jr) if (e.startsWith(t)) {\n    const n = jr[t];\n    e = e.replace(t, n);\n  }\n\n  return !e.startsWith(\"http://\") && !e.startsWith(\"https://\") && (e = `${Ru}${e}`), e;\n}\n\nfunction Iu(e) {\n  return e && typeof e == \"object\" && e.isBuffer;\n}\n\nfunction No(e) {\n  if (Iu(e)) return e;\n  if (e instanceof ArrayBuffer) return e;\n  if (ArrayBuffer.isView(e)) return e.byteOffset === 0 && e.byteLength === e.buffer.byteLength ? e.buffer : e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);\n\n  if (typeof e == \"string\") {\n    const t = e;\n    return new TextEncoder().encode(t).buffer;\n  }\n\n  if (e && typeof e == \"object\" && e._toArrayBuffer) return e._toArrayBuffer();\n  throw new Error(\"toArrayBuffer\");\n}\n\nfunction Su() {\n  var e;\n  if (typeof process < \"u\" && typeof process.cwd < \"u\") return process.cwd();\n  const t = (e = window.location) === null || e === void 0 ? void 0 : e.pathname;\n  return (t == null ? void 0 : t.slice(0, t.lastIndexOf(\"/\") + 1)) || \"\";\n}\n\nfunction Uo(e) {\n  const t = e ? e.lastIndexOf(\"/\") : -1;\n  return t >= 0 ? e.substr(t + 1) : \"\";\n}\n\nfunction rr(e) {\n  const t = e ? e.lastIndexOf(\"/\") : -1;\n  return t >= 0 ? e.substr(0, t) : \"\";\n}\n\nfunction xu() {\n  const e = [];\n\n  for (let r = 0; r < arguments.length; r++) e[r] = r < 0 || arguments.length <= r ? void 0 : arguments[r];\n\n  let t = \"\",\n      n = !1,\n      s;\n\n  for (let r = e.length - 1; r >= -1 && !n; r--) {\n    let i;\n    r >= 0 ? i = e[r] : (s === void 0 && (s = Su()), i = s), i.length !== 0 && (t = `${i}/${t}`, n = i.charCodeAt(0) === we);\n  }\n\n  return t = Ou(t, !n), n ? `/${t}` : t.length > 0 ? t : \".\";\n}\n\nconst we = 47,\n      ts = 46;\n\nfunction Ou(e, t) {\n  let n = \"\",\n      s = -1,\n      r = 0,\n      i,\n      o = !1;\n\n  for (let a = 0; a <= e.length; ++a) {\n    if (a < e.length) i = e.charCodeAt(a);else {\n      if (i === we) break;\n      i = we;\n    }\n\n    if (i === we) {\n      if (!(s === a - 1 || r === 1)) if (s !== a - 1 && r === 2) {\n        if (n.length < 2 || !o || n.charCodeAt(n.length - 1) !== ts || n.charCodeAt(n.length - 2) !== ts) {\n          if (n.length > 2) {\n            const c = n.length - 1;\n            let u = c;\n\n            for (; u >= 0 && n.charCodeAt(u) !== we; --u);\n\n            if (u !== c) {\n              n = u === -1 ? \"\" : n.slice(0, u), s = a, r = 0, o = !1;\n              continue;\n            }\n          } else if (n.length === 2 || n.length === 1) {\n            n = \"\", s = a, r = 0, o = !1;\n            continue;\n          }\n        }\n\n        t && (n.length > 0 ? n += \"/..\" : n = \"..\", o = !0);\n      } else {\n        const c = e.slice(s + 1, a);\n        n.length > 0 ? n += `/${c}` : n = c, o = !1;\n      }\n      s = a, r = 0;\n    } else i === ts && r !== -1 ? ++r : r = -1;\n  }\n\n  return n;\n}\n\nconst Fu = e => typeof e == \"boolean\",\n      Me = e => typeof e == \"function\",\n      Ve = e => e !== null && typeof e == \"object\",\n      kr = e => Ve(e) && e.constructor === {}.constructor,\n      vu = e => !!e && typeof e[Symbol.iterator] == \"function\",\n      Du = e => e && typeof e[Symbol.asyncIterator] == \"function\",\n      $t = e => typeof Response < \"u\" && e instanceof Response || e && e.arrayBuffer && e.text && e.json,\n      Zt = e => typeof Blob < \"u\" && e instanceof Blob,\n      Lu = e => e && typeof e == \"object\" && e.isBuffer,\n      Gu = e => typeof ReadableStream < \"u\" && e instanceof ReadableStream || Ve(e) && Me(e.tee) && Me(e.cancel) && Me(e.getReader),\n      Pu = e => Ve(e) && Me(e.read) && Me(e.pipe) && Fu(e.readable),\n      Ho = e => Gu(e) || Pu(e),\n      Nu = /^data:([-\\w.]+\\/[-\\w.+]+)(;|,)/,\n      Uu = /^([-\\w.]+\\/[-\\w.+]+)/;\n\nfunction Hu(e) {\n  const t = Uu.exec(e);\n  return t ? t[1] : e;\n}\n\nfunction Kr(e) {\n  const t = Nu.exec(e);\n  return t ? t[1] : \"\";\n}\n\nconst Jo = /\\?.*/;\n\nfunction Ju(e) {\n  const t = e.match(Jo);\n  return t && t[0];\n}\n\nfunction ir(e) {\n  return e.replace(Jo, \"\");\n}\n\nfunction Gn(e) {\n  return $t(e) ? e.url : Zt(e) ? e.name || \"\" : typeof e == \"string\" ? e : \"\";\n}\n\nfunction or(e) {\n  if ($t(e)) {\n    const t = e,\n          n = t.headers.get(\"content-type\") || \"\",\n          s = ir(t.url);\n    return Hu(n) || Kr(s);\n  }\n\n  return Zt(e) ? e.type || \"\" : typeof e == \"string\" ? Kr(e) : \"\";\n}\n\nfunction Vu(e) {\n  return $t(e) ? e.headers[\"content-length\"] || -1 : Zt(e) ? e.size : typeof e == \"string\" ? e.length : e instanceof ArrayBuffer || ArrayBuffer.isView(e) ? e.byteLength : -1;\n}\n\nasync function Vo(e) {\n  if ($t(e)) return e;\n  const t = {},\n        n = Vu(e);\n  n >= 0 && (t[\"content-length\"] = String(n));\n  const s = Gn(e),\n        r = or(e);\n  r && (t[\"content-type\"] = r);\n  const i = await Ku(e);\n  i && (t[\"x-first-bytes\"] = i), typeof e == \"string\" && (e = new TextEncoder().encode(e));\n  const o = new Response(e, {\n    headers: t\n  });\n  return Object.defineProperty(o, \"url\", {\n    value: s\n  }), o;\n}\n\nasync function ju(e) {\n  if (!e.ok) {\n    const t = await ku(e);\n    throw new Error(t);\n  }\n}\n\nasync function ku(e) {\n  let t = `Failed to fetch resource ${e.url} (${e.status}): `;\n\n  try {\n    const n = e.headers.get(\"Content-Type\");\n    let s = e.statusText;\n    n != null && n.includes(\"application/json\") && (s += ` ${await e.text()}`), t += s, t = t.length > 60 ? `${t.slice(0, 60)}...` : t;\n  } catch {}\n\n  return t;\n}\n\nasync function Ku(e) {\n  if (typeof e == \"string\") return `data:,${e.slice(0, 5)}`;\n\n  if (e instanceof Blob) {\n    const n = e.slice(0, 5);\n    return await new Promise(s => {\n      const r = new FileReader();\n      r.onload = i => {\n        var o;\n        return s(i == null || (o = i.target) === null || o === void 0 ? void 0 : o.result);\n      }, r.readAsDataURL(n);\n    });\n  }\n\n  if (e instanceof ArrayBuffer) {\n    const n = e.slice(0, 5);\n    return `data:base64,${zu(n)}`;\n  }\n\n  return null;\n}\n\nfunction zu(e) {\n  let t = \"\";\n  const n = new Uint8Array(e);\n\n  for (let s = 0; s < n.byteLength; s++) t += String.fromCharCode(n[s]);\n\n  return btoa(t);\n}\n\nfunction Wu(e) {\n  return !Xu(e) && !Qu(e);\n}\n\nfunction Xu(e) {\n  return e.startsWith(\"http:\") || e.startsWith(\"https:\");\n}\n\nfunction Qu(e) {\n  return e.startsWith(\"data:\");\n}\n\nasync function Fe(e, t) {\n  if (typeof e == \"string\") {\n    const r = Mu(e);\n\n    if (Wu(r)) {\n      var n;\n\n      if ((n = globalThis.loaders) !== null && n !== void 0 && n.fetchNode) {\n        var s;\n        return (s = globalThis.loaders) === null || s === void 0 ? void 0 : s.fetchNode(r, t);\n      }\n    }\n\n    return await fetch(r, t);\n  }\n\n  return await Vo(e);\n}\n\nfunction qu(e) {\n  if (typeof window < \"u\" && typeof window.process == \"object\" && window.process.type === \"renderer\" || typeof process < \"u\" && typeof process.versions == \"object\" && process.versions.electron) return !0;\n  const t = typeof navigator == \"object\" && typeof navigator.userAgent == \"string\" && navigator.userAgent,\n        n = e || t;\n  return !!(n && n.indexOf(\"Electron\") >= 0);\n}\n\nfunction je() {\n  return !(typeof process == \"object\" && String(process) === \"[object process]\" && !process.browser) || qu();\n}\n\nconst Xe = globalThis.window || globalThis.self || globalThis.global,\n      pe = globalThis.process || {},\n      jo = typeof __VERSION__ < \"u\" ? __VERSION__ : \"untranspiled source\";\nje();\n\nfunction Yu(e) {\n  try {\n    const t = window[e],\n          n = \"__storage_test__\";\n    return t.setItem(n, n), t.removeItem(n), t;\n  } catch {\n    return null;\n  }\n}\n\nclass $u {\n  constructor(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"sessionStorage\";\n    this.storage = void 0, this.id = void 0, this.config = void 0, this.storage = Yu(s), this.id = t, this.config = n, this._loadConfiguration();\n  }\n\n  getConfiguration() {\n    return this.config;\n  }\n\n  setConfiguration(t) {\n    if (Object.assign(this.config, t), this.storage) {\n      const n = JSON.stringify(this.config);\n      this.storage.setItem(this.id, n);\n    }\n  }\n\n  _loadConfiguration() {\n    let t = {};\n\n    if (this.storage) {\n      const n = this.storage.getItem(this.id);\n      t = n ? JSON.parse(n) : {};\n    }\n\n    return Object.assign(this.config, t), this;\n  }\n\n}\n\nfunction Zu(e) {\n  let t;\n  return e < 10 ? t = \"\".concat(e.toFixed(2), \"ms\") : e < 100 ? t = \"\".concat(e.toFixed(1), \"ms\") : e < 1e3 ? t = \"\".concat(e.toFixed(0), \"ms\") : t = \"\".concat((e / 1e3).toFixed(2), \"s\"), t;\n}\n\nfunction tl(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;\n  const n = Math.max(t - e.length, 0);\n  return \"\".concat(\" \".repeat(n)).concat(e);\n}\n\nfunction es(e, t, n) {\n  let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;\n  const r = e.src.replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\");\n  e.width > s && (n = Math.min(n, s / e.width));\n  const i = e.width * n,\n        o = e.height * n,\n        a = [\"font-size:1px;\", \"padding:\".concat(Math.floor(o / 2), \"px \").concat(Math.floor(i / 2), \"px;\"), \"line-height:\".concat(o, \"px;\"), \"background:url(\".concat(r, \");\"), \"background-size:\".concat(i, \"px \").concat(o, \"px;\"), \"color:transparent;\"].join(\"\");\n  return [\"\".concat(t, \" %c+\"), a];\n}\n\nlet Tn;\n\n(function (e) {\n  e[e.BLACK = 30] = \"BLACK\", e[e.RED = 31] = \"RED\", e[e.GREEN = 32] = \"GREEN\", e[e.YELLOW = 33] = \"YELLOW\", e[e.BLUE = 34] = \"BLUE\", e[e.MAGENTA = 35] = \"MAGENTA\", e[e.CYAN = 36] = \"CYAN\", e[e.WHITE = 37] = \"WHITE\", e[e.BRIGHT_BLACK = 90] = \"BRIGHT_BLACK\", e[e.BRIGHT_RED = 91] = \"BRIGHT_RED\", e[e.BRIGHT_GREEN = 92] = \"BRIGHT_GREEN\", e[e.BRIGHT_YELLOW = 93] = \"BRIGHT_YELLOW\", e[e.BRIGHT_BLUE = 94] = \"BRIGHT_BLUE\", e[e.BRIGHT_MAGENTA = 95] = \"BRIGHT_MAGENTA\", e[e.BRIGHT_CYAN = 96] = \"BRIGHT_CYAN\", e[e.BRIGHT_WHITE = 97] = \"BRIGHT_WHITE\";\n})(Tn || (Tn = {}));\n\nconst el = 10;\n\nfunction zr(e) {\n  return typeof e != \"string\" ? e : (e = e.toUpperCase(), Tn[e] || Tn.WHITE);\n}\n\nfunction nl(e, t, n) {\n  if (!je && typeof e == \"string\") {\n    if (t) {\n      const s = zr(t);\n      e = \"\\x1B[\".concat(s, \"m\").concat(e, \"\\x1B[39m\");\n    }\n\n    if (n) {\n      const s = zr(n);\n      e = \"\\x1B[\".concat(s + el, \"m\").concat(e, \"\\x1B[49m\");\n    }\n  }\n\n  return e;\n}\n\nfunction sl(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [\"constructor\"];\n  const n = Object.getPrototypeOf(e),\n        s = Object.getOwnPropertyNames(n),\n        r = e;\n\n  for (const i of s) {\n    const o = r[i];\n    typeof o == \"function\" && (t.find(a => i === a) || (r[i] = o.bind(e)));\n  }\n}\n\nfunction bn(e, t) {\n  if (!e) throw new Error(t || \"Assertion failed\");\n}\n\nfunction se() {\n  let e;\n\n  if (je() && Xe.performance) {\n    var t, n;\n    e = Xe == null || (t = Xe.performance) === null || t === void 0 || (n = t.now) === null || n === void 0 ? void 0 : n.call(t);\n  } else if (\"hrtime\" in pe) {\n    var s;\n    const r = pe == null || (s = pe.hrtime) === null || s === void 0 ? void 0 : s.call(pe);\n    e = r[0] * 1e3 + r[1] / 1e6;\n  } else e = Date.now();\n\n  return e;\n}\n\nconst re = {\n  debug: je() && console.debug || console.log,\n  log: console.log,\n  info: console.info,\n  warn: console.warn,\n  error: console.error\n},\n      rl = {\n  enabled: !0,\n  level: 0\n};\n\nfunction yt() {}\n\nconst Wr = {},\n      Xr = {\n  once: !0\n};\n\nclass Pn {\n  constructor() {\n    let {\n      id: t\n    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {\n      id: \"\"\n    };\n    this.id = void 0, this.VERSION = jo, this._startTs = se(), this._deltaTs = se(), this._storage = void 0, this.userData = {}, this.LOG_THROTTLE_TIMEOUT = 0, this.id = t, this.userData = {}, this._storage = new $u(\"__probe-\".concat(this.id, \"__\"), rl), this.timeStamp(\"\".concat(this.id, \" started\")), sl(this), Object.seal(this);\n  }\n\n  set level(t) {\n    this.setLevel(t);\n  }\n\n  get level() {\n    return this.getLevel();\n  }\n\n  isEnabled() {\n    return this._storage.config.enabled;\n  }\n\n  getLevel() {\n    return this._storage.config.level;\n  }\n\n  getTotal() {\n    return Number((se() - this._startTs).toPrecision(10));\n  }\n\n  getDelta() {\n    return Number((se() - this._deltaTs).toPrecision(10));\n  }\n\n  set priority(t) {\n    this.level = t;\n  }\n\n  get priority() {\n    return this.level;\n  }\n\n  getPriority() {\n    return this.level;\n  }\n\n  enable() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;\n    return this._storage.setConfiguration({\n      enabled: t\n    }), this;\n  }\n\n  setLevel(t) {\n    return this._storage.setConfiguration({\n      level: t\n    }), this;\n  }\n\n  get(t) {\n    return this._storage.config[t];\n  }\n\n  set(t, n) {\n    this._storage.setConfiguration({\n      [t]: n\n    });\n  }\n\n  settings() {\n    console.table ? console.table(this._storage.config) : console.log(this._storage.config);\n  }\n\n  assert(t, n) {\n    bn(t, n);\n  }\n\n  warn(t) {\n    return this._getLogFunction(0, t, re.warn, arguments, Xr);\n  }\n\n  error(t) {\n    return this._getLogFunction(0, t, re.error, arguments);\n  }\n\n  deprecated(t, n) {\n    return this.warn(\"`\".concat(t, \"` is deprecated and will be removed in a later version. Use `\").concat(n, \"` instead\"));\n  }\n\n  removed(t, n) {\n    return this.error(\"`\".concat(t, \"` has been removed. Use `\").concat(n, \"` instead\"));\n  }\n\n  probe(t, n) {\n    return this._getLogFunction(t, n, re.log, arguments, {\n      time: !0,\n      once: !0\n    });\n  }\n\n  log(t, n) {\n    return this._getLogFunction(t, n, re.debug, arguments);\n  }\n\n  info(t, n) {\n    return this._getLogFunction(t, n, console.info, arguments);\n  }\n\n  once(t, n) {\n    return this._getLogFunction(t, n, re.debug || re.info, arguments, Xr);\n  }\n\n  table(t, n, s) {\n    return n ? this._getLogFunction(t, n, console.table || yt, s && [s], {\n      tag: cl(n)\n    }) : yt;\n  }\n\n  image(t) {\n    let {\n      logLevel: n,\n      priority: s,\n      image: r,\n      message: i = \"\",\n      scale: o = 1\n    } = t;\n    return this._shouldLog(n || s) ? je() ? al({\n      image: r,\n      message: i,\n      scale: o\n    }) : ol() : yt;\n  }\n\n  time(t, n) {\n    return this._getLogFunction(t, n, console.time ? console.time : console.info);\n  }\n\n  timeEnd(t, n) {\n    return this._getLogFunction(t, n, console.timeEnd ? console.timeEnd : console.info);\n  }\n\n  timeStamp(t, n) {\n    return this._getLogFunction(t, n, console.timeStamp || yt);\n  }\n\n  group(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {\n      collapsed: !1\n    };\n    const r = Qr({\n      logLevel: t,\n      message: n,\n      opts: s\n    }),\n          {\n      collapsed: i\n    } = s;\n    return r.method = (i ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(r);\n  }\n\n  groupCollapsed(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return this.group(t, n, Object.assign({}, s, {\n      collapsed: !0\n    }));\n  }\n\n  groupEnd(t) {\n    return this._getLogFunction(t, \"\", console.groupEnd || yt);\n  }\n\n  withGroup(t, n, s) {\n    this.group(t, n)();\n\n    try {\n      s();\n    } finally {\n      this.groupEnd(t)();\n    }\n  }\n\n  trace() {\n    console.trace && console.trace();\n  }\n\n  _shouldLog(t) {\n    return this.isEnabled() && this.getLevel() >= ko(t);\n  }\n\n  _getLogFunction(t, n, s, r, i) {\n    if (this._shouldLog(t)) {\n      i = Qr({\n        logLevel: t,\n        message: n,\n        args: r,\n        opts: i\n      }), s = s || i.method, bn(s), i.total = this.getTotal(), i.delta = this.getDelta(), this._deltaTs = se();\n      const o = i.tag || i.message;\n      if (i.once && o) if (!Wr[o]) Wr[o] = se();else return yt;\n      return n = il(this.id, i.message, i), s.bind(console, n, ...i.args);\n    }\n\n    return yt;\n  }\n\n}\n\nPn.VERSION = jo;\n\nfunction ko(e) {\n  if (!e) return 0;\n  let t;\n\n  switch (typeof e) {\n    case \"number\":\n      t = e;\n      break;\n\n    case \"object\":\n      t = e.logLevel || e.priority || 0;\n      break;\n\n    default:\n      return 0;\n  }\n\n  return bn(Number.isFinite(t) && t >= 0), t;\n}\n\nfunction Qr(e) {\n  const {\n    logLevel: t,\n    message: n\n  } = e;\n  e.logLevel = ko(t);\n  const s = e.args ? Array.from(e.args) : [];\n\n  for (; s.length && s.shift() !== n;);\n\n  switch (typeof t) {\n    case \"string\":\n    case \"function\":\n      n !== void 0 && s.unshift(n), e.message = t;\n      break;\n\n    case \"object\":\n      Object.assign(e, t);\n      break;\n  }\n\n  typeof e.message == \"function\" && (e.message = e.message());\n  const r = typeof e.message;\n  return bn(r === \"string\" || r === \"object\"), Object.assign(e, {\n    args: s\n  }, e.opts);\n}\n\nfunction il(e, t, n) {\n  if (typeof t == \"string\") {\n    const s = n.time ? tl(Zu(n.total)) : \"\";\n    t = n.time ? \"\".concat(e, \": \").concat(s, \"  \").concat(t) : \"\".concat(e, \": \").concat(t), t = nl(t, n.color, n.background);\n  }\n\n  return t;\n}\n\nfunction ol(e) {\n  return console.warn(\"removed\"), yt;\n}\n\nfunction al(e) {\n  let {\n    image: t,\n    message: n = \"\",\n    scale: s = 1\n  } = e;\n\n  if (typeof t == \"string\") {\n    const i = new Image();\n    return i.onload = () => {\n      const o = es(i, n, s);\n      console.log(...o);\n    }, i.src = t, yt;\n  }\n\n  const r = t.nodeName || \"\";\n  if (r.toLowerCase() === \"img\") return console.log(...es(t, n, s)), yt;\n\n  if (r.toLowerCase() === \"canvas\") {\n    const i = new Image();\n    return i.onload = () => console.log(...es(i, n, s)), i.src = t.toDataURL(), yt;\n  }\n\n  return yt;\n}\n\nfunction cl(e) {\n  for (const t in e) for (const n in e[t]) return n || \"untitled\";\n\n  return \"empty\";\n}\n\nconst Ko = new Pn({\n  id: \"@probe.gl/log\"\n}),\n      qr = new Pn({\n  id: \"loaders.gl\"\n});\n\nclass ul {\n  log() {\n    return () => {};\n  }\n\n  info() {\n    return () => {};\n  }\n\n  warn() {\n    return () => {};\n  }\n\n  error() {\n    return () => {};\n  }\n\n}\n\nclass ll {\n  constructor() {\n    this.console = void 0, this.console = console;\n  }\n\n  log() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++) n[s] = arguments[s];\n\n    return this.console.log.bind(this.console, ...n);\n  }\n\n  info() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++) n[s] = arguments[s];\n\n    return this.console.info.bind(this.console, ...n);\n  }\n\n  warn() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++) n[s] = arguments[s];\n\n    return this.console.warn.bind(this.console, ...n);\n  }\n\n  error() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++) n[s] = arguments[s];\n\n    return this.console.error.bind(this.console, ...n);\n  }\n\n}\n\nconst zo = {\n  fetch: null,\n  mimeType: void 0,\n  nothrow: !1,\n  log: new ll(),\n  useLocalLibraries: !1,\n  CDN: \"https://unpkg.com/@loaders.gl\",\n  worker: !0,\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  reuseWorkers: Ln,\n  _nodeWorkers: !1,\n  _workerType: \"\",\n  limit: 0,\n  _limitMB: 0,\n  batchSize: \"auto\",\n  batchDebounceMs: 0,\n  metadata: !1,\n  transforms: []\n},\n      hl = {\n  throws: \"nothrow\",\n  dataType: \"(no longer used)\",\n  uri: \"baseUri\",\n  method: \"fetch.method\",\n  headers: \"fetch.headers\",\n  body: \"fetch.body\",\n  mode: \"fetch.mode\",\n  credentials: \"fetch.credentials\",\n  cache: \"fetch.cache\",\n  redirect: \"fetch.redirect\",\n  referrer: \"fetch.referrer\",\n  referrerPolicy: \"fetch.referrerPolicy\",\n  integrity: \"fetch.integrity\",\n  keepalive: \"fetch.keepalive\",\n  signal: \"fetch.signal\"\n};\n\nfunction Wo() {\n  globalThis.loaders = globalThis.loaders || {};\n  const {\n    loaders: e\n  } = globalThis;\n  return e._state = e._state || {}, e._state;\n}\n\nfunction Xo() {\n  const e = Wo();\n  return e.globalOptions = e.globalOptions || { ...zo\n  }, e.globalOptions;\n}\n\nfunction fl(e, t, n, s) {\n  return n = n || [], n = Array.isArray(n) ? n : [n], dl(e, n), gl(t, e, s);\n}\n\nfunction dl(e, t) {\n  Yr(e, null, zo, hl, t);\n\n  for (const n of t) {\n    const s = e && e[n.id] || {},\n          r = n.options && n.options[n.id] || {},\n          i = n.deprecatedOptions && n.deprecatedOptions[n.id] || {};\n    Yr(s, n.id, r, i, t);\n  }\n}\n\nfunction Yr(e, t, n, s, r) {\n  const i = t || \"Top level\",\n        o = t ? `${t}.` : \"\";\n\n  for (const a in e) {\n    const c = !t && Ve(e[a]),\n          u = a === \"baseUri\" && !t,\n          l = a === \"workerUrl\" && t;\n\n    if (!(a in n) && !u && !l) {\n      if (a in s) qr.warn(`${i} loader option '${o}${a}' no longer supported, use '${s[a]}'`)();else if (!c) {\n        const h = ml(a, r);\n        qr.warn(`${i} loader option '${o}${a}' not recognized. ${h}`)();\n      }\n    }\n  }\n}\n\nfunction ml(e, t) {\n  const n = e.toLowerCase();\n  let s = \"\";\n\n  for (const r of t) for (const i in r.options) {\n    if (e === i) return `Did you mean '${r.id}.${i}'?`;\n    const o = i.toLowerCase();\n    (n.startsWith(o) || o.startsWith(n)) && (s = s || `Did you mean '${r.id}.${i}'?`);\n  }\n\n  return s;\n}\n\nfunction gl(e, t, n) {\n  const r = { ...(e.options || {})\n  };\n  return Al(r, n), r.log === null && (r.log = new ul()), $r(r, Xo()), $r(r, t), r;\n}\n\nfunction $r(e, t) {\n  for (const n in t) if (n in t) {\n    const s = t[n];\n    kr(s) && kr(e[n]) ? e[n] = { ...e[n],\n      ...t[n]\n    } : e[n] = t[n];\n  }\n}\n\nfunction Al(e, t) {\n  t && !(\"baseUri\" in e) && (e.baseUri = t);\n}\n\nfunction ar(e) {\n  var t;\n  return e ? (Array.isArray(e) && (e = e[0]), Array.isArray((t = e) === null || t === void 0 ? void 0 : t.extensions)) : !1;\n}\n\nfunction Qo(e) {\n  var t, n;\n  U(e, \"null loader\"), U(ar(e), \"invalid loader\");\n  let s;\n  return Array.isArray(e) && (s = e[1], e = e[0], e = { ...e,\n    options: { ...e.options,\n      ...s\n    }\n  }), ((t = e) !== null && t !== void 0 && t.parseTextSync || (n = e) !== null && n !== void 0 && n.parseText) && (e.text = !0), e.text || (e.binary = !0), e;\n}\n\nconst pl = () => {\n  const e = Wo();\n  return e.loaderRegistry = e.loaderRegistry || [], e.loaderRegistry;\n};\n\nfunction yl() {\n  return pl();\n}\n\nconst Bl = new Pn({\n  id: \"loaders.gl\"\n}),\n      Cl = /\\.([^.]+)$/;\n\nasync function El(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],\n      n = arguments.length > 2 ? arguments[2] : void 0,\n      s = arguments.length > 3 ? arguments[3] : void 0;\n  if (!qo(e)) return null;\n  let r = Zr(e, t, { ...n,\n    nothrow: !0\n  }, s);\n  if (r) return r;\n  if (Zt(e) && (e = await e.slice(0, 10).arrayBuffer(), r = Zr(e, t, n, s)), !r && !(n != null && n.nothrow)) throw new Error(Yo(e));\n  return r;\n}\n\nfunction Zr(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],\n      n = arguments.length > 2 ? arguments[2] : void 0,\n      s = arguments.length > 3 ? arguments[3] : void 0;\n  if (!qo(e)) return null;\n  if (t && !Array.isArray(t)) return Qo(t);\n  let r = [];\n  t && (r = r.concat(t)), n != null && n.ignoreRegisteredLoaders || r.push(...yl()), bl(r);\n  const i = Tl(e, r, n, s);\n  if (!i && !(n != null && n.nothrow)) throw new Error(Yo(e));\n  return i;\n}\n\nfunction Tl(e, t, n, s) {\n  const r = Gn(e),\n        i = or(e),\n        o = ir(r) || (s == null ? void 0 : s.url);\n  let a = null,\n      c = \"\";\n\n  if (n != null && n.mimeType && (a = ns(t, n == null ? void 0 : n.mimeType), c = `match forced by supplied MIME type ${n == null ? void 0 : n.mimeType}`), a = a || _l(t, o), c = c || (a ? `matched url ${o}` : \"\"), a = a || ns(t, i), c = c || (a ? `matched MIME type ${i}` : \"\"), a = a || Rl(t, e), c = c || (a ? `matched initial data ${$o(e)}` : \"\"), n != null && n.fallbackMimeType && (a = a || ns(t, n == null ? void 0 : n.fallbackMimeType), c = c || (a ? `matched fallback MIME type ${i}` : \"\")), c) {\n    var u;\n    Bl.log(1, `selectLoader selected ${(u = a) === null || u === void 0 ? void 0 : u.name}: ${c}.`);\n  }\n\n  return a;\n}\n\nfunction qo(e) {\n  return !(e instanceof Response && e.status === 204);\n}\n\nfunction Yo(e) {\n  const t = Gn(e),\n        n = or(e);\n  let s = \"No valid loader found (\";\n  s += t ? `${Uo(t)}, ` : \"no url provided, \", s += `MIME type: ${n ? `\"${n}\"` : \"not provided\"}, `;\n  const r = e ? $o(e) : \"\";\n  return s += r ? ` first bytes: \"${r}\"` : \"first bytes: not available\", s += \")\", s;\n}\n\nfunction bl(e) {\n  for (const t of e) Qo(t);\n}\n\nfunction _l(e, t) {\n  const n = t && Cl.exec(t),\n        s = n && n[1];\n  return s ? wl(e, s) : null;\n}\n\nfunction wl(e, t) {\n  t = t.toLowerCase();\n\n  for (const n of e) for (const s of n.extensions) if (s.toLowerCase() === t) return n;\n\n  return null;\n}\n\nfunction ns(e, t) {\n  for (const n of e) if (n.mimeTypes && n.mimeTypes.includes(t) || t === `application/x.${n.id}`) return n;\n\n  return null;\n}\n\nfunction Rl(e, t) {\n  if (!t) return null;\n\n  for (const n of e) if (typeof t == \"string\") {\n    if (Ml(t, n)) return n;\n  } else if (ArrayBuffer.isView(t)) {\n    if (ti(t.buffer, t.byteOffset, n)) return n;\n  } else if (t instanceof ArrayBuffer && ti(t, 0, n)) return n;\n\n  return null;\n}\n\nfunction Ml(e, t) {\n  return t.testText ? t.testText(e) : (Array.isArray(t.tests) ? t.tests : [t.tests]).some(s => e.startsWith(s));\n}\n\nfunction ti(e, t, n) {\n  return (Array.isArray(n.tests) ? n.tests : [n.tests]).some(r => Il(e, t, n, r));\n}\n\nfunction Il(e, t, n, s) {\n  if (s instanceof ArrayBuffer) return mu(s, e, s.byteLength);\n\n  switch (typeof s) {\n    case \"function\":\n      return s(e);\n\n    case \"string\":\n      const r = Ls(e, t, s.length);\n      return s === r;\n\n    default:\n      return !1;\n  }\n}\n\nfunction $o(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;\n  return typeof e == \"string\" ? e.slice(0, t) : ArrayBuffer.isView(e) ? Ls(e.buffer, e.byteOffset, t) : e instanceof ArrayBuffer ? Ls(e, 0, t) : \"\";\n}\n\nfunction Ls(e, t, n) {\n  if (e.byteLength < t + n) return \"\";\n  const s = new DataView(e);\n  let r = \"\";\n\n  for (let i = 0; i < n; i++) r += String.fromCharCode(s.getUint8(t + i));\n\n  return r;\n}\n\nconst Sl = 256 * 1024;\n\nfunction* xl(e, t) {\n  const n = (t == null ? void 0 : t.chunkSize) || Sl;\n  let s = 0;\n  const r = new TextEncoder();\n\n  for (; s < e.length;) {\n    const i = Math.min(e.length - s, n),\n          o = e.slice(s, s + i);\n    s += i, yield r.encode(o);\n  }\n}\n\nconst Ol = 256 * 1024;\n\nfunction Fl(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  return function* () {\n    const {\n      chunkSize: n = Ol\n    } = t;\n    let s = 0;\n\n    for (; s < e.byteLength;) {\n      const r = Math.min(e.byteLength - s, n),\n            i = new ArrayBuffer(r),\n            o = new Uint8Array(e, s, r);\n      new Uint8Array(i).set(o), s += r, yield i;\n    }\n  }();\n}\n\nconst vl = 1024 * 1024;\n\nasync function* Dl(e, t) {\n  const n = (t == null ? void 0 : t.chunkSize) || vl;\n  let s = 0;\n\n  for (; s < e.size;) {\n    const r = s + n,\n          i = await e.slice(s, r).arrayBuffer();\n    s = r, yield i;\n  }\n}\n\nfunction ei(e, t) {\n  return Ln ? Ll(e, t) : Gl(e);\n}\n\nasync function* Ll(e, t) {\n  const n = e.getReader();\n  let s;\n\n  try {\n    for (;;) {\n      const r = s || n.read();\n      t != null && t._streamReadAhead && (s = n.read());\n      const {\n        done: i,\n        value: o\n      } = await r;\n      if (i) return;\n      yield No(o);\n    }\n  } catch {\n    n.releaseLock();\n  }\n}\n\nasync function* Gl(e, t) {\n  for await (const n of e) yield No(n);\n}\n\nfunction Pl(e, t) {\n  if (typeof e == \"string\") return xl(e, t);\n  if (e instanceof ArrayBuffer) return Fl(e, t);\n  if (Zt(e)) return Dl(e, t);\n  if (Ho(e)) return ei(e, t);\n  if ($t(e)) return ei(e.body, t);\n  throw new Error(\"makeIterator\");\n}\n\nconst Zo = \"Cannot convert supplied data type\";\n\nfunction Nl(e, t, n) {\n  if (t.text && typeof e == \"string\") return e;\n\n  if (Lu(e) && (e = e.buffer), e instanceof ArrayBuffer) {\n    const s = e;\n    return t.text && !t.binary ? new TextDecoder(\"utf8\").decode(s) : s;\n  }\n\n  if (ArrayBuffer.isView(e)) {\n    if (t.text && !t.binary) return new TextDecoder(\"utf8\").decode(e);\n    let s = e.buffer;\n    const r = e.byteLength || e.length;\n    return (e.byteOffset !== 0 || r !== s.byteLength) && (s = s.slice(e.byteOffset, e.byteOffset + r)), s;\n  }\n\n  throw new Error(Zo);\n}\n\nasync function Ul(e, t, n) {\n  const s = e instanceof ArrayBuffer || ArrayBuffer.isView(e);\n  if (typeof e == \"string\" || s) return Nl(e, t);\n\n  if (Zt(e) && (e = await Vo(e)), $t(e)) {\n    const r = e;\n    return await ju(r), t.binary ? await r.arrayBuffer() : await r.text();\n  }\n\n  if (Ho(e) && (e = Pl(e, n)), vu(e) || Du(e)) return yu(e);\n  throw new Error(Zo);\n}\n\nfunction ta(e, t) {\n  const n = Xo(),\n        s = e || n;\n  return typeof s.fetch == \"function\" ? s.fetch : Ve(s.fetch) ? r => Fe(r, s.fetch) : t != null && t.fetch ? t == null ? void 0 : t.fetch : Fe;\n}\n\nfunction Hl(e, t, n) {\n  if (n) return n;\n  const s = {\n    fetch: ta(t, e),\n    ...e\n  };\n\n  if (s.url) {\n    const r = ir(s.url);\n    s.baseUrl = r, s.queryString = Ju(s.url), s.filename = Uo(r), s.baseUrl = rr(r);\n  }\n\n  return Array.isArray(s.loaders) || (s.loaders = null), s;\n}\n\nfunction Jl(e, t) {\n  if (e && !Array.isArray(e)) return e;\n  let n;\n\n  if (e && (n = Array.isArray(e) ? e : [e]), t && t.loaders) {\n    const s = Array.isArray(t.loaders) ? t.loaders : [t.loaders];\n    n = n ? [...n, ...s] : s;\n  }\n\n  return n && n.length ? n : void 0;\n}\n\nasync function _n(e, t, n, s) {\n  t && !Array.isArray(t) && !ar(t) && (s = void 0, n = t, t = void 0), e = await e, n = n || {};\n  const r = Gn(e),\n        o = Jl(t, s),\n        a = await El(e, o, n);\n  return a ? (n = fl(n, a, o, r), s = Hl({\n    url: r,\n    _parse: _n,\n    loaders: o\n  }, n, s || null), await Vl(a, e, n, s)) : null;\n}\n\nasync function Vl(e, t, n, s) {\n  if (eu(e), n = kc(e.options, n), $t(t)) {\n    const i = t,\n          {\n      ok: o,\n      redirected: a,\n      status: c,\n      statusText: u,\n      type: l,\n      url: h\n    } = i,\n          f = Object.fromEntries(i.headers.entries());\n    s.response = {\n      headers: f,\n      ok: o,\n      redirected: a,\n      status: c,\n      statusText: u,\n      type: l,\n      url: h\n    };\n  }\n\n  t = await Ul(t, e, n);\n  const r = e;\n  if (r.parseTextSync && typeof t == \"string\") return r.parseTextSync(t, n, s);\n  if (uu(e, n)) return await lu(e, t, n, s, _n);\n  if (r.parseText && typeof t == \"string\") return await r.parseText(t, n, s);\n  if (r.parse) return await r.parse(t, n, s);\n  throw Nt(!r.parseSync), new Error(`${e.id} loader - no parser found and worker is disabled`);\n}\n\nfunction jl(e) {\n  switch (e.constructor) {\n    case Int8Array:\n      return \"int8\";\n\n    case Uint8Array:\n    case Uint8ClampedArray:\n      return \"uint8\";\n\n    case Int16Array:\n      return \"int16\";\n\n    case Uint16Array:\n      return \"uint16\";\n\n    case Int32Array:\n      return \"int32\";\n\n    case Uint32Array:\n      return \"uint32\";\n\n    case Float32Array:\n      return \"float32\";\n\n    case Float64Array:\n      return \"float64\";\n\n    default:\n      return \"null\";\n  }\n}\n\nfunction kl(e) {\n  let t = 1 / 0,\n      n = 1 / 0,\n      s = 1 / 0,\n      r = -1 / 0,\n      i = -1 / 0,\n      o = -1 / 0;\n  const a = e.POSITION ? e.POSITION.value : [],\n        c = a && a.length;\n\n  for (let u = 0; u < c; u += 3) {\n    const l = a[u],\n          h = a[u + 1],\n          f = a[u + 2];\n    t = l < t ? l : t, n = h < n ? h : n, s = f < s ? f : s, r = l > r ? l : r, i = h > i ? h : i, o = f > o ? f : o;\n  }\n\n  return [[t, n, s], [r, i, o]];\n}\n\nfunction Kl(e, t, n) {\n  const s = jl(t.value),\n        r = n || zl(t);\n  return {\n    name: e,\n    type: {\n      type: \"fixed-size-list\",\n      listSize: t.size,\n      children: [{\n        name: \"value\",\n        type: s\n      }]\n    },\n    nullable: !1,\n    metadata: r\n  };\n}\n\nfunction zl(e) {\n  const t = {};\n  return \"byteOffset\" in e && (t.byteOffset = e.byteOffset.toString(10)), \"byteStride\" in e && (t.byteStride = e.byteStride.toString(10)), \"normalized\" in e && (t.normalized = e.normalized.toString()), t;\n}\n\nasync function fe(e, t, n, s) {\n  let r, i;\n  !Array.isArray(t) && !ar(t) ? (r = [], i = t) : (r = t, i = n);\n  const o = ta(i);\n  let a = e;\n  return typeof e == \"string\" && (a = await o(e)), Zt(e) && (a = await o(e)), Array.isArray(r) ? await _n(a, r, i) : await _n(a, r, i);\n}\n\nconst Wl = 1 / Math.PI * 180,\n      Xl = 1 / 180 * Math.PI,\n      Ql = {\n  EPSILON: 1e-12,\n  debug: !1,\n  precision: 4,\n  printTypes: !1,\n  printDegrees: !1,\n  printRowMajor: !0,\n  _cartographicRadians: !1\n};\nglobalThis.mathgl = globalThis.mathgl || {\n  config: { ...Ql\n  }\n};\nconst tt = globalThis.mathgl.config;\n\nfunction ql(e, {\n  precision: t = tt.precision\n} = {}) {\n  return e = eh(e), \"\".concat(parseFloat(e.toPrecision(t)));\n}\n\nfunction qt(e) {\n  return Array.isArray(e) || ArrayBuffer.isView(e) && !(e instanceof DataView);\n}\n\nfunction Yl(e) {\n  return Zl(e);\n}\n\nfunction $l(e) {\n  return _t(e);\n}\n\nfunction Zl(e, t) {\n  return cr(e, n => n * Xl, t);\n}\n\nfunction _t(e, t) {\n  return cr(e, n => n * Wl, t);\n}\n\nfunction th(e, t, n) {\n  return cr(e, s => Math.max(t, Math.min(n, s)));\n}\n\nfunction Jt(e, t, n) {\n  const s = tt.EPSILON;\n  n && (tt.EPSILON = n);\n\n  try {\n    if (e === t) return !0;\n\n    if (qt(e) && qt(t)) {\n      if (e.length !== t.length) return !1;\n\n      for (let r = 0; r < e.length; ++r) if (!Jt(e[r], t[r])) return !1;\n\n      return !0;\n    }\n\n    return e && e.equals ? e.equals(t) : t && t.equals ? t.equals(e) : typeof e == \"number\" && typeof t == \"number\" ? Math.abs(e - t) <= tt.EPSILON * Math.max(1, Math.abs(e), Math.abs(t)) : !1;\n  } finally {\n    tt.EPSILON = s;\n  }\n}\n\nfunction eh(e) {\n  return Math.round(e / tt.EPSILON) * tt.EPSILON;\n}\n\nfunction nh(e) {\n  return e.clone ? e.clone() : new Array(e.length);\n}\n\nfunction cr(e, t, n) {\n  if (qt(e)) {\n    const s = e;\n    n = n || nh(s);\n\n    for (let r = 0; r < n.length && r < s.length; ++r) {\n      const i = typeof e == \"number\" ? e : e[r];\n      n[r] = t(i, r, n);\n    }\n\n    return n;\n  }\n\n  return t(e);\n}\n\nfunction sh(e) {\n  function t() {\n    var n = Reflect.construct(e, Array.from(arguments));\n    return Object.setPrototypeOf(n, Object.getPrototypeOf(this)), n;\n  }\n\n  return t.prototype = Object.create(e.prototype, {\n    constructor: {\n      value: e,\n      enumerable: !1,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e, t;\n}\n\nclass ur extends sh(Array) {\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  fromArray(t, n = 0) {\n    for (let s = 0; s < this.ELEMENTS; ++s) this[s] = t[s + n];\n\n    return this.check();\n  }\n\n  toArray(t = [], n = 0) {\n    for (let s = 0; s < this.ELEMENTS; ++s) t[n + s] = this[s];\n\n    return t;\n  }\n\n  toObject(t) {\n    return t;\n  }\n\n  from(t) {\n    return Array.isArray(t) ? this.copy(t) : this.fromObject(t);\n  }\n\n  to(t) {\n    return t === this ? this : qt(t) ? this.toArray(t) : this.toObject(t);\n  }\n\n  toTarget(t) {\n    return t ? this.to(t) : this;\n  }\n\n  toFloat32Array() {\n    return new Float32Array(this);\n  }\n\n  toString() {\n    return this.formatString(tt);\n  }\n\n  formatString(t) {\n    let n = \"\";\n\n    for (let s = 0; s < this.ELEMENTS; ++s) n += (s > 0 ? \", \" : \"\") + ql(this[s], t);\n\n    return \"\".concat(t.printTypes ? this.constructor.name : \"\", \"[\").concat(n, \"]\");\n  }\n\n  equals(t) {\n    if (!t || this.length !== t.length) return !1;\n\n    for (let n = 0; n < this.ELEMENTS; ++n) if (!Jt(this[n], t[n])) return !1;\n\n    return !0;\n  }\n\n  exactEquals(t) {\n    if (!t || this.length !== t.length) return !1;\n\n    for (let n = 0; n < this.ELEMENTS; ++n) if (this[n] !== t[n]) return !1;\n\n    return !0;\n  }\n\n  negate() {\n    for (let t = 0; t < this.ELEMENTS; ++t) this[t] = -this[t];\n\n    return this.check();\n  }\n\n  lerp(t, n, s) {\n    if (s === void 0) return this.lerp(this, t, n);\n\n    for (let r = 0; r < this.ELEMENTS; ++r) {\n      const i = t[r],\n            o = typeof n == \"number\" ? n : n[r];\n      this[r] = i + s * (o - i);\n    }\n\n    return this.check();\n  }\n\n  min(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n) this[n] = Math.min(t[n], this[n]);\n\n    return this.check();\n  }\n\n  max(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n) this[n] = Math.max(t[n], this[n]);\n\n    return this.check();\n  }\n\n  clamp(t, n) {\n    for (let s = 0; s < this.ELEMENTS; ++s) this[s] = Math.min(Math.max(this[s], t[s]), n[s]);\n\n    return this.check();\n  }\n\n  add(...t) {\n    for (const n of t) for (let s = 0; s < this.ELEMENTS; ++s) this[s] += n[s];\n\n    return this.check();\n  }\n\n  subtract(...t) {\n    for (const n of t) for (let s = 0; s < this.ELEMENTS; ++s) this[s] -= n[s];\n\n    return this.check();\n  }\n\n  scale(t) {\n    if (typeof t == \"number\") for (let n = 0; n < this.ELEMENTS; ++n) this[n] *= t;else for (let n = 0; n < this.ELEMENTS && n < t.length; ++n) this[n] *= t[n];\n    return this.check();\n  }\n\n  multiplyByScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n) this[n] *= t;\n\n    return this.check();\n  }\n\n  check() {\n    if (tt.debug && !this.validate()) throw new Error(\"math.gl: \".concat(this.constructor.name, \" some fields set to invalid numbers'\"));\n    return this;\n  }\n\n  validate() {\n    let t = this.length === this.ELEMENTS;\n\n    for (let n = 0; n < this.ELEMENTS; ++n) t = t && Number.isFinite(this[n]);\n\n    return t;\n  }\n\n  sub(t) {\n    return this.subtract(t);\n  }\n\n  setScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n) this[n] = t;\n\n    return this.check();\n  }\n\n  addScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n) this[n] += t;\n\n    return this.check();\n  }\n\n  subScalar(t) {\n    return this.addScalar(-t);\n  }\n\n  multiplyScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n) this[n] *= t;\n\n    return this.check();\n  }\n\n  divideScalar(t) {\n    return this.multiplyByScalar(1 / t);\n  }\n\n  clampScalar(t, n) {\n    for (let s = 0; s < this.ELEMENTS; ++s) this[s] = Math.min(Math.max(this[s], t), n);\n\n    return this.check();\n  }\n\n  get elements() {\n    return this;\n  }\n\n}\n\nfunction rh(e, t) {\n  if (e.length !== t) return !1;\n\n  for (let n = 0; n < e.length; ++n) if (!Number.isFinite(e[n])) return !1;\n\n  return !0;\n}\n\nfunction N(e) {\n  if (!Number.isFinite(e)) throw new Error(\"Invalid number \".concat(JSON.stringify(e)));\n  return e;\n}\n\nfunction Ie(e, t, n = \"\") {\n  if (tt.debug && !rh(e, t)) throw new Error(\"math.gl: \".concat(n, \" some fields set to invalid numbers'\"));\n  return e;\n}\n\nfunction k(e, t) {\n  if (!e) throw new Error(\"math.gl assertion \".concat(t));\n}\n\nclass lr extends ur {\n  get x() {\n    return this[0];\n  }\n\n  set x(t) {\n    this[0] = N(t);\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  set y(t) {\n    this[1] = N(t);\n  }\n\n  len() {\n    return Math.sqrt(this.lengthSquared());\n  }\n\n  magnitude() {\n    return this.len();\n  }\n\n  lengthSquared() {\n    let t = 0;\n\n    for (let n = 0; n < this.ELEMENTS; ++n) t += this[n] * this[n];\n\n    return t;\n  }\n\n  magnitudeSquared() {\n    return this.lengthSquared();\n  }\n\n  distance(t) {\n    return Math.sqrt(this.distanceSquared(t));\n  }\n\n  distanceSquared(t) {\n    let n = 0;\n\n    for (let s = 0; s < this.ELEMENTS; ++s) {\n      const r = this[s] - t[s];\n      n += r * r;\n    }\n\n    return N(n);\n  }\n\n  dot(t) {\n    let n = 0;\n\n    for (let s = 0; s < this.ELEMENTS; ++s) n += this[s] * t[s];\n\n    return N(n);\n  }\n\n  normalize() {\n    const t = this.magnitude();\n    if (t !== 0) for (let n = 0; n < this.ELEMENTS; ++n) this[n] /= t;\n    return this.check();\n  }\n\n  multiply(...t) {\n    for (const n of t) for (let s = 0; s < this.ELEMENTS; ++s) this[s] *= n[s];\n\n    return this.check();\n  }\n\n  divide(...t) {\n    for (const n of t) for (let s = 0; s < this.ELEMENTS; ++s) this[s] /= n[s];\n\n    return this.check();\n  }\n\n  lengthSq() {\n    return this.lengthSquared();\n  }\n\n  distanceTo(t) {\n    return this.distance(t);\n  }\n\n  distanceToSquared(t) {\n    return this.distanceSquared(t);\n  }\n\n  getComponent(t) {\n    return k(t >= 0 && t < this.ELEMENTS, \"index is out of range\"), N(this[t]);\n  }\n\n  setComponent(t, n) {\n    return k(t >= 0 && t < this.ELEMENTS, \"index is out of range\"), this[t] = n, this.check();\n  }\n\n  addVectors(t, n) {\n    return this.copy(t).add(n);\n  }\n\n  subVectors(t, n) {\n    return this.copy(t).subtract(n);\n  }\n\n  multiplyVectors(t, n) {\n    return this.copy(t).multiply(n);\n  }\n\n  addScaledVector(t, n) {\n    return this.add(new this.constructor(t).multiplyScalar(n));\n  }\n\n}\n\nconst Se = 1e-6;\nlet Rt = typeof Float32Array < \"u\" ? Float32Array : Array;\n\nfunction ih() {\n  const e = new Rt(2);\n  return Rt != Float32Array && (e[0] = 0, e[1] = 0), e;\n}\n\nfunction oh(e, t, n) {\n  const s = t[0],\n        r = t[1];\n  return e[0] = n[0] * s + n[2] * r, e[1] = n[1] * s + n[3] * r, e;\n}\n\nfunction ah(e, t, n) {\n  const s = t[0],\n        r = t[1];\n  return e[0] = n[0] * s + n[2] * r + n[4], e[1] = n[1] * s + n[3] * r + n[5], e;\n}\n\nfunction ea(e, t, n) {\n  const s = t[0],\n        r = t[1];\n  return e[0] = n[0] * s + n[3] * r + n[6], e[1] = n[1] * s + n[4] * r + n[7], e;\n}\n\nfunction na(e, t, n) {\n  const s = t[0],\n        r = t[1];\n  return e[0] = n[0] * s + n[4] * r + n[12], e[1] = n[1] * s + n[5] * r + n[13], e;\n}\n\n(function () {\n  const e = ih();\n  return function (t, n, s, r, i, o) {\n    let a, c;\n\n    for (n || (n = 2), s || (s = 0), r ? c = Math.min(r * n + s, t.length) : c = t.length, a = s; a < c; a += n) e[0] = t[a], e[1] = t[a + 1], i(e, e, o), t[a] = e[0], t[a + 1] = e[1];\n\n    return t;\n  };\n})();\n\nfunction sa(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = n[3] * s + n[7] * r || 1;\n  return e[0] = (n[0] * s + n[4] * r) / i, e[1] = (n[1] * s + n[5] * r) / i, e;\n}\n\nfunction ra(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = n[3] * s + n[7] * r + n[11] * i || 1;\n  return e[0] = (n[0] * s + n[4] * r + n[8] * i) / o, e[1] = (n[1] * s + n[5] * r + n[9] * i) / o, e[2] = (n[2] * s + n[6] * r + n[10] * i) / o, e;\n}\n\nfunction ch(e, t, n) {\n  const s = t[0],\n        r = t[1];\n  return e[0] = n[0] * s + n[2] * r, e[1] = n[1] * s + n[3] * r, e[2] = t[2], e;\n}\n\nfunction uh(e, t, n) {\n  const s = t[0],\n        r = t[1];\n  return e[0] = n[0] * s + n[2] * r, e[1] = n[1] * s + n[3] * r, e[2] = t[2], e[3] = t[3], e;\n}\n\nfunction ia(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2];\n  return e[0] = n[0] * s + n[3] * r + n[6] * i, e[1] = n[1] * s + n[4] * r + n[7] * i, e[2] = n[2] * s + n[5] * r + n[8] * i, e[3] = t[3], e;\n}\n\nclass Nn extends lr {\n  constructor(t = 0, n = 0) {\n    super(2), qt(t) && arguments.length === 1 ? this.copy(t) : (tt.debug && (N(t), N(n)), this[0] = t, this[1] = n);\n  }\n\n  set(t, n) {\n    return this[0] = t, this[1] = n, this.check();\n  }\n\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this.check();\n  }\n\n  fromObject(t) {\n    return tt.debug && (N(t.x), N(t.y)), this[0] = t.x, this[1] = t.y, this.check();\n  }\n\n  toObject(t) {\n    return t.x = this[0], t.y = this[1], t;\n  }\n\n  get ELEMENTS() {\n    return 2;\n  }\n\n  horizontalAngle() {\n    return Math.atan2(this.y, this.x);\n  }\n\n  verticalAngle() {\n    return Math.atan2(this.x, this.y);\n  }\n\n  transform(t) {\n    return this.transformAsPoint(t);\n  }\n\n  transformAsPoint(t) {\n    return na(this, this, t), this.check();\n  }\n\n  transformAsVector(t) {\n    return sa(this, this, t), this.check();\n  }\n\n  transformByMatrix3(t) {\n    return ea(this, this, t), this.check();\n  }\n\n  transformByMatrix2x3(t) {\n    return ah(this, this, t), this.check();\n  }\n\n  transformByMatrix2(t) {\n    return oh(this, this, t), this.check();\n  }\n\n}\n\nfunction oa() {\n  const e = new Rt(3);\n  return Rt != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e;\n}\n\nfunction aa(e) {\n  const t = e[0],\n        n = e[1],\n        s = e[2];\n  return Math.sqrt(t * t + n * n + s * s);\n}\n\nfunction ni(e, t, n) {\n  const s = new Rt(3);\n  return s[0] = e, s[1] = t, s[2] = n, s;\n}\n\nfunction lh(e, t) {\n  const n = t[0],\n        s = t[1],\n        r = t[2];\n  let i = n * n + s * s + r * r;\n  return i > 0 && (i = 1 / Math.sqrt(i)), e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i, e;\n}\n\nfunction hr(e, t) {\n  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];\n}\n\nfunction An(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = n[0],\n        a = n[1],\n        c = n[2];\n  return e[0] = r * c - i * a, e[1] = i * o - s * c, e[2] = s * a - r * o, e;\n}\n\nfunction fr(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2];\n  let o = n[3] * s + n[7] * r + n[11] * i + n[15];\n  return o = o || 1, e[0] = (n[0] * s + n[4] * r + n[8] * i + n[12]) / o, e[1] = (n[1] * s + n[5] * r + n[9] * i + n[13]) / o, e[2] = (n[2] * s + n[6] * r + n[10] * i + n[14]) / o, e;\n}\n\nfunction ca(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2];\n  return e[0] = s * n[0] + r * n[3] + i * n[6], e[1] = s * n[1] + r * n[4] + i * n[7], e[2] = s * n[2] + r * n[5] + i * n[8], e;\n}\n\nfunction ua(e, t, n) {\n  const s = n[0],\n        r = n[1],\n        i = n[2],\n        o = n[3],\n        a = t[0],\n        c = t[1],\n        u = t[2];\n  let l = r * u - i * c,\n      h = i * a - s * u,\n      f = s * c - r * a,\n      d = r * f - i * h,\n      m = i * l - s * f,\n      g = s * h - r * l;\n  const p = o * 2;\n  return l *= p, h *= p, f *= p, d *= 2, m *= 2, g *= 2, e[0] = a + l + d, e[1] = c + h + m, e[2] = u + f + g, e;\n}\n\nfunction hh(e, t, n, s) {\n  const r = [],\n        i = [];\n  return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], i[0] = r[0], i[1] = r[1] * Math.cos(s) - r[2] * Math.sin(s), i[2] = r[1] * Math.sin(s) + r[2] * Math.cos(s), e[0] = i[0] + n[0], e[1] = i[1] + n[1], e[2] = i[2] + n[2], e;\n}\n\nfunction fh(e, t, n, s) {\n  const r = [],\n        i = [];\n  return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], i[0] = r[2] * Math.sin(s) + r[0] * Math.cos(s), i[1] = r[1], i[2] = r[2] * Math.cos(s) - r[0] * Math.sin(s), e[0] = i[0] + n[0], e[1] = i[1] + n[1], e[2] = i[2] + n[2], e;\n}\n\nfunction dh(e, t, n, s) {\n  const r = [],\n        i = [];\n  return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], i[0] = r[0] * Math.cos(s) - r[1] * Math.sin(s), i[1] = r[0] * Math.sin(s) + r[1] * Math.cos(s), i[2] = r[2], e[0] = i[0] + n[0], e[1] = i[1] + n[1], e[2] = i[2] + n[2], e;\n}\n\nfunction mh(e, t) {\n  const n = e[0],\n        s = e[1],\n        r = e[2],\n        i = t[0],\n        o = t[1],\n        a = t[2],\n        c = Math.sqrt((n * n + s * s + r * r) * (i * i + o * o + a * a)),\n        u = c && hr(e, t) / c;\n  return Math.acos(Math.min(Math.max(u, -1), 1));\n}\n\nconst gh = aa;\n\n(function () {\n  const e = oa();\n  return function (t, n, s, r, i, o) {\n    let a, c;\n\n    for (n || (n = 3), s || (s = 0), r ? c = Math.min(r * n + s, t.length) : c = t.length, a = s; a < c; a += n) e[0] = t[a], e[1] = t[a + 1], e[2] = t[a + 2], i(e, e, o), t[a] = e[0], t[a + 1] = e[1], t[a + 2] = e[2];\n\n    return t;\n  };\n})();\n\nconst ss = [0, 0, 0];\nlet Qe;\n\nclass A extends lr {\n  static get ZERO() {\n    return Qe || (Qe = new A(0, 0, 0), Object.freeze(Qe)), Qe;\n  }\n\n  constructor(t = 0, n = 0, s = 0) {\n    super(-0, -0, -0), arguments.length === 1 && qt(t) ? this.copy(t) : (tt.debug && (N(t), N(n), N(s)), this[0] = t, this[1] = n, this[2] = s);\n  }\n\n  set(t, n, s) {\n    return this[0] = t, this[1] = n, this[2] = s, this.check();\n  }\n\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this.check();\n  }\n\n  fromObject(t) {\n    return tt.debug && (N(t.x), N(t.y), N(t.z)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this.check();\n  }\n\n  toObject(t) {\n    return t.x = this[0], t.y = this[1], t.z = this[2], t;\n  }\n\n  get ELEMENTS() {\n    return 3;\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set z(t) {\n    this[2] = N(t);\n  }\n\n  angle(t) {\n    return mh(this, t);\n  }\n\n  cross(t) {\n    return An(this, this, t), this.check();\n  }\n\n  rotateX({\n    radians: t,\n    origin: n = ss\n  }) {\n    return hh(this, this, n, t), this.check();\n  }\n\n  rotateY({\n    radians: t,\n    origin: n = ss\n  }) {\n    return fh(this, this, n, t), this.check();\n  }\n\n  rotateZ({\n    radians: t,\n    origin: n = ss\n  }) {\n    return dh(this, this, n, t), this.check();\n  }\n\n  transform(t) {\n    return this.transformAsPoint(t);\n  }\n\n  transformAsPoint(t) {\n    return fr(this, this, t), this.check();\n  }\n\n  transformAsVector(t) {\n    return ra(this, this, t), this.check();\n  }\n\n  transformByMatrix3(t) {\n    return ca(this, this, t), this.check();\n  }\n\n  transformByMatrix2(t) {\n    return ch(this, this, t), this.check();\n  }\n\n  transformByQuaternion(t) {\n    return ua(this, this, t), this.check();\n  }\n\n}\n\nlet qe;\n\nclass dr extends lr {\n  static get ZERO() {\n    return qe || (qe = new dr(0, 0, 0, 0), Object.freeze(qe)), qe;\n  }\n\n  constructor(t = 0, n = 0, s = 0, r = 0) {\n    super(-0, -0, -0, -0), qt(t) && arguments.length === 1 ? this.copy(t) : (tt.debug && (N(t), N(n), N(s), N(r)), this[0] = t, this[1] = n, this[2] = s, this[3] = r);\n  }\n\n  set(t, n, s, r) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this.check();\n  }\n\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this.check();\n  }\n\n  fromObject(t) {\n    return tt.debug && (N(t.x), N(t.y), N(t.z), N(t.w)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this[3] = t.w, this;\n  }\n\n  toObject(t) {\n    return t.x = this[0], t.y = this[1], t.z = this[2], t.w = this[3], t;\n  }\n\n  get ELEMENTS() {\n    return 4;\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set z(t) {\n    this[2] = N(t);\n  }\n\n  get w() {\n    return this[3];\n  }\n\n  set w(t) {\n    this[3] = N(t);\n  }\n\n  transform(t) {\n    return fr(this, this, t), this.check();\n  }\n\n  transformByMatrix3(t) {\n    return ia(this, this, t), this.check();\n  }\n\n  transformByMatrix2(t) {\n    return uh(this, this, t), this.check();\n  }\n\n  transformByQuaternion(t) {\n    return ua(this, this, t), this.check();\n  }\n\n  applyMatrix4(t) {\n    return t.transform(this, this), this;\n  }\n\n}\n\nclass la extends ur {\n  toString() {\n    let t = \"[\";\n\n    if (tt.printRowMajor) {\n      t += \"row-major:\";\n\n      for (let n = 0; n < this.RANK; ++n) for (let s = 0; s < this.RANK; ++s) t += \" \".concat(this[s * this.RANK + n]);\n    } else {\n      t += \"column-major:\";\n\n      for (let n = 0; n < this.ELEMENTS; ++n) t += \" \".concat(this[n]);\n    }\n\n    return t += \"]\", t;\n  }\n\n  getElementIndex(t, n) {\n    return n * this.RANK + t;\n  }\n\n  getElement(t, n) {\n    return this[n * this.RANK + t];\n  }\n\n  setElement(t, n, s) {\n    return this[n * this.RANK + t] = N(s), this;\n  }\n\n  getColumn(t, n = new Array(this.RANK).fill(-0)) {\n    const s = t * this.RANK;\n\n    for (let r = 0; r < this.RANK; ++r) n[r] = this[s + r];\n\n    return n;\n  }\n\n  setColumn(t, n) {\n    const s = t * this.RANK;\n\n    for (let r = 0; r < this.RANK; ++r) this[s + r] = n[r];\n\n    return this;\n  }\n\n}\n\nfunction Ah() {\n  const e = new Rt(9);\n  return Rt != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[5] = 0, e[6] = 0, e[7] = 0), e[0] = 1, e[4] = 1, e[8] = 1, e;\n}\n\nfunction ph(e, t) {\n  if (e === t) {\n    const n = t[1],\n          s = t[2],\n          r = t[5];\n    e[1] = t[3], e[2] = t[6], e[3] = n, e[5] = t[7], e[6] = s, e[7] = r;\n  } else e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8];\n\n  return e;\n}\n\nfunction yh(e, t) {\n  const n = t[0],\n        s = t[1],\n        r = t[2],\n        i = t[3],\n        o = t[4],\n        a = t[5],\n        c = t[6],\n        u = t[7],\n        l = t[8],\n        h = l * o - a * u,\n        f = -l * i + a * c,\n        d = u * i - o * c;\n  let m = n * h + s * f + r * d;\n  return m ? (m = 1 / m, e[0] = h * m, e[1] = (-l * s + r * u) * m, e[2] = (a * s - r * o) * m, e[3] = f * m, e[4] = (l * n - r * c) * m, e[5] = (-a * n + r * i) * m, e[6] = d * m, e[7] = (-u * n + s * c) * m, e[8] = (o * n - s * i) * m, e) : null;\n}\n\nfunction Bh(e) {\n  const t = e[0],\n        n = e[1],\n        s = e[2],\n        r = e[3],\n        i = e[4],\n        o = e[5],\n        a = e[6],\n        c = e[7],\n        u = e[8];\n  return t * (u * i - o * c) + n * (-u * r + o * a) + s * (c * r - i * a);\n}\n\nfunction si(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = t[3],\n        a = t[4],\n        c = t[5],\n        u = t[6],\n        l = t[7],\n        h = t[8],\n        f = n[0],\n        d = n[1],\n        m = n[2],\n        g = n[3],\n        p = n[4],\n        C = n[5],\n        w = n[6],\n        y = n[7],\n        B = n[8];\n  return e[0] = f * s + d * o + m * u, e[1] = f * r + d * a + m * l, e[2] = f * i + d * c + m * h, e[3] = g * s + p * o + C * u, e[4] = g * r + p * a + C * l, e[5] = g * i + p * c + C * h, e[6] = w * s + y * o + B * u, e[7] = w * r + y * a + B * l, e[8] = w * i + y * c + B * h, e;\n}\n\nfunction Ch(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = t[3],\n        a = t[4],\n        c = t[5],\n        u = t[6],\n        l = t[7],\n        h = t[8],\n        f = n[0],\n        d = n[1];\n  return e[0] = s, e[1] = r, e[2] = i, e[3] = o, e[4] = a, e[5] = c, e[6] = f * s + d * o + u, e[7] = f * r + d * a + l, e[8] = f * i + d * c + h, e;\n}\n\nfunction Eh(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = t[3],\n        a = t[4],\n        c = t[5],\n        u = t[6],\n        l = t[7],\n        h = t[8],\n        f = Math.sin(n),\n        d = Math.cos(n);\n  return e[0] = d * s + f * o, e[1] = d * r + f * a, e[2] = d * i + f * c, e[3] = d * o - f * s, e[4] = d * a - f * r, e[5] = d * c - f * i, e[6] = u, e[7] = l, e[8] = h, e;\n}\n\nfunction ri(e, t, n) {\n  const s = n[0],\n        r = n[1];\n  return e[0] = s * t[0], e[1] = s * t[1], e[2] = s * t[2], e[3] = r * t[3], e[4] = r * t[4], e[5] = r * t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e;\n}\n\nfunction Th(e, t) {\n  const n = t[0],\n        s = t[1],\n        r = t[2],\n        i = t[3],\n        o = n + n,\n        a = s + s,\n        c = r + r,\n        u = n * o,\n        l = s * o,\n        h = s * a,\n        f = r * o,\n        d = r * a,\n        m = r * c,\n        g = i * o,\n        p = i * a,\n        C = i * c;\n  return e[0] = 1 - h - m, e[3] = l - C, e[6] = f + p, e[1] = l + C, e[4] = 1 - u - m, e[7] = d - g, e[2] = f - p, e[5] = d + g, e[8] = 1 - u - h, e;\n}\n\nvar Gs;\n\n(function (e) {\n  e[e.COL0ROW0 = 0] = \"COL0ROW0\", e[e.COL0ROW1 = 1] = \"COL0ROW1\", e[e.COL0ROW2 = 2] = \"COL0ROW2\", e[e.COL1ROW0 = 3] = \"COL1ROW0\", e[e.COL1ROW1 = 4] = \"COL1ROW1\", e[e.COL1ROW2 = 5] = \"COL1ROW2\", e[e.COL2ROW0 = 6] = \"COL2ROW0\", e[e.COL2ROW1 = 7] = \"COL2ROW1\", e[e.COL2ROW2 = 8] = \"COL2ROW2\";\n})(Gs || (Gs = {}));\n\nconst bh = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);\n\nclass Q extends la {\n  static get IDENTITY() {\n    return wh();\n  }\n\n  static get ZERO() {\n    return _h();\n  }\n\n  get ELEMENTS() {\n    return 9;\n  }\n\n  get RANK() {\n    return 3;\n  }\n\n  get INDICES() {\n    return Gs;\n  }\n\n  constructor(t, ...n) {\n    super(-0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(t) ? this.copy(t) : n.length > 0 ? this.copy([t, ...n]) : this.identity();\n  }\n\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this[4] = t[4], this[5] = t[5], this[6] = t[6], this[7] = t[7], this[8] = t[8], this.check();\n  }\n\n  identity() {\n    return this.copy(bh);\n  }\n\n  fromObject(t) {\n    return this.check();\n  }\n\n  fromQuaternion(t) {\n    return Th(this, t), this.check();\n  }\n\n  set(t, n, s, r, i, o, a, c, u) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this[4] = i, this[5] = o, this[6] = a, this[7] = c, this[8] = u, this.check();\n  }\n\n  setRowMajor(t, n, s, r, i, o, a, c, u) {\n    return this[0] = t, this[1] = r, this[2] = a, this[3] = n, this[4] = i, this[5] = c, this[6] = s, this[7] = o, this[8] = u, this.check();\n  }\n\n  determinant() {\n    return Bh(this);\n  }\n\n  transpose() {\n    return ph(this, this), this.check();\n  }\n\n  invert() {\n    return yh(this, this), this.check();\n  }\n\n  multiplyLeft(t) {\n    return si(this, t, this), this.check();\n  }\n\n  multiplyRight(t) {\n    return si(this, this, t), this.check();\n  }\n\n  rotate(t) {\n    return Eh(this, this, t), this.check();\n  }\n\n  scale(t) {\n    return Array.isArray(t) ? ri(this, this, t) : ri(this, this, [t, t]), this.check();\n  }\n\n  translate(t) {\n    return Ch(this, this, t), this.check();\n  }\n\n  transform(t, n) {\n    let s;\n\n    switch (t.length) {\n      case 2:\n        s = ea(n || [-0, -0], t, this);\n        break;\n\n      case 3:\n        s = ca(n || [-0, -0, -0], t, this);\n        break;\n\n      case 4:\n        s = ia(n || [-0, -0, -0, -0], t, this);\n        break;\n\n      default:\n        throw new Error(\"Illegal vector\");\n    }\n\n    return Ie(s, t.length), s;\n  }\n\n  transformVector(t, n) {\n    return this.transform(t, n);\n  }\n\n  transformVector2(t, n) {\n    return this.transform(t, n);\n  }\n\n  transformVector3(t, n) {\n    return this.transform(t, n);\n  }\n\n}\n\nlet Ye,\n    $e = null;\n\nfunction _h() {\n  return Ye || (Ye = new Q([0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Ye)), Ye;\n}\n\nfunction wh() {\n  return $e || ($e = new Q(), Object.freeze($e)), $e;\n}\n\nfunction Rh(e) {\n  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;\n}\n\nfunction Mh(e, t) {\n  if (e === t) {\n    const n = t[1],\n          s = t[2],\n          r = t[3],\n          i = t[6],\n          o = t[7],\n          a = t[11];\n    e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = n, e[6] = t[9], e[7] = t[13], e[8] = s, e[9] = i, e[11] = t[14], e[12] = r, e[13] = o, e[14] = a;\n  } else e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];\n\n  return e;\n}\n\nfunction Ih(e, t) {\n  const n = t[0],\n        s = t[1],\n        r = t[2],\n        i = t[3],\n        o = t[4],\n        a = t[5],\n        c = t[6],\n        u = t[7],\n        l = t[8],\n        h = t[9],\n        f = t[10],\n        d = t[11],\n        m = t[12],\n        g = t[13],\n        p = t[14],\n        C = t[15],\n        w = n * a - s * o,\n        y = n * c - r * o,\n        B = n * u - i * o,\n        R = s * c - r * a,\n        E = s * u - i * a,\n        O = r * u - i * c,\n        F = l * g - h * m,\n        x = l * p - f * m,\n        v = l * C - d * m,\n        K = h * p - f * g,\n        q = h * C - d * g,\n        Y = f * C - d * p;\n  let D = w * Y - y * q + B * K + R * v - E * x + O * F;\n  return D ? (D = 1 / D, e[0] = (a * Y - c * q + u * K) * D, e[1] = (r * q - s * Y - i * K) * D, e[2] = (g * O - p * E + C * R) * D, e[3] = (f * E - h * O - d * R) * D, e[4] = (c * v - o * Y - u * x) * D, e[5] = (n * Y - r * v + i * x) * D, e[6] = (p * B - m * O - C * y) * D, e[7] = (l * O - f * B + d * y) * D, e[8] = (o * q - a * v + u * F) * D, e[9] = (s * v - n * q - i * F) * D, e[10] = (m * E - g * B + C * w) * D, e[11] = (h * B - l * E - d * w) * D, e[12] = (a * x - o * K - c * F) * D, e[13] = (n * K - s * x + r * F) * D, e[14] = (g * y - m * R - p * w) * D, e[15] = (l * R - h * y + f * w) * D, e) : null;\n}\n\nfunction Sh(e) {\n  const t = e[0],\n        n = e[1],\n        s = e[2],\n        r = e[3],\n        i = e[4],\n        o = e[5],\n        a = e[6],\n        c = e[7],\n        u = e[8],\n        l = e[9],\n        h = e[10],\n        f = e[11],\n        d = e[12],\n        m = e[13],\n        g = e[14],\n        p = e[15],\n        C = t * o - n * i,\n        w = t * a - s * i,\n        y = n * a - s * o,\n        B = u * m - l * d,\n        R = u * g - h * d,\n        E = l * g - h * m,\n        O = t * E - n * R + s * B,\n        F = i * E - o * R + a * B,\n        x = u * y - l * w + h * C,\n        v = d * y - m * w + g * C;\n  return c * O - r * F + p * x - f * v;\n}\n\nfunction ii(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = t[3],\n        a = t[4],\n        c = t[5],\n        u = t[6],\n        l = t[7],\n        h = t[8],\n        f = t[9],\n        d = t[10],\n        m = t[11],\n        g = t[12],\n        p = t[13],\n        C = t[14],\n        w = t[15];\n  let y = n[0],\n      B = n[1],\n      R = n[2],\n      E = n[3];\n  return e[0] = y * s + B * a + R * h + E * g, e[1] = y * r + B * c + R * f + E * p, e[2] = y * i + B * u + R * d + E * C, e[3] = y * o + B * l + R * m + E * w, y = n[4], B = n[5], R = n[6], E = n[7], e[4] = y * s + B * a + R * h + E * g, e[5] = y * r + B * c + R * f + E * p, e[6] = y * i + B * u + R * d + E * C, e[7] = y * o + B * l + R * m + E * w, y = n[8], B = n[9], R = n[10], E = n[11], e[8] = y * s + B * a + R * h + E * g, e[9] = y * r + B * c + R * f + E * p, e[10] = y * i + B * u + R * d + E * C, e[11] = y * o + B * l + R * m + E * w, y = n[12], B = n[13], R = n[14], E = n[15], e[12] = y * s + B * a + R * h + E * g, e[13] = y * r + B * c + R * f + E * p, e[14] = y * i + B * u + R * d + E * C, e[15] = y * o + B * l + R * m + E * w, e;\n}\n\nfunction xh(e, t, n) {\n  const s = n[0],\n        r = n[1],\n        i = n[2];\n  let o, a, c, u, l, h, f, d, m, g, p, C;\n  return t === e ? (e[12] = t[0] * s + t[4] * r + t[8] * i + t[12], e[13] = t[1] * s + t[5] * r + t[9] * i + t[13], e[14] = t[2] * s + t[6] * r + t[10] * i + t[14], e[15] = t[3] * s + t[7] * r + t[11] * i + t[15]) : (o = t[0], a = t[1], c = t[2], u = t[3], l = t[4], h = t[5], f = t[6], d = t[7], m = t[8], g = t[9], p = t[10], C = t[11], e[0] = o, e[1] = a, e[2] = c, e[3] = u, e[4] = l, e[5] = h, e[6] = f, e[7] = d, e[8] = m, e[9] = g, e[10] = p, e[11] = C, e[12] = o * s + l * r + m * i + t[12], e[13] = a * s + h * r + g * i + t[13], e[14] = c * s + f * r + p * i + t[14], e[15] = u * s + d * r + C * i + t[15]), e;\n}\n\nfunction Oh(e, t, n) {\n  const s = n[0],\n        r = n[1],\n        i = n[2];\n  return e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s, e[3] = t[3] * s, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * i, e[9] = t[9] * i, e[10] = t[10] * i, e[11] = t[11] * i, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;\n}\n\nfunction Fh(e, t, n, s) {\n  let r = s[0],\n      i = s[1],\n      o = s[2],\n      a = Math.sqrt(r * r + i * i + o * o),\n      c,\n      u,\n      l,\n      h,\n      f,\n      d,\n      m,\n      g,\n      p,\n      C,\n      w,\n      y,\n      B,\n      R,\n      E,\n      O,\n      F,\n      x,\n      v,\n      K,\n      q,\n      Y,\n      D,\n      at;\n  return a < Se ? null : (a = 1 / a, r *= a, i *= a, o *= a, u = Math.sin(n), c = Math.cos(n), l = 1 - c, h = t[0], f = t[1], d = t[2], m = t[3], g = t[4], p = t[5], C = t[6], w = t[7], y = t[8], B = t[9], R = t[10], E = t[11], O = r * r * l + c, F = i * r * l + o * u, x = o * r * l - i * u, v = r * i * l - o * u, K = i * i * l + c, q = o * i * l + r * u, Y = r * o * l + i * u, D = i * o * l - r * u, at = o * o * l + c, e[0] = h * O + g * F + y * x, e[1] = f * O + p * F + B * x, e[2] = d * O + C * F + R * x, e[3] = m * O + w * F + E * x, e[4] = h * v + g * K + y * q, e[5] = f * v + p * K + B * q, e[6] = d * v + C * K + R * q, e[7] = m * v + w * K + E * q, e[8] = h * Y + g * D + y * at, e[9] = f * Y + p * D + B * at, e[10] = d * Y + C * D + R * at, e[11] = m * Y + w * D + E * at, t !== e && (e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e);\n}\n\nfunction vh(e, t, n) {\n  const s = Math.sin(n),\n        r = Math.cos(n),\n        i = t[4],\n        o = t[5],\n        a = t[6],\n        c = t[7],\n        u = t[8],\n        l = t[9],\n        h = t[10],\n        f = t[11];\n  return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = i * r + u * s, e[5] = o * r + l * s, e[6] = a * r + h * s, e[7] = c * r + f * s, e[8] = u * r - i * s, e[9] = l * r - o * s, e[10] = h * r - a * s, e[11] = f * r - c * s, e;\n}\n\nfunction Dh(e, t, n) {\n  const s = Math.sin(n),\n        r = Math.cos(n),\n        i = t[0],\n        o = t[1],\n        a = t[2],\n        c = t[3],\n        u = t[8],\n        l = t[9],\n        h = t[10],\n        f = t[11];\n  return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = i * r - u * s, e[1] = o * r - l * s, e[2] = a * r - h * s, e[3] = c * r - f * s, e[8] = i * s + u * r, e[9] = o * s + l * r, e[10] = a * s + h * r, e[11] = c * s + f * r, e;\n}\n\nfunction Lh(e, t, n) {\n  const s = Math.sin(n),\n        r = Math.cos(n),\n        i = t[0],\n        o = t[1],\n        a = t[2],\n        c = t[3],\n        u = t[4],\n        l = t[5],\n        h = t[6],\n        f = t[7];\n  return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = i * r + u * s, e[1] = o * r + l * s, e[2] = a * r + h * s, e[3] = c * r + f * s, e[4] = u * r - i * s, e[5] = l * r - o * s, e[6] = h * r - a * s, e[7] = f * r - c * s, e;\n}\n\nfunction Gh(e, t) {\n  const n = t[0],\n        s = t[1],\n        r = t[2],\n        i = t[4],\n        o = t[5],\n        a = t[6],\n        c = t[8],\n        u = t[9],\n        l = t[10];\n  return e[0] = Math.sqrt(n * n + s * s + r * r), e[1] = Math.sqrt(i * i + o * o + a * a), e[2] = Math.sqrt(c * c + u * u + l * l), e;\n}\n\nfunction Ph(e, t) {\n  const n = t[0],\n        s = t[1],\n        r = t[2],\n        i = t[3],\n        o = n + n,\n        a = s + s,\n        c = r + r,\n        u = n * o,\n        l = s * o,\n        h = s * a,\n        f = r * o,\n        d = r * a,\n        m = r * c,\n        g = i * o,\n        p = i * a,\n        C = i * c;\n  return e[0] = 1 - h - m, e[1] = l + C, e[2] = f - p, e[3] = 0, e[4] = l - C, e[5] = 1 - u - m, e[6] = d + g, e[7] = 0, e[8] = f + p, e[9] = d - g, e[10] = 1 - u - h, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;\n}\n\nfunction Nh(e, t, n, s, r, i, o) {\n  const a = 1 / (n - t),\n        c = 1 / (r - s),\n        u = 1 / (i - o);\n  return e[0] = i * 2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i * 2 * c, e[6] = 0, e[7] = 0, e[8] = (n + t) * a, e[9] = (r + s) * c, e[10] = (o + i) * u, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = o * i * 2 * u, e[15] = 0, e;\n}\n\nfunction Uh(e, t, n, s, r) {\n  const i = 1 / Math.tan(t / 2);\n\n  if (e[0] = i / n, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, r != null && r !== 1 / 0) {\n    const o = 1 / (s - r);\n    e[10] = (r + s) * o, e[14] = 2 * r * s * o;\n  } else e[10] = -1, e[14] = -2 * s;\n\n  return e;\n}\n\nconst Hh = Uh;\n\nfunction Jh(e, t, n, s, r, i, o) {\n  const a = 1 / (t - n),\n        c = 1 / (s - r),\n        u = 1 / (i - o);\n  return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * u, e[11] = 0, e[12] = (t + n) * a, e[13] = (r + s) * c, e[14] = (o + i) * u, e[15] = 1, e;\n}\n\nconst Vh = Jh;\n\nfunction jh(e, t, n, s) {\n  let r, i, o, a, c, u, l, h, f, d;\n  const m = t[0],\n        g = t[1],\n        p = t[2],\n        C = s[0],\n        w = s[1],\n        y = s[2],\n        B = n[0],\n        R = n[1],\n        E = n[2];\n  return Math.abs(m - B) < Se && Math.abs(g - R) < Se && Math.abs(p - E) < Se ? Rh(e) : (h = m - B, f = g - R, d = p - E, r = 1 / Math.sqrt(h * h + f * f + d * d), h *= r, f *= r, d *= r, i = w * d - y * f, o = y * h - C * d, a = C * f - w * h, r = Math.sqrt(i * i + o * o + a * a), r ? (r = 1 / r, i *= r, o *= r, a *= r) : (i = 0, o = 0, a = 0), c = f * a - d * o, u = d * i - h * a, l = h * o - f * i, r = Math.sqrt(c * c + u * u + l * l), r ? (r = 1 / r, c *= r, u *= r, l *= r) : (c = 0, u = 0, l = 0), e[0] = i, e[1] = c, e[2] = h, e[3] = 0, e[4] = o, e[5] = u, e[6] = f, e[7] = 0, e[8] = a, e[9] = l, e[10] = d, e[11] = 0, e[12] = -(i * m + o * g + a * p), e[13] = -(c * m + u * g + l * p), e[14] = -(h * m + f * g + d * p), e[15] = 1, e);\n}\n\nfunction kh() {\n  const e = new Rt(4);\n  return Rt != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0), e;\n}\n\nfunction Kh(e, t, n) {\n  return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e;\n}\n\nfunction zh(e, t, n) {\n  return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e;\n}\n\nfunction Wh(e) {\n  const t = e[0],\n        n = e[1],\n        s = e[2],\n        r = e[3];\n  return Math.sqrt(t * t + n * n + s * s + r * r);\n}\n\nfunction Xh(e) {\n  const t = e[0],\n        n = e[1],\n        s = e[2],\n        r = e[3];\n  return t * t + n * n + s * s + r * r;\n}\n\nfunction Qh(e, t) {\n  const n = t[0],\n        s = t[1],\n        r = t[2],\n        i = t[3];\n  let o = n * n + s * s + r * r + i * i;\n  return o > 0 && (o = 1 / Math.sqrt(o)), e[0] = n * o, e[1] = s * o, e[2] = r * o, e[3] = i * o, e;\n}\n\nfunction qh(e, t) {\n  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];\n}\n\nfunction Yh(e, t, n, s) {\n  const r = t[0],\n        i = t[1],\n        o = t[2],\n        a = t[3];\n  return e[0] = r + s * (n[0] - r), e[1] = i + s * (n[1] - i), e[2] = o + s * (n[2] - o), e[3] = a + s * (n[3] - a), e;\n}\n\nfunction $h(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = t[3];\n  return e[0] = n[0] * s + n[4] * r + n[8] * i + n[12] * o, e[1] = n[1] * s + n[5] * r + n[9] * i + n[13] * o, e[2] = n[2] * s + n[6] * r + n[10] * i + n[14] * o, e[3] = n[3] * s + n[7] * r + n[11] * i + n[15] * o, e;\n}\n\nfunction Zh(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = n[0],\n        a = n[1],\n        c = n[2],\n        u = n[3],\n        l = u * s + a * i - c * r,\n        h = u * r + c * s - o * i,\n        f = u * i + o * r - a * s,\n        d = -o * s - a * r - c * i;\n  return e[0] = l * u + d * -o + h * -c - f * -a, e[1] = h * u + d * -a + f * -o - l * -c, e[2] = f * u + d * -c + l * -a - h * -o, e[3] = t[3], e;\n}\n\n(function () {\n  const e = kh();\n  return function (t, n, s, r, i, o) {\n    let a, c;\n\n    for (n || (n = 4), s || (s = 0), r ? c = Math.min(r * n + s, t.length) : c = t.length, a = s; a < c; a += n) e[0] = t[a], e[1] = t[a + 1], e[2] = t[a + 2], e[3] = t[a + 3], i(e, e, o), t[a] = e[0], t[a + 1] = e[1], t[a + 2] = e[2], t[a + 3] = e[3];\n\n    return t;\n  };\n})();\n\nvar Ps;\n\n(function (e) {\n  e[e.COL0ROW0 = 0] = \"COL0ROW0\", e[e.COL0ROW1 = 1] = \"COL0ROW1\", e[e.COL0ROW2 = 2] = \"COL0ROW2\", e[e.COL0ROW3 = 3] = \"COL0ROW3\", e[e.COL1ROW0 = 4] = \"COL1ROW0\", e[e.COL1ROW1 = 5] = \"COL1ROW1\", e[e.COL1ROW2 = 6] = \"COL1ROW2\", e[e.COL1ROW3 = 7] = \"COL1ROW3\", e[e.COL2ROW0 = 8] = \"COL2ROW0\", e[e.COL2ROW1 = 9] = \"COL2ROW1\", e[e.COL2ROW2 = 10] = \"COL2ROW2\", e[e.COL2ROW3 = 11] = \"COL2ROW3\", e[e.COL3ROW0 = 12] = \"COL3ROW0\", e[e.COL3ROW1 = 13] = \"COL3ROW1\", e[e.COL3ROW2 = 14] = \"COL3ROW2\", e[e.COL3ROW3 = 15] = \"COL3ROW3\";\n})(Ps || (Ps = {}));\n\nconst tf = 45 * Math.PI / 180,\n      ef = 1,\n      rs = 0.1,\n      is = 500,\n      nf = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n\nclass V extends la {\n  static get IDENTITY() {\n    return rf();\n  }\n\n  static get ZERO() {\n    return sf();\n  }\n\n  get ELEMENTS() {\n    return 16;\n  }\n\n  get RANK() {\n    return 4;\n  }\n\n  get INDICES() {\n    return Ps;\n  }\n\n  constructor(t) {\n    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(t) ? this.copy(t) : this.identity();\n  }\n\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this[4] = t[4], this[5] = t[5], this[6] = t[6], this[7] = t[7], this[8] = t[8], this[9] = t[9], this[10] = t[10], this[11] = t[11], this[12] = t[12], this[13] = t[13], this[14] = t[14], this[15] = t[15], this.check();\n  }\n\n  set(t, n, s, r, i, o, a, c, u, l, h, f, d, m, g, p) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this[4] = i, this[5] = o, this[6] = a, this[7] = c, this[8] = u, this[9] = l, this[10] = h, this[11] = f, this[12] = d, this[13] = m, this[14] = g, this[15] = p, this.check();\n  }\n\n  setRowMajor(t, n, s, r, i, o, a, c, u, l, h, f, d, m, g, p) {\n    return this[0] = t, this[1] = i, this[2] = u, this[3] = d, this[4] = n, this[5] = o, this[6] = l, this[7] = m, this[8] = s, this[9] = a, this[10] = h, this[11] = g, this[12] = r, this[13] = c, this[14] = f, this[15] = p, this.check();\n  }\n\n  toRowMajor(t) {\n    return t[0] = this[0], t[1] = this[4], t[2] = this[8], t[3] = this[12], t[4] = this[1], t[5] = this[5], t[6] = this[9], t[7] = this[13], t[8] = this[2], t[9] = this[6], t[10] = this[10], t[11] = this[14], t[12] = this[3], t[13] = this[7], t[14] = this[11], t[15] = this[15], t;\n  }\n\n  identity() {\n    return this.copy(nf);\n  }\n\n  fromObject(t) {\n    return this.check();\n  }\n\n  fromQuaternion(t) {\n    return Ph(this, t), this.check();\n  }\n\n  frustum(t) {\n    const {\n      left: n,\n      right: s,\n      bottom: r,\n      top: i,\n      near: o = rs,\n      far: a = is\n    } = t;\n    return a === 1 / 0 ? of(this, n, s, r, i, o) : Nh(this, n, s, r, i, o, a), this.check();\n  }\n\n  lookAt(t) {\n    const {\n      eye: n,\n      center: s = [0, 0, 0],\n      up: r = [0, 1, 0]\n    } = t;\n    return jh(this, n, s, r), this.check();\n  }\n\n  ortho(t) {\n    const {\n      left: n,\n      right: s,\n      bottom: r,\n      top: i,\n      near: o = rs,\n      far: a = is\n    } = t;\n    return Vh(this, n, s, r, i, o, a), this.check();\n  }\n\n  orthographic(t) {\n    const {\n      fovy: n = tf,\n      aspect: s = ef,\n      focalDistance: r = 1,\n      near: i = rs,\n      far: o = is\n    } = t;\n    oi(n);\n    const a = n / 2,\n          c = r * Math.tan(a),\n          u = c * s;\n    return this.ortho({\n      left: -u,\n      right: u,\n      bottom: -c,\n      top: c,\n      near: i,\n      far: o\n    });\n  }\n\n  perspective(t) {\n    const {\n      fovy: n = 45 * Math.PI / 180,\n      aspect: s = 1,\n      near: r = 0.1,\n      far: i = 500\n    } = t;\n    return oi(n), Hh(this, n, s, r, i), this.check();\n  }\n\n  determinant() {\n    return Sh(this);\n  }\n\n  getScale(t = [-0, -0, -0]) {\n    return t[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), t[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), t[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), t;\n  }\n\n  getTranslation(t = [-0, -0, -0]) {\n    return t[0] = this[12], t[1] = this[13], t[2] = this[14], t;\n  }\n\n  getRotation(t, n) {\n    t = t || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], n = n || [-0, -0, -0];\n    const s = this.getScale(n),\n          r = 1 / s[0],\n          i = 1 / s[1],\n          o = 1 / s[2];\n    return t[0] = this[0] * r, t[1] = this[1] * i, t[2] = this[2] * o, t[3] = 0, t[4] = this[4] * r, t[5] = this[5] * i, t[6] = this[6] * o, t[7] = 0, t[8] = this[8] * r, t[9] = this[9] * i, t[10] = this[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n  }\n\n  getRotationMatrix3(t, n) {\n    t = t || [-0, -0, -0, -0, -0, -0, -0, -0, -0], n = n || [-0, -0, -0];\n    const s = this.getScale(n),\n          r = 1 / s[0],\n          i = 1 / s[1],\n          o = 1 / s[2];\n    return t[0] = this[0] * r, t[1] = this[1] * i, t[2] = this[2] * o, t[3] = this[4] * r, t[4] = this[5] * i, t[5] = this[6] * o, t[6] = this[8] * r, t[7] = this[9] * i, t[8] = this[10] * o, t;\n  }\n\n  transpose() {\n    return Mh(this, this), this.check();\n  }\n\n  invert() {\n    return Ih(this, this), this.check();\n  }\n\n  multiplyLeft(t) {\n    return ii(this, t, this), this.check();\n  }\n\n  multiplyRight(t) {\n    return ii(this, this, t), this.check();\n  }\n\n  rotateX(t) {\n    return vh(this, this, t), this.check();\n  }\n\n  rotateY(t) {\n    return Dh(this, this, t), this.check();\n  }\n\n  rotateZ(t) {\n    return Lh(this, this, t), this.check();\n  }\n\n  rotateXYZ(t) {\n    return this.rotateX(t[0]).rotateY(t[1]).rotateZ(t[2]);\n  }\n\n  rotateAxis(t, n) {\n    return Fh(this, this, t, n), this.check();\n  }\n\n  scale(t) {\n    return Oh(this, this, Array.isArray(t) ? t : [t, t, t]), this.check();\n  }\n\n  translate(t) {\n    return xh(this, this, t), this.check();\n  }\n\n  transform(t, n) {\n    return t.length === 4 ? (n = $h(n || [-0, -0, -0, -0], t, this), Ie(n, 4), n) : this.transformAsPoint(t, n);\n  }\n\n  transformAsPoint(t, n) {\n    const {\n      length: s\n    } = t;\n    let r;\n\n    switch (s) {\n      case 2:\n        r = na(n || [-0, -0], t, this);\n        break;\n\n      case 3:\n        r = fr(n || [-0, -0, -0], t, this);\n        break;\n\n      default:\n        throw new Error(\"Illegal vector\");\n    }\n\n    return Ie(r, t.length), r;\n  }\n\n  transformAsVector(t, n) {\n    let s;\n\n    switch (t.length) {\n      case 2:\n        s = sa(n || [-0, -0], t, this);\n        break;\n\n      case 3:\n        s = ra(n || [-0, -0, -0], t, this);\n        break;\n\n      default:\n        throw new Error(\"Illegal vector\");\n    }\n\n    return Ie(s, t.length), s;\n  }\n\n  transformPoint(t, n) {\n    return this.transformAsPoint(t, n);\n  }\n\n  transformVector(t, n) {\n    return this.transformAsPoint(t, n);\n  }\n\n  transformDirection(t, n) {\n    return this.transformAsVector(t, n);\n  }\n\n  makeRotationX(t) {\n    return this.identity().rotateX(t);\n  }\n\n  makeTranslation(t, n, s) {\n    return this.identity().translate([t, n, s]);\n  }\n\n}\n\nlet Ze, tn;\n\nfunction sf() {\n  return Ze || (Ze = new V([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Ze)), Ze;\n}\n\nfunction rf() {\n  return tn || (tn = new V(), Object.freeze(tn)), tn;\n}\n\nfunction oi(e) {\n  if (e > Math.PI * 2) throw Error(\"expected radians\");\n}\n\nfunction of(e, t, n, s, r, i) {\n  const o = 2 * i / (n - t),\n        a = 2 * i / (r - s),\n        c = (n + t) / (n - t),\n        u = (r + s) / (r - s),\n        l = -1,\n        h = -1,\n        f = -2 * i;\n  return e[0] = o, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = a, e[6] = 0, e[7] = 0, e[8] = c, e[9] = u, e[10] = l, e[11] = h, e[12] = 0, e[13] = 0, e[14] = f, e[15] = 0, e;\n}\n\nfunction ai() {\n  const e = new Rt(4);\n  return Rt != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e[3] = 1, e;\n}\n\nfunction af(e) {\n  return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;\n}\n\nfunction ha(e, t, n) {\n  n = n * 0.5;\n  const s = Math.sin(n);\n  return e[0] = s * t[0], e[1] = s * t[1], e[2] = s * t[2], e[3] = Math.cos(n), e;\n}\n\nfunction ci(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = t[3],\n        a = n[0],\n        c = n[1],\n        u = n[2],\n        l = n[3];\n  return e[0] = s * l + o * a + r * u - i * c, e[1] = r * l + o * c + i * a - s * u, e[2] = i * l + o * u + s * c - r * a, e[3] = o * l - s * a - r * c - i * u, e;\n}\n\nfunction cf(e, t, n) {\n  n *= 0.5;\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = t[3],\n        a = Math.sin(n),\n        c = Math.cos(n);\n  return e[0] = s * c + o * a, e[1] = r * c + i * a, e[2] = i * c - r * a, e[3] = o * c - s * a, e;\n}\n\nfunction uf(e, t, n) {\n  n *= 0.5;\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = t[3],\n        a = Math.sin(n),\n        c = Math.cos(n);\n  return e[0] = s * c - i * a, e[1] = r * c + o * a, e[2] = i * c + s * a, e[3] = o * c - r * a, e;\n}\n\nfunction lf(e, t, n) {\n  n *= 0.5;\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = t[3],\n        a = Math.sin(n),\n        c = Math.cos(n);\n  return e[0] = s * c + r * a, e[1] = r * c - s * a, e[2] = i * c + o * a, e[3] = o * c - i * a, e;\n}\n\nfunction hf(e, t) {\n  const n = t[0],\n        s = t[1],\n        r = t[2];\n  return e[0] = n, e[1] = s, e[2] = r, e[3] = Math.sqrt(Math.abs(1 - n * n - s * s - r * r)), e;\n}\n\nfunction pn(e, t, n, s) {\n  const r = t[0],\n        i = t[1],\n        o = t[2],\n        a = t[3];\n  let c = n[0],\n      u = n[1],\n      l = n[2],\n      h = n[3],\n      f,\n      d,\n      m,\n      g,\n      p;\n  return f = r * c + i * u + o * l + a * h, f < 0 && (f = -f, c = -c, u = -u, l = -l, h = -h), 1 - f > Se ? (d = Math.acos(f), p = Math.sin(d), m = Math.sin((1 - s) * d) / p, g = Math.sin(s * d) / p) : (m = 1 - s, g = s), e[0] = m * r + g * c, e[1] = m * i + g * u, e[2] = m * o + g * l, e[3] = m * a + g * h, e;\n}\n\nfunction ff(e, t) {\n  const n = t[0],\n        s = t[1],\n        r = t[2],\n        i = t[3],\n        o = n * n + s * s + r * r + i * i,\n        a = o ? 1 / o : 0;\n  return e[0] = -n * a, e[1] = -s * a, e[2] = -r * a, e[3] = i * a, e;\n}\n\nfunction df(e, t) {\n  return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e;\n}\n\nfunction fa(e, t) {\n  const n = t[0] + t[4] + t[8];\n  let s;\n  if (n > 0) s = Math.sqrt(n + 1), e[3] = 0.5 * s, s = 0.5 / s, e[0] = (t[5] - t[7]) * s, e[1] = (t[6] - t[2]) * s, e[2] = (t[1] - t[3]) * s;else {\n    let r = 0;\n    t[4] > t[0] && (r = 1), t[8] > t[r * 3 + r] && (r = 2);\n    const i = (r + 1) % 3,\n          o = (r + 2) % 3;\n    s = Math.sqrt(t[r * 3 + r] - t[i * 3 + i] - t[o * 3 + o] + 1), e[r] = 0.5 * s, s = 0.5 / s, e[3] = (t[i * 3 + o] - t[o * 3 + i]) * s, e[i] = (t[i * 3 + r] + t[r * 3 + i]) * s, e[o] = (t[o * 3 + r] + t[r * 3 + o]) * s;\n  }\n  return e;\n}\n\nconst mf = Kh,\n      gf = zh,\n      Af = qh,\n      pf = Yh,\n      yf = Wh,\n      Bf = Xh,\n      da = Qh,\n      Cf = function () {\n  const e = oa(),\n        t = ni(1, 0, 0),\n        n = ni(0, 1, 0);\n  return function (s, r, i) {\n    const o = hr(r, i);\n    return o < -0.999999 ? (An(e, t, r), gh(e) < 1e-6 && An(e, n, r), lh(e, e), ha(s, e, Math.PI), s) : o > 0.999999 ? (s[0] = 0, s[1] = 0, s[2] = 0, s[3] = 1, s) : (An(e, r, i), s[0] = e[0], s[1] = e[1], s[2] = e[2], s[3] = 1 + o, da(s, s));\n  };\n}();\n\n(function () {\n  const e = ai(),\n        t = ai();\n  return function (n, s, r, i, o, a) {\n    return pn(e, s, o, a), pn(t, r, i, a), pn(n, e, t, 2 * a * (1 - a)), n;\n  };\n})();\n\n(function () {\n  const e = Ah();\n  return function (t, n, s, r) {\n    return e[0] = s[0], e[3] = s[1], e[6] = s[2], e[1] = r[0], e[4] = r[1], e[7] = r[2], e[2] = -n[0], e[5] = -n[1], e[8] = -n[2], da(t, fa(t, e));\n  };\n})();\n\nconst Ef = [0, 0, 0, 1];\n\nclass wn extends ur {\n  constructor(t = 0, n = 0, s = 0, r = 1) {\n    super(-0, -0, -0, -0), Array.isArray(t) && arguments.length === 1 ? this.copy(t) : this.set(t, n, s, r);\n  }\n\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this.check();\n  }\n\n  set(t, n, s, r) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this.check();\n  }\n\n  fromObject(t) {\n    return this[0] = t.x, this[1] = t.y, this[2] = t.z, this[3] = t.w, this.check();\n  }\n\n  fromMatrix3(t) {\n    return fa(this, t), this.check();\n  }\n\n  fromAxisRotation(t, n) {\n    return ha(this, t, n), this.check();\n  }\n\n  identity() {\n    return af(this), this.check();\n  }\n\n  setAxisAngle(t, n) {\n    return this.fromAxisRotation(t, n);\n  }\n\n  get ELEMENTS() {\n    return 4;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  set x(t) {\n    this[0] = N(t);\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  set y(t) {\n    this[1] = N(t);\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set z(t) {\n    this[2] = N(t);\n  }\n\n  get w() {\n    return this[3];\n  }\n\n  set w(t) {\n    this[3] = N(t);\n  }\n\n  len() {\n    return yf(this);\n  }\n\n  lengthSquared() {\n    return Bf(this);\n  }\n\n  dot(t) {\n    return Af(this, t);\n  }\n\n  rotationTo(t, n) {\n    return Cf(this, t, n), this.check();\n  }\n\n  add(t) {\n    return mf(this, this, t), this.check();\n  }\n\n  calculateW() {\n    return hf(this, this), this.check();\n  }\n\n  conjugate() {\n    return df(this, this), this.check();\n  }\n\n  invert() {\n    return ff(this, this), this.check();\n  }\n\n  lerp(t, n, s) {\n    return s === void 0 ? this.lerp(this, t, n) : (pf(this, t, n, s), this.check());\n  }\n\n  multiplyRight(t) {\n    return ci(this, this, t), this.check();\n  }\n\n  multiplyLeft(t) {\n    return ci(this, t, this), this.check();\n  }\n\n  normalize() {\n    const t = this.len(),\n          n = t > 0 ? 1 / t : 0;\n    return this[0] = this[0] * n, this[1] = this[1] * n, this[2] = this[2] * n, this[3] = this[3] * n, t === 0 && (this[3] = 1), this.check();\n  }\n\n  rotateX(t) {\n    return cf(this, this, t), this.check();\n  }\n\n  rotateY(t) {\n    return uf(this, this, t), this.check();\n  }\n\n  rotateZ(t) {\n    return lf(this, this, t), this.check();\n  }\n\n  scale(t) {\n    return gf(this, this, t), this.check();\n  }\n\n  slerp(t, n, s) {\n    let r, i, o;\n\n    switch (arguments.length) {\n      case 1:\n        ({\n          start: r = Ef,\n          target: i,\n          ratio: o\n        } = t);\n        break;\n\n      case 2:\n        r = this, i = t, o = n;\n        break;\n\n      default:\n        r = t, i = n, o = s;\n    }\n\n    return pn(this, r, i, o), this.check();\n  }\n\n  transformVector4(t, n = new dr()) {\n    return Zh(n, t, this), Ie(n, 4);\n  }\n\n  lengthSq() {\n    return this.lengthSquared();\n  }\n\n  setFromAxisAngle(t, n) {\n    return this.setAxisAngle(t, n);\n  }\n\n  premultiply(t) {\n    return this.multiplyLeft(t);\n  }\n\n  multiply(t) {\n    return this.multiplyRight(t);\n  }\n\n}\n\nfunction ve(e) {\n  \"@babel/helpers - typeof\";\n\n  return ve = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function (t) {\n    return typeof t;\n  } : function (t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, ve(e);\n}\n\nfunction Tf(e, t) {\n  if (ve(e) != \"object\" || !e) return e;\n  var n = e[Symbol.toPrimitive];\n\n  if (n !== void 0) {\n    var s = n.call(e, t || \"default\");\n    if (ve(s) != \"object\") return s;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (t === \"string\" ? String : Number)(e);\n}\n\nfunction bf(e) {\n  var t = Tf(e, \"string\");\n  return ve(t) == \"symbol\" ? t : String(t);\n}\n\nfunction S(e, t, n) {\n  return t = bf(t), t in e ? Object.defineProperty(e, t, {\n    value: n,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[t] = n, e;\n}\n\nconst _f = 0.1,\n      wf = 1e-12,\n      ma = 1e-15,\n      Rf = 1e-20,\n      Mf = 6378137,\n      If = 6378137,\n      Sf = 6356752314245179e-9;\n\nfunction Un(e) {\n  return e;\n}\n\nnew A();\n\nfunction xf(e, t = [], n = Un) {\n  return \"longitude\" in e ? (t[0] = n(e.longitude), t[1] = n(e.latitude), t[2] = e.height) : \"x\" in e ? (t[0] = n(e.x), t[1] = n(e.y), t[2] = e.z) : (t[0] = n(e[0]), t[1] = n(e[1]), t[2] = e[2]), t;\n}\n\nfunction Of(e, t = []) {\n  return xf(e, t, tt._cartographicRadians ? Un : Yl);\n}\n\nfunction Ff(e, t, n = Un) {\n  return \"longitude\" in t ? (t.longitude = n(e[0]), t.latitude = n(e[1]), t.height = e[2]) : \"x\" in t ? (t.x = n(e[0]), t.y = n(e[1]), t.z = e[2]) : (t[0] = n(e[0]), t[1] = n(e[1]), t[2] = e[2]), t;\n}\n\nfunction vf(e, t) {\n  return Ff(e, t, tt._cartographicRadians ? Un : $l);\n}\n\nconst ui = 1e-14,\n      Df = new A(),\n      li = {\n  up: {\n    south: \"east\",\n    north: \"west\",\n    west: \"south\",\n    east: \"north\"\n  },\n  down: {\n    south: \"west\",\n    north: \"east\",\n    west: \"north\",\n    east: \"south\"\n  },\n  south: {\n    up: \"west\",\n    down: \"east\",\n    west: \"down\",\n    east: \"up\"\n  },\n  north: {\n    up: \"east\",\n    down: \"west\",\n    west: \"up\",\n    east: \"down\"\n  },\n  west: {\n    up: \"north\",\n    down: \"south\",\n    north: \"down\",\n    south: \"up\"\n  },\n  east: {\n    up: \"south\",\n    down: \"north\",\n    north: \"up\",\n    south: \"down\"\n  }\n},\n      os = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1]\n},\n      ye = {\n  east: new A(),\n  north: new A(),\n  up: new A(),\n  west: new A(),\n  south: new A(),\n  down: new A()\n},\n      Lf = new A(),\n      Gf = new A(),\n      Pf = new A();\n\nfunction hi(e, t, n, s, r, i) {\n  const o = li[t] && li[t][n];\n  k(o && (!s || s === o));\n  let a, c, u;\n  const l = Df.copy(r);\n\n  if (Jt(l.x, 0, ui) && Jt(l.y, 0, ui)) {\n    const f = Math.sign(l.z);\n    a = Lf.fromArray(os[t]), t !== \"east\" && t !== \"west\" && a.scale(f), c = Gf.fromArray(os[n]), n !== \"east\" && n !== \"west\" && c.scale(f), u = Pf.fromArray(os[s]), s !== \"east\" && s !== \"west\" && u.scale(f);\n  } else {\n    const {\n      up: f,\n      east: d,\n      north: m\n    } = ye;\n    d.set(-l.y, l.x, 0).normalize(), e.geodeticSurfaceNormal(l, f), m.copy(f).cross(d);\n    const {\n      down: g,\n      west: p,\n      south: C\n    } = ye;\n    g.copy(f).scale(-1), p.copy(d).scale(-1), C.copy(m).scale(-1), a = ye[t], c = ye[n], u = ye[s];\n  }\n\n  return i[0] = a.x, i[1] = a.y, i[2] = a.z, i[3] = 0, i[4] = c.x, i[5] = c.y, i[6] = c.z, i[7] = 0, i[8] = u.x, i[9] = u.y, i[10] = u.z, i[11] = 0, i[12] = l.x, i[13] = l.y, i[14] = l.z, i[15] = 1, i;\n}\n\nconst ie = new A(),\n      Nf = new A(),\n      Uf = new A();\n\nfunction Hf(e, t, n = []) {\n  const {\n    oneOverRadii: s,\n    oneOverRadiiSquared: r,\n    centerToleranceSquared: i\n  } = t;\n  ie.from(e);\n  const o = ie.x,\n        a = ie.y,\n        c = ie.z,\n        u = s.x,\n        l = s.y,\n        h = s.z,\n        f = o * o * u * u,\n        d = a * a * l * l,\n        m = c * c * h * h,\n        g = f + d + m,\n        p = Math.sqrt(1 / g);\n  if (!Number.isFinite(p)) return;\n  const C = Nf;\n  if (C.copy(e).scale(p), g < i) return C.to(n);\n  const w = r.x,\n        y = r.y,\n        B = r.z,\n        R = Uf;\n  R.set(C.x * w * 2, C.y * y * 2, C.z * B * 2);\n  let E = (1 - p) * ie.len() / (0.5 * R.len()),\n      O = 0,\n      F,\n      x,\n      v,\n      K;\n\n  do {\n    E -= O, F = 1 / (1 + E * w), x = 1 / (1 + E * y), v = 1 / (1 + E * B);\n    const q = F * F,\n          Y = x * x,\n          D = v * v,\n          at = q * F,\n          ee = Y * x,\n          ne = D * v;\n    K = f * q + d * Y + m * D - 1;\n    const Ft = -2 * (f * at * w + d * ee * y + m * ne * B);\n    O = K / Ft;\n  } while (Math.abs(K) > wf);\n\n  return ie.scale([F, x, v]).to(n);\n}\n\nconst en = new A(),\n      fi = new A(),\n      Jf = new A(),\n      bt = new A(),\n      Vf = new A(),\n      nn = new A();\n\nclass J {\n  constructor(t = 0, n = 0, s = 0) {\n    S(this, \"radii\", void 0), S(this, \"radiiSquared\", void 0), S(this, \"radiiToTheFourth\", void 0), S(this, \"oneOverRadii\", void 0), S(this, \"oneOverRadiiSquared\", void 0), S(this, \"minimumRadius\", void 0), S(this, \"maximumRadius\", void 0), S(this, \"centerToleranceSquared\", _f), S(this, \"squaredXOverSquaredZ\", void 0), k(t >= 0), k(n >= 0), k(s >= 0), this.radii = new A(t, n, s), this.radiiSquared = new A(t * t, n * n, s * s), this.radiiToTheFourth = new A(t * t * t * t, n * n * n * n, s * s * s * s), this.oneOverRadii = new A(t === 0 ? 0 : 1 / t, n === 0 ? 0 : 1 / n, s === 0 ? 0 : 1 / s), this.oneOverRadiiSquared = new A(t === 0 ? 0 : 1 / (t * t), n === 0 ? 0 : 1 / (n * n), s === 0 ? 0 : 1 / (s * s)), this.minimumRadius = Math.min(t, n, s), this.maximumRadius = Math.max(t, n, s), this.radiiSquared.z !== 0 && (this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z), Object.freeze(this);\n  }\n\n  equals(t) {\n    return this === t || !!(t && this.radii.equals(t.radii));\n  }\n\n  toString() {\n    return this.radii.toString();\n  }\n\n  cartographicToCartesian(t, n = [0, 0, 0]) {\n    const s = fi,\n          r = Jf,\n          [,, i] = t;\n    this.geodeticSurfaceNormalCartographic(t, s), r.copy(this.radiiSquared).scale(s);\n    const o = Math.sqrt(s.dot(r));\n    return r.scale(1 / o), s.scale(i), r.add(s), r.to(n);\n  }\n\n  cartesianToCartographic(t, n = [0, 0, 0]) {\n    nn.from(t);\n    const s = this.scaleToGeodeticSurface(nn, bt);\n    if (!s) return;\n    const r = this.geodeticSurfaceNormal(s, fi),\n          i = Vf;\n    i.copy(nn).subtract(s);\n    const o = Math.atan2(r.y, r.x),\n          a = Math.asin(r.z),\n          c = Math.sign(hr(i, nn)) * aa(i);\n    return vf([o, a, c], n);\n  }\n\n  eastNorthUpToFixedFrame(t, n = new V()) {\n    return hi(this, \"east\", \"north\", \"up\", t, n);\n  }\n\n  localFrameToFixedFrame(t, n, s, r, i = new V()) {\n    return hi(this, t, n, s, r, i);\n  }\n\n  geocentricSurfaceNormal(t, n = [0, 0, 0]) {\n    return en.from(t).normalize().to(n);\n  }\n\n  geodeticSurfaceNormalCartographic(t, n = [0, 0, 0]) {\n    const s = Of(t),\n          r = s[0],\n          i = s[1],\n          o = Math.cos(i);\n    return en.set(o * Math.cos(r), o * Math.sin(r), Math.sin(i)).normalize(), en.to(n);\n  }\n\n  geodeticSurfaceNormal(t, n = [0, 0, 0]) {\n    return en.from(t).scale(this.oneOverRadiiSquared).normalize().to(n);\n  }\n\n  scaleToGeodeticSurface(t, n) {\n    return Hf(t, this, n);\n  }\n\n  scaleToGeocentricSurface(t, n = [0, 0, 0]) {\n    bt.from(t);\n    const s = bt.x,\n          r = bt.y,\n          i = bt.z,\n          o = this.oneOverRadiiSquared,\n          a = 1 / Math.sqrt(s * s * o.x + r * r * o.y + i * i * o.z);\n    return bt.multiplyScalar(a).to(n);\n  }\n\n  transformPositionToScaledSpace(t, n = [0, 0, 0]) {\n    return bt.from(t).scale(this.oneOverRadii).to(n);\n  }\n\n  transformPositionFromScaledSpace(t, n = [0, 0, 0]) {\n    return bt.from(t).scale(this.radii).to(n);\n  }\n\n  getSurfaceNormalIntersectionWithZAxis(t, n = 0, s = [0, 0, 0]) {\n    k(Jt(this.radii.x, this.radii.y, ma)), k(this.radii.z > 0), bt.from(t);\n    const r = bt.z * (1 - this.squaredXOverSquaredZ);\n    if (!(Math.abs(r) >= this.radii.z - n)) return bt.set(0, 0, r).to(s);\n  }\n\n}\n\nS(J, \"WGS84\", new J(Mf, If, Sf));\n\nclass jf {\n  constructor(t, n, s) {\n    this.item = void 0, this.previous = void 0, this.next = void 0, this.item = t, this.previous = n, this.next = s;\n  }\n\n}\n\nclass kf {\n  constructor() {\n    this.head = null, this.tail = null, this._length = 0;\n  }\n\n  get length() {\n    return this._length;\n  }\n\n  add(t) {\n    const n = new jf(t, this.tail, null);\n    return this.tail ? (this.tail.next = n, this.tail = n) : (this.head = n, this.tail = n), ++this._length, n;\n  }\n\n  remove(t) {\n    t && (t.previous && t.next ? (t.previous.next = t.next, t.next.previous = t.previous) : t.previous ? (t.previous.next = null, this.tail = t.previous) : t.next ? (t.next.previous = null, this.head = t.next) : (this.head = null, this.tail = null), t.next = null, t.previous = null, --this._length);\n  }\n\n  splice(t, n) {\n    t !== n && (this.remove(n), this._insert(t, n));\n  }\n\n  _insert(t, n) {\n    const s = t.next;\n    t.next = n, this.tail === t ? this.tail = n : s.previous = n, n.next = s, n.previous = t, ++this._length;\n  }\n\n}\n\nclass Kf {\n  constructor() {\n    this._list = void 0, this._sentinel = void 0, this._trimTiles = void 0, this._list = new kf(), this._sentinel = this._list.add(\"sentinel\"), this._trimTiles = !1;\n  }\n\n  reset() {\n    this._list.splice(this._list.tail, this._sentinel);\n  }\n\n  touch(t) {\n    const n = t._cacheNode;\n    n && this._list.splice(this._sentinel, n);\n  }\n\n  add(t, n, s) {\n    n._cacheNode || (n._cacheNode = this._list.add(n), s && s(t, n));\n  }\n\n  unloadTile(t, n, s) {\n    const r = n._cacheNode;\n    r && (this._list.remove(r), n._cacheNode = null, s && s(t, n));\n  }\n\n  unloadTiles(t, n) {\n    const s = this._trimTiles;\n    this._trimTiles = !1;\n    const r = this._list,\n          i = t.maximumMemoryUsage * 1024 * 1024,\n          o = this._sentinel;\n    let a = r.head;\n\n    for (; a !== o && (t.gpuMemoryUsageInBytes > i || s);) {\n      const c = a.item;\n      a = a.next, this.unloadTile(t, c, n);\n    }\n  }\n\n  trim() {\n    this._trimTiles = !0;\n  }\n\n}\n\nfunction zf(e, t) {\n  U(e), U(t);\n  const {\n    rtcCenter: n,\n    gltfUpAxis: s\n  } = t,\n        {\n    computedTransform: r,\n    boundingVolume: {\n      center: i\n    }\n  } = e;\n  let o = new V(r);\n\n  switch (n && o.translate(n), s) {\n    case \"Z\":\n      break;\n\n    case \"Y\":\n      const h = new V().rotateX(Math.PI / 2);\n      o = o.multiplyRight(h);\n      break;\n\n    case \"X\":\n      const f = new V().rotateY(-Math.PI / 2);\n      o = o.multiplyRight(f);\n      break;\n  }\n\n  t.isQuantized && o.translate(t.quantizedVolumeOffset).scale(t.quantizedVolumeScale);\n  const a = new A(i);\n  t.cartesianModelMatrix = o, t.cartesianOrigin = a;\n  const c = J.WGS84.cartesianToCartographic(a, new A()),\n        l = J.WGS84.eastNorthUpToFixedFrame(a).invert();\n  t.cartographicModelMatrix = l.multiplyRight(o), t.cartographicOrigin = c, t.coordinateSystem || (t.modelMatrix = t.cartographicModelMatrix);\n}\n\nconst mt = {\n  OUTSIDE: -1,\n  INTERSECTING: 0,\n  INSIDE: 1\n};\nnew A();\nnew A();\nconst Be = new A(),\n      di = new A();\n\nclass ke {\n  constructor(t = [0, 0, 0], n = 0) {\n    S(this, \"center\", void 0), S(this, \"radius\", void 0), this.radius = -0, this.center = new A(), this.fromCenterRadius(t, n);\n  }\n\n  fromCenterRadius(t, n) {\n    return this.center.from(t), this.radius = n, this;\n  }\n\n  fromCornerPoints(t, n) {\n    return n = Be.from(n), this.center = new A().from(t).add(n).scale(0.5), this.radius = this.center.distance(n), this;\n  }\n\n  equals(t) {\n    return this === t || !!t && this.center.equals(t.center) && this.radius === t.radius;\n  }\n\n  clone() {\n    return new ke(this.center, this.radius);\n  }\n\n  union(t) {\n    const n = this.center,\n          s = this.radius,\n          r = t.center,\n          i = t.radius,\n          o = Be.copy(r).subtract(n),\n          a = o.magnitude();\n    if (s >= a + i) return this.clone();\n    if (i >= a + s) return t.clone();\n    const c = (s + a + i) * 0.5;\n    return di.copy(o).scale((-s + c) / a).add(n), this.center.copy(di), this.radius = c, this;\n  }\n\n  expand(t) {\n    const s = Be.from(t).subtract(this.center).magnitude();\n    return s > this.radius && (this.radius = s), this;\n  }\n\n  transform(t) {\n    this.center.transform(t);\n    const n = Gh(Be, t);\n    return this.radius = Math.max(n[0], Math.max(n[1], n[2])) * this.radius, this;\n  }\n\n  distanceSquaredTo(t) {\n    const n = this.distanceTo(t);\n    return n * n;\n  }\n\n  distanceTo(t) {\n    const s = Be.from(t).subtract(this.center);\n    return Math.max(0, s.len() - this.radius);\n  }\n\n  intersectPlane(t) {\n    const n = this.center,\n          s = this.radius,\n          i = t.normal.dot(n) + t.distance;\n    return i < -s ? mt.OUTSIDE : i < s ? mt.INTERSECTING : mt.INSIDE;\n  }\n\n}\n\nconst Wf = new A(),\n      Xf = new A(),\n      sn = new A(),\n      rn = new A(),\n      on = new A(),\n      Qf = new A(),\n      qf = new A(),\n      Dt = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\n\nclass Ke {\n  constructor(t = [0, 0, 0], n = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {\n    S(this, \"center\", void 0), S(this, \"halfAxes\", void 0), this.center = new A().from(t), this.halfAxes = new Q(n);\n  }\n\n  get halfSize() {\n    const t = this.halfAxes.getColumn(0),\n          n = this.halfAxes.getColumn(1),\n          s = this.halfAxes.getColumn(2);\n    return [new A(t).len(), new A(n).len(), new A(s).len()];\n  }\n\n  get quaternion() {\n    const t = this.halfAxes.getColumn(0),\n          n = this.halfAxes.getColumn(1),\n          s = this.halfAxes.getColumn(2),\n          r = new A(t).normalize(),\n          i = new A(n).normalize(),\n          o = new A(s).normalize();\n    return new wn().fromMatrix3(new Q([...r, ...i, ...o]));\n  }\n\n  fromCenterHalfSizeQuaternion(t, n, s) {\n    const r = new wn(s),\n          i = new Q().fromQuaternion(r);\n    return i[0] = i[0] * n[0], i[1] = i[1] * n[0], i[2] = i[2] * n[0], i[3] = i[3] * n[1], i[4] = i[4] * n[1], i[5] = i[5] * n[1], i[6] = i[6] * n[2], i[7] = i[7] * n[2], i[8] = i[8] * n[2], this.center = new A().from(t), this.halfAxes = i, this;\n  }\n\n  clone() {\n    return new Ke(this.center, this.halfAxes);\n  }\n\n  equals(t) {\n    return this === t || !!t && this.center.equals(t.center) && this.halfAxes.equals(t.halfAxes);\n  }\n\n  getBoundingSphere(t = new ke()) {\n    const n = this.halfAxes,\n          s = n.getColumn(0, sn),\n          r = n.getColumn(1, rn),\n          i = n.getColumn(2, on),\n          o = Wf.copy(s).add(r).add(i);\n    return t.center.copy(this.center), t.radius = o.magnitude(), t;\n  }\n\n  intersectPlane(t) {\n    const n = this.center,\n          s = t.normal,\n          r = this.halfAxes,\n          i = s.x,\n          o = s.y,\n          a = s.z,\n          c = Math.abs(i * r[Dt.COLUMN0ROW0] + o * r[Dt.COLUMN0ROW1] + a * r[Dt.COLUMN0ROW2]) + Math.abs(i * r[Dt.COLUMN1ROW0] + o * r[Dt.COLUMN1ROW1] + a * r[Dt.COLUMN1ROW2]) + Math.abs(i * r[Dt.COLUMN2ROW0] + o * r[Dt.COLUMN2ROW1] + a * r[Dt.COLUMN2ROW2]),\n          u = s.dot(n) + t.distance;\n    return u <= -c ? mt.OUTSIDE : u >= c ? mt.INSIDE : mt.INTERSECTING;\n  }\n\n  distanceTo(t) {\n    return Math.sqrt(this.distanceSquaredTo(t));\n  }\n\n  distanceSquaredTo(t) {\n    const n = Xf.from(t).subtract(this.center),\n          s = this.halfAxes,\n          r = s.getColumn(0, sn),\n          i = s.getColumn(1, rn),\n          o = s.getColumn(2, on),\n          a = r.magnitude(),\n          c = i.magnitude(),\n          u = o.magnitude();\n    r.normalize(), i.normalize(), o.normalize();\n    let l = 0,\n        h;\n    return h = Math.abs(n.dot(r)) - a, h > 0 && (l += h * h), h = Math.abs(n.dot(i)) - c, h > 0 && (l += h * h), h = Math.abs(n.dot(o)) - u, h > 0 && (l += h * h), l;\n  }\n\n  computePlaneDistances(t, n, s = [-0, -0]) {\n    let r = Number.POSITIVE_INFINITY,\n        i = Number.NEGATIVE_INFINITY;\n    const o = this.center,\n          a = this.halfAxes,\n          c = a.getColumn(0, sn),\n          u = a.getColumn(1, rn),\n          l = a.getColumn(2, on),\n          h = Qf.copy(c).add(u).add(l).add(o),\n          f = qf.copy(h).subtract(t);\n    let d = n.dot(f);\n    return r = Math.min(d, r), i = Math.max(d, i), h.copy(o).add(c).add(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), h.copy(o).add(c).subtract(u).add(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), h.copy(o).add(c).subtract(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).add(u).add(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).add(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).subtract(u).add(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).subtract(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), s[0] = r, s[1] = i, s;\n  }\n\n  transform(t) {\n    this.center.transformAsPoint(t);\n    const n = this.halfAxes.getColumn(0, sn);\n    n.transformAsPoint(t);\n    const s = this.halfAxes.getColumn(1, rn);\n    s.transformAsPoint(t);\n    const r = this.halfAxes.getColumn(2, on);\n    return r.transformAsPoint(t), this.halfAxes = new Q([...n, ...s, ...r]), this;\n  }\n\n  getTransform() {\n    throw new Error(\"not implemented\");\n  }\n\n}\n\nconst mi = new A(),\n      gi = new A();\n\nclass et {\n  constructor(t = [0, 0, 1], n = 0) {\n    S(this, \"normal\", void 0), S(this, \"distance\", void 0), this.normal = new A(), this.distance = -0, this.fromNormalDistance(t, n);\n  }\n\n  fromNormalDistance(t, n) {\n    return k(Number.isFinite(n)), this.normal.from(t).normalize(), this.distance = n, this;\n  }\n\n  fromPointNormal(t, n) {\n    t = mi.from(t), this.normal.from(n).normalize();\n    const s = -this.normal.dot(t);\n    return this.distance = s, this;\n  }\n\n  fromCoefficients(t, n, s, r) {\n    return this.normal.set(t, n, s), k(Jt(this.normal.len(), 1)), this.distance = r, this;\n  }\n\n  clone() {\n    return new et(this.normal, this.distance);\n  }\n\n  equals(t) {\n    return Jt(this.distance, t.distance) && Jt(this.normal, t.normal);\n  }\n\n  getPointDistance(t) {\n    return this.normal.dot(t) + this.distance;\n  }\n\n  transform(t) {\n    const n = gi.copy(this.normal).transformAsVector(t).normalize(),\n          s = this.normal.scale(-this.distance).transform(t);\n    return this.fromPointNormal(s, n);\n  }\n\n  projectPointOntoPlane(t, n = [0, 0, 0]) {\n    const s = mi.from(t),\n          r = this.getPointDistance(s),\n          i = gi.copy(this.normal).scale(r);\n    return s.subtract(i).to(n);\n  }\n\n}\n\nconst Ai = [new A([1, 0, 0]), new A([0, 1, 0]), new A([0, 0, 1])],\n      pi = new A(),\n      Yf = new A();\n\nclass ht {\n  constructor(t = []) {\n    S(this, \"planes\", void 0), this.planes = t;\n  }\n\n  fromBoundingSphere(t) {\n    this.planes.length = 2 * Ai.length;\n    const n = t.center,\n          s = t.radius;\n    let r = 0;\n\n    for (const i of Ai) {\n      let o = this.planes[r],\n          a = this.planes[r + 1];\n      o || (o = this.planes[r] = new et()), a || (a = this.planes[r + 1] = new et());\n      const c = pi.copy(i).scale(-s).add(n);\n      o.fromPointNormal(c, i);\n      const u = pi.copy(i).scale(s).add(n),\n            l = Yf.copy(i).negate();\n      a.fromPointNormal(u, l), r += 2;\n    }\n\n    return this;\n  }\n\n  computeVisibility(t) {\n    let n = mt.INSIDE;\n\n    for (const s of this.planes) switch (t.intersectPlane(s)) {\n      case mt.OUTSIDE:\n        return mt.OUTSIDE;\n\n      case mt.INTERSECTING:\n        n = mt.INTERSECTING;\n        break;\n    }\n\n    return n;\n  }\n\n  computeVisibilityWithPlaneMask(t, n) {\n    if (k(Number.isFinite(n), \"parentPlaneMask is required.\"), n === ht.MASK_OUTSIDE || n === ht.MASK_INSIDE) return n;\n    let s = ht.MASK_INSIDE;\n    const r = this.planes;\n\n    for (let i = 0; i < this.planes.length; ++i) {\n      const o = i < 31 ? 1 << i : 0;\n      if (i < 31 && !(n & o)) continue;\n      const a = r[i],\n            c = t.intersectPlane(a);\n      if (c === mt.OUTSIDE) return ht.MASK_OUTSIDE;\n      c === mt.INTERSECTING && (s |= o);\n    }\n\n    return s;\n  }\n\n}\n\nS(ht, \"MASK_OUTSIDE\", 4294967295);\nS(ht, \"MASK_INSIDE\", 0);\nS(ht, \"MASK_INDETERMINATE\", 2147483647);\nconst $f = new A(),\n      Zf = new A(),\n      td = new A(),\n      ed = new A(),\n      nd = new A();\n\nclass Rn {\n  constructor(t = {}) {\n    S(this, \"left\", void 0), S(this, \"_left\", void 0), S(this, \"right\", void 0), S(this, \"_right\", void 0), S(this, \"top\", void 0), S(this, \"_top\", void 0), S(this, \"bottom\", void 0), S(this, \"_bottom\", void 0), S(this, \"near\", void 0), S(this, \"_near\", void 0), S(this, \"far\", void 0), S(this, \"_far\", void 0), S(this, \"_cullingVolume\", new ht([new et(), new et(), new et(), new et(), new et(), new et()])), S(this, \"_perspectiveMatrix\", new V()), S(this, \"_infinitePerspective\", new V());\n    const {\n      near: n = 1,\n      far: s = 5e8\n    } = t;\n    this.left = t.left, this._left = void 0, this.right = t.right, this._right = void 0, this.top = t.top, this._top = void 0, this.bottom = t.bottom, this._bottom = void 0, this.near = n, this._near = n, this.far = s, this._far = s;\n  }\n\n  clone() {\n    return new Rn({\n      right: this.right,\n      left: this.left,\n      top: this.top,\n      bottom: this.bottom,\n      near: this.near,\n      far: this.far\n    });\n  }\n\n  equals(t) {\n    return t && t instanceof Rn && this.right === t.right && this.left === t.left && this.top === t.top && this.bottom === t.bottom && this.near === t.near && this.far === t.far;\n  }\n\n  get projectionMatrix() {\n    return this._update(), this._perspectiveMatrix;\n  }\n\n  get infiniteProjectionMatrix() {\n    return this._update(), this._infinitePerspective;\n  }\n\n  computeCullingVolume(t, n, s) {\n    k(t, \"position is required.\"), k(n, \"direction is required.\"), k(s, \"up is required.\");\n    const r = this._cullingVolume.planes;\n    s = $f.copy(s).normalize();\n    const i = Zf.copy(n).cross(s).normalize(),\n          o = td.copy(n).multiplyByScalar(this.near).add(t),\n          a = ed.copy(n).multiplyByScalar(this.far).add(t);\n    let c = nd;\n    return c.copy(i).multiplyByScalar(this.left).add(o).subtract(t).cross(s), r[0].fromPointNormal(t, c), c.copy(i).multiplyByScalar(this.right).add(o).subtract(t).cross(s).negate(), r[1].fromPointNormal(t, c), c.copy(s).multiplyByScalar(this.bottom).add(o).subtract(t).cross(i).negate(), r[2].fromPointNormal(t, c), c.copy(s).multiplyByScalar(this.top).add(o).subtract(t).cross(i), r[3].fromPointNormal(t, c), c = new A().copy(n), r[4].fromPointNormal(o, c), c.negate(), r[5].fromPointNormal(a, c), this._cullingVolume;\n  }\n\n  getPixelDimensions(t, n, s, r) {\n    this._update(), k(Number.isFinite(t) && Number.isFinite(n)), k(t > 0), k(n > 0), k(s > 0), k(r);\n    const i = 1 / this.near;\n    let o = this.top * i;\n    const a = 2 * s * o / n;\n    o = this.right * i;\n    const c = 2 * s * o / t;\n    return r.x = c, r.y = a, r;\n  }\n\n  _update() {\n    k(Number.isFinite(this.right) && Number.isFinite(this.left) && Number.isFinite(this.top) && Number.isFinite(this.bottom) && Number.isFinite(this.near) && Number.isFinite(this.far));\n    const {\n      top: t,\n      bottom: n,\n      right: s,\n      left: r,\n      near: i,\n      far: o\n    } = this;\n    (t !== this._top || n !== this._bottom || r !== this._left || s !== this._right || i !== this._near || o !== this._far) && (k(this.near > 0 && this.near < this.far, \"near must be greater than zero and less than far.\"), this._left = r, this._right = s, this._top = t, this._bottom = n, this._near = i, this._far = o, this._perspectiveMatrix = new V().frustum({\n      left: r,\n      right: s,\n      bottom: n,\n      top: t,\n      near: i,\n      far: o\n    }), this._infinitePerspective = new V().frustum({\n      left: r,\n      right: s,\n      bottom: n,\n      top: t,\n      near: i,\n      far: 1 / 0\n    }));\n  }\n\n}\n\nconst sd = e => e !== null && typeof e < \"u\";\n\nclass Mn {\n  constructor(t = {}) {\n    S(this, \"_offCenterFrustum\", new Rn()), S(this, \"fov\", void 0), S(this, \"_fov\", void 0), S(this, \"_fovy\", void 0), S(this, \"_sseDenominator\", void 0), S(this, \"aspectRatio\", void 0), S(this, \"_aspectRatio\", void 0), S(this, \"near\", void 0), S(this, \"_near\", void 0), S(this, \"far\", void 0), S(this, \"_far\", void 0), S(this, \"xOffset\", void 0), S(this, \"_xOffset\", void 0), S(this, \"yOffset\", void 0), S(this, \"_yOffset\", void 0);\n    const {\n      fov: n,\n      aspectRatio: s,\n      near: r = 1,\n      far: i = 5e8,\n      xOffset: o = 0,\n      yOffset: a = 0\n    } = t;\n    this.fov = n, this.aspectRatio = s, this.near = r, this.far = i, this.xOffset = o, this.yOffset = a;\n  }\n\n  clone() {\n    return new Mn({\n      aspectRatio: this.aspectRatio,\n      fov: this.fov,\n      near: this.near,\n      far: this.far\n    });\n  }\n\n  equals(t) {\n    return !sd(t) || !(t instanceof Mn) ? !1 : (this._update(), t._update(), this.fov === t.fov && this.aspectRatio === t.aspectRatio && this.near === t.near && this.far === t.far && this._offCenterFrustum.equals(t._offCenterFrustum));\n  }\n\n  get projectionMatrix() {\n    return this._update(), this._offCenterFrustum.projectionMatrix;\n  }\n\n  get infiniteProjectionMatrix() {\n    return this._update(), this._offCenterFrustum.infiniteProjectionMatrix;\n  }\n\n  get fovy() {\n    return this._update(), this._fovy;\n  }\n\n  get sseDenominator() {\n    return this._update(), this._sseDenominator;\n  }\n\n  computeCullingVolume(t, n, s) {\n    return this._update(), this._offCenterFrustum.computeCullingVolume(t, n, s);\n  }\n\n  getPixelDimensions(t, n, s, r) {\n    return this._update(), this._offCenterFrustum.getPixelDimensions(t, n, s, r || new Nn());\n  }\n\n  _update() {\n    k(Number.isFinite(this.fov) && Number.isFinite(this.aspectRatio) && Number.isFinite(this.near) && Number.isFinite(this.far));\n    const t = this._offCenterFrustum;\n    (this.fov !== this._fov || this.aspectRatio !== this._aspectRatio || this.near !== this._near || this.far !== this._far || this.xOffset !== this._xOffset || this.yOffset !== this._yOffset) && (k(this.fov >= 0 && this.fov < Math.PI), k(this.aspectRatio > 0), k(this.near >= 0 && this.near < this.far), this._aspectRatio = this.aspectRatio, this._fov = this.fov, this._fovy = this.aspectRatio <= 1 ? this.fov : Math.atan(Math.tan(this.fov * 0.5) / this.aspectRatio) * 2, this._near = this.near, this._far = this.far, this._sseDenominator = 2 * Math.tan(0.5 * this._fovy), this._xOffset = this.xOffset, this._yOffset = this.yOffset, t.top = this.near * Math.tan(0.5 * this._fovy), t.bottom = -t.top, t.right = this.aspectRatio * t.top, t.left = -t.right, t.near = this.near, t.far = this.far, t.right += this.xOffset, t.left += this.xOffset, t.top += this.yOffset, t.bottom += this.yOffset);\n  }\n\n}\n\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nconst It = new Q(),\n      rd = new Q(),\n      id = new Q(),\n      an = new Q(),\n      yi = new Q();\n\nfunction od(e, t = {}) {\n  const n = Rf,\n        s = 10;\n  let r = 0,\n      i = 0;\n  const o = rd,\n        a = id;\n  o.identity(), a.copy(e);\n  const c = n * ad(a);\n\n  for (; i < s && cd(a) > c;) ud(a, an), yi.copy(an).transpose(), a.multiplyRight(an), a.multiplyLeft(yi), o.multiplyRight(an), ++r > 2 && (++i, r = 0);\n\n  return t.unitary = o.toTarget(t.unitary), t.diagonal = a.toTarget(t.diagonal), t;\n}\n\nfunction ad(e) {\n  let t = 0;\n\n  for (let n = 0; n < 9; ++n) {\n    const s = e[n];\n    t += s * s;\n  }\n\n  return Math.sqrt(t);\n}\n\nconst Ns = [1, 0, 0],\n      Us = [2, 2, 1];\n\nfunction cd(e) {\n  let t = 0;\n\n  for (let n = 0; n < 3; ++n) {\n    const s = e[It.getElementIndex(Us[n], Ns[n])];\n    t += 2 * s * s;\n  }\n\n  return Math.sqrt(t);\n}\n\nfunction ud(e, t) {\n  const n = ma;\n  let s = 0,\n      r = 1;\n\n  for (let u = 0; u < 3; ++u) {\n    const l = Math.abs(e[It.getElementIndex(Us[u], Ns[u])]);\n    l > s && (r = u, s = l);\n  }\n\n  const i = Ns[r],\n        o = Us[r];\n  let a = 1,\n      c = 0;\n\n  if (Math.abs(e[It.getElementIndex(o, i)]) > n) {\n    const u = e[It.getElementIndex(o, o)],\n          l = e[It.getElementIndex(i, i)],\n          h = e[It.getElementIndex(o, i)],\n          f = (u - l) / 2 / h;\n    let d;\n    f < 0 ? d = -1 / (-f + Math.sqrt(1 + f * f)) : d = 1 / (f + Math.sqrt(1 + f * f)), a = 1 / Math.sqrt(1 + d * d), c = d * a;\n  }\n\n  return Q.IDENTITY.to(t), t[It.getElementIndex(i, i)] = t[It.getElementIndex(o, o)] = a, t[It.getElementIndex(o, i)] = c, t[It.getElementIndex(i, o)] = -c, t;\n}\n\nconst Ut = new A(),\n      ld = new A(),\n      hd = new A(),\n      fd = new A(),\n      dd = new A(),\n      md = new Q(),\n      gd = {\n  diagonal: new Q(),\n  unitary: new Q()\n};\n\nfunction Ad(e, t = new Ke()) {\n  if (!e || e.length === 0) return t.halfAxes = new Q([0, 0, 0, 0, 0, 0, 0, 0, 0]), t.center = new A(), t;\n  const n = e.length,\n        s = new A(0, 0, 0);\n\n  for (const x of e) s.add(x);\n\n  const r = 1 / n;\n  s.multiplyByScalar(r);\n  let i = 0,\n      o = 0,\n      a = 0,\n      c = 0,\n      u = 0,\n      l = 0;\n\n  for (const x of e) {\n    const v = Ut.copy(x).subtract(s);\n    i += v.x * v.x, o += v.x * v.y, a += v.x * v.z, c += v.y * v.y, u += v.y * v.z, l += v.z * v.z;\n  }\n\n  i *= r, o *= r, a *= r, c *= r, u *= r, l *= r;\n  const h = md;\n  h[0] = i, h[1] = o, h[2] = a, h[3] = o, h[4] = c, h[5] = u, h[6] = a, h[7] = u, h[8] = l;\n  const {\n    unitary: f\n  } = od(h, gd),\n        d = t.halfAxes.copy(f);\n  let m = d.getColumn(0, hd),\n      g = d.getColumn(1, fd),\n      p = d.getColumn(2, dd),\n      C = -Number.MAX_VALUE,\n      w = -Number.MAX_VALUE,\n      y = -Number.MAX_VALUE,\n      B = Number.MAX_VALUE,\n      R = Number.MAX_VALUE,\n      E = Number.MAX_VALUE;\n\n  for (const x of e) Ut.copy(x), C = Math.max(Ut.dot(m), C), w = Math.max(Ut.dot(g), w), y = Math.max(Ut.dot(p), y), B = Math.min(Ut.dot(m), B), R = Math.min(Ut.dot(g), R), E = Math.min(Ut.dot(p), E);\n\n  m = m.multiplyByScalar(0.5 * (B + C)), g = g.multiplyByScalar(0.5 * (R + w)), p = p.multiplyByScalar(0.5 * (E + y)), t.center.copy(m).add(g).add(p);\n  const O = ld.set(C - B, w - R, y - E).multiplyByScalar(0.5),\n        F = new Q([O[0], 0, 0, 0, O[1], 0, 0, 0, O[2]]);\n  return t.halfAxes.multiplyRight(F), t;\n}\n\nconst Bi = new A(),\n      as = new A(),\n      Hs = new ht([new et(), new et(), new et(), new et(), new et(), new et()]);\n\nfunction pd(e, t) {\n  const {\n    cameraDirection: n,\n    cameraUp: s,\n    height: r\n  } = e,\n        {\n    metersPerUnit: i\n  } = e.distanceScales,\n        o = yn(e, e.center),\n        a = J.WGS84.eastNorthUpToFixedFrame(o),\n        c = e.unprojectPosition(e.cameraPosition),\n        u = J.WGS84.cartographicToCartesian(c, new A()),\n        l = new A(a.transformAsVector(new A(n).scale(i))).normalize(),\n        h = new A(a.transformAsVector(new A(s).scale(i))).normalize();\n  Bd(e);\n  const f = e.constructor,\n        {\n    longitude: d,\n    latitude: m,\n    width: g,\n    bearing: p,\n    zoom: C\n  } = e,\n        w = new f({\n    longitude: d,\n    latitude: m,\n    height: r,\n    width: g,\n    bearing: p,\n    zoom: C,\n    pitch: 0\n  });\n  return {\n    camera: {\n      position: u,\n      direction: l,\n      up: h\n    },\n    viewport: e,\n    topDownViewport: w,\n    height: r,\n    cullingVolume: Hs,\n    frameNumber: t,\n    sseDenominator: 1.15\n  };\n}\n\nfunction yd(e, t, n) {\n  if (n === 0 || e.length <= n) return [e, []];\n  const s = [],\n        {\n    longitude: r,\n    latitude: i\n  } = t.viewport;\n\n  for (const [u, l] of e.entries()) {\n    const [h, f] = l.header.mbs,\n          d = Math.abs(r - h),\n          m = Math.abs(i - f),\n          g = Math.sqrt(m * m + d * d);\n    s.push([u, g]);\n  }\n\n  const o = s.sort((u, l) => u[1] - l[1]),\n        a = [];\n\n  for (let u = 0; u < n; u++) a.push(e[o[u][0]]);\n\n  const c = [];\n\n  for (let u = n; u < o.length; u++) c.push(e[o[u][0]]);\n\n  return [a, c];\n}\n\nfunction Bd(e) {\n  const t = e.getFrustumPlanes(),\n        n = Ci(t.near, e.cameraPosition),\n        s = yn(e, n),\n        r = yn(e, e.cameraPosition, as);\n  let i = 0;\n  Hs.planes[i++].fromPointNormal(s, Bi.copy(s).subtract(r));\n\n  for (const o in t) {\n    if (o === \"near\") continue;\n    const a = t[o],\n          c = Ci(a, n, as),\n          u = yn(e, c, as);\n    Hs.planes[i++].fromPointNormal(u, Bi.copy(s).subtract(u));\n  }\n}\n\nfunction Ci(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new A();\n  const s = e.normal.dot(t);\n  return n.copy(e.normal).scale(e.distance - s).add(t), n;\n}\n\nfunction yn(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new A();\n  const s = e.unprojectPosition(t);\n  return J.WGS84.cartographicToCartesian(s, n);\n}\n\nconst Cd = 6378137,\n      Ed = 6378137,\n      Js = 6356752314245179e-9,\n      ue = new A();\n\nfunction Td(e, t) {\n  if (e instanceof Ke) {\n    const {\n      halfAxes: n\n    } = e,\n          s = _d(n);\n\n    return Math.log2(Js / (s + t[2]));\n  } else if (e instanceof ke) {\n    const {\n      radius: n\n    } = e;\n    return Math.log2(Js / (n + t[2]));\n  } else if (e.width && e.height) {\n    const {\n      width: n,\n      height: s\n    } = e,\n          r = Math.log2(Cd / n),\n          i = Math.log2(Ed / s);\n    return (r + i) / 2;\n  }\n\n  return 1;\n}\n\nfunction ga(e, t, n) {\n  J.WGS84.cartographicToCartesian([e.xmax, e.ymax, e.zmax], ue);\n  const s = Math.sqrt(Math.pow(ue[0] - n[0], 2) + Math.pow(ue[1] - n[1], 2) + Math.pow(ue[2] - n[2], 2));\n  return Math.log2(Js / (s + t[2]));\n}\n\nfunction bd(e, t, n) {\n  const [s, r, i, o] = e;\n  return ga({\n    xmin: s,\n    xmax: i,\n    ymin: r,\n    ymax: o,\n    zmin: 0,\n    zmax: 0\n  }, t, n);\n}\n\nfunction _d(e) {\n  e.getColumn(0, ue);\n  const t = e.getColumn(1),\n        n = e.getColumn(2);\n  return ue.add(t).add(n).len();\n}\n\nconst ut = {\n  UNLOADED: 0,\n  LOADING: 1,\n  PROCESSING: 2,\n  READY: 3,\n  EXPIRED: 4,\n  FAILED: 5\n};\n\nlet Pt = function (e) {\n  return e[e.ADD = 1] = \"ADD\", e[e.REPLACE = 2] = \"REPLACE\", e;\n}({}),\n    zt = function (e) {\n  return e.EMPTY = \"empty\", e.SCENEGRAPH = \"scenegraph\", e.POINTCLOUD = \"pointcloud\", e.MESH = \"mesh\", e;\n}({}),\n    At = function (e) {\n  return e.I3S = \"I3S\", e.TILES3D = \"TILES3D\", e;\n}({}),\n    Hn = function (e) {\n  return e.GEOMETRIC_ERROR = \"geometricError\", e.MAX_SCREEN_THRESHOLD = \"maxScreenThreshold\", e;\n}({});\n\nconst wd = {\n  NOT_COMPUTED: -1,\n  USE_OPTIMIZATION: 1,\n  SKIP_OPTIMIZATION: 0\n};\n\nfunction Aa(e) {\n  return e != null;\n}\n\nconst rt = new A(),\n      Bn = new A(),\n      Rd = new A(),\n      Md = new A(),\n      kt = new A(),\n      Ei = new A(),\n      Ti = new A(),\n      bi = new A();\n\nfunction cs(e, t, n) {\n  if (U(e, \"3D Tile: boundingVolume must be defined\"), e.box) return pa(e.box, t, n);\n  if (e.region) return xd(e.region);\n  if (e.sphere) return Sd(e.sphere, t, n);\n  throw new Error(\"3D Tile: boundingVolume must contain a sphere, region, or box\");\n}\n\nfunction Id(e, t) {\n  if (e.box) return Od(t);\n\n  if (e.region) {\n    const [n, s, r, i, o, a] = e.region;\n    return [[_t(n), _t(s), o], [_t(r), _t(i), a]];\n  }\n\n  if (e.sphere) return Fd(t);\n  throw new Error(\"Unkown boundingVolume type\");\n}\n\nfunction pa(e, t, n) {\n  const s = new A(e[0], e[1], e[2]);\n  t.transform(s, s);\n  let r = [];\n\n  if (e.length === 10) {\n    const u = e.slice(3, 6),\n          l = new wn();\n    l.fromArray(e, 6);\n    const h = new A([1, 0, 0]),\n          f = new A([0, 1, 0]),\n          d = new A([0, 0, 1]);\n    h.transformByQuaternion(l), h.scale(u[0]), f.transformByQuaternion(l), f.scale(u[1]), d.transformByQuaternion(l), d.scale(u[2]), r = [...h.toArray(), ...f.toArray(), ...d.toArray()];\n  } else r = [...e.slice(3, 6), ...e.slice(6, 9), ...e.slice(9, 12)];\n\n  const i = t.transformAsVector(r.slice(0, 3)),\n        o = t.transformAsVector(r.slice(3, 6)),\n        a = t.transformAsVector(r.slice(6, 9)),\n        c = new Q([i[0], i[1], i[2], o[0], o[1], o[2], a[0], a[1], a[2]]);\n  return Aa(n) ? (n.center = s, n.halfAxes = c, n) : new Ke(s, c);\n}\n\nfunction Sd(e, t, n) {\n  const s = new A(e[0], e[1], e[2]);\n  t.transform(s, s);\n  const r = t.getScale(Bn),\n        i = Math.max(Math.max(r[0], r[1]), r[2]),\n        o = e[3] * i;\n  return Aa(n) ? (n.center = s, n.radius = o, n) : new ke(s, o);\n}\n\nfunction xd(e) {\n  const [t, n, s, r, i, o] = e,\n        a = J.WGS84.cartographicToCartesian([_t(t), _t(r), i], Rd),\n        c = J.WGS84.cartographicToCartesian([_t(s), _t(n), o], Md),\n        u = new A().addVectors(a, c).multiplyByScalar(0.5);\n  return J.WGS84.cartesianToCartographic(u, kt), J.WGS84.cartographicToCartesian([_t(s), kt[1], kt[2]], Ei), J.WGS84.cartographicToCartesian([kt[0], _t(r), kt[2]], Ti), J.WGS84.cartographicToCartesian([kt[0], kt[1], o], bi), pa([...u, ...Ei.subtract(u), ...Ti.subtract(u), ...bi.subtract(u)], new V());\n}\n\nfunction Od(e) {\n  const t = ya(),\n        {\n    halfAxes: n\n  } = e,\n        s = new A(n.getColumn(0)),\n        r = new A(n.getColumn(1)),\n        i = new A(n.getColumn(2));\n\n  for (let o = 0; o < 2; o++) {\n    for (let a = 0; a < 2; a++) {\n      for (let c = 0; c < 2; c++) rt.copy(e.center), rt.add(s), rt.add(r), rt.add(i), Ba(t, rt), i.negate();\n\n      r.negate();\n    }\n\n    s.negate();\n  }\n\n  return t;\n}\n\nfunction Fd(e) {\n  const t = ya(),\n        {\n    center: n,\n    radius: s\n  } = e,\n        r = J.WGS84.scaleToGeodeticSurface(n, rt);\n  let i;\n  r ? i = J.WGS84.geodeticSurfaceNormal(r) : i = new A(0, 0, 1);\n  let o = new A(i[2], -i[1], 0);\n  o.len() > 0 ? o.normalize() : o = new A(0, 1, 0);\n  const a = o.clone().cross(i);\n\n  for (const c of [o, a, i]) {\n    Bn.copy(c).scale(s);\n\n    for (let u = 0; u < 2; u++) rt.copy(n), rt.add(Bn), Ba(t, rt), Bn.negate();\n  }\n\n  return t;\n}\n\nfunction ya() {\n  return [[1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]];\n}\n\nfunction Ba(e, t) {\n  J.WGS84.cartesianToCartographic(t, rt), e[0][0] = Math.min(e[0][0], rt[0]), e[0][1] = Math.min(e[0][1], rt[1]), e[0][2] = Math.min(e[0][2], rt[2]), e[1][0] = Math.max(e[1][0], rt[0]), e[1][1] = Math.max(e[1][1], rt[1]), e[1][2] = Math.max(e[1][2], rt[2]);\n}\n\nnew A();\nnew A();\nnew V();\nnew A();\nnew A();\nnew A();\n\nfunction vd(e, t) {\n  const n = e * t;\n  return 1 - Math.exp(-(n * n));\n}\n\nfunction Dd(e, t) {\n  if (e.dynamicScreenSpaceError && e.dynamicScreenSpaceErrorComputedDensity) {\n    const n = e.dynamicScreenSpaceErrorComputedDensity,\n          s = e.dynamicScreenSpaceErrorFactor;\n    return vd(t, n) * s;\n  }\n\n  return 0;\n}\n\nfunction Ld(e, t, n) {\n  const s = e.tileset,\n        r = e.parent && e.parent.lodMetricValue || e.lodMetricValue,\n        i = n ? r : e.lodMetricValue;\n  if (i === 0) return 0;\n  const o = Math.max(e._distanceToCamera, 1e-7),\n        {\n    height: a,\n    sseDenominator: c\n  } = t,\n        {\n    viewDistanceScale: u\n  } = s.options;\n  let l = i * a * (u || 1) / (o * c);\n  return l -= Dd(s, o), l;\n}\n\nconst us = new A(),\n      _i = new A(),\n      Ht = new A(),\n      wi = new A(),\n      Gd = new A(),\n      ls = new V(),\n      Ri = new V();\n\nfunction Pd(e, t) {\n  if (e.lodMetricValue === 0 || isNaN(e.lodMetricValue)) return \"DIG\";\n  const n = 2 * Ca(e, t);\n  return n < 2 ? \"OUT\" : !e.header.children || n <= e.lodMetricValue ? \"DRAW\" : e.header.children ? \"DIG\" : \"OUT\";\n}\n\nfunction Ca(e, t) {\n  const {\n    topDownViewport: n\n  } = t,\n        s = e.header.mbs[1],\n        r = e.header.mbs[0],\n        i = e.header.mbs[2],\n        o = e.header.mbs[3],\n        a = [...e.boundingVolume.center],\n        c = n.unprojectPosition(n.cameraPosition);\n  J.WGS84.cartographicToCartesian(c, us), _i.copy(us).subtract(a).normalize(), J.WGS84.eastNorthUpToFixedFrame(a, ls), Ri.copy(ls).invert(), Ht.copy(us).transform(Ri);\n  const u = Math.sqrt(Ht[0] * Ht[0] + Ht[1] * Ht[1]),\n        l = u * u / Ht[2];\n  wi.copy([Ht[0], Ht[1], l]);\n\n  const f = wi.transform(ls).subtract(a).normalize(),\n        m = _i.cross(f).normalize().scale(o).add(a),\n        g = J.WGS84.cartesianToCartographic(m),\n        p = n.project([r, s, i]),\n        C = n.project(g);\n\n  return Gd.copy(p).subtract(C).magnitude();\n}\n\nfunction Nd(e) {\n  return {\n    assetGltfUpAxis: e.asset && e.asset.gltfUpAxis || \"Y\"\n  };\n}\n\nclass Mi {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n    this._map = /* @__PURE__ */new Map(), this._array = void 0, this._length = void 0, this._array = new Array(t), this._length = t;\n  }\n\n  get length() {\n    return this._length;\n  }\n\n  set length(t) {\n    this._length = t, t > this._array.length && (this._array.length = t);\n  }\n\n  get values() {\n    return this._array;\n  }\n\n  get(t) {\n    return U(t < this._array.length), this._array[t];\n  }\n\n  set(t, n) {\n    U(t >= 0), t >= this.length && (this.length = t + 1), this._map.has(this._array[t]) && this._map.delete(this._array[t]), this._array[t] = n, this._map.set(n, t);\n  }\n\n  delete(t) {\n    const n = this._map.get(t);\n\n    n >= 0 && (this._array.splice(n, 1), this._map.delete(t), this.length--);\n  }\n\n  peek() {\n    return this._array[this._length - 1];\n  }\n\n  push(t) {\n    if (!this._map.has(t)) {\n      const n = this.length++;\n      this._array[n] = t, this._map.set(t, n);\n    }\n  }\n\n  pop() {\n    const t = this._array[--this.length];\n    return this._map.delete(t), t;\n  }\n\n  reserve(t) {\n    U(t >= 0), t > this._array.length && (this._array.length = t);\n  }\n\n  resize(t) {\n    U(t >= 0), this.length = t;\n  }\n\n  trim(t) {\n    t == null && (t = this.length), this._array.length = t;\n  }\n\n  reset() {\n    this._array = [], this._map = /* @__PURE__ */new Map(), this._length = 0;\n  }\n\n  find(t) {\n    return this._map.has(t);\n  }\n\n}\n\nconst Ud = {\n  loadSiblings: !1,\n  skipLevelOfDetail: !1,\n  updateTransforms: !0,\n  onTraversalEnd: () => {},\n  viewportTraversersMap: {},\n  basePath: \"\"\n};\n\nclass Jn {\n  traversalFinished(t) {\n    return !0;\n  }\n\n  constructor(t) {\n    this.options = void 0, this.root = null, this.selectedTiles = {}, this.requestedTiles = {}, this.emptyTiles = {}, this.lastUpdate = /* @__PURE__ */new Date().getTime(), this.updateDebounceTime = 1e3, this._traversalStack = new Mi(), this._emptyTraversalStack = new Mi(), this._frameNumber = null, this.options = { ...Ud,\n      ...t\n    };\n  }\n\n  traverse(t, n, s) {\n    this.root = t, this.options = { ...this.options,\n      ...s\n    }, this.reset(), this.updateTile(t, n), this._frameNumber = n.frameNumber, this.executeTraversal(t, n);\n  }\n\n  reset() {\n    this.requestedTiles = {}, this.selectedTiles = {}, this.emptyTiles = {}, this._traversalStack.reset(), this._emptyTraversalStack.reset();\n  }\n\n  executeTraversal(t, n) {\n    const s = this._traversalStack;\n\n    for (t._selectionDepth = 1, s.push(t); s.length > 0;) {\n      const i = s.pop();\n      let o = !1;\n      this.canTraverse(i, n) && (this.updateChildTiles(i, n), o = this.updateAndPushChildren(i, n, s, i.hasRenderContent ? i._selectionDepth + 1 : i._selectionDepth));\n      const a = i.parent,\n            c = !!(!a || a._shouldRefine),\n            u = !o;\n      i.hasRenderContent ? i.refine === Pt.ADD ? (this.loadTile(i, n), this.selectTile(i, n)) : i.refine === Pt.REPLACE && (this.loadTile(i, n), u && this.selectTile(i, n)) : (this.emptyTiles[i.id] = i, this.loadTile(i, n), u && this.selectTile(i, n)), this.touchTile(i, n), i._shouldRefine = o && c;\n    }\n\n    const r = /* @__PURE__ */new Date().getTime();\n    (this.traversalFinished(n) || r - this.lastUpdate > this.updateDebounceTime) && (this.lastUpdate = r, this.options.onTraversalEnd(n));\n  }\n\n  updateChildTiles(t, n) {\n    const s = t.children;\n\n    for (const r of s) this.updateTile(r, n);\n  }\n\n  updateAndPushChildren(t, n, s, r) {\n    const {\n      loadSiblings: i,\n      skipLevelOfDetail: o\n    } = this.options,\n          a = t.children;\n    a.sort(this.compareDistanceToCamera.bind(this));\n    const c = t.refine === Pt.REPLACE && t.hasRenderContent && !o;\n    let u = !1,\n        l = !0;\n\n    for (const h of a) if (h._selectionDepth = r, h.isVisibleAndInRequestVolume ? (s.find(h) && s.delete(h), s.push(h), u = !0) : (c || i) && (this.loadTile(h, n), this.touchTile(h, n)), c) {\n      let f;\n      if (h._inRequestVolume ? h.hasRenderContent ? f = h.contentAvailable : f = this.executeEmptyTraversal(h, n) : f = !1, l = l && f, !l) return !1;\n    }\n\n    return u || (l = !1), l;\n  }\n\n  updateTile(t, n) {\n    this.updateTileVisibility(t, n);\n  }\n\n  selectTile(t, n) {\n    this.shouldSelectTile(t) && (t._selectedFrame = n.frameNumber, this.selectedTiles[t.id] = t);\n  }\n\n  loadTile(t, n) {\n    this.shouldLoadTile(t) && (t._requestedFrame = n.frameNumber, t._priority = t._getPriority(), this.requestedTiles[t.id] = t);\n  }\n\n  touchTile(t, n) {\n    t.tileset._cache.touch(t), t._touchedFrame = n.frameNumber;\n  }\n\n  canTraverse(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,\n        r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;\n    return t.hasChildren ? t.hasTilesetContent ? !t.contentExpired : !r && !t.isVisibleAndInRequestVolume ? !1 : this.shouldRefine(t, n, s) : !1;\n  }\n\n  shouldLoadTile(t) {\n    return t.hasUnloadedContent || t.contentExpired;\n  }\n\n  shouldSelectTile(t) {\n    return t.contentAvailable && !this.options.skipLevelOfDetail;\n  }\n\n  shouldRefine(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,\n        r = t._screenSpaceError;\n    return s && (r = t.getScreenSpaceError(n, !0)), r > t.tileset.memoryAdjustedScreenSpaceError;\n  }\n\n  updateTileVisibility(t, n) {\n    const s = [];\n    if (this.options.viewportTraversersMap) for (const r in this.options.viewportTraversersMap) this.options.viewportTraversersMap[r] === n.viewport.id && s.push(r);else s.push(n.viewport.id);\n    t.updateVisibility(n, s);\n  }\n\n  compareDistanceToCamera(t, n) {\n    return t._distanceToCamera - n._distanceToCamera;\n  }\n\n  anyChildrenVisible(t, n) {\n    let s = !1;\n\n    for (const r of t.children) r.updateVisibility(n), s = s || r.isVisibleAndInRequestVolume;\n\n    return s;\n  }\n\n  executeEmptyTraversal(t, n) {\n    let s = !0;\n    const r = this._emptyTraversalStack;\n\n    for (r.push(t); r.length > 0;) {\n      const i = r.pop(),\n            o = !i.hasRenderContent && this.canTraverse(i, n, !1, !1),\n            a = !i.hasRenderContent && i.children.length === 0;\n\n      if (!o && !i.contentAvailable && !a && (s = !1), this.updateTile(i, n), i.isVisibleAndInRequestVolume || (this.loadTile(i, n), this.touchTile(i, n)), o) {\n        const c = i.children;\n\n        for (const u of c) r.push(u);\n      }\n    }\n\n    return s;\n  }\n\n}\n\nconst Ii = new A();\n\nfunction Hd(e) {\n  return e != null;\n}\n\nclass Vs {\n  constructor(t, n, s) {\n    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"\";\n    this.tileset = void 0, this.header = void 0, this.id = void 0, this.url = void 0, this.parent = void 0, this.refine = void 0, this.type = void 0, this.contentUrl = void 0, this.lodMetricType = \"geometricError\", this.lodMetricValue = 0, this.boundingVolume = null, this.content = null, this.contentState = ut.UNLOADED, this.gpuMemoryUsageInBytes = 0, this.children = [], this.depth = 0, this.viewportIds = [], this.transform = new V(), this.extensions = null, this.implicitTiling = null, this.userData = {}, this.computedTransform = void 0, this.hasEmptyContent = !1, this.hasTilesetContent = !1, this.traverser = new Jn({}), this._cacheNode = null, this._frameNumber = null, this._expireDate = null, this._expiredContent = null, this._boundingBox = void 0, this._distanceToCamera = 0, this._screenSpaceError = 0, this._visibilityPlaneMask = void 0, this._visible = void 0, this._contentBoundingVolume = void 0, this._viewerRequestVolume = void 0, this._initialTransform = new V(), this._priority = 0, this._selectedFrame = 0, this._requestedFrame = 0, this._selectionDepth = 0, this._touchedFrame = 0, this._centerZDepth = 0, this._shouldRefine = !1, this._stackLength = 0, this._visitedFrame = 0, this._inRequestVolume = !1, this._lodJudge = null, this.header = n, this.tileset = t, this.id = r || n.id, this.url = n.url, this.parent = s, this.refine = this._getRefine(n.refine), this.type = n.type, this.contentUrl = n.contentUrl, this._initializeLodMetric(n), this._initializeTransforms(n), this._initializeBoundingVolumes(n), this._initializeContent(n), this._initializeRenderingState(n), Object.seal(this);\n  }\n\n  destroy() {\n    this.header = null;\n  }\n\n  isDestroyed() {\n    return this.header === null;\n  }\n\n  get selected() {\n    return this._selectedFrame === this.tileset._frameNumber;\n  }\n\n  get isVisible() {\n    return this._visible;\n  }\n\n  get isVisibleAndInRequestVolume() {\n    return this._visible && this._inRequestVolume;\n  }\n\n  get hasRenderContent() {\n    return !this.hasEmptyContent && !this.hasTilesetContent;\n  }\n\n  get hasChildren() {\n    return this.children.length > 0 || this.header.children && this.header.children.length > 0;\n  }\n\n  get contentReady() {\n    return this.contentState === ut.READY || this.hasEmptyContent;\n  }\n\n  get contentAvailable() {\n    return !!(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);\n  }\n\n  get hasUnloadedContent() {\n    return this.hasRenderContent && this.contentUnloaded;\n  }\n\n  get contentUnloaded() {\n    return this.contentState === ut.UNLOADED;\n  }\n\n  get contentExpired() {\n    return this.contentState === ut.EXPIRED;\n  }\n\n  get contentFailed() {\n    return this.contentState === ut.FAILED;\n  }\n\n  get distanceToCamera() {\n    return this._distanceToCamera;\n  }\n\n  get screenSpaceError() {\n    return this._screenSpaceError;\n  }\n\n  get boundingBox() {\n    return this._boundingBox || (this._boundingBox = Id(this.header.boundingVolume, this.boundingVolume)), this._boundingBox;\n  }\n\n  getScreenSpaceError(t, n) {\n    switch (this.tileset.type) {\n      case At.I3S:\n        return Ca(this, t);\n\n      case At.TILES3D:\n        return Ld(this, t, n);\n\n      default:\n        throw new Error(\"Unsupported tileset type\");\n    }\n  }\n\n  unselect() {\n    this._selectedFrame = 0;\n  }\n\n  _getGpuMemoryUsageInBytes() {\n    return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;\n  }\n\n  _getPriority() {\n    const t = this.tileset._traverser,\n          {\n      skipLevelOfDetail: n\n    } = t.options,\n          s = this.refine === Pt.ADD || n;\n    if (s && !this.isVisible && this._visible !== void 0 || this.tileset._frameNumber - this._touchedFrame >= 1 || this.contentState === ut.UNLOADED) return -1;\n    const r = this.parent,\n          o = r && (!s || this._screenSpaceError === 0 || r.hasTilesetContent) ? r._screenSpaceError : this._screenSpaceError,\n          a = t.root ? t.root._screenSpaceError : 0;\n    return Math.max(a - o, 0);\n  }\n\n  async loadContent() {\n    if (this.hasEmptyContent) return !1;\n    if (this.content) return !0;\n    this.contentExpired && (this._expireDate = null), this.contentState = ut.LOADING;\n    const n = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));\n    if (!n) return this.contentState = ut.UNLOADED, !1;\n\n    try {\n      const s = this.tileset.getTileUrl(this.contentUrl),\n            r = this.tileset.loader,\n            i = { ...this.tileset.loadOptions,\n        [r.id]: { ...this.tileset.loadOptions[r.id],\n          isTileset: this.type === \"json\",\n          ...this._getLoaderSpecificOptions(r.id)\n        }\n      };\n      return this.content = await fe(s, r, i), this.tileset.options.contentLoader && (await this.tileset.options.contentLoader(this)), this._isTileset() && this.tileset._initializeTileHeaders(this.content, this), this.contentState = ut.READY, this._onContentLoaded(), !0;\n    } catch (s) {\n      throw this.contentState = ut.FAILED, s;\n    } finally {\n      n.done();\n    }\n  }\n\n  unloadContent() {\n    return this.content && this.content.destroy && this.content.destroy(), this.content = null, this.header.content && this.header.content.destroy && this.header.content.destroy(), this.header.content = null, this.contentState = ut.UNLOADED, !0;\n  }\n\n  updateVisibility(t, n) {\n    if (this._frameNumber === t.frameNumber) return;\n    const s = this.parent,\n          r = s ? s._visibilityPlaneMask : ht.MASK_INDETERMINATE;\n\n    if (this.tileset._traverser.options.updateTransforms) {\n      const i = s ? s.computedTransform : this.tileset.modelMatrix;\n\n      this._updateTransform(i);\n    }\n\n    this._distanceToCamera = this.distanceToTile(t), this._screenSpaceError = this.getScreenSpaceError(t, !1), this._visibilityPlaneMask = this.visibility(t, r), this._visible = this._visibilityPlaneMask !== ht.MASK_OUTSIDE, this._inRequestVolume = this.insideViewerRequestVolume(t), this._frameNumber = t.frameNumber, this.viewportIds = n;\n  }\n\n  visibility(t, n) {\n    const {\n      cullingVolume: s\n    } = t,\n          {\n      boundingVolume: r\n    } = this;\n    return s.computeVisibilityWithPlaneMask(r, n);\n  }\n\n  contentVisibility() {\n    return !0;\n  }\n\n  distanceToTile(t) {\n    const n = this.boundingVolume;\n    return Math.sqrt(Math.max(n.distanceSquaredTo(t.camera.position), 0));\n  }\n\n  cameraSpaceZDepth(t) {\n    let {\n      camera: n\n    } = t;\n    const s = this.boundingVolume;\n    return Ii.subVectors(s.center, n.position), n.direction.dot(Ii);\n  }\n\n  insideViewerRequestVolume(t) {\n    const n = this._viewerRequestVolume;\n    return !n || n.distanceSquaredTo(t.camera.position) <= 0;\n  }\n\n  updateExpiration() {\n    if (Hd(this._expireDate) && this.contentReady && !this.hasEmptyContent) {\n      const t = Date.now();\n      Date.lessThan(this._expireDate, t) && (this.contentState = ut.EXPIRED, this._expiredContent = this.content);\n    }\n  }\n\n  get extras() {\n    return this.header.extras;\n  }\n\n  _initializeLodMetric(t) {\n    \"lodMetricType\" in t ? this.lodMetricType = t.lodMetricType : (this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType, console.warn(\"3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType\")), \"lodMetricValue\" in t ? this.lodMetricValue = t.lodMetricValue : (this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue, console.warn(\"3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue\"));\n  }\n\n  _initializeTransforms(t) {\n    this.transform = t.transform ? new V(t.transform) : new V();\n    const n = this.parent,\n          s = this.tileset,\n          r = n && n.computedTransform ? n.computedTransform.clone() : s.modelMatrix.clone();\n    this.computedTransform = new V(r).multiplyRight(this.transform);\n    const i = n && n._initialTransform ? n._initialTransform.clone() : new V();\n    this._initialTransform = new V(i).multiplyRight(this.transform);\n  }\n\n  _initializeBoundingVolumes(t) {\n    this._contentBoundingVolume = null, this._viewerRequestVolume = null, this._updateBoundingVolume(t);\n  }\n\n  _initializeContent(t) {\n    this.content = {\n      _tileset: this.tileset,\n      _tile: this\n    }, this.hasEmptyContent = !0, this.contentState = ut.UNLOADED, this.hasTilesetContent = !1, t.contentUrl && (this.content = null, this.hasEmptyContent = !1);\n  }\n\n  _initializeRenderingState(t) {\n    this.depth = t.level || (this.parent ? this.parent.depth + 1 : 0), this._shouldRefine = !1, this._distanceToCamera = 0, this._centerZDepth = 0, this._screenSpaceError = 0, this._visibilityPlaneMask = ht.MASK_INDETERMINATE, this._visible = void 0, this._inRequestVolume = !1, this._stackLength = 0, this._selectionDepth = 0, this._frameNumber = 0, this._touchedFrame = 0, this._visitedFrame = 0, this._selectedFrame = 0, this._requestedFrame = 0, this._priority = 0;\n  }\n\n  _getRefine(t) {\n    return t || this.parent && this.parent.refine || Pt.REPLACE;\n  }\n\n  _isTileset() {\n    return this.contentUrl.indexOf(\".json\") !== -1;\n  }\n\n  _onContentLoaded() {\n    switch (this.content && this.content.type) {\n      case \"vctr\":\n      case \"geom\":\n        this.tileset._traverser.disableSkipLevelOfDetail = !0;\n        break;\n    }\n\n    this._isTileset() ? this.hasTilesetContent = !0 : this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();\n  }\n\n  _updateBoundingVolume(t) {\n    this.boundingVolume = cs(t.boundingVolume, this.computedTransform, this.boundingVolume);\n    const n = t.content;\n    n && (n.boundingVolume && (this._contentBoundingVolume = cs(n.boundingVolume, this.computedTransform, this._contentBoundingVolume)), t.viewerRequestVolume && (this._viewerRequestVolume = cs(t.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume)));\n  }\n\n  _updateTransform() {\n    const n = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new V()).clone().multiplyRight(this.transform);\n    n.equals(this.computedTransform) || (this.computedTransform = n, this._updateBoundingVolume(this.header));\n  }\n\n  _getLoaderSpecificOptions(t) {\n    switch (t) {\n      case \"i3s\":\n        return { ...this.tileset.options.i3s,\n          _tileOptions: {\n            attributeUrls: this.header.attributeUrls,\n            textureUrl: this.header.textureUrl,\n            textureFormat: this.header.textureFormat,\n            textureLoaderOptions: this.header.textureLoaderOptions,\n            materialDefinition: this.header.materialDefinition,\n            isDracoGeometry: this.header.isDracoGeometry,\n            mbs: this.header.mbs\n          },\n          _tilesetOptions: {\n            store: this.tileset.tileset.store,\n            attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,\n            fields: this.tileset.tileset.fields\n          },\n          isTileHeader: !1\n        };\n\n      case \"3d-tiles\":\n      case \"cesium-ion\":\n      default:\n        return Nd(this.tileset.tileset);\n    }\n  }\n\n}\n\nclass Jd extends Jn {\n  compareDistanceToCamera(t, n) {\n    return n._distanceToCamera === 0 && t._distanceToCamera === 0 ? n._centerZDepth - t._centerZDepth : n._distanceToCamera - t._distanceToCamera;\n  }\n\n  updateTileVisibility(t, n) {\n    if (super.updateTileVisibility(t, n), !t.isVisibleAndInRequestVolume) return;\n    const s = t.children.length > 0;\n\n    if (t.hasTilesetContent && s) {\n      const o = t.children[0];\n      this.updateTileVisibility(o, n), t._visible = o._visible;\n      return;\n    }\n\n    if (this.meetsScreenSpaceErrorEarly(t, n)) {\n      t._visible = !1;\n      return;\n    }\n\n    const r = t.refine === Pt.REPLACE,\n          i = t._optimChildrenWithinParent === wd.USE_OPTIMIZATION;\n\n    if (r && i && s && !this.anyChildrenVisible(t, n)) {\n      t._visible = !1;\n      return;\n    }\n  }\n\n  meetsScreenSpaceErrorEarly(t, n) {\n    const {\n      parent: s\n    } = t;\n    return !s || s.hasTilesetContent || s.refine !== Pt.ADD ? !1 : !this.shouldRefine(t, n, !0);\n  }\n\n}\n\nclass Vd {\n  constructor() {\n    this.frameNumberMap = /* @__PURE__ */new Map();\n  }\n\n  register(t, n) {\n    const s = this.frameNumberMap.get(t) || /* @__PURE__ */new Map(),\n          r = s.get(n) || 0;\n    s.set(n, r + 1), this.frameNumberMap.set(t, s);\n  }\n\n  deregister(t, n) {\n    const s = this.frameNumberMap.get(t);\n    if (!s) return;\n    const r = s.get(n) || 1;\n    s.set(n, r - 1);\n  }\n\n  isZero(t, n) {\n    var s;\n    return (((s = this.frameNumberMap.get(t)) === null || s === void 0 ? void 0 : s.get(n)) || 0) === 0;\n  }\n\n}\n\nconst hs = {\n  REQUESTED: \"REQUESTED\",\n  COMPLETED: \"COMPLETED\",\n  ERROR: \"ERROR\"\n};\n\nclass jd {\n  constructor() {\n    this._statusMap = void 0, this.pendingTilesRegister = new Vd(), this._statusMap = {};\n  }\n\n  add(t, n, s, r) {\n    if (!this._statusMap[n]) {\n      const {\n        frameNumber: i,\n        viewport: {\n          id: o\n        }\n      } = r;\n      this._statusMap[n] = {\n        request: t,\n        callback: s,\n        key: n,\n        frameState: r,\n        status: hs.REQUESTED\n      }, this.pendingTilesRegister.register(o, i), t().then(a => {\n        this._statusMap[n].status = hs.COMPLETED;\n        const {\n          frameNumber: c,\n          viewport: {\n            id: u\n          }\n        } = this._statusMap[n].frameState;\n        this.pendingTilesRegister.deregister(u, c), this._statusMap[n].callback(a, r);\n      }).catch(a => {\n        this._statusMap[n].status = hs.ERROR;\n        const {\n          frameNumber: c,\n          viewport: {\n            id: u\n          }\n        } = this._statusMap[n].frameState;\n        this.pendingTilesRegister.deregister(u, c), s(a);\n      });\n    }\n  }\n\n  update(t, n) {\n    if (this._statusMap[t]) {\n      const {\n        frameNumber: s,\n        viewport: {\n          id: r\n        }\n      } = this._statusMap[t].frameState;\n      this.pendingTilesRegister.deregister(r, s);\n      const {\n        frameNumber: i,\n        viewport: {\n          id: o\n        }\n      } = n;\n      this.pendingTilesRegister.register(o, i), this._statusMap[t].frameState = n;\n    }\n  }\n\n  find(t) {\n    return this._statusMap[t];\n  }\n\n  hasPendingTiles(t, n) {\n    return !this.pendingTilesRegister.isZero(t, n);\n  }\n\n}\n\nclass kd extends Jn {\n  constructor(t) {\n    super(t), this._tileManager = void 0, this._tileManager = new jd();\n  }\n\n  traversalFinished(t) {\n    return !this._tileManager.hasPendingTiles(t.viewport.id, this._frameNumber || 0);\n  }\n\n  shouldRefine(t, n) {\n    return t._lodJudge = Pd(t, n), t._lodJudge === \"DIG\";\n  }\n\n  updateChildTiles(t, n) {\n    const s = t.header.children || [],\n          r = t.children,\n          i = t.tileset;\n\n    for (const o of s) {\n      const a = `${o.id}-${n.viewport.id}`,\n            c = r && r.find(u => u.id === a);\n      if (c) c && this.updateTile(c, n);else {\n        let u = () => this._loadTile(o.id, i);\n\n        this._tileManager.find(a) ? this._tileManager.update(a, n) : (i.tileset.nodePages && (u = () => i.tileset.nodePagesTile.formTileFromNodePages(o.id)), this._tileManager.add(u, a, h => this._onTileLoad(h, t, a), n));\n      }\n    }\n\n    return !1;\n  }\n\n  async _loadTile(t, n) {\n    const {\n      loader: s\n    } = n,\n          r = n.getTileUrl(`${n.url}/nodes/${t}`),\n          i = { ...n.loadOptions,\n      i3s: { ...n.loadOptions.i3s,\n        isTileHeader: !0\n      }\n    };\n    return await fe(r, s, i);\n  }\n\n  _onTileLoad(t, n, s) {\n    const r = new Vs(n.tileset, t, n, s);\n    n.children.push(r);\n\n    const i = this._tileManager.find(r.id).frameState;\n\n    this.updateTile(r, i), this._frameNumber === i.frameNumber && (this.traversalFinished(i) || /* @__PURE__ */new Date().getTime() - this.lastUpdate > this.updateDebounceTime) && this.executeTraversal(r, i);\n  }\n\n}\n\nconst Kd = {\n  description: \"\",\n  ellipsoid: J.WGS84,\n  modelMatrix: new V(),\n  throttleRequests: !0,\n  maxRequests: 64,\n  maximumMemoryUsage: 32,\n  memoryCacheOverflow: 1,\n  maximumTilesSelected: 0,\n  debounceTime: 0,\n  onTileLoad: () => {},\n  onTileUnload: () => {},\n  onTileError: () => {},\n  onTraversalComplete: e => e,\n  contentLoader: void 0,\n  viewDistanceScale: 1,\n  maximumScreenSpaceError: 8,\n  memoryAdjustedScreenSpaceError: !1,\n  loadTiles: !0,\n  updateTransforms: !0,\n  viewportTraversersMap: null,\n  loadOptions: {\n    fetch: {}\n  },\n  attributions: [],\n  basePath: \"\",\n  i3s: {}\n},\n      cn = \"Tiles In Tileset(s)\",\n      fs = \"Tiles In Memory\",\n      Si = \"Tiles In View\",\n      xi = \"Tiles To Render\",\n      Oi = \"Tiles Loaded\",\n      ds = \"Tiles Loading\",\n      Fi = \"Tiles Unloaded\",\n      vi = \"Failed Tile Loads\",\n      Di = \"Points/Vertices\",\n      ms = \"Tile Memory Use\",\n      Li = \"Maximum Screen Space Error\";\n\nclass zd {\n  constructor(t, n) {\n    this.options = void 0, this.loadOptions = void 0, this.type = void 0, this.tileset = void 0, this.loader = void 0, this.url = void 0, this.basePath = void 0, this.modelMatrix = void 0, this.ellipsoid = void 0, this.lodMetricType = void 0, this.lodMetricValue = void 0, this.refine = void 0, this.root = null, this.roots = {}, this.asset = {}, this.description = \"\", this.properties = void 0, this.extras = null, this.attributions = {}, this.credits = {}, this.stats = void 0, this.contentFormats = {\n      draco: !1,\n      meshopt: !1,\n      dds: !1,\n      ktx2: !1\n    }, this.cartographicCenter = null, this.cartesianCenter = null, this.zoom = 1, this.boundingVolume = null, this.dynamicScreenSpaceErrorComputedDensity = 0, this.maximumMemoryUsage = 32, this.gpuMemoryUsageInBytes = 0, this.memoryAdjustedScreenSpaceError = 0, this._cacheBytes = 0, this._cacheOverflowBytes = 0, this._frameNumber = 0, this._queryParams = {}, this._extensionsUsed = [], this._tiles = {}, this._pendingCount = 0, this.selectedTiles = [], this.traverseCounter = 0, this.geometricError = 0, this.lastUpdatedVieports = null, this._requestedTiles = [], this._emptyTiles = [], this.frameStateData = {}, this._traverser = void 0, this._cache = new Kf(), this._requestScheduler = void 0, this.updatePromise = null, this.tilesetInitializationPromise = void 0, this.options = { ...Kd,\n      ...n\n    }, this.tileset = t, this.loader = t.loader, this.type = t.type, this.url = t.url, this.basePath = t.basePath || rr(this.url), this.modelMatrix = this.options.modelMatrix, this.ellipsoid = this.options.ellipsoid, this.lodMetricType = t.lodMetricType, this.lodMetricValue = t.lodMetricValue, this.refine = t.root.refine, this.loadOptions = this.options.loadOptions || {}, this._traverser = this._initializeTraverser(), this._requestScheduler = new wu({\n      throttleRequests: this.options.throttleRequests,\n      maxRequests: this.options.maxRequests\n    }), this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError, this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024, this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024, this.stats = new Po({\n      id: this.url\n    }), this._initializeStats(), this.tilesetInitializationPromise = this._initializeTileSet(t);\n  }\n\n  destroy() {\n    this._destroy();\n  }\n\n  isLoaded() {\n    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;\n  }\n\n  get tiles() {\n    return Object.values(this._tiles);\n  }\n\n  get frameNumber() {\n    return this._frameNumber;\n  }\n\n  get queryParams() {\n    return new URLSearchParams(this._queryParams).toString();\n  }\n\n  setProps(t) {\n    this.options = { ...this.options,\n      ...t\n    };\n  }\n\n  getTileUrl(t) {\n    if (t.startsWith(\"data:\")) return t;\n    let s = t;\n    return this.queryParams.length && (s = `${t}${t.includes(\"?\") ? \"&\" : \"?\"}${this.queryParams}`), s;\n  }\n\n  hasExtension(t) {\n    return this._extensionsUsed.indexOf(t) > -1;\n  }\n\n  update() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n    this.tilesetInitializationPromise.then(() => {\n      !t && this.lastUpdatedVieports ? t = this.lastUpdatedVieports : this.lastUpdatedVieports = t, t && this.doUpdate(t);\n    });\n  }\n\n  async selectTiles() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n    return await this.tilesetInitializationPromise, t && (this.lastUpdatedVieports = t), this.updatePromise || (this.updatePromise = new Promise(n => {\n      setTimeout(() => {\n        this.lastUpdatedVieports && this.doUpdate(this.lastUpdatedVieports), n(this._frameNumber), this.updatePromise = null;\n      }, this.options.debounceTime);\n    })), this.updatePromise;\n  }\n\n  adjustScreenSpaceError() {\n    this.gpuMemoryUsageInBytes < this._cacheBytes ? this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError) : this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes && (this.memoryAdjustedScreenSpaceError *= 1.02);\n  }\n\n  doUpdate(t) {\n    if (\"loadTiles\" in this.options && !this.options.loadTiles || this.traverseCounter > 0) return;\n    const n = t instanceof Array ? t : [t];\n    this._cache.reset(), this._frameNumber++, this.traverseCounter = n.length;\n    const s = [];\n\n    for (const r of n) {\n      const i = r.id;\n      this._needTraverse(i) ? s.push(i) : this.traverseCounter--;\n    }\n\n    for (const r of n) {\n      const i = r.id;\n      if (this.roots[i] || (this.roots[i] = this._initializeTileHeaders(this.tileset, null)), !s.includes(i)) continue;\n      const o = pd(r, this._frameNumber);\n\n      this._traverser.traverse(this.roots[i], o, this.options);\n    }\n  }\n\n  _needTraverse(t) {\n    let n = t;\n    return this.options.viewportTraversersMap && (n = this.options.viewportTraversersMap[t]), n === t;\n  }\n\n  _onTraversalEnd(t) {\n    const n = t.viewport.id;\n    this.frameStateData[n] || (this.frameStateData[n] = {\n      selectedTiles: [],\n      _requestedTiles: [],\n      _emptyTiles: []\n    });\n    const s = this.frameStateData[n],\n          r = Object.values(this._traverser.selectedTiles),\n          [i, o] = yd(r, t, this.options.maximumTilesSelected);\n    s.selectedTiles = i;\n\n    for (const a of o) a.unselect();\n\n    s._requestedTiles = Object.values(this._traverser.requestedTiles), s._emptyTiles = Object.values(this._traverser.emptyTiles), this.traverseCounter--, !(this.traverseCounter > 0) && this._updateTiles();\n  }\n\n  _updateTiles() {\n    this.selectedTiles = [], this._requestedTiles = [], this._emptyTiles = [];\n\n    for (const t in this.frameStateData) {\n      const n = this.frameStateData[t];\n      this.selectedTiles = this.selectedTiles.concat(n.selectedTiles), this._requestedTiles = this._requestedTiles.concat(n._requestedTiles), this._emptyTiles = this._emptyTiles.concat(n._emptyTiles);\n    }\n\n    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);\n\n    for (const t of this.selectedTiles) this._tiles[t.id] = t;\n\n    this._loadTiles(), this._unloadTiles(), this._updateStats();\n  }\n\n  _tilesChanged(t, n) {\n    if (t.length !== n.length) return !0;\n    const s = new Set(t.map(o => o.id)),\n          r = new Set(n.map(o => o.id));\n    let i = t.filter(o => !r.has(o.id)).length > 0;\n    return i = i || n.filter(o => !s.has(o.id)).length > 0, i;\n  }\n\n  _loadTiles() {\n    for (const t of this._requestedTiles) t.contentUnloaded && this._loadTile(t);\n  }\n\n  _unloadTiles() {\n    this._cache.unloadTiles(this, (t, n) => t._unloadTile(n));\n  }\n\n  _updateStats() {\n    let t = 0,\n        n = 0;\n\n    for (const s of this.selectedTiles) s.contentAvailable && s.content && (t++, s.content.pointCount ? n += s.content.pointCount : n += s.content.vertexCount);\n\n    this.stats.get(Si).count = this.selectedTiles.length, this.stats.get(xi).count = t, this.stats.get(Di).count = n, this.stats.get(Li).count = this.memoryAdjustedScreenSpaceError;\n  }\n\n  async _initializeTileSet(t) {\n    this.type === At.I3S && (this.calculateViewPropsI3S(), t.root = await t.root), this.root = this._initializeTileHeaders(t, null), this.type === At.TILES3D && (this._initializeTiles3DTileset(t), this.calculateViewPropsTiles3D()), this.type === At.I3S && this._initializeI3STileset();\n  }\n\n  calculateViewPropsI3S() {\n    var t;\n    const n = this.tileset.fullExtent;\n\n    if (n) {\n      const {\n        xmin: r,\n        xmax: i,\n        ymin: o,\n        ymax: a,\n        zmin: c,\n        zmax: u\n      } = n;\n      this.cartographicCenter = new A(r + (i - r) / 2, o + (a - o) / 2, c + (u - c) / 2), this.cartesianCenter = new A(), J.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = ga(n, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n\n    const s = (t = this.tileset.store) === null || t === void 0 ? void 0 : t.extent;\n\n    if (s) {\n      const [r, i, o, a] = s;\n      this.cartographicCenter = new A(r + (o - r) / 2, i + (a - i) / 2, 0), this.cartesianCenter = new A(), J.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = bd(s, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n\n    console.warn(\"Extent is not defined in the tileset header\"), this.cartographicCenter = new A(), this.zoom = 1;\n  }\n\n  calculateViewPropsTiles3D() {\n    const t = this.root,\n          {\n      center: n\n    } = t.boundingVolume;\n\n    if (!n) {\n      console.warn(\"center was not pre-calculated for the root tile\"), this.cartographicCenter = new A(), this.zoom = 1;\n      return;\n    }\n\n    n[0] !== 0 || n[1] !== 0 || n[2] !== 0 ? (this.cartographicCenter = new A(), J.WGS84.cartesianToCartographic(n, this.cartographicCenter)) : this.cartographicCenter = new A(0, 0, -J.WGS84.radii[0]), this.cartesianCenter = n, this.zoom = Td(t.boundingVolume, this.cartographicCenter);\n  }\n\n  _initializeStats() {\n    this.stats.get(cn), this.stats.get(ds), this.stats.get(fs), this.stats.get(Si), this.stats.get(xi), this.stats.get(Oi), this.stats.get(Fi), this.stats.get(vi), this.stats.get(Di), this.stats.get(ms, \"memory\"), this.stats.get(Li);\n  }\n\n  _initializeTileHeaders(t, n) {\n    const s = new Vs(this, t.root, n);\n\n    if (n && (n.children.push(s), s.depth = n.depth + 1), this.type === At.TILES3D) {\n      const i = [];\n\n      for (i.push(s); i.length > 0;) {\n        const o = i.pop();\n        this.stats.get(cn).incrementCount();\n        const a = o.header.children || [];\n\n        for (const c of a) {\n          var r;\n          const u = new Vs(this, c, o);\n\n          if ((r = u.contentUrl) !== null && r !== void 0 && r.includes(\"?session=\")) {\n            const h = new URL(u.contentUrl).searchParams.get(\"session\");\n            h && (this._queryParams.session = h);\n          }\n\n          o.children.push(u), u.depth = o.depth + 1, i.push(u);\n        }\n      }\n    }\n\n    return s;\n  }\n\n  _initializeTraverser() {\n    let t;\n\n    switch (this.type) {\n      case At.TILES3D:\n        t = Jd;\n        break;\n\n      case At.I3S:\n        t = kd;\n        break;\n\n      default:\n        t = Jn;\n    }\n\n    return new t({\n      basePath: this.basePath,\n      onTraversalEnd: this._onTraversalEnd.bind(this)\n    });\n  }\n\n  _destroyTileHeaders(t) {\n    this._destroySubtree(t);\n  }\n\n  async _loadTile(t) {\n    let n;\n\n    try {\n      this._onStartTileLoading(), n = await t.loadContent();\n    } catch (s) {\n      this._onTileLoadError(t, s instanceof Error ? s : new Error(\"load failed\"));\n    } finally {\n      this._onEndTileLoading(), this._onTileLoad(t, n);\n    }\n  }\n\n  _onTileLoadError(t, n) {\n    this.stats.get(vi).incrementCount();\n    const s = n.message || n.toString(),\n          r = t.url;\n    console.error(`A 3D tile failed to load: ${t.url} ${s}`), this.options.onTileError(t, s, r);\n  }\n\n  _onTileLoad(t, n) {\n    if (n) {\n      if (this.type === At.I3S) {\n        var s, r;\n        const i = ((s = this.tileset) === null || s === void 0 || (r = s.nodePagesTile) === null || r === void 0 ? void 0 : r.nodesInNodePages) || 0;\n        this.stats.get(cn).reset(), this.stats.get(cn).addCount(i);\n      }\n\n      t && t.content && zf(t, t.content), this.updateContentTypes(t), this._addTileToCache(t), this.options.onTileLoad(t);\n    }\n  }\n\n  updateContentTypes(t) {\n    if (this.type === At.I3S) switch (t.header.isDracoGeometry && (this.contentFormats.draco = !0), t.header.textureFormat) {\n      case \"dds\":\n        this.contentFormats.dds = !0;\n        break;\n\n      case \"ktx2\":\n        this.contentFormats.ktx2 = !0;\n        break;\n    } else if (this.type === At.TILES3D) {\n      var n;\n      const {\n        extensionsRemoved: s = []\n      } = ((n = t.content) === null || n === void 0 ? void 0 : n.gltf) || {};\n      s.includes(\"KHR_draco_mesh_compression\") && (this.contentFormats.draco = !0), s.includes(\"EXT_meshopt_compression\") && (this.contentFormats.meshopt = !0), s.includes(\"KHR_texture_basisu\") && (this.contentFormats.ktx2 = !0);\n    }\n  }\n\n  _onStartTileLoading() {\n    this._pendingCount++, this.stats.get(ds).incrementCount();\n  }\n\n  _onEndTileLoading() {\n    this._pendingCount--, this.stats.get(ds).decrementCount();\n  }\n\n  _addTileToCache(t) {\n    this._cache.add(this, t, n => n._updateCacheStats(t));\n  }\n\n  _updateCacheStats(t) {\n    this.stats.get(Oi).incrementCount(), this.stats.get(fs).incrementCount(), this.gpuMemoryUsageInBytes += t.gpuMemoryUsageInBytes || 0, this.stats.get(ms).count = this.gpuMemoryUsageInBytes, this.options.memoryAdjustedScreenSpaceError && this.adjustScreenSpaceError();\n  }\n\n  _unloadTile(t) {\n    this.gpuMemoryUsageInBytes -= t.gpuMemoryUsageInBytes || 0, this.stats.get(fs).decrementCount(), this.stats.get(Fi).incrementCount(), this.stats.get(ms).count = this.gpuMemoryUsageInBytes, this.options.onTileUnload(t), t.unloadContent();\n  }\n\n  _destroy() {\n    const t = [];\n\n    for (this.root && t.push(this.root); t.length > 0;) {\n      const n = t.pop();\n\n      for (const s of n.children) t.push(s);\n\n      this._destroyTile(n);\n    }\n\n    this.root = null;\n  }\n\n  _destroySubtree(t) {\n    const n = t,\n          s = [];\n\n    for (s.push(n); s.length > 0;) {\n      t = s.pop();\n\n      for (const r of t.children) s.push(r);\n\n      t !== n && this._destroyTile(t);\n    }\n\n    n.children = [];\n  }\n\n  _destroyTile(t) {\n    this._cache.unloadTile(this, t), this._unloadTile(t), t.destroy();\n  }\n\n  _initializeTiles3DTileset(t) {\n    if (t.queryString) {\n      const n = new URLSearchParams(t.queryString),\n            s = Object.fromEntries(n.entries());\n      this._queryParams = { ...this._queryParams,\n        ...s\n      };\n    }\n\n    if (this.asset = t.asset, !this.asset) throw new Error(\"Tileset must have an asset property.\");\n    if (this.asset.version !== \"0.0\" && this.asset.version !== \"1.0\" && this.asset.version !== \"1.1\") throw new Error(\"The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.\");\n    \"tilesetVersion\" in this.asset && (this._queryParams.v = this.asset.tilesetVersion), this.credits = {\n      attributions: this.options.attributions || []\n    }, this.description = this.options.description || \"\", this.properties = t.properties, this.geometricError = t.geometricError, this._extensionsUsed = t.extensionsUsed || [], this.extras = t.extras;\n  }\n\n  _initializeI3STileset() {\n    this.loadOptions.i3s && \"token\" in this.loadOptions.i3s && (this._queryParams.token = this.loadOptions.i3s.token);\n  }\n\n}\n\nconst Ea = \"4.1.1\",\n      Ce = {\n  COMPOSITE: \"cmpt\",\n  POINT_CLOUD: \"pnts\",\n  BATCHED_3D_MODEL: \"b3dm\",\n  INSTANCED_3D_MODEL: \"i3dm\",\n  GEOMETRY: \"geom\",\n  VECTOR: \"vect\",\n  GLTF: \"glTF\"\n};\n\nfunction Ta(e, t, n) {\n  U(e instanceof ArrayBuffer);\n  const s = new TextDecoder(\"utf8\"),\n        r = new Uint8Array(e, t, n);\n  return s.decode(r);\n}\n\nfunction Wd(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n  const n = new DataView(e);\n  return `${String.fromCharCode(n.getUint8(t + 0))}${String.fromCharCode(n.getUint8(t + 1))}${String.fromCharCode(n.getUint8(t + 2))}${String.fromCharCode(n.getUint8(t + 3))}`;\n}\n\nconst Xd = \"4.1.1\",\n      Qd = {\n  name: \"Draco\",\n  id: \"draco\",\n  module: \"draco\",\n  version: Xd,\n  worker: !0,\n  extensions: [\"drc\"],\n  mimeTypes: [\"application/octet-stream\"],\n  binary: !0,\n  tests: [\"DRACO\"],\n  options: {\n    draco: {\n      decoderType: typeof WebAssembly == \"object\" ? \"wasm\" : \"js\",\n      libraryPath: \"libs/\",\n      extraAttributes: {},\n      attributeNameEntry: void 0\n    }\n  }\n};\n\nfunction qd(e, t, n) {\n  const s = ba(t.metadata),\n        r = [],\n        i = Yd(t.attributes);\n\n  for (const o in e) {\n    const a = e[o],\n          c = Gi(o, a, i[o]);\n    r.push(c);\n  }\n\n  if (n) {\n    const o = Gi(\"indices\", n);\n    r.push(o);\n  }\n\n  return {\n    fields: r,\n    metadata: s\n  };\n}\n\nfunction Yd(e) {\n  const t = {};\n\n  for (const n in e) {\n    const s = e[n];\n    t[s.name || \"undefined\"] = s;\n  }\n\n  return t;\n}\n\nfunction Gi(e, t, n) {\n  const s = n ? ba(n.metadata) : void 0;\n  return Kl(e, t, s);\n}\n\nfunction ba(e) {\n  Object.entries(e);\n  const t = {};\n\n  for (const n in e) t[`${n}.string`] = JSON.stringify(e[n]);\n\n  return t;\n}\n\nconst Pi = {\n  POSITION: \"POSITION\",\n  NORMAL: \"NORMAL\",\n  COLOR: \"COLOR_0\",\n  TEX_COORD: \"TEXCOORD_0\"\n},\n      $d = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n},\n      Zd = 4;\n\nclass tm {\n  constructor(t) {\n    this.draco = void 0, this.decoder = void 0, this.metadataQuerier = void 0, this.draco = t, this.decoder = new this.draco.Decoder(), this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n\n  destroy() {\n    this.draco.destroy(this.decoder), this.draco.destroy(this.metadataQuerier);\n  }\n\n  parseSync(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const s = new this.draco.DecoderBuffer();\n    s.Init(new Int8Array(t), t.byteLength), this._disableAttributeTransforms(n);\n    const r = this.decoder.GetEncodedGeometryType(s),\n          i = r === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();\n\n    try {\n      let o;\n\n      switch (r) {\n        case this.draco.TRIANGULAR_MESH:\n          o = this.decoder.DecodeBufferToMesh(s, i);\n          break;\n\n        case this.draco.POINT_CLOUD:\n          o = this.decoder.DecodeBufferToPointCloud(s, i);\n          break;\n\n        default:\n          throw new Error(\"DRACO: Unknown geometry type.\");\n      }\n\n      if (!o.ok() || !i.ptr) {\n        const f = `DRACO decompression failed: ${o.error_msg()}`;\n        throw new Error(f);\n      }\n\n      const a = this._getDracoLoaderData(i, r, n),\n            c = this._getMeshData(i, a, n),\n            u = kl(c.attributes),\n            l = qd(c.attributes, a, c.indices);\n\n      return {\n        loader: \"draco\",\n        loaderData: a,\n        header: {\n          vertexCount: i.num_points(),\n          boundingBox: u\n        },\n        ...c,\n        schema: l\n      };\n    } finally {\n      this.draco.destroy(s), i && this.draco.destroy(i);\n    }\n  }\n\n  _getDracoLoaderData(t, n, s) {\n    const r = this._getTopLevelMetadata(t),\n          i = this._getDracoAttributes(t, s);\n\n    return {\n      geometry_type: n,\n      num_attributes: t.num_attributes(),\n      num_points: t.num_points(),\n      num_faces: t instanceof this.draco.Mesh ? t.num_faces() : 0,\n      metadata: r,\n      attributes: i\n    };\n  }\n\n  _getDracoAttributes(t, n) {\n    const s = {};\n\n    for (let r = 0; r < t.num_attributes(); r++) {\n      const i = this.decoder.GetAttribute(t, r),\n            o = this._getAttributeMetadata(t, r);\n\n      s[i.unique_id()] = {\n        unique_id: i.unique_id(),\n        attribute_type: i.attribute_type(),\n        data_type: i.data_type(),\n        num_components: i.num_components(),\n        byte_offset: i.byte_offset(),\n        byte_stride: i.byte_stride(),\n        normalized: i.normalized(),\n        attribute_index: r,\n        metadata: o\n      };\n\n      const a = this._getQuantizationTransform(i, n);\n\n      a && (s[i.unique_id()].quantization_transform = a);\n\n      const c = this._getOctahedronTransform(i, n);\n\n      c && (s[i.unique_id()].octahedron_transform = c);\n    }\n\n    return s;\n  }\n\n  _getMeshData(t, n, s) {\n    const r = this._getMeshAttributes(n, t, s);\n\n    if (!r.POSITION) throw new Error(\"DRACO: No position attribute found.\");\n    if (t instanceof this.draco.Mesh) switch (s.topology) {\n      case \"triangle-strip\":\n        return {\n          topology: \"triangle-strip\",\n          mode: 4,\n          attributes: r,\n          indices: {\n            value: this._getTriangleStripIndices(t),\n            size: 1\n          }\n        };\n\n      case \"triangle-list\":\n      default:\n        return {\n          topology: \"triangle-list\",\n          mode: 5,\n          attributes: r,\n          indices: {\n            value: this._getTriangleListIndices(t),\n            size: 1\n          }\n        };\n    }\n    return {\n      topology: \"point-list\",\n      mode: 0,\n      attributes: r\n    };\n  }\n\n  _getMeshAttributes(t, n, s) {\n    const r = {};\n\n    for (const i of Object.values(t.attributes)) {\n      const o = this._deduceAttributeName(i, s);\n\n      i.name = o;\n\n      const {\n        value: a,\n        size: c\n      } = this._getAttributeValues(n, i);\n\n      r[o] = {\n        value: a,\n        size: c,\n        byteOffset: i.byte_offset,\n        byteStride: i.byte_stride,\n        normalized: i.normalized\n      };\n    }\n\n    return r;\n  }\n\n  _getTriangleListIndices(t) {\n    const s = t.num_faces() * 3,\n          r = s * Zd,\n          i = this.draco._malloc(r);\n\n    try {\n      return this.decoder.GetTrianglesUInt32Array(t, r, i), new Uint32Array(this.draco.HEAPF32.buffer, i, s).slice();\n    } finally {\n      this.draco._free(i);\n    }\n  }\n\n  _getTriangleStripIndices(t) {\n    const n = new this.draco.DracoInt32Array();\n\n    try {\n      return this.decoder.GetTriangleStripsFromMesh(t, n), sm(n);\n    } finally {\n      this.draco.destroy(n);\n    }\n  }\n\n  _getAttributeValues(t, n) {\n    const s = $d[n.data_type],\n          r = n.num_components,\n          o = t.num_points() * r,\n          a = o * s.BYTES_PER_ELEMENT,\n          c = em(this.draco, s);\n    let u;\n\n    const l = this.draco._malloc(a);\n\n    try {\n      const h = this.decoder.GetAttribute(t, n.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(t, h, c, a, l), u = new s(this.draco.HEAPF32.buffer, l, o).slice();\n    } finally {\n      this.draco._free(l);\n    }\n\n    return {\n      value: u,\n      size: r\n    };\n  }\n\n  _deduceAttributeName(t, n) {\n    const s = t.unique_id;\n\n    for (const [o, a] of Object.entries(n.extraAttributes || {})) if (a === s) return o;\n\n    const r = t.attribute_type;\n\n    for (const o in Pi) if (this.draco[o] === r) return Pi[o];\n\n    const i = n.attributeNameEntry || \"name\";\n    return t.metadata[i] ? t.metadata[i].string : `CUSTOM_ATTRIBUTE_${s}`;\n  }\n\n  _getTopLevelMetadata(t) {\n    const n = this.decoder.GetMetadata(t);\n    return this._getDracoMetadata(n);\n  }\n\n  _getAttributeMetadata(t, n) {\n    const s = this.decoder.GetAttributeMetadata(t, n);\n    return this._getDracoMetadata(s);\n  }\n\n  _getDracoMetadata(t) {\n    if (!t || !t.ptr) return {};\n    const n = {},\n          s = this.metadataQuerier.NumEntries(t);\n\n    for (let r = 0; r < s; r++) {\n      const i = this.metadataQuerier.GetEntryName(t, r);\n      n[i] = this._getDracoMetadataField(t, i);\n    }\n\n    return n;\n  }\n\n  _getDracoMetadataField(t, n) {\n    const s = new this.draco.DracoInt32Array();\n\n    try {\n      this.metadataQuerier.GetIntEntryArray(t, n, s);\n      const r = nm(s);\n      return {\n        int: this.metadataQuerier.GetIntEntry(t, n),\n        string: this.metadataQuerier.GetStringEntry(t, n),\n        double: this.metadataQuerier.GetDoubleEntry(t, n),\n        intArray: r\n      };\n    } finally {\n      this.draco.destroy(s);\n    }\n  }\n\n  _disableAttributeTransforms(t) {\n    const {\n      quantizedAttributes: n = [],\n      octahedronAttributes: s = []\n    } = t,\n          r = [...n, ...s];\n\n    for (const i of r) this.decoder.SkipAttributeTransform(this.draco[i]);\n  }\n\n  _getQuantizationTransform(t, n) {\n    const {\n      quantizedAttributes: s = []\n    } = n,\n          r = t.attribute_type();\n\n    if (s.map(o => this.decoder[o]).includes(r)) {\n      const o = new this.draco.AttributeQuantizationTransform();\n\n      try {\n        if (o.InitFromAttribute(t)) return {\n          quantization_bits: o.quantization_bits(),\n          range: o.range(),\n          min_values: new Float32Array([1, 2, 3]).map(a => o.min_value(a))\n        };\n      } finally {\n        this.draco.destroy(o);\n      }\n    }\n\n    return null;\n  }\n\n  _getOctahedronTransform(t, n) {\n    const {\n      octahedronAttributes: s = []\n    } = n,\n          r = t.attribute_type();\n\n    if (s.map(o => this.decoder[o]).includes(r)) {\n      const o = new this.draco.AttributeQuantizationTransform();\n\n      try {\n        if (o.InitFromAttribute(t)) return {\n          quantization_bits: o.quantization_bits()\n        };\n      } finally {\n        this.draco.destroy(o);\n      }\n    }\n\n    return null;\n  }\n\n}\n\nfunction em(e, t) {\n  switch (t) {\n    case Float32Array:\n      return e.DT_FLOAT32;\n\n    case Int8Array:\n      return e.DT_INT8;\n\n    case Int16Array:\n      return e.DT_INT16;\n\n    case Int32Array:\n      return e.DT_INT32;\n\n    case Uint8Array:\n      return e.DT_UINT8;\n\n    case Uint16Array:\n      return e.DT_UINT16;\n\n    case Uint32Array:\n      return e.DT_UINT32;\n\n    default:\n      return e.DT_INVALID;\n  }\n}\n\nfunction nm(e) {\n  const t = e.size(),\n        n = new Int32Array(t);\n\n  for (let s = 0; s < t; s++) n[s] = e.GetValue(s);\n\n  return n;\n}\n\nfunction sm(e) {\n  const t = e.size(),\n        n = new Int32Array(t);\n\n  for (let s = 0; s < t; s++) n[s] = e.GetValue(s);\n\n  return n;\n}\n\nconst rm = \"1.5.6\",\n      im = \"1.4.1\",\n      gs = `https://www.gstatic.com/draco/versioned/decoders/${rm}`,\n      lt = {\n  DECODER: \"draco_wasm_wrapper.js\",\n  DECODER_WASM: \"draco_decoder.wasm\",\n  FALLBACK_DECODER: \"draco_decoder.js\",\n  ENCODER: \"draco_encoder.js\"\n},\n      As = {\n  [lt.DECODER]: `${gs}/${lt.DECODER}`,\n  [lt.DECODER_WASM]: `${gs}/${lt.DECODER_WASM}`,\n  [lt.FALLBACK_DECODER]: `${gs}/${lt.FALLBACK_DECODER}`,\n  [lt.ENCODER]: `https://raw.githubusercontent.com/google/draco/${im}/javascript/${lt.ENCODER}`\n};\nlet Ee;\n\nasync function om(e) {\n  const t = e.modules || {};\n  return t.draco3d ? Ee = Ee || t.draco3d.createDecoderModule({}).then(n => ({\n    draco: n\n  })) : Ee = Ee || am(e), await Ee;\n}\n\nasync function am(e) {\n  let t, n;\n\n  switch (e.draco && e.draco.decoderType) {\n    case \"js\":\n      t = await Xt(As[lt.FALLBACK_DECODER], \"draco\", e, lt.FALLBACK_DECODER);\n      break;\n\n    case \"wasm\":\n    default:\n      [t, n] = await Promise.all([await Xt(As[lt.DECODER], \"draco\", e, lt.DECODER), await Xt(As[lt.DECODER_WASM], \"draco\", e, lt.DECODER_WASM)]);\n  }\n\n  return t = t || globalThis.DracoDecoderModule, await cm(t, n);\n}\n\nfunction cm(e, t) {\n  const n = {};\n  return t && (n.wasmBinary = t), new Promise(s => {\n    e({ ...n,\n      onModuleLoaded: r => s({\n        draco: r\n      })\n    });\n  });\n}\n\nconst _a = { ...Qd,\n  parse: um\n};\n\nasync function um(e, t) {\n  const {\n    draco: n\n  } = await om(t),\n        s = new tm(n);\n\n  try {\n    return s.parseSync(e, t == null ? void 0 : t.draco);\n  } finally {\n    s.destroy();\n  }\n}\n\nconst lm = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6\n},\n      $ = {\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  DOUBLE: 5130\n},\n      G = { ...lm,\n  ...$\n},\n      ps = {\n  [$.DOUBLE]: Float64Array,\n  [$.FLOAT]: Float32Array,\n  [$.UNSIGNED_SHORT]: Uint16Array,\n  [$.UNSIGNED_INT]: Uint32Array,\n  [$.UNSIGNED_BYTE]: Uint8Array,\n  [$.BYTE]: Int8Array,\n  [$.SHORT]: Int16Array,\n  [$.INT]: Int32Array\n},\n      hm = {\n  DOUBLE: $.DOUBLE,\n  FLOAT: $.FLOAT,\n  UNSIGNED_SHORT: $.UNSIGNED_SHORT,\n  UNSIGNED_INT: $.UNSIGNED_INT,\n  UNSIGNED_BYTE: $.UNSIGNED_BYTE,\n  BYTE: $.BYTE,\n  SHORT: $.SHORT,\n  INT: $.INT\n},\n      ys = \"Failed to convert GL type\";\n\nclass Ot {\n  static fromTypedArray(t) {\n    t = ArrayBuffer.isView(t) ? t.constructor : t;\n\n    for (const n in ps) if (ps[n] === t) return n;\n\n    throw new Error(ys);\n  }\n\n  static fromName(t) {\n    const n = hm[t];\n    if (!n) throw new Error(ys);\n    return n;\n  }\n\n  static getArrayType(t) {\n    switch (t) {\n      case $.UNSIGNED_SHORT_5_6_5:\n      case $.UNSIGNED_SHORT_4_4_4_4:\n      case $.UNSIGNED_SHORT_5_5_5_1:\n        return Uint16Array;\n\n      default:\n        const n = ps[t];\n        if (!n) throw new Error(ys);\n        return n;\n    }\n  }\n\n  static getByteSize(t) {\n    return Ot.getArrayType(t).BYTES_PER_ELEMENT;\n  }\n\n  static validate(t) {\n    return !!Ot.getArrayType(t);\n  }\n\n  static createTypedArray(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,\n        r = arguments.length > 3 ? arguments[3] : void 0;\n    r === void 0 && (r = (n.byteLength - s) / Ot.getByteSize(t));\n    const i = Ot.getArrayType(t);\n    return new i(n, s, r);\n  }\n\n}\n\nfunction fm(e, t) {\n  if (!e) throw new Error(`math.gl assertion failed. ${t}`);\n}\n\nfunction dm(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];\n  const n = e >> 11 & 31,\n        s = e >> 5 & 63,\n        r = e & 31;\n  return t[0] = n << 3, t[1] = s << 2, t[2] = r << 3, t;\n}\n\nnew Nn();\nnew A();\nnew Nn();\nnew Nn();\n\nfunction Ni(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 255;\n  return th(e, 0, t) / t * 2 - 1;\n}\n\nfunction Ui(e) {\n  return e < 0 ? -1 : 1;\n}\n\nfunction mm(e, t, n, s) {\n  if (fm(s), e < 0 || e > n || t < 0 || t > n) throw new Error(`x and y must be unsigned normalized integers between 0 and ${n}`);\n\n  if (s.x = Ni(e, n), s.y = Ni(t, n), s.z = 1 - (Math.abs(s.x) + Math.abs(s.y)), s.z < 0) {\n    const r = s.x;\n    s.x = (1 - Math.abs(s.y)) * Ui(r), s.y = (1 - Math.abs(r)) * Ui(s.y);\n  }\n\n  return s.normalize();\n}\n\nfunction gm(e, t, n) {\n  return mm(e, t, 255, n);\n}\n\nclass mr {\n  constructor(t, n) {\n    this.json = void 0, this.buffer = void 0, this.featuresLength = 0, this._cachedTypedArrays = {}, this.json = t, this.buffer = n;\n  }\n\n  getExtension(t) {\n    return this.json.extensions && this.json.extensions[t];\n  }\n\n  hasProperty(t) {\n    return !!this.json[t];\n  }\n\n  getGlobalProperty(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : G.UNSIGNED_INT,\n        s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n    const r = this.json[t];\n    return r && Number.isFinite(r.byteOffset) ? this._getTypedArrayFromBinary(t, n, s, 1, r.byteOffset) : r;\n  }\n\n  getPropertyArray(t, n, s) {\n    const r = this.json[t];\n    return r && Number.isFinite(r.byteOffset) ? (\"componentType\" in r && (n = Ot.fromName(r.componentType)), this._getTypedArrayFromBinary(t, n, s, this.featuresLength, r.byteOffset)) : this._getTypedArrayFromArray(t, n, r);\n  }\n\n  getProperty(t, n, s, r, i) {\n    const o = this.json[t];\n    if (!o) return o;\n    const a = this.getPropertyArray(t, n, s);\n    if (s === 1) return a[r];\n\n    for (let c = 0; c < s; ++c) i[c] = a[s * r + c];\n\n    return i;\n  }\n\n  _getTypedArrayFromBinary(t, n, s, r, i) {\n    const o = this._cachedTypedArrays;\n    let a = o[t];\n    return a || (a = Ot.createTypedArray(n, this.buffer.buffer, this.buffer.byteOffset + i, r * s), o[t] = a), a;\n  }\n\n  _getTypedArrayFromArray(t, n, s) {\n    const r = this._cachedTypedArrays;\n    let i = r[t];\n    return i || (i = Ot.createTypedArray(n, s), r[t] = i), i;\n  }\n\n}\n\nconst Am = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n},\n      pm = {\n  SCALAR: (e, t) => e[t],\n  VEC2: (e, t) => [e[2 * t + 0], e[2 * t + 1]],\n  VEC3: (e, t) => [e[3 * t + 0], e[3 * t + 1], e[3 * t + 2]],\n  VEC4: (e, t) => [e[4 * t + 0], e[4 * t + 1], e[4 * t + 2], e[4 * t + 3]],\n  MAT2: (e, t) => [e[4 * t + 0], e[4 * t + 1], e[4 * t + 2], e[4 * t + 3]],\n  MAT3: (e, t) => [e[9 * t + 0], e[9 * t + 1], e[9 * t + 2], e[9 * t + 3], e[9 * t + 4], e[9 * t + 5], e[9 * t + 6], e[9 * t + 7], e[9 * t + 8]],\n  MAT4: (e, t) => [e[16 * t + 0], e[16 * t + 1], e[16 * t + 2], e[16 * t + 3], e[16 * t + 4], e[16 * t + 5], e[16 * t + 6], e[16 * t + 7], e[16 * t + 8], e[16 * t + 9], e[16 * t + 10], e[16 * t + 11], e[16 * t + 12], e[16 * t + 13], e[16 * t + 14], e[16 * t + 15]]\n},\n      ym = {\n  SCALAR: (e, t, n) => {\n    t[n] = e;\n  },\n  VEC2: (e, t, n) => {\n    t[2 * n + 0] = e[0], t[2 * n + 1] = e[1];\n  },\n  VEC3: (e, t, n) => {\n    t[3 * n + 0] = e[0], t[3 * n + 1] = e[1], t[3 * n + 2] = e[2];\n  },\n  VEC4: (e, t, n) => {\n    t[4 * n + 0] = e[0], t[4 * n + 1] = e[1], t[4 * n + 2] = e[2], t[4 * n + 3] = e[3];\n  },\n  MAT2: (e, t, n) => {\n    t[4 * n + 0] = e[0], t[4 * n + 1] = e[1], t[4 * n + 2] = e[2], t[4 * n + 3] = e[3];\n  },\n  MAT3: (e, t, n) => {\n    t[9 * n + 0] = e[0], t[9 * n + 1] = e[1], t[9 * n + 2] = e[2], t[9 * n + 3] = e[3], t[9 * n + 4] = e[4], t[9 * n + 5] = e[5], t[9 * n + 6] = e[6], t[9 * n + 7] = e[7], t[9 * n + 8] = e[8], t[9 * n + 9] = e[9];\n  },\n  MAT4: (e, t, n) => {\n    t[16 * n + 0] = e[0], t[16 * n + 1] = e[1], t[16 * n + 2] = e[2], t[16 * n + 3] = e[3], t[16 * n + 4] = e[4], t[16 * n + 5] = e[5], t[16 * n + 6] = e[6], t[16 * n + 7] = e[7], t[16 * n + 8] = e[8], t[16 * n + 9] = e[9], t[16 * n + 10] = e[10], t[16 * n + 11] = e[11], t[16 * n + 12] = e[12], t[16 * n + 13] = e[13], t[16 * n + 14] = e[14], t[16 * n + 15] = e[15];\n  }\n};\n\nfunction Bm(e, t, n, s) {\n  const {\n    componentType: r\n  } = e;\n  U(e.componentType);\n  const i = typeof r == \"string\" ? Ot.fromName(r) : r,\n        o = Am[e.type],\n        a = pm[e.type],\n        c = ym[e.type];\n  return n += e.byteOffset, {\n    values: Ot.createTypedArray(i, t, n, o * s),\n    type: i,\n    size: o,\n    unpacker: a,\n    packer: c\n  };\n}\n\nconst St = e => e !== void 0;\n\nfunction Cm(e, t, n) {\n  if (!t) return null;\n  let s = e.getExtension(\"3DTILES_batch_table_hierarchy\");\n  const r = t.HIERARCHY;\n  return r && (console.warn(\"3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.\"), t.extensions = t.extensions || {}, t.extensions[\"3DTILES_batch_table_hierarchy\"] = r, s = r), s ? Em(s, n) : null;\n}\n\nfunction Em(e, t) {\n  let n, s, r;\n  const i = e.instancesLength,\n        o = e.classes;\n  let a = e.classIds,\n      c = e.parentCounts,\n      u = e.parentIds,\n      l = i;\n  St(a.byteOffset) && (a.componentType = defaultValue(a.componentType, GL.UNSIGNED_SHORT), a.type = AttributeType.SCALAR, r = getBinaryAccessor(a), a = r.createArrayBufferView(t.buffer, t.byteOffset + a.byteOffset, i));\n  let h;\n  if (St(c)) for (St(c.byteOffset) && (c.componentType = defaultValue(c.componentType, GL.UNSIGNED_SHORT), c.type = AttributeType.SCALAR, r = getBinaryAccessor(c), c = r.createArrayBufferView(t.buffer, t.byteOffset + c.byteOffset, i)), h = new Uint16Array(i), l = 0, n = 0; n < i; ++n) h[n] = l, l += c[n];\n  St(u) && St(u.byteOffset) && (u.componentType = defaultValue(u.componentType, GL.UNSIGNED_SHORT), u.type = AttributeType.SCALAR, r = getBinaryAccessor(u), u = r.createArrayBufferView(t.buffer, t.byteOffset + u.byteOffset, l));\n  const f = o.length;\n\n  for (n = 0; n < f; ++n) {\n    const p = o[n].length,\n          C = o[n].instances,\n          w = getBinaryProperties(p, C, t);\n    o[n].instances = combine(w, C);\n  }\n\n  const d = new Array(f).fill(0),\n        m = new Uint16Array(i);\n\n  for (n = 0; n < i; ++n) s = a[n], m[n] = d[s], ++d[s];\n\n  const g = {\n    classes: o,\n    classIds: a,\n    classIndexes: m,\n    parentCounts: c,\n    parentIndexes: h,\n    parentIds: u\n  };\n  return _m(g), g;\n}\n\nfunction Te(e, t, n) {\n  if (!e) return;\n  const s = e.parentCounts;\n  return e.parentIds ? n(e, t) : s > 0 ? Tm(e, t, n) : bm(e, t, n);\n}\n\nfunction Tm(e, t, n) {\n  const s = e.classIds,\n        r = e.parentCounts,\n        i = e.parentIds,\n        o = e.parentIndexes,\n        a = s.length,\n        c = scratchVisited;\n  c.length = Math.max(c.length, a);\n  const u = ++marker,\n        l = scratchStack;\n\n  for (l.length = 0, l.push(t); l.length > 0;) {\n    if (t = l.pop(), c[t] === u) continue;\n    c[t] = u;\n    const h = n(e, t);\n    if (St(h)) return h;\n    const f = r[t],\n          d = o[t];\n\n    for (let m = 0; m < f; ++m) {\n      const g = i[d + m];\n      g !== t && l.push(g);\n    }\n  }\n\n  return null;\n}\n\nfunction bm(e, t, n) {\n  let s = !0;\n\n  for (; s;) {\n    const r = n(e, t);\n    if (St(r)) return r;\n    const i = e.parentIds[t];\n    s = i !== t, t = i;\n  }\n\n  throw new Error(\"traverseHierarchySingleParent\");\n}\n\nfunction _m(e) {\n  const n = e.classIds.length;\n\n  for (let s = 0; s < n; ++s) wa(e, s, stack);\n}\n\nfunction wa(e, t, n) {\n  const s = e.parentCounts,\n        r = e.parentIds,\n        i = e.parentIndexes,\n        a = e.classIds.length;\n  if (!St(r)) return;\n  assert(t < a, `Parent index ${t} exceeds the total number of instances: ${a}`), assert(n.indexOf(t) === -1, \"Circular dependency detected in the batch table hierarchy.\"), n.push(t);\n  const c = St(s) ? s[t] : 1,\n        u = St(s) ? i[t] : t;\n\n  for (let l = 0; l < c; ++l) {\n    const h = r[u + l];\n    h !== t && wa(e, h, n);\n  }\n\n  n.pop(t);\n}\n\nfunction ct(e) {\n  return e != null;\n}\n\nconst un = (e, t) => e,\n      wm = {\n  HIERARCHY: !0,\n  extensions: !0,\n  extras: !0\n};\n\nclass Ra {\n  constructor(t, n, s) {\n    var r;\n    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    this.json = void 0, this.binary = void 0, this.featureCount = void 0, this._extensions = void 0, this._properties = void 0, this._binaryProperties = void 0, this._hierarchy = void 0, U(s >= 0), this.json = t || {}, this.binary = n, this.featureCount = s, this._extensions = ((r = this.json) === null || r === void 0 ? void 0 : r.extensions) || {}, this._properties = {};\n\n    for (const o in this.json) wm[o] || (this._properties[o] = this.json[o]);\n\n    this._binaryProperties = this._initializeBinaryProperties(), i[\"3DTILES_batch_table_hierarchy\"] && (this._hierarchy = Cm(this, this.json, this.binary));\n  }\n\n  getExtension(t) {\n    return this.json && this.json.extensions && this.json.extensions[t];\n  }\n\n  memorySizeInBytes() {\n    return 0;\n  }\n\n  isClass(t, n) {\n    if (this._checkBatchId(t), U(typeof n == \"string\", n), this._hierarchy) {\n      const s = Te(this._hierarchy, t, (r, i) => {\n        const o = r.classIds[i];\n        return r.classes[o].name === n;\n      });\n      return ct(s);\n    }\n\n    return !1;\n  }\n\n  isExactClass(t, n) {\n    return U(typeof n == \"string\", n), this.getExactClassName(t) === n;\n  }\n\n  getExactClassName(t) {\n    if (this._checkBatchId(t), this._hierarchy) {\n      const n = this._hierarchy.classIds[t];\n      return this._hierarchy.classes[n].name;\n    }\n  }\n\n  hasProperty(t, n) {\n    return this._checkBatchId(t), U(typeof n == \"string\", n), ct(this._properties[n]) || this._hasPropertyInHierarchy(t, n);\n  }\n\n  getPropertyNames(t, n) {\n    this._checkBatchId(t), n = ct(n) ? n : [], n.length = 0;\n    const s = Object.keys(this._properties);\n    return n.push(...s), this._hierarchy && this._getPropertyNamesInHierarchy(t, n), n;\n  }\n\n  getProperty(t, n) {\n    if (this._checkBatchId(t), U(typeof n == \"string\", n), this._binaryProperties) {\n      const r = this._binaryProperties[n];\n      if (ct(r)) return this._getBinaryProperty(r, t);\n    }\n\n    const s = this._properties[n];\n    if (ct(s)) return un(s[t]);\n\n    if (this._hierarchy) {\n      const r = this._getHierarchyProperty(t, n);\n\n      if (ct(r)) return r;\n    }\n  }\n\n  setProperty(t, n, s) {\n    const r = this.featureCount;\n\n    if (this._checkBatchId(t), U(typeof n == \"string\", n), this._binaryProperties) {\n      const o = this._binaryProperties[n];\n\n      if (o) {\n        this._setBinaryProperty(o, t, s);\n\n        return;\n      }\n    }\n\n    if (this._hierarchy && this._setHierarchyProperty(this, t, n, s)) return;\n    let i = this._properties[n];\n    ct(i) || (this._properties[n] = new Array(r), i = this._properties[n]), i[t] = un(s);\n  }\n\n  _checkBatchId(t) {\n    if (!(t >= 0 && t < this.featureCount)) throw new Error(\"batchId not in range [0, featureCount - 1].\");\n  }\n\n  _getBinaryProperty(t, n) {\n    return t.unpack(t.typedArray, n);\n  }\n\n  _setBinaryProperty(t, n, s) {\n    t.pack(s, t.typedArray, n);\n  }\n\n  _initializeBinaryProperties() {\n    let t = null;\n\n    for (const n in this._properties) {\n      const s = this._properties[n],\n            r = this._initializeBinaryProperty(n, s);\n\n      r && (t = t || {}, t[n] = r);\n    }\n\n    return t;\n  }\n\n  _initializeBinaryProperty(t, n) {\n    if (\"byteOffset\" in n) {\n      const s = n;\n      U(this.binary, `Property ${t} requires a batch table binary.`), U(s.type, `Property ${t} requires a type.`);\n      const r = Bm(s, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);\n      return {\n        typedArray: r.values,\n        componentCount: r.size,\n        unpack: r.unpacker,\n        pack: r.packer\n      };\n    }\n\n    return null;\n  }\n\n  _hasPropertyInHierarchy(t, n) {\n    if (!this._hierarchy) return !1;\n    const s = Te(this._hierarchy, t, (r, i) => {\n      const o = r.classIds[i],\n            a = r.classes[o].instances;\n      return ct(a[n]);\n    });\n    return ct(s);\n  }\n\n  _getPropertyNamesInHierarchy(t, n) {\n    Te(this._hierarchy, t, (s, r) => {\n      const i = s.classIds[r],\n            o = s.classes[i].instances;\n\n      for (const a in o) o.hasOwnProperty(a) && n.indexOf(a) === -1 && n.push(a);\n    });\n  }\n\n  _getHierarchyProperty(t, n) {\n    return Te(this._hierarchy, t, (s, r) => {\n      const i = s.classIds[r],\n            o = s.classes[i],\n            a = s.classIndexes[r],\n            c = o.instances[n];\n      return ct(c) ? ct(c.typedArray) ? this._getBinaryProperty(c, a) : un(c[a]) : null;\n    });\n  }\n\n  _setHierarchyProperty(t, n, s, r) {\n    const i = Te(this._hierarchy, n, (o, a) => {\n      const c = o.classIds[a],\n            u = o.classes[c],\n            l = o.classIndexes[a],\n            h = u.instances[s];\n      return ct(h) ? (U(a === n, `Inherited property \"${s}\" is read-only.`), ct(h.typedArray) ? this._setBinaryProperty(h, l, r) : h[l] = un(r), !0) : !1;\n    });\n    return ct(i);\n  }\n\n}\n\nconst Bs = 4;\n\nfunction Vn(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  const s = new DataView(t);\n  if (e.magic = s.getUint32(n, !0), n += Bs, e.version = s.getUint32(n, !0), n += Bs, e.byteLength = s.getUint32(n, !0), n += Bs, e.version !== 1) throw new Error(`3D Tile Version ${e.version} not supported`);\n  return n;\n}\n\nconst oe = 4,\n      Hi = \"b3dm tile in legacy format.\";\n\nfunction gr(e, t, n) {\n  const s = new DataView(t);\n  let r;\n  e.header = e.header || {};\n  let i = s.getUint32(n, !0);\n  n += oe;\n  let o = s.getUint32(n, !0);\n  n += oe;\n  let a = s.getUint32(n, !0);\n  n += oe;\n  let c = s.getUint32(n, !0);\n  return n += oe, a >= 570425344 ? (n -= oe * 2, r = i, a = o, c = 0, i = 0, o = 0, console.warn(Hi)) : c >= 570425344 && (n -= oe, r = a, a = i, c = o, i = 0, o = 0, console.warn(Hi)), e.header.featureTableJsonByteLength = i, e.header.featureTableBinaryByteLength = o, e.header.batchTableJsonByteLength = a, e.header.batchTableBinaryByteLength = c, e.header.batchLength = r, n;\n}\n\nfunction Ar(e, t, n, s) {\n  return n = Rm(e, t, n), n = Mm(e, t, n), n;\n}\n\nfunction Rm(e, t, n, s) {\n  const {\n    featureTableJsonByteLength: r,\n    featureTableBinaryByteLength: i,\n    batchLength: o\n  } = e.header || {};\n\n  if (e.featureTableJson = {\n    BATCH_LENGTH: o || 0\n  }, r && r > 0) {\n    const a = Ta(t, n, r);\n    e.featureTableJson = JSON.parse(a);\n  }\n\n  return n += r || 0, e.featureTableBinary = new Uint8Array(t, n, i), n += i || 0, n;\n}\n\nfunction Mm(e, t, n, s) {\n  const {\n    batchTableJsonByteLength: r,\n    batchTableBinaryByteLength: i\n  } = e.header || {};\n\n  if (r && r > 0) {\n    const o = Ta(t, n, r);\n    e.batchTableJson = JSON.parse(o), n += r, i && i > 0 && (e.batchTableBinary = new Uint8Array(t, n, i), e.batchTableBinary = new Uint8Array(e.batchTableBinary), n += i);\n  }\n\n  return n;\n}\n\nfunction Ma(e, t, n) {\n  if (!t && (!e || !e.batchIds || !n)) return null;\n  const {\n    batchIds: s,\n    isRGB565: r,\n    pointCount: i = 0\n  } = e;\n\n  if (s && n) {\n    const o = new Uint8ClampedArray(i * 3);\n\n    for (let a = 0; a < i; a++) {\n      const c = s[a],\n            l = n.getProperty(c, \"dimensions\").map(h => h * 255);\n      o[a * 3] = l[0], o[a * 3 + 1] = l[1], o[a * 3 + 2] = l[2];\n    }\n\n    return {\n      type: G.UNSIGNED_BYTE,\n      value: o,\n      size: 3,\n      normalized: !0\n    };\n  }\n\n  if (t && r) {\n    const o = new Uint8ClampedArray(i * 3);\n\n    for (let a = 0; a < i; a++) {\n      const c = dm(t[a]);\n      o[a * 3] = c[0], o[a * 3 + 1] = c[1], o[a * 3 + 2] = c[2];\n    }\n\n    return {\n      type: G.UNSIGNED_BYTE,\n      value: o,\n      size: 3,\n      normalized: !0\n    };\n  }\n\n  return t && t.length === i * 3 ? {\n    type: G.UNSIGNED_BYTE,\n    value: t,\n    size: 3,\n    normalized: !0\n  } : {\n    type: G.UNSIGNED_BYTE,\n    value: t || new Uint8ClampedArray(),\n    size: 4,\n    normalized: !0\n  };\n}\n\nconst Ji = new A();\n\nfunction Im(e, t) {\n  if (!t) return null;\n\n  if (e.isOctEncoded16P) {\n    const n = new Float32Array((e.pointsLength || 0) * 3);\n\n    for (let s = 0; s < (e.pointsLength || 0); s++) gm(t[s * 2], t[s * 2 + 1], Ji), Ji.toArray(n, s * 3);\n\n    return {\n      type: G.FLOAT,\n      size: 2,\n      value: n\n    };\n  }\n\n  return {\n    type: G.FLOAT,\n    size: 2,\n    value: t\n  };\n}\n\nfunction Sm(e, t, n) {\n  return e.isQuantized ? n[\"3d-tiles\"] && n[\"3d-tiles\"].decodeQuantizedPositions ? (e.isQuantized = !1, xm(e, t)) : {\n    type: G.UNSIGNED_SHORT,\n    value: t,\n    size: 3,\n    normalized: !0\n  } : t;\n}\n\nfunction xm(e, t) {\n  const n = new A(),\n        s = new Float32Array(e.pointCount * 3);\n\n  for (let r = 0; r < e.pointCount; r++) n.set(t[r * 3], t[r * 3 + 1], t[r * 3 + 2]).scale(1 / e.quantizedRange).multiply(e.quantizedVolumeScale).add(e.quantizedVolumeOffset).toArray(s, r * 3);\n\n  return s;\n}\n\nasync function Om(e, t, n, s, r) {\n  n = Vn(e, t, n), n = gr(e, t, n), n = Ar(e, t, n), Fm(e);\n  const {\n    featureTable: i,\n    batchTable: o\n  } = vm(e);\n  return await Nm(e, i, o, s, r), Dm(e, i, s), Lm(e, i, o), Gm(e, i), n;\n}\n\nfunction Fm(e) {\n  e.attributes = {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, e.isQuantized = !1, e.isTranslucent = !1, e.isRGB565 = !1, e.isOctEncoded16P = !1;\n}\n\nfunction vm(e) {\n  const t = new mr(e.featureTableJson, e.featureTableBinary),\n        n = t.getGlobalProperty(\"POINTS_LENGTH\");\n  if (!Number.isFinite(n)) throw new Error(\"POINTS_LENGTH must be defined\");\n  t.featuresLength = n, e.featuresLength = n, e.pointsLength = n, e.pointCount = n, e.rtcCenter = t.getGlobalProperty(\"RTC_CENTER\", G.FLOAT, 3);\n  const s = Pm(e, t);\n  return {\n    featureTable: t,\n    batchTable: s\n  };\n}\n\nfunction Dm(e, t, n) {\n  if (e.attributes = e.attributes || {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, !e.attributes.positions) {\n    if (t.hasProperty(\"POSITION\")) e.attributes.positions = t.getPropertyArray(\"POSITION\", G.FLOAT, 3);else if (t.hasProperty(\"POSITION_QUANTIZED\")) {\n      const s = t.getPropertyArray(\"POSITION_QUANTIZED\", G.UNSIGNED_SHORT, 3);\n      if (e.isQuantized = !0, e.quantizedRange = 65535, e.quantizedVolumeScale = t.getGlobalProperty(\"QUANTIZED_VOLUME_SCALE\", G.FLOAT, 3), !e.quantizedVolumeScale) throw new Error(\"QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\");\n      if (e.quantizedVolumeOffset = t.getGlobalProperty(\"QUANTIZED_VOLUME_OFFSET\", G.FLOAT, 3), !e.quantizedVolumeOffset) throw new Error(\"QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\");\n      e.attributes.positions = Sm(e, s, n);\n    }\n  }\n\n  if (!e.attributes.positions) throw new Error(\"Either POSITION or POSITION_QUANTIZED must be defined.\");\n}\n\nfunction Lm(e, t, n) {\n  if (e.attributes = e.attributes || {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, !e.attributes.colors) {\n    let s = null;\n    t.hasProperty(\"RGBA\") ? (s = t.getPropertyArray(\"RGBA\", G.UNSIGNED_BYTE, 4), e.isTranslucent = !0) : t.hasProperty(\"RGB\") ? s = t.getPropertyArray(\"RGB\", G.UNSIGNED_BYTE, 3) : t.hasProperty(\"RGB565\") && (s = t.getPropertyArray(\"RGB565\", G.UNSIGNED_SHORT, 1), e.isRGB565 = !0), e.attributes.colors = Ma(e, s, n);\n  }\n\n  t.hasProperty(\"CONSTANT_RGBA\") && (e.constantRGBA = t.getGlobalProperty(\"CONSTANT_RGBA\", G.UNSIGNED_BYTE, 4));\n}\n\nfunction Gm(e, t) {\n  if (e.attributes = e.attributes || {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, !e.attributes.normals) {\n    let n = null;\n    t.hasProperty(\"NORMAL\") ? n = t.getPropertyArray(\"NORMAL\", G.FLOAT, 3) : t.hasProperty(\"NORMAL_OCT16P\") && (n = t.getPropertyArray(\"NORMAL_OCT16P\", G.UNSIGNED_BYTE, 2), e.isOctEncoded16P = !0), e.attributes.normals = Im(e, n);\n  }\n}\n\nfunction Pm(e, t) {\n  let n = null;\n\n  if (!e.batchIds && t.hasProperty(\"BATCH_ID\") && (e.batchIds = t.getPropertyArray(\"BATCH_ID\", G.UNSIGNED_SHORT, 1), e.batchIds)) {\n    const s = t.getGlobalProperty(\"BATCH_LENGTH\");\n    if (!s) throw new Error(\"Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.\");\n    const {\n      batchTableJson: r,\n      batchTableBinary: i\n    } = e;\n    n = new Ra(r, i, s);\n  }\n\n  return n;\n}\n\nasync function Nm(e, t, n, s, r) {\n  let i, o, a;\n  const c = e.batchTableJson && e.batchTableJson.extensions && e.batchTableJson.extensions[\"3DTILES_draco_point_compression\"];\n  c && (a = c.properties);\n  const u = t.getExtension(\"3DTILES_draco_point_compression\");\n\n  if (u) {\n    o = u.properties;\n    const h = u.byteOffset,\n          f = u.byteLength;\n    if (!o || !Number.isFinite(h) || !f) throw new Error(\"Draco properties, byteOffset, and byteLength must be defined\");\n    i = (e.featureTableBinary || []).slice(h, h + f), e.hasPositions = Number.isFinite(o.POSITION), e.hasColors = Number.isFinite(o.RGB) || Number.isFinite(o.RGBA), e.hasNormals = Number.isFinite(o.NORMAL), e.hasBatchIds = Number.isFinite(o.BATCH_ID), e.isTranslucent = Number.isFinite(o.RGBA);\n  }\n\n  if (!i) return !0;\n  const l = {\n    buffer: i,\n    properties: { ...o,\n      ...a\n    },\n    featureTableProperties: o,\n    batchTableProperties: a,\n    dequantizeInShader: !1\n  };\n  return await Um(e, l, s, r);\n}\n\nasync function Um(e, t, n, s) {\n  if (!s) return;\n  const r = { ...n,\n    draco: { ...(n == null ? void 0 : n.draco),\n      extraAttributes: t.batchTableProperties || {}\n    }\n  };\n  delete r[\"3d-tiles\"];\n  const i = await He(t.buffer, _a, r, s),\n        o = i.attributes.POSITION && i.attributes.POSITION.value,\n        a = i.attributes.COLOR_0 && i.attributes.COLOR_0.value,\n        c = i.attributes.NORMAL && i.attributes.NORMAL.value,\n        u = i.attributes.BATCH_ID && i.attributes.BATCH_ID.value,\n        l = o && i.attributes.POSITION.value.quantization,\n        h = c && i.attributes.NORMAL.value.quantization;\n\n  if (l) {\n    const d = i.POSITION.data.quantization,\n          m = d.range;\n    e.quantizedVolumeScale = new A(m, m, m), e.quantizedVolumeOffset = new A(d.minValues), e.quantizedRange = (1 << d.quantizationBits) - 1, e.isQuantizedDraco = !0;\n  }\n\n  h && (e.octEncodedRange = (1 << i.NORMAL.data.quantization.quantizationBits) - 1, e.isOctEncodedDraco = !0);\n  const f = {};\n  if (t.batchTableProperties) for (const d of Object.keys(t.batchTableProperties)) i.attributes[d] && i.attributes[d].value && (f[d.toLowerCase()] = i.attributes[d].value);\n  e.attributes = {\n    positions: o,\n    colors: Ma(e, a, void 0),\n    normals: c,\n    batchIds: u,\n    ...f\n  };\n}\n\nconst Hm = \"4.1.1\";\nvar Cs;\nconst Jm = (Cs = globalThis.loaders) === null || Cs === void 0 ? void 0 : Cs.parseImageNode,\n      js = typeof Image < \"u\",\n      ks = typeof ImageBitmap < \"u\",\n      Vm = !!Jm,\n      Ks = Ln ? !0 : Vm;\n\nfunction jm(e) {\n  switch (e) {\n    case \"auto\":\n      return ks || js || Ks;\n\n    case \"imagebitmap\":\n      return ks;\n\n    case \"image\":\n      return js;\n\n    case \"data\":\n      return Ks;\n\n    default:\n      throw new Error(`@loaders.gl/images: image ${e} not supported in this environment`);\n  }\n}\n\nfunction km() {\n  if (ks) return \"imagebitmap\";\n  if (js) return \"image\";\n  if (Ks) return \"data\";\n  throw new Error(\"Install '@loaders.gl/polyfills' to parse images under Node.js\");\n}\n\nfunction Km(e) {\n  const t = zm(e);\n  if (!t) throw new Error(\"Not an image\");\n  return t;\n}\n\nfunction Ia(e) {\n  switch (Km(e)) {\n    case \"data\":\n      return e;\n\n    case \"image\":\n    case \"imagebitmap\":\n      const t = document.createElement(\"canvas\"),\n            n = t.getContext(\"2d\");\n      if (!n) throw new Error(\"getImageData\");\n      return t.width = e.width, t.height = e.height, n.drawImage(e, 0, 0), n.getImageData(0, 0, e.width, e.height);\n\n    default:\n      throw new Error(\"getImageData\");\n  }\n}\n\nfunction zm(e) {\n  return typeof ImageBitmap < \"u\" && e instanceof ImageBitmap ? \"imagebitmap\" : typeof Image < \"u\" && e instanceof Image ? \"image\" : e && typeof e == \"object\" && e.data && e.width && e.height ? \"data\" : null;\n}\n\nconst Wm = /^data:image\\/svg\\+xml/,\n      Xm = /\\.svg((\\?|#).*)?$/;\n\nfunction pr(e) {\n  return e && (Wm.test(e) || Xm.test(e));\n}\n\nfunction Qm(e, t) {\n  if (pr(t)) {\n    let s = new TextDecoder().decode(e);\n\n    try {\n      typeof unescape == \"function\" && typeof encodeURIComponent == \"function\" && (s = unescape(encodeURIComponent(s)));\n    } catch (i) {\n      throw new Error(i.message);\n    }\n\n    return `data:image/svg+xml;base64,${btoa(s)}`;\n  }\n\n  return Sa(e, t);\n}\n\nfunction Sa(e, t) {\n  if (pr(t)) throw new Error(\"SVG cannot be parsed directly to imagebitmap\");\n  return new Blob([new Uint8Array(e)]);\n}\n\nasync function xa(e, t, n) {\n  const s = Qm(e, n),\n        r = self.URL || self.webkitURL,\n        i = typeof s != \"string\" && r.createObjectURL(s);\n\n  try {\n    return await qm(i || s, t);\n  } finally {\n    i && r.revokeObjectURL(i);\n  }\n}\n\nasync function qm(e, t) {\n  const n = new Image();\n  return n.src = e, t.image && t.image.decode && n.decode ? (await n.decode(), n) : await new Promise((s, r) => {\n    try {\n      n.onload = () => s(n), n.onerror = i => {\n        const o = i instanceof Error ? i.message : \"error\";\n        r(new Error(o));\n      };\n    } catch (i) {\n      r(i);\n    }\n  });\n}\n\nconst Ym = {};\nlet Vi = !0;\n\nasync function $m(e, t, n) {\n  let s;\n  pr(n) ? s = await xa(e, t, n) : s = Sa(e, n);\n  const r = t && t.imagebitmap;\n  return await Zm(s, r);\n}\n\nasync function Zm(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n  if ((tg(t) || !Vi) && (t = null), t) try {\n    return await createImageBitmap(e, t);\n  } catch (n) {\n    console.warn(n), Vi = !1;\n  }\n  return await createImageBitmap(e);\n}\n\nfunction tg(e) {\n  for (const t in e || Ym) return !1;\n\n  return !0;\n}\n\nfunction eg(e) {\n  return !ig(e, \"ftyp\", 4) || !(e[8] & 96) ? null : ng(e);\n}\n\nfunction ng(e) {\n  switch (sg(e, 8, 12).replace(\"\\0\", \" \").trim()) {\n    case \"avif\":\n    case \"avis\":\n      return {\n        extension: \"avif\",\n        mimeType: \"image/avif\"\n      };\n\n    default:\n      return null;\n  }\n}\n\nfunction sg(e, t, n) {\n  return String.fromCharCode(...e.slice(t, n));\n}\n\nfunction rg(e) {\n  return [...e].map(t => t.charCodeAt(0));\n}\n\nfunction ig(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  const s = rg(t);\n\n  for (let r = 0; r < s.length; ++r) if (s[r] !== e[r + n]) return !1;\n\n  return !0;\n}\n\nconst xt = !1,\n      xe = !0;\n\nfunction yr(e) {\n  const t = ze(e);\n  return ag(t) || lg(t) || cg(t) || ug(t) || og(t);\n}\n\nfunction og(e) {\n  const t = new Uint8Array(e instanceof DataView ? e.buffer : e),\n        n = eg(t);\n  return n ? {\n    mimeType: n.mimeType,\n    width: 0,\n    height: 0\n  } : null;\n}\n\nfunction ag(e) {\n  const t = ze(e);\n  return t.byteLength >= 24 && t.getUint32(0, xt) === 2303741511 ? {\n    mimeType: \"image/png\",\n    width: t.getUint32(16, xt),\n    height: t.getUint32(20, xt)\n  } : null;\n}\n\nfunction cg(e) {\n  const t = ze(e);\n  return t.byteLength >= 10 && t.getUint32(0, xt) === 1195984440 ? {\n    mimeType: \"image/gif\",\n    width: t.getUint16(6, xe),\n    height: t.getUint16(8, xe)\n  } : null;\n}\n\nfunction ug(e) {\n  const t = ze(e);\n  return t.byteLength >= 14 && t.getUint16(0, xt) === 16973 && t.getUint32(2, xe) === t.byteLength ? {\n    mimeType: \"image/bmp\",\n    width: t.getUint32(18, xe),\n    height: t.getUint32(22, xe)\n  } : null;\n}\n\nfunction lg(e) {\n  const t = ze(e);\n  if (!(t.byteLength >= 3 && t.getUint16(0, xt) === 65496 && t.getUint8(2) === 255)) return null;\n  const {\n    tableMarkers: s,\n    sofMarkers: r\n  } = hg();\n  let i = 2;\n\n  for (; i + 9 < t.byteLength;) {\n    const o = t.getUint16(i, xt);\n    if (r.has(o)) return {\n      mimeType: \"image/jpeg\",\n      height: t.getUint16(i + 5, xt),\n      width: t.getUint16(i + 7, xt)\n    };\n    if (!s.has(o)) return null;\n    i += 2, i += t.getUint16(i, xt);\n  }\n\n  return null;\n}\n\nfunction hg() {\n  const e = /* @__PURE__ */new Set([65499, 65476, 65484, 65501, 65534]);\n\n  for (let n = 65504; n < 65520; ++n) e.add(n);\n\n  return {\n    tableMarkers: e,\n    sofMarkers: /* @__PURE__ */new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502])\n  };\n}\n\nfunction ze(e) {\n  if (e instanceof DataView) return e;\n  if (ArrayBuffer.isView(e)) return new DataView(e.buffer);\n  if (e instanceof ArrayBuffer) return new DataView(e);\n  throw new Error(\"toDataView\");\n}\n\nasync function fg(e, t) {\n  var n;\n  const {\n    mimeType: s\n  } = yr(e) || {},\n        r = (n = globalThis.loaders) === null || n === void 0 ? void 0 : n.parseImageNode;\n  return U(r), await r(e, s);\n}\n\nasync function dg(e, t, n) {\n  t = t || {};\n  const r = (t.image || {}).type || \"auto\",\n        {\n    url: i\n  } = n || {},\n        o = mg(r);\n  let a;\n\n  switch (o) {\n    case \"imagebitmap\":\n      a = await $m(e, t, i);\n      break;\n\n    case \"image\":\n      a = await xa(e, t, i);\n      break;\n\n    case \"data\":\n      a = await fg(e);\n      break;\n\n    default:\n      U(!1);\n  }\n\n  return r === \"data\" && (a = Ia(a)), a;\n}\n\nfunction mg(e) {\n  switch (e) {\n    case \"auto\":\n    case \"data\":\n      return km();\n\n    default:\n      return jm(e), e;\n  }\n}\n\nconst gg = [\"png\", \"jpg\", \"jpeg\", \"gif\", \"webp\", \"bmp\", \"ico\", \"svg\", \"avif\"],\n      Ag = [\"image/png\", \"image/jpeg\", \"image/gif\", \"image/webp\", \"image/avif\", \"image/bmp\", \"image/vnd.microsoft.icon\", \"image/svg+xml\"],\n      pg = {\n  image: {\n    type: \"auto\",\n    decode: !0\n  }\n},\n      yg = {\n  id: \"image\",\n  module: \"images\",\n  name: \"Images\",\n  version: Hm,\n  mimeTypes: Ag,\n  extensions: gg,\n  parse: dg,\n  tests: [e => !!yr(new DataView(e))],\n  options: pg\n},\n      Es = {};\n\nfunction Bg(e) {\n  if (Es[e] === void 0) {\n    const t = Ln ? Eg(e) : Cg(e);\n    Es[e] = t;\n  }\n\n  return Es[e];\n}\n\nfunction Cg(e) {\n  var t, n;\n  const s = [\"image/png\", \"image/jpeg\", \"image/gif\"],\n        r = ((t = globalThis.loaders) === null || t === void 0 ? void 0 : t.imageFormatsNode) || s;\n  return !!((n = globalThis.loaders) === null || n === void 0 ? void 0 : n.parseImageNode) && r.includes(e);\n}\n\nfunction Eg(e) {\n  switch (e) {\n    case \"image/avif\":\n    case \"image/webp\":\n      return Tg(e);\n\n    default:\n      return !0;\n  }\n}\n\nfunction Tg(e) {\n  try {\n    return document.createElement(\"canvas\").toDataURL(e).indexOf(`data:${e}`) === 0;\n  } catch {\n    return !1;\n  }\n}\n\nfunction gt(e, t) {\n  if (!e) throw new Error(t || \"assert failed: gltf\");\n}\n\nconst Oa = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n},\n      Fa = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n},\n      bg = 1.33,\n      ji = [\"SCALAR\", \"VEC2\", \"VEC3\", \"VEC4\"],\n      _g = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]],\n      wg = new Map(_g),\n      Rg = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n},\n      Mg = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n},\n      Ig = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\nfunction va(e) {\n  return ji[e - 1] || ji[0];\n}\n\nfunction Br(e) {\n  const t = wg.get(e.constructor);\n  if (!t) throw new Error(\"Illegal typed array\");\n  return t;\n}\n\nfunction Cr(e, t) {\n  const n = Ig[e.componentType],\n        s = Rg[e.type],\n        r = Mg[e.componentType],\n        i = e.count * s,\n        o = e.count * s * r;\n  gt(o >= 0 && o <= t.byteLength);\n  const a = Fa[e.componentType],\n        c = Oa[e.type];\n  return {\n    ArrayType: n,\n    length: i,\n    byteLength: o,\n    componentByteSize: a,\n    numberOfComponentsInElement: c\n  };\n}\n\nfunction Da(e) {\n  let {\n    images: t,\n    bufferViews: n\n  } = e;\n  t = t || [], n = n || [];\n  const s = t.map(o => o.bufferView);\n  n = n.filter(o => !s.includes(o));\n  const r = n.reduce((o, a) => o + a.byteLength, 0),\n        i = t.reduce((o, a) => {\n    const {\n      width: c,\n      height: u\n    } = a.image;\n    return o + c * u;\n  }, 0);\n  return r + Math.ceil(4 * i * bg);\n}\n\nfunction Sg(e, t, n) {\n  const s = e.bufferViews[n];\n  gt(s);\n  const r = s.buffer,\n        i = t[r];\n  gt(i);\n  const o = (s.byteOffset || 0) + i.byteOffset;\n  return new Uint8Array(i.arrayBuffer, o, s.byteLength);\n}\n\nfunction xg(e, t, n) {\n  var s, r;\n  const i = typeof n == \"number\" ? (s = e.accessors) === null || s === void 0 ? void 0 : s[n] : n;\n  if (!i) throw new Error(`No gltf accessor ${JSON.stringify(n)}`);\n  const o = (r = e.bufferViews) === null || r === void 0 ? void 0 : r[i.bufferView || 0];\n  if (!o) throw new Error(`No gltf buffer view for accessor ${o}`);\n  const {\n    arrayBuffer: a,\n    byteOffset: c\n  } = t[o.buffer],\n        u = (c || 0) + (i.byteOffset || 0) + (o.byteOffset || 0),\n        {\n    ArrayType: l,\n    length: h,\n    componentByteSize: f,\n    numberOfComponentsInElement: d\n  } = Cr(i, o),\n        m = f * d,\n        g = o.byteStride || m;\n  if (typeof o.byteStride > \"u\" || o.byteStride === m) return new l(a, u, h);\n  const p = new l(h);\n\n  for (let C = 0; C < i.count; C++) {\n    const w = new l(a, u + C * g, d);\n    p.set(w, C * d);\n  }\n\n  return p;\n}\n\nfunction Og() {\n  return {\n    asset: {\n      version: \"2.0\",\n      generator: \"loaders.gl\"\n    },\n    buffers: [],\n    extensions: {},\n    extensionsRequired: [],\n    extensionsUsed: []\n  };\n}\n\nclass it {\n  constructor(t) {\n    this.gltf = void 0, this.sourceBuffers = void 0, this.byteLength = void 0, this.gltf = {\n      json: (t == null ? void 0 : t.json) || Og(),\n      buffers: (t == null ? void 0 : t.buffers) || [],\n      images: (t == null ? void 0 : t.images) || []\n    }, this.sourceBuffers = [], this.byteLength = 0, this.gltf.buffers && this.gltf.buffers[0] && (this.byteLength = this.gltf.buffers[0].byteLength, this.sourceBuffers = [this.gltf.buffers[0]]);\n  }\n\n  get json() {\n    return this.gltf.json;\n  }\n\n  getApplicationData(t) {\n    return this.json[t];\n  }\n\n  getExtraData(t) {\n    return (this.json.extras || {})[t];\n  }\n\n  hasExtension(t) {\n    const n = this.getUsedExtensions().find(r => r === t),\n          s = this.getRequiredExtensions().find(r => r === t);\n    return typeof n == \"string\" || typeof s == \"string\";\n  }\n\n  getExtension(t) {\n    const n = this.getUsedExtensions().find(r => r === t),\n          s = this.json.extensions || {};\n    return n ? s[t] : null;\n  }\n\n  getRequiredExtension(t) {\n    return this.getRequiredExtensions().find(s => s === t) ? this.getExtension(t) : null;\n  }\n\n  getRequiredExtensions() {\n    return this.json.extensionsRequired || [];\n  }\n\n  getUsedExtensions() {\n    return this.json.extensionsUsed || [];\n  }\n\n  getRemovedExtensions() {\n    return this.json.extensionsRemoved || [];\n  }\n\n  getObjectExtension(t, n) {\n    return (t.extensions || {})[n];\n  }\n\n  getScene(t) {\n    return this.getObject(\"scenes\", t);\n  }\n\n  getNode(t) {\n    return this.getObject(\"nodes\", t);\n  }\n\n  getSkin(t) {\n    return this.getObject(\"skins\", t);\n  }\n\n  getMesh(t) {\n    return this.getObject(\"meshes\", t);\n  }\n\n  getMaterial(t) {\n    return this.getObject(\"materials\", t);\n  }\n\n  getAccessor(t) {\n    return this.getObject(\"accessors\", t);\n  }\n\n  getTexture(t) {\n    return this.getObject(\"textures\", t);\n  }\n\n  getSampler(t) {\n    return this.getObject(\"samplers\", t);\n  }\n\n  getImage(t) {\n    return this.getObject(\"images\", t);\n  }\n\n  getBufferView(t) {\n    return this.getObject(\"bufferViews\", t);\n  }\n\n  getBuffer(t) {\n    return this.getObject(\"buffers\", t);\n  }\n\n  getObject(t, n) {\n    if (typeof n == \"object\") return n;\n    const s = this.json[t] && this.json[t][n];\n    if (!s) throw new Error(`glTF file error: Could not find ${t}[${n}]`);\n    return s;\n  }\n\n  getTypedArrayForBufferView(t) {\n    t = this.getBufferView(t);\n    const n = t.buffer,\n          s = this.gltf.buffers[n];\n    gt(s);\n    const r = (t.byteOffset || 0) + s.byteOffset;\n    return new Uint8Array(s.arrayBuffer, r, t.byteLength);\n  }\n\n  getTypedArrayForAccessor(t) {\n    const n = this.getAccessor(t);\n    return xg(this.gltf.json, this.gltf.buffers, n);\n  }\n\n  getTypedArrayForImageData(t) {\n    t = this.getAccessor(t);\n    const n = this.getBufferView(t.bufferView),\n          r = this.getBuffer(n.buffer).data,\n          i = n.byteOffset || 0;\n    return new Uint8Array(r, i, n.byteLength);\n  }\n\n  addApplicationData(t, n) {\n    return this.json[t] = n, this;\n  }\n\n  addExtraData(t, n) {\n    return this.json.extras = this.json.extras || {}, this.json.extras[t] = n, this;\n  }\n\n  addObjectExtension(t, n, s) {\n    return t.extensions = t.extensions || {}, t.extensions[n] = s, this.registerUsedExtension(n), this;\n  }\n\n  setObjectExtension(t, n, s) {\n    const r = t.extensions || {};\n    r[n] = s;\n  }\n\n  removeObjectExtension(t, n) {\n    const s = (t == null ? void 0 : t.extensions) || {};\n\n    if (s[n]) {\n      this.json.extensionsRemoved = this.json.extensionsRemoved || [];\n      const r = this.json.extensionsRemoved;\n      r.includes(n) || r.push(n);\n    }\n\n    delete s[n];\n  }\n\n  addExtension(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return gt(n), this.json.extensions = this.json.extensions || {}, this.json.extensions[t] = n, this.registerUsedExtension(t), n;\n  }\n\n  addRequiredExtension(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return gt(n), this.addExtension(t, n), this.registerRequiredExtension(t), n;\n  }\n\n  registerUsedExtension(t) {\n    this.json.extensionsUsed = this.json.extensionsUsed || [], this.json.extensionsUsed.find(n => n === t) || this.json.extensionsUsed.push(t);\n  }\n\n  registerRequiredExtension(t) {\n    this.registerUsedExtension(t), this.json.extensionsRequired = this.json.extensionsRequired || [], this.json.extensionsRequired.find(n => n === t) || this.json.extensionsRequired.push(t);\n  }\n\n  removeExtension(t) {\n    var n;\n\n    if ((n = this.json.extensions) !== null && n !== void 0 && n[t]) {\n      this.json.extensionsRemoved = this.json.extensionsRemoved || [];\n      const s = this.json.extensionsRemoved;\n      s.includes(t) || s.push(t);\n    }\n\n    this.json.extensions && delete this.json.extensions[t], this.json.extensionsRequired && this._removeStringFromArray(this.json.extensionsRequired, t), this.json.extensionsUsed && this._removeStringFromArray(this.json.extensionsUsed, t);\n  }\n\n  setDefaultScene(t) {\n    this.json.scene = t;\n  }\n\n  addScene(t) {\n    const {\n      nodeIndices: n\n    } = t;\n    return this.json.scenes = this.json.scenes || [], this.json.scenes.push({\n      nodes: n\n    }), this.json.scenes.length - 1;\n  }\n\n  addNode(t) {\n    const {\n      meshIndex: n,\n      matrix: s\n    } = t;\n    this.json.nodes = this.json.nodes || [];\n    const r = {\n      mesh: n\n    };\n    return s && (r.matrix = s), this.json.nodes.push(r), this.json.nodes.length - 1;\n  }\n\n  addMesh(t) {\n    const {\n      attributes: n,\n      indices: s,\n      material: r,\n      mode: i = 4\n    } = t,\n          a = {\n      primitives: [{\n        attributes: this._addAttributes(n),\n        mode: i\n      }]\n    };\n\n    if (s) {\n      const c = this._addIndices(s);\n\n      a.primitives[0].indices = c;\n    }\n\n    return Number.isFinite(r) && (a.primitives[0].material = r), this.json.meshes = this.json.meshes || [], this.json.meshes.push(a), this.json.meshes.length - 1;\n  }\n\n  addPointCloud(t) {\n    const s = {\n      primitives: [{\n        attributes: this._addAttributes(t),\n        mode: 0\n      }]\n    };\n    return this.json.meshes = this.json.meshes || [], this.json.meshes.push(s), this.json.meshes.length - 1;\n  }\n\n  addImage(t, n) {\n    const s = yr(t),\n          r = n || (s == null ? void 0 : s.mimeType),\n          o = {\n      bufferView: this.addBufferView(t),\n      mimeType: r\n    };\n    return this.json.images = this.json.images || [], this.json.images.push(o), this.json.images.length - 1;\n  }\n\n  addBufferView(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,\n        s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.byteLength;\n    const r = t.byteLength;\n    gt(Number.isFinite(r)), this.sourceBuffers = this.sourceBuffers || [], this.sourceBuffers.push(t);\n    const i = {\n      buffer: n,\n      byteOffset: s,\n      byteLength: r\n    };\n    return this.byteLength += Je(r, 4), this.json.bufferViews = this.json.bufferViews || [], this.json.bufferViews.push(i), this.json.bufferViews.length - 1;\n  }\n\n  addAccessor(t, n) {\n    const s = {\n      bufferView: t,\n      type: va(n.size),\n      componentType: n.componentType,\n      count: n.count,\n      max: n.max,\n      min: n.min\n    };\n    return this.json.accessors = this.json.accessors || [], this.json.accessors.push(s), this.json.accessors.length - 1;\n  }\n\n  addBinaryBuffer(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n      size: 3\n    };\n    const s = this.addBufferView(t);\n    let r = {\n      min: n.min,\n      max: n.max\n    };\n    (!r.min || !r.max) && (r = this._getAccessorMinMax(t, n.size));\n    const i = {\n      size: n.size,\n      componentType: Br(t),\n      count: Math.round(t.length / n.size),\n      min: r.min,\n      max: r.max\n    };\n    return this.addAccessor(s, Object.assign(i, n));\n  }\n\n  addTexture(t) {\n    const {\n      imageIndex: n\n    } = t,\n          s = {\n      source: n\n    };\n    return this.json.textures = this.json.textures || [], this.json.textures.push(s), this.json.textures.length - 1;\n  }\n\n  addMaterial(t) {\n    return this.json.materials = this.json.materials || [], this.json.materials.push(t), this.json.materials.length - 1;\n  }\n\n  createBinaryChunk() {\n    var t, n;\n    this.gltf.buffers = [];\n    const s = this.byteLength,\n          r = new ArrayBuffer(s),\n          i = new Uint8Array(r);\n    let o = 0;\n\n    for (const a of this.sourceBuffers || []) o = pu(a, i, o);\n\n    (t = this.json) !== null && t !== void 0 && (n = t.buffers) !== null && n !== void 0 && n[0] ? this.json.buffers[0].byteLength = s : this.json.buffers = [{\n      byteLength: s\n    }], this.gltf.binary = r, this.sourceBuffers = [r];\n  }\n\n  _removeStringFromArray(t, n) {\n    let s = !0;\n\n    for (; s;) {\n      const r = t.indexOf(n);\n      r > -1 ? t.splice(r, 1) : s = !1;\n    }\n  }\n\n  _addAttributes() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const n = {};\n\n    for (const s in t) {\n      const r = t[s],\n            i = this._getGltfAttributeName(s),\n            o = this.addBinaryBuffer(r.value, r);\n\n      n[i] = o;\n    }\n\n    return n;\n  }\n\n  _addIndices(t) {\n    return this.addBinaryBuffer(t, {\n      size: 1\n    });\n  }\n\n  _getGltfAttributeName(t) {\n    switch (t.toLowerCase()) {\n      case \"position\":\n      case \"positions\":\n      case \"vertices\":\n        return \"POSITION\";\n\n      case \"normal\":\n      case \"normals\":\n        return \"NORMAL\";\n\n      case \"color\":\n      case \"colors\":\n        return \"COLOR_0\";\n\n      case \"texcoord\":\n      case \"texcoords\":\n        return \"TEXCOORD_0\";\n\n      default:\n        return t;\n    }\n  }\n\n  _getAccessorMinMax(t, n) {\n    const s = {\n      min: null,\n      max: null\n    };\n    if (t.length < n) return s;\n    s.min = [], s.max = [];\n    const r = t.subarray(0, n);\n\n    for (const i of r) s.min.push(i), s.max.push(i);\n\n    for (let i = n; i < t.length; i += n) for (let o = 0; o < n; o++) s.min[0 + o] = Math.min(s.min[0 + o], t[i + o]), s.max[0 + o] = Math.max(s.max[0 + o], t[i + o]);\n\n    return s;\n  }\n\n}\n\nfunction ki(e) {\n  return (e % 1 + 1) % 1;\n}\n\nconst La = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16,\n  BOOLEAN: 1,\n  STRING: 1,\n  ENUM: 1\n},\n      Fg = {\n  INT8: Int8Array,\n  UINT8: Uint8Array,\n  INT16: Int16Array,\n  UINT16: Uint16Array,\n  INT32: Int32Array,\n  UINT32: Uint32Array,\n  INT64: BigInt64Array,\n  UINT64: BigUint64Array,\n  FLOAT32: Float32Array,\n  FLOAT64: Float64Array\n},\n      Ga = {\n  INT8: 1,\n  UINT8: 1,\n  INT16: 2,\n  UINT16: 2,\n  INT32: 4,\n  UINT32: 4,\n  INT64: 8,\n  UINT64: 8,\n  FLOAT32: 4,\n  FLOAT64: 8\n};\n\nfunction Er(e, t) {\n  return Ga[t] * La[e];\n}\n\nfunction jn(e, t, n, s) {\n  if (n !== \"UINT8\" && n !== \"UINT16\" && n !== \"UINT32\" && n !== \"UINT64\") return null;\n  const r = e.getTypedArrayForBufferView(t),\n        i = kn(r, \"SCALAR\", n, s + 1);\n  return i instanceof BigInt64Array || i instanceof BigUint64Array ? null : i;\n}\n\nfunction kn(e, t, n) {\n  let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n  const r = La[t],\n        i = Fg[n],\n        o = Ga[n],\n        a = s * r,\n        c = a * o;\n  let u = e.buffer,\n      l = e.byteOffset;\n  return l % o !== 0 && (u = new Uint8Array(u).slice(l, l + c).buffer, l = 0), new i(u, l, a);\n}\n\nfunction Tr(e, t, n) {\n  var s, r;\n  const i = `TEXCOORD_${t.texCoord || 0}`,\n        o = n.attributes[i],\n        a = e.getTypedArrayForAccessor(o),\n        c = e.gltf.json,\n        u = t.index,\n        l = (s = c.textures) === null || s === void 0 || (r = s[u]) === null || r === void 0 ? void 0 : r.source;\n\n  if (typeof l < \"u\") {\n    var h, f, d;\n    const m = (h = c.images) === null || h === void 0 || (f = h[l]) === null || f === void 0 ? void 0 : f.mimeType,\n          g = (d = e.gltf.images) === null || d === void 0 ? void 0 : d[l];\n\n    if (g && typeof g.width < \"u\") {\n      const p = [];\n\n      for (let C = 0; C < a.length; C += 2) {\n        const w = vg(g, m, a, C, t.channels);\n        p.push(w);\n      }\n\n      return p;\n    }\n  }\n\n  return [];\n}\n\nfunction Pa(e, t, n, s, r) {\n  if (!(n != null && n.length)) return;\n  const i = [];\n\n  for (const l of n) {\n    let h = s.findIndex(f => f === l);\n    h === -1 && (h = s.push(l) - 1), i.push(h);\n  }\n\n  const o = new Uint32Array(i),\n        a = e.gltf.buffers.push({\n    arrayBuffer: o.buffer,\n    byteOffset: o.byteOffset,\n    byteLength: o.byteLength\n  }) - 1,\n        c = e.addBufferView(o, a, 0),\n        u = e.addAccessor(c, {\n    size: 1,\n    componentType: Br(o),\n    count: o.length\n  });\n  r.attributes[t] = u;\n}\n\nfunction vg(e, t, n, s) {\n  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [0];\n  const i = {\n    r: {\n      offset: 0,\n      shift: 0\n    },\n    g: {\n      offset: 1,\n      shift: 8\n    },\n    b: {\n      offset: 2,\n      shift: 16\n    },\n    a: {\n      offset: 3,\n      shift: 24\n    }\n  },\n        o = n[s],\n        a = n[s + 1];\n  let c = 1;\n  t && (t.indexOf(\"image/jpeg\") !== -1 || t.indexOf(\"image/png\") !== -1) && (c = 4);\n  const u = Dg(o, a, e, c);\n  let l = 0;\n\n  for (const h of r) {\n    const f = typeof h == \"number\" ? Object.values(i)[h] : i[h],\n          d = u + f.offset,\n          m = Ia(e);\n    if (m.data.length <= d) throw new Error(`${m.data.length} <= ${d}`);\n    const g = m.data[d];\n    l |= g << f.shift;\n  }\n\n  return l;\n}\n\nfunction Dg(e, t, n) {\n  let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n  const r = n.width,\n        i = ki(e) * (r - 1),\n        o = Math.round(i),\n        a = n.height,\n        c = ki(t) * (a - 1),\n        u = Math.round(c),\n        l = n.components ? n.components : s;\n  return (u * r + o) * l;\n}\n\nfunction Na(e, t, n, s, r) {\n  const i = [];\n\n  for (let o = 0; o < t; o++) {\n    const a = n[o],\n          c = n[o + 1] - n[o];\n    if (c + a > s) break;\n    const u = a / r,\n          l = c / r;\n    i.push(e.slice(u, u + l));\n  }\n\n  return i;\n}\n\nfunction Ua(e, t, n) {\n  const s = [];\n\n  for (let r = 0; r < t; r++) {\n    const i = r * n;\n    s.push(e.slice(i, i + n));\n  }\n\n  return s;\n}\n\nfunction Ha(e, t, n, s) {\n  if (n) throw new Error(\"Not implemented - arrayOffsets for strings is specified\");\n\n  if (s) {\n    const r = [],\n          i = new TextDecoder(\"utf8\");\n    let o = 0;\n\n    for (let a = 0; a < e; a++) {\n      const c = s[a + 1] - s[a];\n\n      if (c + o <= t.length) {\n        const u = t.subarray(o, c + o),\n              l = i.decode(u);\n        r.push(l), o += c;\n      }\n    }\n\n    return r;\n  }\n\n  return [];\n}\n\nconst Ja = \"EXT_mesh_features\",\n      Lg = Ja;\n\nasync function Gg(e, t) {\n  const n = new it(e);\n  Pg(n, t);\n}\n\nfunction Pg(e, t) {\n  const n = e.gltf.json;\n  if (n.meshes) for (const s of n.meshes) for (const r of s.primitives) Ng(e, r, t);\n}\n\nfunction Ng(e, t, n) {\n  var s, r;\n  if (!(n != null && (s = n.gltf) !== null && s !== void 0 && s.loadBuffers)) return;\n  const i = (r = t.extensions) === null || r === void 0 ? void 0 : r[Ja],\n        o = i == null ? void 0 : i.featureIds;\n  if (o) for (const c of o) {\n    var a;\n    let u;\n\n    if (typeof c.attribute < \"u\") {\n      const l = `_FEATURE_ID_${c.attribute}`,\n            h = t.attributes[l];\n      u = e.getTypedArrayForAccessor(h);\n    } else typeof c.texture < \"u\" && n !== null && n !== void 0 && (a = n.gltf) !== null && a !== void 0 && a.loadImages ? u = Tr(e, c.texture, t) : u = [];\n\n    c.data = u;\n  }\n}\n\nconst Ug = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  decode: Gg,\n  name: Lg\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      br = \"EXT_structural_metadata\",\n      Hg = br;\n\nasync function Jg(e, t) {\n  const n = new it(e);\n  Vg(n, t);\n}\n\nfunction Vg(e, t) {\n  var n, s;\n  if (!((n = t.gltf) !== null && n !== void 0 && n.loadBuffers)) return;\n  const r = e.getExtension(br);\n  r && ((s = t.gltf) !== null && s !== void 0 && s.loadImages && jg(e, r), kg(e, r));\n}\n\nfunction jg(e, t) {\n  const n = t.propertyTextures,\n        s = e.gltf.json;\n  if (n && s.meshes) for (const r of s.meshes) for (const i of r.primitives) zg(e, n, i, t);\n}\n\nfunction kg(e, t) {\n  const n = t.schema;\n  if (!n) return;\n  const s = n.classes,\n        r = t.propertyTables;\n  if (s && r) for (const i in s) {\n    const o = Kg(r, i);\n    o && Xg(e, n, o);\n  }\n}\n\nfunction Kg(e, t) {\n  for (const n of e) if (n.class === t) return n;\n\n  return null;\n}\n\nfunction zg(e, t, n, s) {\n  var r;\n  if (!t) return;\n  const i = (r = n.extensions) === null || r === void 0 ? void 0 : r[br],\n        o = i == null ? void 0 : i.propertyTextures;\n  if (o) for (const a of o) {\n    const c = t[a];\n    Wg(e, c, n, s);\n  }\n}\n\nfunction Wg(e, t, n, s) {\n  if (!t.properties) return;\n  s.dataAttributeNames || (s.dataAttributeNames = []);\n  const r = t.class;\n\n  for (const o in t.properties) {\n    var i;\n    const a = `${r}_${o}`,\n          c = (i = t.properties) === null || i === void 0 ? void 0 : i[o];\n    if (!c) continue;\n    c.data || (c.data = []);\n    const u = c.data,\n          l = Tr(e, c, n);\n    l !== null && (Pa(e, a, l, u, n), c.data = u, s.dataAttributeNames.push(a));\n  }\n}\n\nfunction Xg(e, t, n) {\n  var s;\n  const r = (s = t.classes) === null || s === void 0 ? void 0 : s[n.class];\n  if (!r) throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${n.class}`);\n  const i = n.count;\n\n  for (const a in r.properties) {\n    var o;\n    const c = r.properties[a],\n          u = (o = n.properties) === null || o === void 0 ? void 0 : o[a];\n\n    if (u) {\n      const l = Qg(e, t, c, i, u);\n      u.data = l;\n    }\n  }\n}\n\nfunction Qg(e, t, n, s, r) {\n  let i = [];\n  const o = r.values,\n        a = e.getTypedArrayForBufferView(o),\n        c = qg(e, n, r, s),\n        u = Yg(e, r, s);\n\n  switch (n.type) {\n    case \"SCALAR\":\n    case \"VEC2\":\n    case \"VEC3\":\n    case \"VEC4\":\n    case \"MAT2\":\n    case \"MAT3\":\n    case \"MAT4\":\n      {\n        i = $g(n, s, a, c);\n        break;\n      }\n\n    case \"BOOLEAN\":\n      throw new Error(`Not implemented - classProperty.type=${n.type}`);\n\n    case \"STRING\":\n      {\n        i = Ha(s, a, c, u);\n        break;\n      }\n\n    case \"ENUM\":\n      {\n        i = Zg(t, n, s, a, c);\n        break;\n      }\n\n    default:\n      throw new Error(`Unknown classProperty type ${n.type}`);\n  }\n\n  return i;\n}\n\nfunction qg(e, t, n, s) {\n  return t.array && typeof t.count > \"u\" && typeof n.arrayOffsets < \"u\" ? jn(e, n.arrayOffsets, n.arrayOffsetType || \"UINT32\", s) : null;\n}\n\nfunction Yg(e, t, n) {\n  return typeof t.stringOffsets < \"u\" ? jn(e, t.stringOffsets, t.stringOffsetType || \"UINT32\", n) : null;\n}\n\nfunction $g(e, t, n, s) {\n  const r = e.array,\n        i = e.count,\n        o = Er(e.type, e.componentType),\n        a = n.byteLength / o;\n  let c;\n  return e.componentType ? c = kn(n, e.type, e.componentType, a) : c = n, r ? s ? Na(c, t, s, n.length, o) : i ? Ua(c, t, i) : [] : c;\n}\n\nfunction Zg(e, t, n, s, r) {\n  var i;\n  const o = t.enumType;\n  if (!o) throw new Error(\"Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM\");\n  const a = (i = e.enums) === null || i === void 0 ? void 0 : i[o];\n  if (!a) throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${o}`);\n  const c = a.valueType || \"UINT16\",\n        u = Er(t.type, c),\n        l = s.byteLength / u;\n  let h = kn(s, t.type, c, l);\n\n  if (h || (h = s), t.array) {\n    if (r) return t0({\n      valuesData: h,\n      numberOfElements: n,\n      arrayOffsets: r,\n      valuesDataBytesLength: s.length,\n      elementSize: u,\n      enumEntry: a\n    });\n    const f = t.count;\n    return f ? e0(h, n, f, a) : [];\n  }\n\n  return _r(h, 0, n, a);\n}\n\nfunction t0(e) {\n  const {\n    valuesData: t,\n    numberOfElements: n,\n    arrayOffsets: s,\n    valuesDataBytesLength: r,\n    elementSize: i,\n    enumEntry: o\n  } = e,\n        a = [];\n\n  for (let c = 0; c < n; c++) {\n    const u = s[c],\n          l = s[c + 1] - s[c];\n    if (l + u > r) break;\n\n    const h = u / i,\n          f = l / i,\n          d = _r(t, h, f, o);\n\n    a.push(d);\n  }\n\n  return a;\n}\n\nfunction e0(e, t, n, s) {\n  const r = [];\n\n  for (let i = 0; i < t; i++) {\n    const o = n * i,\n          a = _r(e, o, n, s);\n\n    r.push(a);\n  }\n\n  return r;\n}\n\nfunction _r(e, t, n, s) {\n  const r = [];\n\n  for (let i = 0; i < n; i++) if (e instanceof BigInt64Array || e instanceof BigUint64Array) r.push(\"\");else {\n    const o = e[t + i],\n          a = n0(s, o);\n    a ? r.push(a.name) : r.push(\"\");\n  }\n\n  return r;\n}\n\nfunction n0(e, t) {\n  for (const n of e.values) if (n.value === t) return n;\n\n  return null;\n}\n\nconst s0 = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  decode: Jg,\n  name: Hg\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      Va = \"EXT_feature_metadata\",\n      r0 = Va;\n\nasync function i0(e, t) {\n  const n = new it(e);\n  o0(n, t);\n}\n\nfunction o0(e, t) {\n  var n, s;\n  if (!((n = t.gltf) !== null && n !== void 0 && n.loadBuffers)) return;\n  const r = e.getExtension(Va);\n  r && ((s = t.gltf) !== null && s !== void 0 && s.loadImages && a0(e, r), c0(e, r));\n}\n\nfunction a0(e, t) {\n  const n = t.schema;\n  if (!n) return;\n  const s = n.classes,\n        {\n    featureTextures: r\n  } = t;\n  if (s && r) for (const i in s) {\n    const o = s[i],\n          a = l0(r, i);\n    a && f0(e, a, o);\n  }\n}\n\nfunction c0(e, t) {\n  const n = t.schema;\n  if (!n) return;\n  const s = n.classes,\n        r = t.featureTables;\n  if (s && r) for (const i in s) {\n    const o = u0(r, i);\n    o && h0(e, n, o);\n  }\n}\n\nfunction u0(e, t) {\n  for (const n in e) {\n    const s = e[n];\n    if (s.class === t) return s;\n  }\n\n  return null;\n}\n\nfunction l0(e, t) {\n  for (const n in e) {\n    const s = e[n];\n    if (s.class === t) return s;\n  }\n\n  return null;\n}\n\nfunction h0(e, t, n) {\n  var s;\n  if (!n.class) return;\n  const r = (s = t.classes) === null || s === void 0 ? void 0 : s[n.class];\n  if (!r) throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${n.class}`);\n  const i = n.count;\n\n  for (const a in r.properties) {\n    var o;\n    const c = r.properties[a],\n          u = (o = n.properties) === null || o === void 0 ? void 0 : o[a];\n\n    if (u) {\n      const l = d0(e, t, c, i, u);\n      u.data = l;\n    }\n  }\n}\n\nfunction f0(e, t, n) {\n  const s = t.class;\n\n  for (const i in n.properties) {\n    var r;\n    const o = t == null || (r = t.properties) === null || r === void 0 ? void 0 : r[i];\n\n    if (o) {\n      const a = y0(e, o, s);\n      o.data = a;\n    }\n  }\n}\n\nfunction d0(e, t, n, s, r) {\n  let i = [];\n  const o = r.bufferView,\n        a = e.getTypedArrayForBufferView(o),\n        c = m0(e, n, r, s),\n        u = g0(e, n, r, s);\n  return n.type === \"STRING\" || n.componentType === \"STRING\" ? i = Ha(s, a, c, u) : A0(n) && (i = p0(n, s, a, c)), i;\n}\n\nfunction m0(e, t, n, s) {\n  return t.type === \"ARRAY\" && typeof t.componentCount > \"u\" && typeof n.arrayOffsetBufferView < \"u\" ? jn(e, n.arrayOffsetBufferView, n.offsetType || \"UINT32\", s) : null;\n}\n\nfunction g0(e, t, n, s) {\n  return typeof n.stringOffsetBufferView < \"u\" ? jn(e, n.stringOffsetBufferView, n.offsetType || \"UINT32\", s) : null;\n}\n\nfunction A0(e) {\n  const t = [\"UINT8\", \"INT16\", \"UINT16\", \"INT32\", \"UINT32\", \"INT64\", \"UINT64\", \"FLOAT32\", \"FLOAT64\"];\n  return t.includes(e.type) || typeof e.componentType < \"u\" && t.includes(e.componentType);\n}\n\nfunction p0(e, t, n, s) {\n  const r = e.type === \"ARRAY\",\n        i = e.componentCount,\n        o = \"SCALAR\",\n        a = e.componentType || e.type,\n        c = Er(o, a),\n        u = n.byteLength / c,\n        l = kn(n, o, a, u);\n  return r ? s ? Na(l, t, s, n.length, c) : i ? Ua(l, t, i) : [] : l;\n}\n\nfunction y0(e, t, n) {\n  const s = e.gltf.json;\n  if (!s.meshes) return [];\n  const r = [];\n\n  for (const i of s.meshes) for (const o of i.primitives) B0(e, n, t, r, o);\n\n  return r;\n}\n\nfunction B0(e, t, n, s, r) {\n  const i = {\n    channels: n.channels,\n    ...n.texture\n  },\n        o = Tr(e, i, r);\n  o && Pa(e, t, o, s, r);\n}\n\nconst C0 = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  decode: i0,\n  name: r0\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      E0 = \"4.1.1\",\n      T0 = \"4.1.1\",\n      In = {\n  TRANSCODER: \"basis_transcoder.js\",\n  TRANSCODER_WASM: \"basis_transcoder.wasm\",\n  ENCODER: \"basis_encoder.js\",\n  ENCODER_WASM: \"basis_encoder.wasm\"\n};\nlet Ts;\n\nasync function Ki(e) {\n  const t = e.modules || {};\n  return t.basis ? t.basis : (Ts = Ts || b0(e), await Ts);\n}\n\nasync function b0(e) {\n  let t = null,\n      n = null;\n  return [t, n] = await Promise.all([await Xt(In.TRANSCODER, \"textures\", e), await Xt(In.TRANSCODER_WASM, \"textures\", e)]), t = t || globalThis.BASIS, await _0(t, n);\n}\n\nfunction _0(e, t) {\n  const n = {};\n  return t && (n.wasmBinary = t), new Promise(s => {\n    e(n).then(r => {\n      const {\n        BasisFile: i,\n        initializeBasis: o\n      } = r;\n      o(), s({\n        BasisFile: i\n      });\n    });\n  });\n}\n\nlet bs;\n\nasync function zi(e) {\n  const t = e.modules || {};\n  return t.basisEncoder ? t.basisEncoder : (bs = bs || w0(e), await bs);\n}\n\nasync function w0(e) {\n  let t = null,\n      n = null;\n  return [t, n] = await Promise.all([await Xt(In.ENCODER, \"textures\", e), await Xt(In.ENCODER_WASM, \"textures\", e)]), t = t || globalThis.BASIS, await R0(t, n);\n}\n\nfunction R0(e, t) {\n  const n = {};\n  return t && (n.wasmBinary = t), new Promise(s => {\n    e(n).then(r => {\n      const {\n        BasisFile: i,\n        KTX2File: o,\n        initializeBasis: a,\n        BasisEncoder: c\n      } = r;\n      a(), s({\n        BasisFile: i,\n        KTX2File: o,\n        BasisEncoder: c\n      });\n    });\n  });\n}\n\nconst ae = {\n  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,\n  COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,\n  COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,\n  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,\n  COMPRESSED_R11_EAC: 37488,\n  COMPRESSED_SIGNED_R11_EAC: 37489,\n  COMPRESSED_RG11_EAC: 37490,\n  COMPRESSED_SIGNED_RG11_EAC: 37491,\n  COMPRESSED_RGB8_ETC2: 37492,\n  COMPRESSED_RGBA8_ETC2_EAC: 37493,\n  COMPRESSED_SRGB8_ETC2: 37494,\n  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,\n  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,\n  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,\n  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,\n  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,\n  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,\n  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,\n  COMPRESSED_RGB_ETC1_WEBGL: 36196,\n  COMPRESSED_RGB_ATC_WEBGL: 35986,\n  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,\n  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,\n  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,\n  COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,\n  COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,\n  COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,\n  COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,\n  COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,\n  COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,\n  COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,\n  COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,\n  COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,\n  COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,\n  COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,\n  COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,\n  COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,\n  COMPRESSED_RED_RGTC1_EXT: 36283,\n  COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,\n  COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,\n  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,\n  COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919\n},\n      M0 = [\"\", \"WEBKIT_\", \"MOZ_\"],\n      Wi = {\n  WEBGL_compressed_texture_s3tc: \"dxt\",\n  WEBGL_compressed_texture_s3tc_srgb: \"dxt-srgb\",\n  WEBGL_compressed_texture_etc1: \"etc1\",\n  WEBGL_compressed_texture_etc: \"etc2\",\n  WEBGL_compressed_texture_pvrtc: \"pvrtc\",\n  WEBGL_compressed_texture_atc: \"atc\",\n  WEBGL_compressed_texture_astc: \"astc\",\n  EXT_texture_compression_rgtc: \"rgtc\"\n};\nlet ln = null;\n\nfunction I0(e) {\n  if (!ln) {\n    e = e || S0() || void 0, ln = /* @__PURE__ */new Set();\n\n    for (const t of M0) for (const n in Wi) if (e && e.getExtension(`${t}${n}`)) {\n      const s = Wi[n];\n      ln.add(s);\n    }\n  }\n\n  return ln;\n}\n\nfunction S0() {\n  try {\n    return document.createElement(\"canvas\").getContext(\"webgl\");\n  } catch {\n    return null;\n  }\n}\n\nvar Xi, Qi, qi, Yi, $i, Zi, to, eo;\n(function (e) {\n  e[e.NONE = 0] = \"NONE\", e[e.BASISLZ = 1] = \"BASISLZ\", e[e.ZSTD = 2] = \"ZSTD\", e[e.ZLIB = 3] = \"ZLIB\";\n})(Xi || (Xi = {})), function (e) {\n  e[e.BASICFORMAT = 0] = \"BASICFORMAT\";\n}(Qi || (Qi = {})), function (e) {\n  e[e.UNSPECIFIED = 0] = \"UNSPECIFIED\", e[e.ETC1S = 163] = \"ETC1S\", e[e.UASTC = 166] = \"UASTC\";\n}(qi || (qi = {})), function (e) {\n  e[e.UNSPECIFIED = 0] = \"UNSPECIFIED\", e[e.SRGB = 1] = \"SRGB\";\n}(Yi || (Yi = {})), function (e) {\n  e[e.UNSPECIFIED = 0] = \"UNSPECIFIED\", e[e.LINEAR = 1] = \"LINEAR\", e[e.SRGB = 2] = \"SRGB\", e[e.ITU = 3] = \"ITU\", e[e.NTSC = 4] = \"NTSC\", e[e.SLOG = 5] = \"SLOG\", e[e.SLOG2 = 6] = \"SLOG2\";\n}($i || ($i = {})), function (e) {\n  e[e.ALPHA_STRAIGHT = 0] = \"ALPHA_STRAIGHT\", e[e.ALPHA_PREMULTIPLIED = 1] = \"ALPHA_PREMULTIPLIED\";\n}(Zi || (Zi = {})), function (e) {\n  e[e.RGB = 0] = \"RGB\", e[e.RRR = 3] = \"RRR\", e[e.GGG = 4] = \"GGG\", e[e.AAA = 15] = \"AAA\";\n}(to || (to = {})), function (e) {\n  e[e.RGB = 0] = \"RGB\", e[e.RGBA = 3] = \"RGBA\", e[e.RRR = 4] = \"RRR\", e[e.RRRG = 5] = \"RRRG\";\n}(eo || (eo = {}));\nconst dt = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];\n\nfunction x0(e) {\n  const t = new Uint8Array(e);\n  return !(t.byteLength < dt.length || t[0] !== dt[0] || t[1] !== dt[1] || t[2] !== dt[2] || t[3] !== dt[3] || t[4] !== dt[4] || t[5] !== dt[5] || t[6] !== dt[6] || t[7] !== dt[7] || t[8] !== dt[8] || t[9] !== dt[9] || t[10] !== dt[10] || t[11] !== dt[11]);\n}\n\nconst O0 = {\n  etc1: {\n    basisFormat: 0,\n    compressed: !0,\n    format: ae.COMPRESSED_RGB_ETC1_WEBGL\n  },\n  etc2: {\n    basisFormat: 1,\n    compressed: !0\n  },\n  bc1: {\n    basisFormat: 2,\n    compressed: !0,\n    format: ae.COMPRESSED_RGB_S3TC_DXT1_EXT\n  },\n  bc3: {\n    basisFormat: 3,\n    compressed: !0,\n    format: ae.COMPRESSED_RGBA_S3TC_DXT5_EXT\n  },\n  bc4: {\n    basisFormat: 4,\n    compressed: !0\n  },\n  bc5: {\n    basisFormat: 5,\n    compressed: !0\n  },\n  \"bc7-m6-opaque-only\": {\n    basisFormat: 6,\n    compressed: !0\n  },\n  \"bc7-m5\": {\n    basisFormat: 7,\n    compressed: !0\n  },\n  \"pvrtc1-4-rgb\": {\n    basisFormat: 8,\n    compressed: !0,\n    format: ae.COMPRESSED_RGB_PVRTC_4BPPV1_IMG\n  },\n  \"pvrtc1-4-rgba\": {\n    basisFormat: 9,\n    compressed: !0,\n    format: ae.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\n  },\n  \"astc-4x4\": {\n    basisFormat: 10,\n    compressed: !0,\n    format: ae.COMPRESSED_RGBA_ASTC_4X4_KHR\n  },\n  \"atc-rgb\": {\n    basisFormat: 11,\n    compressed: !0\n  },\n  \"atc-rgba-interpolated-alpha\": {\n    basisFormat: 12,\n    compressed: !0\n  },\n  rgba32: {\n    basisFormat: 13,\n    compressed: !1\n  },\n  rgb565: {\n    basisFormat: 14,\n    compressed: !1\n  },\n  bgr565: {\n    basisFormat: 15,\n    compressed: !1\n  },\n  rgba4444: {\n    basisFormat: 16,\n    compressed: !1\n  }\n};\n\nasync function F0(e, t) {\n  if (t.basis.containerFormat === \"auto\") {\n    if (x0(e)) {\n      const s = await zi(t);\n      return no(s.KTX2File, e, t);\n    }\n\n    const {\n      BasisFile: n\n    } = await Ki(t);\n    return _s(n, e, t);\n  }\n\n  switch (t.basis.module) {\n    case \"encoder\":\n      const n = await zi(t);\n\n      switch (t.basis.containerFormat) {\n        case \"ktx2\":\n          return no(n.KTX2File, e, t);\n\n        case \"basis\":\n        default:\n          return _s(n.BasisFile, e, t);\n      }\n\n    case \"transcoder\":\n    default:\n      const {\n        BasisFile: s\n      } = await Ki(t);\n      return _s(s, e, t);\n  }\n}\n\nfunction _s(e, t, n) {\n  const s = new e(new Uint8Array(t));\n\n  try {\n    if (!s.startTranscoding()) throw new Error(\"Failed to start basis transcoding\");\n    const r = s.getNumImages(),\n          i = [];\n\n    for (let o = 0; o < r; o++) {\n      const a = s.getNumLevels(o),\n            c = [];\n\n      for (let u = 0; u < a; u++) c.push(v0(s, o, u, n));\n\n      i.push(c);\n    }\n\n    return i;\n  } finally {\n    s.close(), s.delete();\n  }\n}\n\nfunction v0(e, t, n, s) {\n  const r = e.getImageWidth(t, n),\n        i = e.getImageHeight(t, n),\n        o = e.getHasAlpha(),\n        {\n    compressed: a,\n    format: c,\n    basisFormat: u\n  } = ja(s, o),\n        l = e.getImageTranscodedSizeInBytes(t, n, u),\n        h = new Uint8Array(l);\n  if (!e.transcodeImage(h, t, n, u, 0, 0)) throw new Error(\"failed to start Basis transcoding\");\n  return {\n    width: r,\n    height: i,\n    data: h,\n    compressed: a,\n    format: c,\n    hasAlpha: o\n  };\n}\n\nfunction no(e, t, n) {\n  const s = new e(new Uint8Array(t));\n\n  try {\n    if (!s.startTranscoding()) throw new Error(\"failed to start KTX2 transcoding\");\n    const r = s.getLevels(),\n          i = [];\n\n    for (let o = 0; o < r; o++) {\n      i.push(D0(s, o, n));\n      break;\n    }\n\n    return [i];\n  } finally {\n    s.close(), s.delete();\n  }\n}\n\nfunction D0(e, t, n) {\n  const {\n    alphaFlag: s,\n    height: r,\n    width: i\n  } = e.getImageLevelInfo(t, 0, 0),\n        {\n    compressed: o,\n    format: a,\n    basisFormat: c\n  } = ja(n, s),\n        u = e.getImageTranscodedSizeInBytes(t, 0, 0, c),\n        l = new Uint8Array(u);\n  if (!e.transcodeImage(l, t, 0, 0, c, 0, -1, -1)) throw new Error(\"Failed to transcode KTX2 image\");\n  return {\n    width: i,\n    height: r,\n    data: l,\n    compressed: o,\n    levelSize: u,\n    hasAlpha: s,\n    format: a\n  };\n}\n\nfunction ja(e, t) {\n  let n = e && e.basis && e.basis.format;\n  return n === \"auto\" && (n = ka()), typeof n == \"object\" && (n = t ? n.alpha : n.noAlpha), n = n.toLowerCase(), O0[n];\n}\n\nfunction ka() {\n  const e = I0();\n  return e.has(\"astc\") ? \"astc-4x4\" : e.has(\"dxt\") ? {\n    alpha: \"bc3\",\n    noAlpha: \"bc1\"\n  } : e.has(\"pvrtc\") ? {\n    alpha: \"pvrtc1-4-rgba\",\n    noAlpha: \"pvrtc1-4-rgb\"\n  } : e.has(\"etc1\") ? \"etc1\" : e.has(\"etc2\") ? \"etc2\" : \"rgb565\";\n}\n\nconst L0 = {\n  name: \"Basis\",\n  id: \"basis\",\n  module: \"textures\",\n  version: T0,\n  worker: !0,\n  extensions: [\"basis\", \"ktx2\"],\n  mimeTypes: [\"application/octet-stream\", \"image/ktx2\"],\n  tests: [\"sB\"],\n  binary: !0,\n  options: {\n    basis: {\n      format: \"auto\",\n      libraryPath: \"libs/\",\n      containerFormat: \"auto\",\n      module: \"transcoder\"\n    }\n  }\n},\n      G0 = { ...L0,\n  parse: F0\n},\n      de = !0,\n      so = 1735152710,\n      wr = 12,\n      Sn = 8,\n      P0 = 1313821514,\n      N0 = 5130562,\n      U0 = 0,\n      H0 = 0,\n      J0 = 1;\n\nfunction V0(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n  return `${String.fromCharCode(e.getUint8(t + 0))}${String.fromCharCode(e.getUint8(t + 1))}${String.fromCharCode(e.getUint8(t + 2))}${String.fromCharCode(e.getUint8(t + 3))}`;\n}\n\nfunction j0(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,\n      n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n  const s = new DataView(e),\n        {\n    magic: r = so\n  } = n,\n        i = s.getUint32(t, !1);\n  return i === r || i === so;\n}\n\nfunction k0(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  const s = new DataView(t),\n        r = V0(s, n + 0),\n        i = s.getUint32(n + 4, de),\n        o = s.getUint32(n + 8, de);\n\n  switch (Object.assign(e, {\n    header: {\n      byteOffset: n,\n      byteLength: o,\n      hasBinChunk: !1\n    },\n    type: r,\n    version: i,\n    json: {},\n    binChunks: []\n  }), n += wr, e.version) {\n    case 1:\n      return K0(e, s, n);\n\n    case 2:\n      return z0(e, s, n, {});\n\n    default:\n      throw new Error(`Invalid GLB version ${e.version}. Only supports version 1 and 2.`);\n  }\n}\n\nfunction K0(e, t, n) {\n  U(e.header.byteLength > wr + Sn);\n  const s = t.getUint32(n + 0, de),\n        r = t.getUint32(n + 4, de);\n  return n += Sn, U(r === U0), zs(e, t, n, s), n += s, n += Ws(e, t, n, e.header.byteLength), n;\n}\n\nfunction z0(e, t, n, s) {\n  return U(e.header.byteLength > wr + Sn), W0(e, t, n, s), n + e.header.byteLength;\n}\n\nfunction W0(e, t, n, s) {\n  for (; n + 8 <= e.header.byteLength;) {\n    const r = t.getUint32(n + 0, de),\n          i = t.getUint32(n + 4, de);\n\n    switch (n += Sn, i) {\n      case P0:\n        zs(e, t, n, r);\n        break;\n\n      case N0:\n        Ws(e, t, n, r);\n        break;\n\n      case H0:\n        s.strict || zs(e, t, n, r);\n        break;\n\n      case J0:\n        s.strict || Ws(e, t, n, r);\n        break;\n    }\n\n    n += Je(r, 4);\n  }\n\n  return n;\n}\n\nfunction zs(e, t, n, s) {\n  const r = new Uint8Array(t.buffer, n, s),\n        o = new TextDecoder(\"utf8\").decode(r);\n  return e.json = JSON.parse(o), Je(s, 4);\n}\n\nfunction Ws(e, t, n, s) {\n  return e.header.hasBinChunk = !0, e.binChunks.push({\n    byteOffset: n,\n    byteLength: s,\n    arrayBuffer: t.buffer\n  }), Je(s, 4);\n}\n\nfunction Ka(e, t) {\n  if (e.startsWith(\"data:\") || e.startsWith(\"http:\") || e.startsWith(\"https:\")) return e;\n  const s = t.baseUri || t.uri;\n  if (!s) throw new Error(`'baseUri' must be provided to resolve relative url ${e}`);\n  return s.substr(0, s.lastIndexOf(\"/\") + 1) + e;\n}\n\nconst X0 = \"B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB\",\n      Q0 = \"B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB\",\n      q0 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]),\n      Y0 = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]),\n      $0 = {\n  0: \"\",\n  1: \"meshopt_decodeFilterOct\",\n  2: \"meshopt_decodeFilterQuat\",\n  3: \"meshopt_decodeFilterExp\",\n  NONE: \"\",\n  OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n  QUATERNION: \"meshopt_decodeFilterQuat\",\n  EXPONENTIAL: \"meshopt_decodeFilterExp\"\n},\n      Z0 = {\n  0: \"meshopt_decodeVertexBuffer\",\n  1: \"meshopt_decodeIndexBuffer\",\n  2: \"meshopt_decodeIndexSequence\",\n  ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n  TRIANGLES: \"meshopt_decodeIndexBuffer\",\n  INDICES: \"meshopt_decodeIndexSequence\"\n};\n\nasync function tA(e, t, n, s, r) {\n  let i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"NONE\";\n  const o = await eA();\n  rA(o, o.exports[Z0[r]], e, t, n, s, o.exports[$0[i || \"NONE\"]]);\n}\n\nlet ws;\n\nasync function eA() {\n  return ws || (ws = nA()), ws;\n}\n\nasync function nA() {\n  let e = X0;\n  WebAssembly.validate(q0) && (e = Q0, console.log(\"Warning: meshopt_decoder is using experimental SIMD support\"));\n  const t = await WebAssembly.instantiate(sA(e), {});\n  return await t.instance.exports.__wasm_call_ctors(), t.instance;\n}\n\nfunction sA(e) {\n  const t = new Uint8Array(e.length);\n\n  for (let s = 0; s < e.length; ++s) {\n    const r = e.charCodeAt(s);\n    t[s] = r > 96 ? r - 71 : r > 64 ? r - 65 : r > 47 ? r + 4 : r > 46 ? 63 : 62;\n  }\n\n  let n = 0;\n\n  for (let s = 0; s < e.length; ++s) t[n++] = t[s] < 60 ? Y0[t[s]] : (t[s] - 60) * 64 + t[++s];\n\n  return t.buffer.slice(0, n);\n}\n\nfunction rA(e, t, n, s, r, i, o) {\n  const a = e.exports.sbrk,\n        c = s + 3 & -4,\n        u = a(c * r),\n        l = a(i.length),\n        h = new Uint8Array(e.exports.memory.buffer);\n  h.set(i, l);\n  const f = t(u, s, r, l, i.length);\n  if (f === 0 && o && o(u, c, r), n.set(h.subarray(u, u + s * r)), a(u - a(0)), f !== 0) throw new Error(`Malformed buffer data: ${f}`);\n}\n\nconst xn = \"EXT_meshopt_compression\",\n      iA = xn;\n\nasync function oA(e, t) {\n  var n, s;\n  const r = new it(e);\n  if (!(t != null && (n = t.gltf) !== null && n !== void 0 && n.decompressMeshes) || !((s = t.gltf) !== null && s !== void 0 && s.loadBuffers)) return;\n  const i = [];\n\n  for (const o of e.json.bufferViews || []) i.push(aA(r, o));\n\n  await Promise.all(i), r.removeExtension(xn);\n}\n\nasync function aA(e, t) {\n  const n = e.getObjectExtension(t, xn);\n\n  if (n) {\n    const {\n      byteOffset: s = 0,\n      byteLength: r = 0,\n      byteStride: i,\n      count: o,\n      mode: a,\n      filter: c = \"NONE\",\n      buffer: u\n    } = n,\n          l = e.gltf.buffers[u],\n          h = new Uint8Array(l.arrayBuffer, l.byteOffset + s, r),\n          f = new Uint8Array(e.gltf.buffers[t.buffer].arrayBuffer, t.byteOffset, t.byteLength);\n    await tA(f, o, i, h, a, c), e.removeObjectExtension(t, xn);\n  }\n}\n\nconst cA = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  decode: oA,\n  name: iA\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      ce = \"EXT_texture_webp\",\n      uA = ce;\n\nfunction lA(e, t) {\n  const n = new it(e);\n\n  if (!Bg(\"image/webp\")) {\n    if (n.getRequiredExtensions().includes(ce)) throw new Error(`gltf: Required extension ${ce} not supported by browser`);\n    return;\n  }\n\n  const {\n    json: s\n  } = n;\n\n  for (const r of s.textures || []) {\n    const i = n.getObjectExtension(r, ce);\n    i && (r.source = i.source), n.removeObjectExtension(r, ce);\n  }\n\n  n.removeExtension(ce);\n}\n\nconst hA = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  name: uA,\n  preprocess: lA\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      Cn = \"KHR_texture_basisu\",\n      fA = Cn;\n\nfunction dA(e, t) {\n  const n = new it(e),\n        {\n    json: s\n  } = n;\n\n  for (const r of s.textures || []) {\n    const i = n.getObjectExtension(r, Cn);\n    i && (r.source = i.source, n.removeObjectExtension(r, Cn));\n  }\n\n  n.removeExtension(Cn);\n}\n\nconst mA = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  name: fA,\n  preprocess: dA\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\n\nfunction gA(e) {\n  const t = {};\n\n  for (const n in e) {\n    const s = e[n];\n\n    if (n !== \"indices\") {\n      const r = za(s);\n      t[n] = r;\n    }\n  }\n\n  return t;\n}\n\nfunction za(e) {\n  const {\n    buffer: t,\n    size: n,\n    count: s\n  } = AA(e);\n  return {\n    value: t,\n    size: n,\n    byteOffset: 0,\n    count: s,\n    type: va(n),\n    componentType: Br(t)\n  };\n}\n\nfunction AA(e) {\n  let t = e,\n      n = 1,\n      s = 0;\n  return e && e.value && (t = e.value, n = e.size || 1), t && (ArrayBuffer.isView(t) || (t = pA(t, Float32Array)), s = t.length / n), {\n    buffer: t,\n    size: n,\n    count: s\n  };\n}\n\nfunction pA(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n  return e ? Array.isArray(e) ? new t(e) : n && !(e instanceof t) ? new t(e) : e : null;\n}\n\nconst Vt = \"KHR_draco_mesh_compression\",\n      yA = Vt;\n\nfunction BA(e, t, n) {\n  const s = new it(e);\n\n  for (const r of Wa(s)) s.getObjectExtension(r, Vt);\n}\n\nasync function CA(e, t, n) {\n  var s;\n  if (!(t != null && (s = t.gltf) !== null && s !== void 0 && s.decompressMeshes)) return;\n  const r = new it(e),\n        i = [];\n\n  for (const o of Wa(r)) r.getObjectExtension(o, Vt) && i.push(TA(r, o, t, n));\n\n  await Promise.all(i), r.removeExtension(Vt);\n}\n\nfunction EA(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  const n = new it(e);\n\n  for (const s of n.json.meshes || []) bA(s, t), n.addRequiredExtension(Vt);\n}\n\nasync function TA(e, t, n, s) {\n  const r = e.getObjectExtension(t, Vt);\n  if (!r) return;\n  const i = e.getTypedArrayForBufferView(r.bufferView),\n        o = sr(i.buffer, i.byteOffset),\n        a = { ...n\n  };\n  delete a[\"3d-tiles\"];\n  const c = await He(o, _a, a, s),\n        u = gA(c.attributes);\n\n  for (const [l, h] of Object.entries(u)) if (l in t.attributes) {\n    const f = t.attributes[l],\n          d = e.getAccessor(f);\n    d != null && d.min && d !== null && d !== void 0 && d.max && (h.min = d.min, h.max = d.max);\n  }\n\n  t.attributes = u, c.indices && (t.indices = za(c.indices)), e.removeObjectExtension(t, Vt), _A(t);\n}\n\nfunction bA(e, t) {\n  var n;\n  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 4,\n      r = arguments.length > 3 ? arguments[3] : void 0,\n      i = arguments.length > 4 ? arguments[4] : void 0;\n  if (!r.DracoWriter) throw new Error(\"options.gltf.DracoWriter not provided\");\n\n  const o = r.DracoWriter.encodeSync({\n    attributes: e\n  }),\n        a = i == null || (n = i.parseSync) === null || n === void 0 ? void 0 : n.call(i, {\n    attributes: e\n  }),\n        c = r._addFauxAttributes(a.attributes),\n        u = r.addBufferView(o);\n\n  return {\n    primitives: [{\n      attributes: c,\n      mode: s,\n      extensions: {\n        [Vt]: {\n          bufferView: u,\n          attributes: c\n        }\n      }\n    }]\n  };\n}\n\nfunction _A(e) {\n  if (!e.attributes && Object.keys(e.attributes).length > 0) throw new Error(\"glTF: Empty primitive detected: Draco decompression failure?\");\n}\n\nfunction* Wa(e) {\n  for (const t of e.json.meshes || []) for (const n of t.primitives) yield n;\n}\n\nconst wA = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  decode: CA,\n  encode: EA,\n  name: yA,\n  preprocess: BA\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      Rr = \"KHR_texture_transform\",\n      RA = Rr,\n      hn = new A(),\n      MA = new Q(),\n      IA = new Q();\n\nasync function SA(e, t) {\n  var n;\n  if (!new it(e).hasExtension(Rr) || !((n = t.gltf) !== null && n !== void 0 && n.loadBuffers)) return;\n  const i = e.json.materials || [];\n\n  for (let o = 0; o < i.length; o++) xA(o, e);\n}\n\nfunction xA(e, t) {\n  var n, s, r;\n  const i = [],\n        o = (n = t.json.materials) === null || n === void 0 ? void 0 : n[e],\n        a = o == null || (s = o.pbrMetallicRoughness) === null || s === void 0 ? void 0 : s.baseColorTexture;\n  a && be(t, e, a, i);\n  const c = o == null ? void 0 : o.emissiveTexture;\n  c && be(t, e, c, i);\n  const u = o == null ? void 0 : o.normalTexture;\n  u && be(t, e, u, i);\n  const l = o == null ? void 0 : o.occlusionTexture;\n  l && be(t, e, l, i);\n  const h = o == null || (r = o.pbrMetallicRoughness) === null || r === void 0 ? void 0 : r.metallicRoughnessTexture;\n  h && be(t, e, h, i);\n}\n\nfunction be(e, t, n, s) {\n  const r = OA(n, s);\n  if (!r) return;\n  const i = e.json.meshes || [];\n\n  for (const o of i) for (const a of o.primitives) {\n    const c = a.material;\n    Number.isFinite(c) && t === c && FA(e, a, r);\n  }\n}\n\nfunction OA(e, t) {\n  var n;\n  const s = (n = e.extensions) === null || n === void 0 ? void 0 : n[Rr],\n        {\n    texCoord: r = 0\n  } = e,\n        {\n    texCoord: i = r\n  } = s;\n\n  if (!(t.findIndex(a => {\n    let [c, u] = a;\n    return c === r && u === i;\n  }) !== -1)) {\n    const a = LA(s);\n    return r !== i && (e.texCoord = i), t.push([r, i]), {\n      originalTexCoord: r,\n      texCoord: i,\n      matrix: a\n    };\n  }\n\n  return null;\n}\n\nfunction FA(e, t, n) {\n  const {\n    originalTexCoord: s,\n    texCoord: r,\n    matrix: i\n  } = n,\n        o = t.attributes[`TEXCOORD_${s}`];\n\n  if (Number.isFinite(o)) {\n    var a;\n    const u = (a = e.json.accessors) === null || a === void 0 ? void 0 : a[o];\n\n    if (u && u.bufferView) {\n      var c;\n      const l = (c = e.json.bufferViews) === null || c === void 0 ? void 0 : c[u.bufferView];\n\n      if (l) {\n        const {\n          arrayBuffer: h,\n          byteOffset: f\n        } = e.buffers[l.buffer],\n              d = (f || 0) + (u.byteOffset || 0) + (l.byteOffset || 0),\n              {\n          ArrayType: m,\n          length: g\n        } = Cr(u, l),\n              p = Fa[u.componentType],\n              C = Oa[u.type],\n              w = l.byteStride || p * C,\n              y = new Float32Array(g);\n\n        for (let B = 0; B < u.count; B++) {\n          const R = new m(h, d + B * w, 2);\n          hn.set(R[0], R[1], 1), hn.transformByMatrix3(i), y.set([hn[0], hn[1]], B * C);\n        }\n\n        s === r ? vA(u, l, e.buffers, y) : DA(r, u, t, e, y);\n      }\n    }\n  }\n}\n\nfunction vA(e, t, n, s) {\n  e.componentType = 5126, n.push({\n    arrayBuffer: s.buffer,\n    byteOffset: 0,\n    byteLength: s.buffer.byteLength\n  }), t.buffer = n.length - 1, t.byteLength = s.buffer.byteLength, t.byteOffset = 0, delete t.byteStride;\n}\n\nfunction DA(e, t, n, s, r) {\n  s.buffers.push({\n    arrayBuffer: r.buffer,\n    byteOffset: 0,\n    byteLength: r.buffer.byteLength\n  });\n  const i = s.json.bufferViews;\n  if (!i) return;\n  i.push({\n    buffer: s.buffers.length - 1,\n    byteLength: r.buffer.byteLength,\n    byteOffset: 0\n  });\n  const o = s.json.accessors;\n  o && (o.push({\n    bufferView: (i == null ? void 0 : i.length) - 1,\n    byteOffset: 0,\n    componentType: 5126,\n    count: t.count,\n    type: \"VEC2\"\n  }), n.attributes[`TEXCOORD_${e}`] = o.length - 1);\n}\n\nfunction LA(e) {\n  const {\n    offset: t = [0, 0],\n    rotation: n = 0,\n    scale: s = [1, 1]\n  } = e,\n        r = new Q().set(1, 0, 0, 0, 1, 0, t[0], t[1], 1),\n        i = MA.set(Math.cos(n), Math.sin(n), 0, -Math.sin(n), Math.cos(n), 0, 0, 0, 1),\n        o = IA.set(s[0], 0, 0, 0, s[1], 0, 0, 0, 1);\n  return r.multiplyRight(i).multiplyRight(o);\n}\n\nconst GA = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  decode: SA,\n  name: RA\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      Wt = \"KHR_lights_punctual\",\n      PA = Wt;\n\nasync function NA(e) {\n  const t = new it(e),\n        {\n    json: n\n  } = t,\n        s = t.getExtension(Wt);\n  s && (t.json.lights = s.lights, t.removeExtension(Wt));\n\n  for (const r of n.nodes || []) {\n    const i = t.getObjectExtension(r, Wt);\n    i && (r.light = i.light), t.removeObjectExtension(r, Wt);\n  }\n}\n\nasync function UA(e) {\n  const t = new it(e),\n        {\n    json: n\n  } = t;\n\n  if (n.lights) {\n    const s = t.addExtension(Wt);\n    gt(!s.lights), s.lights = n.lights, delete n.lights;\n  }\n\n  if (t.json.lights) {\n    for (const s of t.json.lights) {\n      const r = s.node;\n      t.addObjectExtension(r, Wt, s);\n    }\n\n    delete t.json.lights;\n  }\n}\n\nconst HA = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  decode: NA,\n  encode: UA,\n  name: PA\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      De = \"KHR_materials_unlit\",\n      JA = De;\n\nasync function VA(e) {\n  const t = new it(e),\n        {\n    json: n\n  } = t;\n\n  for (const s of n.materials || []) s.extensions && s.extensions.KHR_materials_unlit && (s.unlit = !0), t.removeObjectExtension(s, De);\n\n  t.removeExtension(De);\n}\n\nfunction jA(e) {\n  const t = new it(e),\n        {\n    json: n\n  } = t;\n  if (t.materials) for (const s of n.materials || []) s.unlit && (delete s.unlit, t.addObjectExtension(s, De, {}), t.addExtension(De));\n}\n\nconst kA = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  decode: VA,\n  encode: jA,\n  name: JA\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      Re = \"KHR_techniques_webgl\",\n      KA = Re;\n\nasync function zA(e) {\n  const t = new it(e),\n        {\n    json: n\n  } = t,\n        s = t.getExtension(Re);\n\n  if (s) {\n    const r = XA(s, t);\n\n    for (const i of n.materials || []) {\n      const o = t.getObjectExtension(i, Re);\n      o && (i.technique = Object.assign({}, o, r[o.technique]), i.technique.values = QA(i.technique, t)), t.removeObjectExtension(i, Re);\n    }\n\n    t.removeExtension(Re);\n  }\n}\n\nasync function WA(e, t) {}\n\nfunction XA(e, t) {\n  const {\n    programs: n = [],\n    shaders: s = [],\n    techniques: r = []\n  } = e,\n        i = new TextDecoder();\n  return s.forEach(o => {\n    if (Number.isFinite(o.bufferView)) o.code = i.decode(t.getTypedArrayForBufferView(o.bufferView));else throw new Error(\"KHR_techniques_webgl: no shader code\");\n  }), n.forEach(o => {\n    o.fragmentShader = s[o.fragmentShader], o.vertexShader = s[o.vertexShader];\n  }), r.forEach(o => {\n    o.program = n[o.program];\n  }), r;\n}\n\nfunction QA(e, t) {\n  const n = Object.assign({}, e.values);\n  return Object.keys(e.uniforms || {}).forEach(s => {\n    e.uniforms[s].value && !(s in n) && (n[s] = e.uniforms[s].value);\n  }), Object.keys(n).forEach(s => {\n    typeof n[s] == \"object\" && n[s].index !== void 0 && (n[s].texture = t.getTexture(n[s].index));\n  }), n;\n}\n\nconst qA = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  decode: zA,\n  encode: WA,\n  name: KA\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      Xa = [s0, Ug, cA, hA, mA, wA, HA, kA, qA, GA, C0];\n\nfunction YA(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},\n      n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = Xa.filter(i => Qa(i.name, t));\n\n  for (const i of s) {\n    var r;\n    (r = i.preprocess) === null || r === void 0 || r.call(i, e, t, n);\n  }\n}\n\nasync function $A(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},\n      n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = Xa.filter(i => Qa(i.name, t));\n\n  for (const i of s) {\n    var r;\n    await ((r = i.decode) === null || r === void 0 ? void 0 : r.call(i, e, t, n));\n  }\n}\n\nfunction Qa(e, t) {\n  var n;\n  const s = (t == null || (n = t.gltf) === null || n === void 0 ? void 0 : n.excludeExtensions) || {};\n  return !(e in s && !s[e]);\n}\n\nconst Rs = \"KHR_binary_glTF\";\n\nfunction ZA(e) {\n  const t = new it(e),\n        {\n    json: n\n  } = t;\n\n  for (const s of n.images || []) {\n    const r = t.getObjectExtension(s, Rs);\n    r && Object.assign(s, r), t.removeObjectExtension(s, Rs);\n  }\n\n  n.buffers && n.buffers[0] && delete n.buffers[0].uri, t.removeExtension(Rs);\n}\n\nconst ro = {\n  accessors: \"accessor\",\n  animations: \"animation\",\n  buffers: \"buffer\",\n  bufferViews: \"bufferView\",\n  images: \"image\",\n  materials: \"material\",\n  meshes: \"mesh\",\n  nodes: \"node\",\n  samplers: \"sampler\",\n  scenes: \"scene\",\n  skins: \"skin\",\n  textures: \"texture\"\n},\n      tp = {\n  accessor: \"accessors\",\n  animations: \"animation\",\n  buffer: \"buffers\",\n  bufferView: \"bufferViews\",\n  image: \"images\",\n  material: \"materials\",\n  mesh: \"meshes\",\n  node: \"nodes\",\n  sampler: \"samplers\",\n  scene: \"scenes\",\n  skin: \"skins\",\n  texture: \"textures\"\n};\n\nclass ep {\n  constructor() {\n    this.idToIndexMap = {\n      animations: {},\n      accessors: {},\n      buffers: {},\n      bufferViews: {},\n      images: {},\n      materials: {},\n      meshes: {},\n      nodes: {},\n      samplers: {},\n      scenes: {},\n      skins: {},\n      textures: {}\n    }, this.json = void 0;\n  }\n\n  normalize(t, n) {\n    this.json = t.json;\n    const s = t.json;\n\n    switch (s.asset && s.asset.version) {\n      case \"2.0\":\n        return;\n\n      case void 0:\n      case \"1.0\":\n        break;\n\n      default:\n        console.warn(`glTF: Unknown version ${s.asset.version}`);\n        return;\n    }\n\n    if (!n.normalize) throw new Error(\"glTF v1 is not supported.\");\n    console.warn(\"Converting glTF v1 to glTF v2 format. This is experimental and may fail.\"), this._addAsset(s), this._convertTopLevelObjectsToArrays(s), ZA(t), this._convertObjectIdsToArrayIndices(s), this._updateObjects(s), this._updateMaterial(s);\n  }\n\n  _addAsset(t) {\n    t.asset = t.asset || {}, t.asset.version = \"2.0\", t.asset.generator = t.asset.generator || \"Normalized to glTF 2.0 by loaders.gl\";\n  }\n\n  _convertTopLevelObjectsToArrays(t) {\n    for (const n in ro) this._convertTopLevelObjectToArray(t, n);\n  }\n\n  _convertTopLevelObjectToArray(t, n) {\n    const s = t[n];\n\n    if (!(!s || Array.isArray(s))) {\n      t[n] = [];\n\n      for (const r in s) {\n        const i = s[r];\n        i.id = i.id || r;\n        const o = t[n].length;\n        t[n].push(i), this.idToIndexMap[n][r] = o;\n      }\n    }\n  }\n\n  _convertObjectIdsToArrayIndices(t) {\n    for (const n in ro) this._convertIdsToIndices(t, n);\n\n    \"scene\" in t && (t.scene = this._convertIdToIndex(t.scene, \"scene\"));\n\n    for (const n of t.textures) this._convertTextureIds(n);\n\n    for (const n of t.meshes) this._convertMeshIds(n);\n\n    for (const n of t.nodes) this._convertNodeIds(n);\n\n    for (const n of t.scenes) this._convertSceneIds(n);\n  }\n\n  _convertTextureIds(t) {\n    t.source && (t.source = this._convertIdToIndex(t.source, \"image\"));\n  }\n\n  _convertMeshIds(t) {\n    for (const n of t.primitives) {\n      const {\n        attributes: s,\n        indices: r,\n        material: i\n      } = n;\n\n      for (const o in s) s[o] = this._convertIdToIndex(s[o], \"accessor\");\n\n      r && (n.indices = this._convertIdToIndex(r, \"accessor\")), i && (n.material = this._convertIdToIndex(i, \"material\"));\n    }\n  }\n\n  _convertNodeIds(t) {\n    t.children && (t.children = t.children.map(n => this._convertIdToIndex(n, \"node\"))), t.meshes && (t.meshes = t.meshes.map(n => this._convertIdToIndex(n, \"mesh\")));\n  }\n\n  _convertSceneIds(t) {\n    t.nodes && (t.nodes = t.nodes.map(n => this._convertIdToIndex(n, \"node\")));\n  }\n\n  _convertIdsToIndices(t, n) {\n    t[n] || (console.warn(`gltf v1: json doesn't contain attribute ${n}`), t[n] = []);\n\n    for (const s of t[n]) for (const r in s) {\n      const i = s[r],\n            o = this._convertIdToIndex(i, r);\n\n      s[r] = o;\n    }\n  }\n\n  _convertIdToIndex(t, n) {\n    const s = tp[n];\n\n    if (s in this.idToIndexMap) {\n      const r = this.idToIndexMap[s][t];\n      if (!Number.isFinite(r)) throw new Error(`gltf v1: failed to resolve ${n} with id ${t}`);\n      return r;\n    }\n\n    return t;\n  }\n\n  _updateObjects(t) {\n    for (const n of this.json.buffers) delete n.type;\n  }\n\n  _updateMaterial(t) {\n    for (const i of t.materials) {\n      var n, s, r;\n      i.pbrMetallicRoughness = {\n        baseColorFactor: [1, 1, 1, 1],\n        metallicFactor: 1,\n        roughnessFactor: 1\n      };\n      const o = ((n = i.values) === null || n === void 0 ? void 0 : n.tex) || ((s = i.values) === null || s === void 0 ? void 0 : s.texture2d_0) || ((r = i.values) === null || r === void 0 ? void 0 : r.diffuseTex),\n            a = t.textures.findIndex(c => c.id === o);\n      a !== -1 && (i.pbrMetallicRoughness.baseColorTexture = {\n        index: a\n      });\n    }\n  }\n\n}\n\nfunction np(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  return new ep().normalize(e, t);\n}\n\nasync function sp(e, t) {\n  var n, s, r;\n  let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,\n      o = arguments.length > 3 ? arguments[3] : void 0,\n      a = arguments.length > 4 ? arguments[4] : void 0;\n  return rp(e, t, i, o), np(e, {\n    normalize: o == null || (n = o.gltf) === null || n === void 0 ? void 0 : n.normalize\n  }), YA(e, o, a), o != null && (s = o.gltf) !== null && s !== void 0 && s.loadBuffers && e.json.buffers && (await ip(e, o, a)), o != null && (r = o.gltf) !== null && r !== void 0 && r.loadImages && (await op(e, o, a)), await $A(e, o, a), e;\n}\n\nfunction rp(e, t, n, s) {\n  if (s.uri && (e.baseUri = s.uri), t instanceof ArrayBuffer && !j0(t, n, s) && (t = new TextDecoder().decode(t)), typeof t == \"string\") e.json = du(t);else if (t instanceof ArrayBuffer) {\n    const o = {};\n    n = k0(o, t, n, s.glb), gt(o.type === \"glTF\", `Invalid GLB magic string ${o.type}`), e._glb = o, e.json = o.json;\n  } else gt(!1, \"GLTF: must be ArrayBuffer or string\");\n  const r = e.json.buffers || [];\n\n  if (e.buffers = new Array(r.length).fill(null), e._glb && e._glb.header.hasBinChunk) {\n    const {\n      binChunks: o\n    } = e._glb;\n    e.buffers[0] = {\n      arrayBuffer: o[0].arrayBuffer,\n      byteOffset: o[0].byteOffset,\n      byteLength: o[0].byteLength\n    };\n  }\n\n  const i = e.json.images || [];\n  e.images = new Array(i.length).fill({});\n}\n\nasync function ip(e, t, n) {\n  const s = e.json.buffers || [];\n\n  for (let o = 0; o < s.length; ++o) {\n    const a = s[o];\n\n    if (a.uri) {\n      var r, i;\n      const {\n        fetch: c\n      } = n;\n      gt(c);\n      const u = Ka(a.uri, t),\n            l = await (n == null || (r = n.fetch) === null || r === void 0 ? void 0 : r.call(n, u)),\n            h = await (l == null || (i = l.arrayBuffer) === null || i === void 0 ? void 0 : i.call(l));\n      e.buffers[o] = {\n        arrayBuffer: h,\n        byteOffset: 0,\n        byteLength: h.byteLength\n      }, delete a.uri;\n    } else e.buffers[o] === null && (e.buffers[o] = {\n      arrayBuffer: new ArrayBuffer(a.byteLength),\n      byteOffset: 0,\n      byteLength: a.byteLength\n    });\n  }\n}\n\nasync function op(e, t, n) {\n  const s = ap(e),\n        r = e.json.images || [],\n        i = [];\n\n  for (const o of s) i.push(cp(e, r[o], o, t, n));\n\n  return await Promise.all(i);\n}\n\nfunction ap(e) {\n  const t = /* @__PURE__ */new Set(),\n        n = e.json.textures || [];\n\n  for (const s of n) s.source !== void 0 && t.add(s.source);\n\n  return Array.from(t).sort();\n}\n\nasync function cp(e, t, n, s, r) {\n  let i;\n\n  if (t.uri && !t.hasOwnProperty(\"bufferView\")) {\n    const a = Ka(t.uri, s),\n          {\n      fetch: c\n    } = r;\n    i = await (await c(a)).arrayBuffer(), t.bufferView = {\n      data: i\n    };\n  }\n\n  if (Number.isFinite(t.bufferView)) {\n    const a = Sg(e.json, e.buffers, t.bufferView);\n    i = sr(a.buffer, a.byteOffset, a.byteLength);\n  }\n\n  gt(i, \"glTF image has no data\");\n  let o = await He(i, [yg, G0], { ...s,\n    mimeType: t.mimeType,\n    basis: s.basis || {\n      format: ka()\n    }\n  }, r);\n  o && o[0] && (o = {\n    compressed: !0,\n    mipmaps: !1,\n    width: o[0].width,\n    height: o[0].height,\n    data: o[0]\n  }), e.images = e.images || [], e.images[n] = o;\n}\n\nconst On = {\n  name: \"glTF\",\n  id: \"gltf\",\n  module: \"gltf\",\n  version: E0,\n  extensions: [\"gltf\", \"glb\"],\n  mimeTypes: [\"model/gltf+json\", \"model/gltf-binary\"],\n  text: !0,\n  binary: !0,\n  tests: [\"glTF\"],\n  parse: up,\n  options: {\n    gltf: {\n      normalize: !0,\n      loadBuffers: !0,\n      loadImages: !0,\n      decompressMeshes: !0\n    },\n    log: console\n  }\n};\n\nasync function up(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},\n      n = arguments.length > 2 ? arguments[2] : void 0;\n  t = { ...On.options,\n    ...t\n  }, t.gltf = { ...On.options.gltf,\n    ...t.gltf\n  };\n  const {\n    byteOffset: s = 0\n  } = t;\n  return await sp({}, e, s, t, n);\n}\n\nconst lp = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n},\n      hp = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n},\n      pt = {\n  TEXTURE_MAG_FILTER: 10240,\n  TEXTURE_MIN_FILTER: 10241,\n  TEXTURE_WRAP_S: 10242,\n  TEXTURE_WRAP_T: 10243,\n  REPEAT: 10497,\n  LINEAR: 9729,\n  NEAREST_MIPMAP_LINEAR: 9986\n},\n      fp = {\n  magFilter: pt.TEXTURE_MAG_FILTER,\n  minFilter: pt.TEXTURE_MIN_FILTER,\n  wrapS: pt.TEXTURE_WRAP_S,\n  wrapT: pt.TEXTURE_WRAP_T\n},\n      dp = {\n  [pt.TEXTURE_MAG_FILTER]: pt.LINEAR,\n  [pt.TEXTURE_MIN_FILTER]: pt.NEAREST_MIPMAP_LINEAR,\n  [pt.TEXTURE_WRAP_S]: pt.REPEAT,\n  [pt.TEXTURE_WRAP_T]: pt.REPEAT\n};\n\nfunction mp() {\n  return {\n    id: \"default-sampler\",\n    parameters: dp\n  };\n}\n\nfunction gp(e) {\n  return hp[e];\n}\n\nfunction Ap(e) {\n  return lp[e];\n}\n\nclass pp {\n  constructor() {\n    this.baseUri = \"\", this.jsonUnprocessed = void 0, this.json = void 0, this.buffers = [], this.images = [];\n  }\n\n  postProcess(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const {\n      json: s,\n      buffers: r = [],\n      images: i = []\n    } = t,\n          {\n      baseUri: o = \"\"\n    } = t;\n    return gt(s), this.baseUri = o, this.buffers = r, this.images = i, this.jsonUnprocessed = s, this.json = this._resolveTree(t.json, n), this.json;\n  }\n\n  _resolveTree(t) {\n    const n = { ...t\n    };\n    return this.json = n, t.bufferViews && (n.bufferViews = t.bufferViews.map((s, r) => this._resolveBufferView(s, r))), t.images && (n.images = t.images.map((s, r) => this._resolveImage(s, r))), t.samplers && (n.samplers = t.samplers.map((s, r) => this._resolveSampler(s, r))), t.textures && (n.textures = t.textures.map((s, r) => this._resolveTexture(s, r))), t.accessors && (n.accessors = t.accessors.map((s, r) => this._resolveAccessor(s, r))), t.materials && (n.materials = t.materials.map((s, r) => this._resolveMaterial(s, r))), t.meshes && (n.meshes = t.meshes.map((s, r) => this._resolveMesh(s, r))), t.nodes && (n.nodes = t.nodes.map((s, r) => this._resolveNode(s, r)), n.nodes = n.nodes.map((s, r) => this._resolveNodeChildren(s))), t.skins && (n.skins = t.skins.map((s, r) => this._resolveSkin(s, r))), t.scenes && (n.scenes = t.scenes.map((s, r) => this._resolveScene(s, r))), typeof this.json.scene == \"number\" && n.scenes && (n.scene = n.scenes[this.json.scene]), n;\n  }\n\n  getScene(t) {\n    return this._get(this.json.scenes, t);\n  }\n\n  getNode(t) {\n    return this._get(this.json.nodes, t);\n  }\n\n  getSkin(t) {\n    return this._get(this.json.skins, t);\n  }\n\n  getMesh(t) {\n    return this._get(this.json.meshes, t);\n  }\n\n  getMaterial(t) {\n    return this._get(this.json.materials, t);\n  }\n\n  getAccessor(t) {\n    return this._get(this.json.accessors, t);\n  }\n\n  getCamera(t) {\n    return this._get(this.json.cameras, t);\n  }\n\n  getTexture(t) {\n    return this._get(this.json.textures, t);\n  }\n\n  getSampler(t) {\n    return this._get(this.json.samplers, t);\n  }\n\n  getImage(t) {\n    return this._get(this.json.images, t);\n  }\n\n  getBufferView(t) {\n    return this._get(this.json.bufferViews, t);\n  }\n\n  getBuffer(t) {\n    return this._get(this.json.buffers, t);\n  }\n\n  _get(t, n) {\n    if (typeof n == \"object\") return n;\n    const s = t && t[n];\n    return s || console.warn(`glTF file error: Could not find ${t}[${n}]`), s;\n  }\n\n  _resolveScene(t, n) {\n    return { ...t,\n      id: t.id || `scene-${n}`,\n      nodes: (t.nodes || []).map(s => this.getNode(s))\n    };\n  }\n\n  _resolveNode(t, n) {\n    const s = { ...t,\n      id: (t == null ? void 0 : t.id) || `node-${n}`\n    };\n    return t.mesh !== void 0 && (s.mesh = this.getMesh(t.mesh)), t.camera !== void 0 && (s.camera = this.getCamera(t.camera)), t.skin !== void 0 && (s.skin = this.getSkin(t.skin)), t.meshes !== void 0 && t.meshes.length && (s.mesh = t.meshes.reduce((r, i) => {\n      const o = this.getMesh(i);\n      return r.id = o.id, r.primitives = r.primitives.concat(o.primitives), r;\n    }, {\n      primitives: []\n    })), s;\n  }\n\n  _resolveNodeChildren(t) {\n    return t.children && (t.children = t.children.map(n => this.getNode(n))), t;\n  }\n\n  _resolveSkin(t, n) {\n    const s = typeof t.inverseBindMatrices == \"number\" ? this.getAccessor(t.inverseBindMatrices) : void 0;\n    return { ...t,\n      id: t.id || `skin-${n}`,\n      inverseBindMatrices: s\n    };\n  }\n\n  _resolveMesh(t, n) {\n    const s = { ...t,\n      id: t.id || `mesh-${n}`,\n      primitives: []\n    };\n    return t.primitives && (s.primitives = t.primitives.map(r => {\n      const i = { ...r,\n        attributes: {},\n        indices: void 0,\n        material: void 0\n      },\n            o = r.attributes;\n\n      for (const a in o) i.attributes[a] = this.getAccessor(o[a]);\n\n      return r.indices !== void 0 && (i.indices = this.getAccessor(r.indices)), r.material !== void 0 && (i.material = this.getMaterial(r.material)), i;\n    })), s;\n  }\n\n  _resolveMaterial(t, n) {\n    const s = { ...t,\n      id: t.id || `material-${n}`\n    };\n\n    if (s.normalTexture && (s.normalTexture = { ...s.normalTexture\n    }, s.normalTexture.texture = this.getTexture(s.normalTexture.index)), s.occlusionTexture && (s.occlusionTexture = { ...s.occlusionTexture\n    }, s.occlusionTexture.texture = this.getTexture(s.occlusionTexture.index)), s.emissiveTexture && (s.emissiveTexture = { ...s.emissiveTexture\n    }, s.emissiveTexture.texture = this.getTexture(s.emissiveTexture.index)), s.emissiveFactor || (s.emissiveFactor = s.emissiveTexture ? [1, 1, 1] : [0, 0, 0]), s.pbrMetallicRoughness) {\n      s.pbrMetallicRoughness = { ...s.pbrMetallicRoughness\n      };\n      const r = s.pbrMetallicRoughness;\n      r.baseColorTexture && (r.baseColorTexture = { ...r.baseColorTexture\n      }, r.baseColorTexture.texture = this.getTexture(r.baseColorTexture.index)), r.metallicRoughnessTexture && (r.metallicRoughnessTexture = { ...r.metallicRoughnessTexture\n      }, r.metallicRoughnessTexture.texture = this.getTexture(r.metallicRoughnessTexture.index));\n    }\n\n    return s;\n  }\n\n  _resolveAccessor(t, n) {\n    const s = gp(t.componentType),\n          r = Ap(t.type),\n          i = s * r,\n          o = { ...t,\n      id: t.id || `accessor-${n}`,\n      bytesPerComponent: s,\n      components: r,\n      bytesPerElement: i,\n      value: void 0,\n      bufferView: void 0,\n      sparse: void 0\n    };\n\n    if (t.bufferView !== void 0 && (o.bufferView = this.getBufferView(t.bufferView)), o.bufferView) {\n      const a = o.bufferView.buffer,\n            {\n        ArrayType: c,\n        byteLength: u\n      } = Cr(o, o.bufferView),\n            l = (o.bufferView.byteOffset || 0) + (o.byteOffset || 0) + a.byteOffset;\n      let h = a.arrayBuffer.slice(l, l + u);\n      o.bufferView.byteStride && (h = this._getValueFromInterleavedBuffer(a, l, o.bufferView.byteStride, o.bytesPerElement, o.count)), o.value = new c(h);\n    }\n\n    return o;\n  }\n\n  _getValueFromInterleavedBuffer(t, n, s, r, i) {\n    const o = new Uint8Array(i * r);\n\n    for (let a = 0; a < i; a++) {\n      const c = n + a * s;\n      o.set(new Uint8Array(t.arrayBuffer.slice(c, c + r)), a * r);\n    }\n\n    return o.buffer;\n  }\n\n  _resolveTexture(t, n) {\n    return { ...t,\n      id: t.id || `texture-${n}`,\n      sampler: typeof t.sampler == \"number\" ? this.getSampler(t.sampler) : mp(),\n      source: typeof t.source == \"number\" ? this.getImage(t.source) : void 0\n    };\n  }\n\n  _resolveSampler(t, n) {\n    const s = {\n      id: t.id || `sampler-${n}`,\n      ...t,\n      parameters: {}\n    };\n\n    for (const r in s) {\n      const i = this._enumSamplerParameter(r);\n\n      i !== void 0 && (s.parameters[i] = s[r]);\n    }\n\n    return s;\n  }\n\n  _enumSamplerParameter(t) {\n    return fp[t];\n  }\n\n  _resolveImage(t, n) {\n    const s = { ...t,\n      id: t.id || `image-${n}`,\n      image: null,\n      bufferView: t.bufferView !== void 0 ? this.getBufferView(t.bufferView) : void 0\n    },\n          r = this.images[n];\n    return r && (s.image = r), s;\n  }\n\n  _resolveBufferView(t, n) {\n    const s = t.buffer,\n          r = this.buffers[s].arrayBuffer;\n    let i = this.buffers[s].byteOffset || 0;\n    return t.byteOffset && (i += t.byteOffset), {\n      id: `bufferView-${n}`,\n      ...t,\n      buffer: this.buffers[s],\n      data: new Uint8Array(r, i, t.byteLength)\n    };\n  }\n\n  _resolveCamera(t, n) {\n    const s = { ...t,\n      id: t.id || `camera-${n}`\n    };\n    return s.perspective, s.orthographic, s;\n  }\n\n}\n\nfunction qa(e, t) {\n  return new pp().postProcess(e, t);\n}\n\nconst Xs = {\n  URI: 0,\n  EMBEDDED: 1\n};\n\nfunction Ya(e, t, n, s) {\n  e.rotateYtoZ = !0;\n  const r = (e.byteOffset || 0) + (e.byteLength || 0) - n;\n  if (r === 0) throw new Error(\"glTF byte length must be greater than 0.\");\n  return e.gltfUpAxis = s != null && s[\"3d-tiles\"] && s[\"3d-tiles\"].assetGltfUpAxis ? s[\"3d-tiles\"].assetGltfUpAxis : \"Y\", e.gltfArrayBuffer = sr(t, n, r), e.gltfByteOffset = 0, e.gltfByteLength = r, n % 4 === 0 || console.warn(`${e.type}: embedded glb is not aligned to a 4-byte boundary.`), (e.byteOffset || 0) + (e.byteLength || 0);\n}\n\nasync function $a(e, t, n, s) {\n  const r = (n == null ? void 0 : n[\"3d-tiles\"]) || {};\n\n  if (yp(e, t), r.loadGLTF) {\n    if (!s) return;\n\n    if (e.gltfUrl) {\n      const {\n        fetch: i\n      } = s,\n            o = await i(e.gltfUrl, n);\n      e.gltfArrayBuffer = await o.arrayBuffer(), e.gltfByteOffset = 0;\n    }\n\n    if (e.gltfArrayBuffer) {\n      const i = await He(e.gltfArrayBuffer, On, n, s);\n      e.gltf = qa(i), e.gpuMemoryUsageInBytes = Da(e.gltf), delete e.gltfArrayBuffer, delete e.gltfByteOffset, delete e.gltfByteLength;\n    }\n  }\n}\n\nfunction yp(e, t, n) {\n  switch (t) {\n    case Xs.URI:\n      if (e.gltfArrayBuffer) {\n        const s = new Uint8Array(e.gltfArrayBuffer, e.gltfByteOffset),\n              i = new TextDecoder().decode(s);\n        e.gltfUrl = i.replace(/[\\s\\0]+$/, \"\");\n      }\n\n      delete e.gltfArrayBuffer, delete e.gltfByteOffset, delete e.gltfByteLength;\n      break;\n\n    case Xs.EMBEDDED:\n      break;\n\n    default:\n      throw new Error(\"b3dm: Illegal glTF format field\");\n  }\n}\n\nasync function Bp(e, t, n, s, r) {\n  var i;\n  n = Cp(e, t, n, s), await $a(e, Xs.EMBEDDED, s, r);\n  const o = e == null || (i = e.gltf) === null || i === void 0 ? void 0 : i.extensions;\n  return o && o.CESIUM_RTC && (e.rtcCenter = o.CESIUM_RTC.center), n;\n}\n\nfunction Cp(e, t, n, s, r) {\n  n = Vn(e, t, n), n = gr(e, t, n), n = Ar(e, t, n), n = Ya(e, t, n, s);\n  const i = new mr(e.featureTableJson, e.featureTableBinary);\n  return e.rtcCenter = i.getGlobalProperty(\"RTC_CENTER\", G.FLOAT, 3), n;\n}\n\nasync function Ep(e, t, n, s, r) {\n  return n = Tp(e, t, n, s), await $a(e, e.gltfFormat || 0, s, r), n;\n}\n\nfunction Tp(e, t, n, s, r) {\n  var i;\n  if (n = Vn(e, t, n), e.version !== 1) throw new Error(`Instanced 3D Model version ${e.version} is not supported`);\n  n = gr(e, t, n);\n  const o = new DataView(t);\n  if (e.gltfFormat = o.getUint32(n, !0), n += 4, n = Ar(e, t, n), n = Ya(e, t, n, s), !(e != null && (i = e.header) !== null && i !== void 0 && i.featureTableJsonByteLength) || e.header.featureTableJsonByteLength === 0) throw new Error(\"i3dm parser: featureTableJsonByteLength is zero.\");\n  const a = new mr(e.featureTableJson, e.featureTableBinary),\n        c = a.getGlobalProperty(\"INSTANCES_LENGTH\");\n  if (a.featuresLength = c, !Number.isFinite(c)) throw new Error(\"i3dm parser: INSTANCES_LENGTH must be defined\");\n  e.eastNorthUp = a.getGlobalProperty(\"EAST_NORTH_UP\"), e.rtcCenter = a.getGlobalProperty(\"RTC_CENTER\", G.FLOAT, 3);\n  const u = new Ra(e.batchTableJson, e.batchTableBinary, c);\n  return bp(e, a, u, c), n;\n}\n\nfunction bp(e, t, n, s) {\n  const r = new Array(s),\n        i = new A();\n  new A(), new A(), new A();\n  const o = new Q(),\n        a = new wn(),\n        c = new A(),\n        u = {},\n        l = new V(),\n        h = [],\n        f = [],\n        d = [],\n        m = [];\n\n  for (let g = 0; g < s; g++) {\n    let p;\n    if (t.hasProperty(\"POSITION\")) p = t.getProperty(\"POSITION\", G.FLOAT, 3, g, i);else if (t.hasProperty(\"POSITION_QUANTIZED\")) {\n      p = t.getProperty(\"POSITION_QUANTIZED\", G.UNSIGNED_SHORT, 3, g, i);\n      const E = t.getGlobalProperty(\"QUANTIZED_VOLUME_OFFSET\", G.FLOAT, 3);\n      if (!E) throw new Error(\"i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\");\n      const O = t.getGlobalProperty(\"QUANTIZED_VOLUME_SCALE\", G.FLOAT, 3);\n      if (!O) throw new Error(\"i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\");\n      const F = 65535;\n\n      for (let x = 0; x < 3; x++) p[x] = p[x] / F * O[x] + E[x];\n    }\n    if (!p) throw new Error(\"i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.\");\n\n    if (i.copy(p), u.translation = i, e.normalUp = t.getProperty(\"NORMAL_UP\", G.FLOAT, 3, g, h), e.normalRight = t.getProperty(\"NORMAL_RIGHT\", G.FLOAT, 3, g, f), e.normalUp) {\n      if (!e.normalRight) throw new Error(\"i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.\");\n      e.hasCustomOrientation = !0;\n    } else {\n      if (e.octNormalUp = t.getProperty(\"NORMAL_UP_OCT32P\", G.UNSIGNED_SHORT, 2, g, h), e.octNormalRight = t.getProperty(\"NORMAL_RIGHT_OCT32P\", G.UNSIGNED_SHORT, 2, g, f), e.octNormalUp) throw e.octNormalRight ? new Error(\"i3dm: oct-encoded orientation not implemented\") : new Error(\"i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P\");\n      e.eastNorthUp ? (J.WGS84.eastNorthUpToFixedFrame(i, l), l.getRotationMatrix3(o)) : o.identity();\n    }\n\n    a.fromMatrix3(o), u.rotation = a, c.set(1, 1, 1);\n    const C = t.getProperty(\"SCALE\", G.FLOAT, 1, g, d);\n    Number.isFinite(C) && c.multiplyByScalar(C);\n    const w = t.getProperty(\"SCALE_NON_UNIFORM\", G.FLOAT, 3, g, h);\n    w && c.scale(w), u.scale = c;\n    let y = t.getProperty(\"BATCH_ID\", G.UNSIGNED_SHORT, 1, g, m);\n    y === void 0 && (y = g);\n    const B = new V().fromQuaternion(u.rotation);\n    l.identity(), l.translate(u.translation), l.multiplyRight(B), l.scale(u.scale);\n    const R = l.clone();\n    r[g] = {\n      modelMatrix: R,\n      batchId: y\n    };\n  }\n\n  e.instances = r;\n}\n\nasync function _p(e, t, n, s, r, i) {\n  n = Vn(e, t, n);\n  const o = new DataView(t);\n\n  for (e.tilesLength = o.getUint32(n, !0), n += 4, e.tiles = []; e.tiles.length < e.tilesLength && (e.byteLength || 0) - n > 12;) {\n    const a = {\n      shape: \"tile3d\"\n    };\n    e.tiles.push(a), n = await i(t, n, s, r, a);\n  }\n\n  return n;\n}\n\nasync function wp(e, t, n, s) {\n  var r, i;\n\n  if (e.rotateYtoZ = !0, e.gltfUpAxis = n != null && (r = n[\"3d-tiles\"]) !== null && r !== void 0 && r.assetGltfUpAxis ? n[\"3d-tiles\"].assetGltfUpAxis : \"Y\", n != null && (i = n[\"3d-tiles\"]) !== null && i !== void 0 && i.loadGLTF) {\n    if (!s) return t.byteLength;\n    const o = await He(t, On, n, s);\n    e.gltf = qa(o), e.gpuMemoryUsageInBytes = Da(e.gltf);\n  } else e.gltfArrayBuffer = t;\n\n  return t.byteLength;\n}\n\nasync function Za(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,\n      n = arguments.length > 2 ? arguments[2] : void 0,\n      s = arguments.length > 3 ? arguments[3] : void 0,\n      r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {\n    shape: \"tile3d\"\n  };\n\n  switch (r.byteOffset = t, r.type = Wd(e, t), r.type) {\n    case Ce.COMPOSITE:\n      return await _p(r, e, t, n, s, Za);\n\n    case Ce.BATCHED_3D_MODEL:\n      return await Bp(r, e, t, n, s);\n\n    case Ce.GLTF:\n      return await wp(r, e, n, s);\n\n    case Ce.INSTANCED_3D_MODEL:\n      return await Ep(r, e, t, n, s);\n\n    case Ce.POINT_CLOUD:\n      return await Om(r, e, t, n, s);\n\n    default:\n      throw new Error(`3DTileLoader: unknown type ${r.type}`);\n  }\n}\n\nconst Rp = 1952609651,\n      Mp = 1;\n\nasync function Ip(e, t, n) {\n  if (new Uint32Array(e.slice(0, 4))[0] !== Rp) throw new Error(\"Wrong subtree file magic number\");\n  if (new Uint32Array(e.slice(4, 8))[0] !== Mp) throw new Error(\"Wrong subtree file verson, must be 1\");\n  const i = io(e.slice(8, 16)),\n        o = new Uint8Array(e, 24, i),\n        c = new TextDecoder(\"utf8\").decode(o),\n        u = JSON.parse(c),\n        l = io(e.slice(16, 24));\n  let h = new ArrayBuffer(0);\n  if (l && (h = e.slice(24 + i)), await fn(u, u.tileAvailability, h, n), Array.isArray(u.contentAvailability)) for (const f of u.contentAvailability) await fn(u, f, h, n);else await fn(u, u.contentAvailability, h, n);\n  return await fn(u, u.childSubtreeAvailability, h, n), u;\n}\n\nasync function fn(e, t, n, s) {\n  const r = Number.isFinite(t.bitstream) ? t.bitstream : t.bufferView;\n  if (typeof r != \"number\") return;\n  const i = e.bufferViews[r],\n        o = e.buffers[i.buffer];\n  if (!(s != null && s.baseUrl)) throw new Error(\"Url is not provided\");\n  if (!s.fetch) throw new Error(\"fetch is not provided\");\n\n  if (o.uri) {\n    const c = `${(s == null ? void 0 : s.baseUrl) || \"\"}/${o.uri}`,\n          l = await (await s.fetch(c)).arrayBuffer();\n    t.explicitBitstream = new Uint8Array(l, i.byteOffset, i.byteLength);\n    return;\n  }\n\n  const a = e.buffers.slice(0, i.buffer).reduce((c, u) => c + u.byteLength, 0);\n  t.explicitBitstream = new Uint8Array(n.slice(a, a + o.byteLength), i.byteOffset, i.byteLength);\n}\n\nfunction io(e) {\n  const t = new DataView(e),\n        n = t.getUint32(0, !0),\n        s = t.getUint32(4, !0);\n  return n + 2 ** 32 * s;\n}\n\nconst tc = {\n  id: \"3d-tiles-subtree\",\n  name: \"3D Tiles Subtree\",\n  module: \"3d-tiles\",\n  version: Ea,\n  extensions: [\"subtree\"],\n  mimeTypes: [\"application/octet-stream\"],\n  tests: [\"subtree\"],\n  parse: Ip,\n  options: {}\n};\n/**\r\n * @license\r\n * Copyright 2009 The Closure Library Authors\r\n * Copyright 2020 Daniel Wirtz / The long.js Authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n * SPDX-License-Identifier: Apache-2.0\r\n */\n\nvar Bt = null;\n\ntry {\n  Bt = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n} catch {}\n\nfunction H(e, t, n) {\n  this.low = e | 0, this.high = t | 0, this.unsigned = !!n;\n}\n\nH.prototype.__isLong__;\nObject.defineProperty(H.prototype, \"__isLong__\", {\n  value: !0\n});\n\nfunction ot(e) {\n  return (e && e.__isLong__) === !0;\n}\n\nfunction oo(e) {\n  var t = Math.clz32(e & -e);\n  return e ? 31 - t : t;\n}\n\nH.isLong = ot;\nvar ao = {},\n    co = {};\n\nfunction te(e, t) {\n  var n, s, r;\n  return t ? (e >>>= 0, (r = 0 <= e && e < 256) && (s = co[e], s) ? s : (n = P(e, 0, !0), r && (co[e] = n), n)) : (e |= 0, (r = -128 <= e && e < 128) && (s = ao[e], s) ? s : (n = P(e, e < 0 ? -1 : 0, !1), r && (ao[e] = n), n));\n}\n\nH.fromInt = te;\n\nfunction Ct(e, t) {\n  if (isNaN(e)) return t ? Gt : wt;\n\n  if (t) {\n    if (e < 0) return Gt;\n    if (e >= ec) return rc;\n  } else {\n    if (e <= -lo) return ft;\n    if (e + 1 >= lo) return sc;\n  }\n\n  return e < 0 ? Ct(-e, t).neg() : P(e % me | 0, e / me | 0, t);\n}\n\nH.fromNumber = Ct;\n\nfunction P(e, t, n) {\n  return new H(e, t, n);\n}\n\nH.fromBits = P;\nvar Fn = Math.pow;\n\nfunction Mr(e, t, n) {\n  if (e.length === 0) throw Error(\"empty string\");\n  if (typeof t == \"number\" ? (n = t, t = !1) : t = !!t, e === \"NaN\" || e === \"Infinity\" || e === \"+Infinity\" || e === \"-Infinity\") return t ? Gt : wt;\n  if (n = n || 10, n < 2 || 36 < n) throw RangeError(\"radix\");\n  var s;\n  if ((s = e.indexOf(\"-\")) > 0) throw Error(\"interior hyphen\");\n  if (s === 0) return Mr(e.substring(1), t, n).neg();\n\n  for (var r = Ct(Fn(n, 8)), i = wt, o = 0; o < e.length; o += 8) {\n    var a = Math.min(8, e.length - o),\n        c = parseInt(e.substring(o, o + a), n);\n\n    if (a < 8) {\n      var u = Ct(Fn(n, a));\n      i = i.mul(u).add(Ct(c));\n    } else i = i.mul(r), i = i.add(Ct(c));\n  }\n\n  return i.unsigned = t, i;\n}\n\nH.fromString = Mr;\n\nfunction Mt(e, t) {\n  return typeof e == \"number\" ? Ct(e, t) : typeof e == \"string\" ? Mr(e, t) : P(e.low, e.high, typeof t == \"boolean\" ? t : e.unsigned);\n}\n\nH.fromValue = Mt;\nvar uo = 65536,\n    Sp = 1 << 24,\n    me = uo * uo,\n    ec = me * me,\n    lo = ec / 2,\n    ho = te(Sp),\n    wt = te(0);\nH.ZERO = wt;\nvar Gt = te(0, !0);\nH.UZERO = Gt;\nvar le = te(1);\nH.ONE = le;\nvar nc = te(1, !0);\nH.UONE = nc;\nvar Qs = te(-1);\nH.NEG_ONE = Qs;\nvar sc = P(-1, 2147483647, !1);\nH.MAX_VALUE = sc;\nvar rc = P(-1, -1, !0);\nH.MAX_UNSIGNED_VALUE = rc;\nvar ft = P(0, -2147483648, !1);\nH.MIN_VALUE = ft;\nvar b = H.prototype;\n\nb.toInt = function () {\n  return this.unsigned ? this.low >>> 0 : this.low;\n};\n\nb.toNumber = function () {\n  return this.unsigned ? (this.high >>> 0) * me + (this.low >>> 0) : this.high * me + (this.low >>> 0);\n};\n\nb.toString = function (t) {\n  if (t = t || 10, t < 2 || 36 < t) throw RangeError(\"radix\");\n  if (this.isZero()) return \"0\";\n  if (this.isNegative()) if (this.eq(ft)) {\n    var n = Ct(t),\n        s = this.div(n),\n        r = s.mul(n).sub(this);\n    return s.toString(t) + r.toInt().toString(t);\n  } else return \"-\" + this.neg().toString(t);\n\n  for (var i = Ct(Fn(t, 6), this.unsigned), o = this, a = \"\";;) {\n    var c = o.div(i),\n        u = o.sub(c.mul(i)).toInt() >>> 0,\n        l = u.toString(t);\n    if (o = c, o.isZero()) return l + a;\n\n    for (; l.length < 6;) l = \"0\" + l;\n\n    a = \"\" + l + a;\n  }\n};\n\nb.getHighBits = function () {\n  return this.high;\n};\n\nb.getHighBitsUnsigned = function () {\n  return this.high >>> 0;\n};\n\nb.getLowBits = function () {\n  return this.low;\n};\n\nb.getLowBitsUnsigned = function () {\n  return this.low >>> 0;\n};\n\nb.getNumBitsAbs = function () {\n  if (this.isNegative()) return this.eq(ft) ? 64 : this.neg().getNumBitsAbs();\n\n  for (var t = this.high != 0 ? this.high : this.low, n = 31; n > 0 && !(t & 1 << n); n--);\n\n  return this.high != 0 ? n + 33 : n + 1;\n};\n\nb.isZero = function () {\n  return this.high === 0 && this.low === 0;\n};\n\nb.eqz = b.isZero;\n\nb.isNegative = function () {\n  return !this.unsigned && this.high < 0;\n};\n\nb.isPositive = function () {\n  return this.unsigned || this.high >= 0;\n};\n\nb.isOdd = function () {\n  return (this.low & 1) === 1;\n};\n\nb.isEven = function () {\n  return (this.low & 1) === 0;\n};\n\nb.equals = function (t) {\n  return ot(t) || (t = Mt(t)), this.unsigned !== t.unsigned && this.high >>> 31 === 1 && t.high >>> 31 === 1 ? !1 : this.high === t.high && this.low === t.low;\n};\n\nb.eq = b.equals;\n\nb.notEquals = function (t) {\n  return !this.eq(\n  /* validates */\n  t);\n};\n\nb.neq = b.notEquals;\nb.ne = b.notEquals;\n\nb.lessThan = function (t) {\n  return this.comp(\n  /* validates */\n  t) < 0;\n};\n\nb.lt = b.lessThan;\n\nb.lessThanOrEqual = function (t) {\n  return this.comp(\n  /* validates */\n  t) <= 0;\n};\n\nb.lte = b.lessThanOrEqual;\nb.le = b.lessThanOrEqual;\n\nb.greaterThan = function (t) {\n  return this.comp(\n  /* validates */\n  t) > 0;\n};\n\nb.gt = b.greaterThan;\n\nb.greaterThanOrEqual = function (t) {\n  return this.comp(\n  /* validates */\n  t) >= 0;\n};\n\nb.gte = b.greaterThanOrEqual;\nb.ge = b.greaterThanOrEqual;\n\nb.compare = function (t) {\n  if (ot(t) || (t = Mt(t)), this.eq(t)) return 0;\n  var n = this.isNegative(),\n      s = t.isNegative();\n  return n && !s ? -1 : !n && s ? 1 : this.unsigned ? t.high >>> 0 > this.high >>> 0 || t.high === this.high && t.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t).isNegative() ? -1 : 1;\n};\n\nb.comp = b.compare;\n\nb.negate = function () {\n  return !this.unsigned && this.eq(ft) ? ft : this.not().add(le);\n};\n\nb.neg = b.negate;\n\nb.add = function (t) {\n  ot(t) || (t = Mt(t));\n  var n = this.high >>> 16,\n      s = this.high & 65535,\n      r = this.low >>> 16,\n      i = this.low & 65535,\n      o = t.high >>> 16,\n      a = t.high & 65535,\n      c = t.low >>> 16,\n      u = t.low & 65535,\n      l = 0,\n      h = 0,\n      f = 0,\n      d = 0;\n  return d += i + u, f += d >>> 16, d &= 65535, f += r + c, h += f >>> 16, f &= 65535, h += s + a, l += h >>> 16, h &= 65535, l += n + o, l &= 65535, P(f << 16 | d, l << 16 | h, this.unsigned);\n};\n\nb.subtract = function (t) {\n  return ot(t) || (t = Mt(t)), this.add(t.neg());\n};\n\nb.sub = b.subtract;\n\nb.multiply = function (t) {\n  if (this.isZero()) return this;\n\n  if (ot(t) || (t = Mt(t)), Bt) {\n    var n = Bt.mul(this.low, this.high, t.low, t.high);\n    return P(n, Bt.get_high(), this.unsigned);\n  }\n\n  if (t.isZero()) return this.unsigned ? Gt : wt;\n  if (this.eq(ft)) return t.isOdd() ? ft : wt;\n  if (t.eq(ft)) return this.isOdd() ? ft : wt;\n  if (this.isNegative()) return t.isNegative() ? this.neg().mul(t.neg()) : this.neg().mul(t).neg();\n  if (t.isNegative()) return this.mul(t.neg()).neg();\n  if (this.lt(ho) && t.lt(ho)) return Ct(this.toNumber() * t.toNumber(), this.unsigned);\n  var s = this.high >>> 16,\n      r = this.high & 65535,\n      i = this.low >>> 16,\n      o = this.low & 65535,\n      a = t.high >>> 16,\n      c = t.high & 65535,\n      u = t.low >>> 16,\n      l = t.low & 65535,\n      h = 0,\n      f = 0,\n      d = 0,\n      m = 0;\n  return m += o * l, d += m >>> 16, m &= 65535, d += i * l, f += d >>> 16, d &= 65535, d += o * u, f += d >>> 16, d &= 65535, f += r * l, h += f >>> 16, f &= 65535, f += i * u, h += f >>> 16, f &= 65535, f += o * c, h += f >>> 16, f &= 65535, h += s * l + r * u + i * c + o * a, h &= 65535, P(d << 16 | m, h << 16 | f, this.unsigned);\n};\n\nb.mul = b.multiply;\n\nb.divide = function (t) {\n  if (ot(t) || (t = Mt(t)), t.isZero()) throw Error(\"division by zero\");\n\n  if (Bt) {\n    if (!this.unsigned && this.high === -2147483648 && t.low === -1 && t.high === -1) return this;\n    var n = (this.unsigned ? Bt.div_u : Bt.div_s)(this.low, this.high, t.low, t.high);\n    return P(n, Bt.get_high(), this.unsigned);\n  }\n\n  if (this.isZero()) return this.unsigned ? Gt : wt;\n  var s, r, i;\n\n  if (this.unsigned) {\n    if (t.unsigned || (t = t.toUnsigned()), t.gt(this)) return Gt;\n    if (t.gt(this.shru(1))) return nc;\n    i = Gt;\n  } else {\n    if (this.eq(ft)) {\n      if (t.eq(le) || t.eq(Qs)) return ft;\n      if (t.eq(ft)) return le;\n      var o = this.shr(1);\n      return s = o.div(t).shl(1), s.eq(wt) ? t.isNegative() ? le : Qs : (r = this.sub(t.mul(s)), i = s.add(r.div(t)), i);\n    } else if (t.eq(ft)) return this.unsigned ? Gt : wt;\n\n    if (this.isNegative()) return t.isNegative() ? this.neg().div(t.neg()) : this.neg().div(t).neg();\n    if (t.isNegative()) return this.div(t.neg()).neg();\n    i = wt;\n  }\n\n  for (r = this; r.gte(t);) {\n    s = Math.max(1, Math.floor(r.toNumber() / t.toNumber()));\n\n    for (var a = Math.ceil(Math.log(s) / Math.LN2), c = a <= 48 ? 1 : Fn(2, a - 48), u = Ct(s), l = u.mul(t); l.isNegative() || l.gt(r);) s -= c, u = Ct(s, this.unsigned), l = u.mul(t);\n\n    u.isZero() && (u = le), i = i.add(u), r = r.sub(l);\n  }\n\n  return i;\n};\n\nb.div = b.divide;\n\nb.modulo = function (t) {\n  if (ot(t) || (t = Mt(t)), Bt) {\n    var n = (this.unsigned ? Bt.rem_u : Bt.rem_s)(this.low, this.high, t.low, t.high);\n    return P(n, Bt.get_high(), this.unsigned);\n  }\n\n  return this.sub(this.div(t).mul(t));\n};\n\nb.mod = b.modulo;\nb.rem = b.modulo;\n\nb.not = function () {\n  return P(~this.low, ~this.high, this.unsigned);\n};\n\nb.countLeadingZeros = function () {\n  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n};\n\nb.clz = b.countLeadingZeros;\n\nb.countTrailingZeros = function () {\n  return this.low ? oo(this.low) : oo(this.high) + 32;\n};\n\nb.ctz = b.countTrailingZeros;\n\nb.and = function (t) {\n  return ot(t) || (t = Mt(t)), P(this.low & t.low, this.high & t.high, this.unsigned);\n};\n\nb.or = function (t) {\n  return ot(t) || (t = Mt(t)), P(this.low | t.low, this.high | t.high, this.unsigned);\n};\n\nb.xor = function (t) {\n  return ot(t) || (t = Mt(t)), P(this.low ^ t.low, this.high ^ t.high, this.unsigned);\n};\n\nb.shiftLeft = function (t) {\n  return ot(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? P(this.low << t, this.high << t | this.low >>> 32 - t, this.unsigned) : P(0, this.low << t - 32, this.unsigned);\n};\n\nb.shl = b.shiftLeft;\n\nb.shiftRight = function (t) {\n  return ot(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? P(this.low >>> t | this.high << 32 - t, this.high >> t, this.unsigned) : P(this.high >> t - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n};\n\nb.shr = b.shiftRight;\n\nb.shiftRightUnsigned = function (t) {\n  return ot(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? P(this.low >>> t | this.high << 32 - t, this.high >>> t, this.unsigned) : t === 32 ? P(this.high, 0, this.unsigned) : P(this.high >>> t - 32, 0, this.unsigned);\n};\n\nb.shru = b.shiftRightUnsigned;\nb.shr_u = b.shiftRightUnsigned;\n\nb.rotateLeft = function (t) {\n  var n;\n  return ot(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t === 32 ? P(this.high, this.low, this.unsigned) : t < 32 ? (n = 32 - t, P(this.low << t | this.high >>> n, this.high << t | this.low >>> n, this.unsigned)) : (t -= 32, n = 32 - t, P(this.high << t | this.low >>> n, this.low << t | this.high >>> n, this.unsigned));\n};\n\nb.rotl = b.rotateLeft;\n\nb.rotateRight = function (t) {\n  var n;\n  return ot(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t === 32 ? P(this.high, this.low, this.unsigned) : t < 32 ? (n = 32 - t, P(this.high << n | this.low >>> t, this.low << n | this.high >>> t, this.unsigned)) : (t -= 32, n = 32 - t, P(this.low << n | this.high >>> t, this.high << n | this.low >>> t, this.unsigned));\n};\n\nb.rotr = b.rotateRight;\n\nb.toSigned = function () {\n  return this.unsigned ? P(this.low, this.high, !1) : this;\n};\n\nb.toUnsigned = function () {\n  return this.unsigned ? this : P(this.low, this.high, !0);\n};\n\nb.toBytes = function (t) {\n  return t ? this.toBytesLE() : this.toBytesBE();\n};\n\nb.toBytesLE = function () {\n  var t = this.high,\n      n = this.low;\n  return [n & 255, n >>> 8 & 255, n >>> 16 & 255, n >>> 24, t & 255, t >>> 8 & 255, t >>> 16 & 255, t >>> 24];\n};\n\nb.toBytesBE = function () {\n  var t = this.high,\n      n = this.low;\n  return [t >>> 24, t >>> 16 & 255, t >>> 8 & 255, t & 255, n >>> 24, n >>> 16 & 255, n >>> 8 & 255, n & 255];\n};\n\nH.fromBytes = function (t, n, s) {\n  return s ? H.fromBytesLE(t, n) : H.fromBytesBE(t, n);\n};\n\nH.fromBytesLE = function (t, n) {\n  return new H(t[0] | t[1] << 8 | t[2] << 16 | t[3] << 24, t[4] | t[5] << 8 | t[6] << 16 | t[7] << 24, n);\n};\n\nH.fromBytesBE = function (t, n) {\n  return new H(t[4] << 24 | t[5] << 16 | t[6] << 8 | t[7], t[0] << 24 | t[1] << 16 | t[2] << 8 | t[3], n);\n};\n\nconst xp = 16;\n\nfunction ic(e) {\n  e === \"X\" && (e = \"\");\n  const t = e.padEnd(xp, \"0\");\n  return H.fromString(t, !0, 16);\n}\n\nfunction Op(e) {\n  if (e.isZero()) return \"X\";\n  let t = e.countTrailingZeros();\n  const n = t % 4;\n  t = (t - n) / 4;\n  const s = t;\n  t *= 4;\n  const i = e.shiftRightUnsigned(t).toString(16).replace(/0+$/, \"\");\n  return Array(17 - s - i.length).join(\"0\") + i;\n}\n\nfunction Fp(e, t) {\n  const n = vp(e).shiftRightUnsigned(2);\n  return e.add(H.fromNumber(2 * t + 1 - 4).multiply(n));\n}\n\nfunction vp(e) {\n  return e.and(e.not().add(1));\n}\n\nconst Dp = 3,\n      Lp = 30,\n      Gp = 2 * Lp + 1,\n      fo = 180 / Math.PI;\n\nfunction Pp(e) {\n  if (e.length === 0) throw new Error(`Invalid Hilbert quad key ${e}`);\n  const t = e.split(\"/\"),\n        n = parseInt(t[0], 10),\n        s = t[1],\n        r = s.length;\n  let i = 0;\n  const o = [0, 0];\n\n  for (let a = r - 1; a >= 0; a--) {\n    i = r - a;\n    const c = s[a];\n    let u = 0,\n        l = 0;\n    c === \"1\" ? l = 1 : c === \"2\" ? (u = 1, l = 1) : c === \"3\" && (u = 1);\n    const h = Math.pow(2, i - 1);\n    Up(h, o, u, l), o[0] += h * u, o[1] += h * l;\n  }\n\n  if (n % 2 === 1) {\n    const a = o[0];\n    o[0] = o[1], o[1] = a;\n  }\n\n  return {\n    face: n,\n    ij: o,\n    level: i\n  };\n}\n\nfunction Np(e) {\n  if (e.isZero()) return \"\";\n  let t = e.toString(2);\n\n  for (; t.length < Dp + Gp;) t = \"0\" + t;\n\n  const n = t.lastIndexOf(\"1\"),\n        s = t.substring(0, 3),\n        r = t.substring(3, n),\n        i = r.length / 2,\n        o = H.fromString(s, !0, 2).toString(10);\n  let a = \"\";\n  if (i !== 0) for (a = H.fromString(r, !0, 2).toString(4); a.length < i;) a = \"0\" + a;\n  return `${o}/${a}`;\n}\n\nfunction oc(e, t, n) {\n  const s = 1 << t;\n  return [(e[0] + n[0]) / s, (e[1] + n[1]) / s];\n}\n\nfunction mo(e) {\n  return e >= 0.5 ? 1 / 3 * (4 * e * e - 1) : 1 / 3 * (1 - 4 * (1 - e) * (1 - e));\n}\n\nfunction ac(e) {\n  return [mo(e[0]), mo(e[1])];\n}\n\nfunction cc(e, t) {\n  let [n, s] = t;\n\n  switch (e) {\n    case 0:\n      return [1, n, s];\n\n    case 1:\n      return [-n, 1, s];\n\n    case 2:\n      return [-n, -s, 1];\n\n    case 3:\n      return [-1, -s, -n];\n\n    case 4:\n      return [s, -1, -n];\n\n    case 5:\n      return [s, n, -1];\n\n    default:\n      throw new Error(\"Invalid face\");\n  }\n}\n\nfunction uc(e) {\n  let [t, n, s] = e;\n  const r = Math.atan2(s, Math.sqrt(t * t + n * n));\n  return [Math.atan2(n, t) * fo, r * fo];\n}\n\nfunction Up(e, t, n, s) {\n  if (s === 0) {\n    n === 1 && (t[0] = e - 1 - t[0], t[1] = e - 1 - t[1]);\n    const r = t[0];\n    t[0] = t[1], t[1] = r;\n  }\n}\n\nfunction Hp(e) {\n  const t = oc(e.ij, e.level, [0.5, 0.5]),\n        n = ac(t),\n        s = cc(e.face, n);\n  return uc(s);\n}\n\nconst Jp = 100;\n\nfunction go(e) {\n  const {\n    face: t,\n    ij: n,\n    level: s\n  } = e,\n        r = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]],\n        i = Math.max(1, Math.ceil(Jp * Math.pow(2, -s))),\n        o = new Float64Array(4 * i * 2 + 2);\n  let a = 0,\n      c = 0;\n\n  for (let u = 0; u < 4; u++) {\n    const l = r[u].slice(0),\n          h = r[u + 1],\n          f = (h[0] - l[0]) / i,\n          d = (h[1] - l[1]) / i;\n\n    for (let m = 0; m < i; m++) {\n      l[0] += f, l[1] += d;\n      const g = oc(n, s, l),\n            p = ac(g),\n            C = cc(t, p),\n            w = uc(C);\n      Math.abs(w[1]) > 89.999 && (w[0] = c);\n      const y = w[0] - c;\n      w[0] += y > 180 ? -360 : y < -180 ? 360 : 0, o[a++] = w[0], o[a++] = w[1], c = w[0];\n    }\n  }\n\n  return o[a++] = o[0], o[a++] = o[1], o;\n}\n\nfunction Ir(e) {\n  const t = Vp(e);\n  return Pp(t);\n}\n\nfunction Vp(e) {\n  if (e.indexOf(\"/\") > 0) return e;\n  const t = ic(e);\n  return Np(t);\n}\n\nfunction jp(e) {\n  const t = Ir(e);\n  return Hp(t);\n}\n\nfunction kp(e) {\n  let t;\n\n  if (e.face === 2 || e.face === 5) {\n    let n = null,\n        s = 0;\n\n    for (let r = 0; r < 4; r++) {\n      const i = `${e.face}/${r}`,\n            o = Ir(i),\n            a = go(o);\n      (typeof n > \"u\" || n === null) && (n = new Float64Array(4 * a.length)), n.set(a, s), s += a.length;\n    }\n\n    t = Ao(n);\n  } else {\n    const n = go(e);\n    t = Ao(n);\n  }\n\n  return t;\n}\n\nfunction Ao(e) {\n  if (e.length % 2 !== 0) throw new Error(\"Invalid corners\");\n  const t = [],\n        n = [];\n\n  for (let s = 0; s < e.length; s += 2) t.push(e[s]), n.push(e[s + 1]);\n\n  return t.sort((s, r) => s - r), n.sort((s, r) => s - r), {\n    west: t[0],\n    east: t[t.length - 1],\n    north: n[n.length - 1],\n    south: n[0]\n  };\n}\n\nfunction Kp(e, t) {\n  const n = (t == null ? void 0 : t.minimumHeight) || 0,\n        s = (t == null ? void 0 : t.maximumHeight) || 0,\n        r = Ir(e),\n        i = kp(r),\n        o = i.west,\n        a = i.south,\n        c = i.east,\n        u = i.north,\n        l = [];\n  return l.push(new A(o, u, n)), l.push(new A(c, u, n)), l.push(new A(c, a, n)), l.push(new A(o, a, n)), l.push(new A(o, u, s)), l.push(new A(c, u, s)), l.push(new A(c, a, s)), l.push(new A(o, a, s)), l;\n}\n\nfunction lc(e) {\n  const t = e.token,\n        n = {\n    minimumHeight: e.minimumHeight,\n    maximumHeight: e.maximumHeight\n  },\n        s = Kp(t, n),\n        r = jp(t),\n        i = r[0],\n        o = r[1],\n        a = J.WGS84.cartographicToCartesian([i, o, n.maximumHeight]),\n        c = new A(a[0], a[1], a[2]);\n  s.push(c);\n  const u = Ad(s);\n  return [...u.center, ...u.halfAxes];\n}\n\nconst zp = 4,\n      Wp = 8,\n      Xp = {\n  QUADTREE: zp,\n  OCTREE: Wp\n};\n\nfunction Qp(e, t, n) {\n  if (e != null && e.box) {\n    const s = ic(e.s2VolumeInfo.token),\n          r = Fp(s, t),\n          i = Op(r),\n          o = { ...e.s2VolumeInfo\n    };\n\n    switch (o.token = i, n) {\n      case \"OCTREE\":\n        const u = e.s2VolumeInfo,\n              l = u.maximumHeight - u.minimumHeight,\n              h = l / 2,\n              f = u.minimumHeight + l / 2;\n        u.minimumHeight = f - h, u.maximumHeight = f + h;\n        break;\n    }\n\n    return {\n      box: lc(o),\n      s2VolumeInfo: o\n    };\n  }\n}\n\nasync function hc(e) {\n  const {\n    implicitOptions: t,\n    parentData: n = {\n      mortonIndex: 0,\n      x: 0,\n      y: 0,\n      z: 0\n    },\n    childIndex: s = 0,\n    s2VolumeBox: r,\n    loaderOptions: i\n  } = e;\n  let {\n    subtree: o,\n    level: a = 0,\n    globalData: c = {\n      level: 0,\n      mortonIndex: 0,\n      x: 0,\n      y: 0,\n      z: 0\n    }\n  } = e;\n  const {\n    subdivisionScheme: u,\n    subtreeLevels: l,\n    maximumLevel: h,\n    contentUrlTemplate: f,\n    subtreesUriTemplate: d,\n    basePath: m\n  } = t,\n        g = {\n    children: [],\n    lodMetricValue: 0,\n    contentUrl: \"\"\n  };\n  if (!h) return Ko.once(`Missing 'maximumLevel' or 'availableLevels' property. The subtree ${f} won't be loaded...`), g;\n  const p = a + c.level;\n  if (p > h) return g;\n  const C = Xp[u],\n        w = Math.log2(C),\n        y = s & 1,\n        B = s >> 1 & 1,\n        R = s >> 2 & 1,\n        E = (C ** a - 1) / (C - 1);\n  let O = Kt(n.mortonIndex, s, w),\n      F = E + O,\n      x = Kt(n.x, y, 1),\n      v = Kt(n.y, B, 1),\n      K = Kt(n.z, R, 1),\n      q = !1;\n  a >= l && (q = Ms(o.childSubtreeAvailability, O));\n  const Y = Kt(c.x, x, a),\n        D = Kt(c.y, v, a),\n        at = Kt(c.z, K, a);\n\n  if (q) {\n    const nt = `${m}/${d}`,\n          vt = qs(nt, p, Y, D, at);\n    o = await fe(vt, tc, i), c = {\n      mortonIndex: O,\n      x,\n      y: v,\n      z: K,\n      level: a\n    }, O = 0, F = 0, x = 0, v = 0, K = 0, a = 0;\n  }\n\n  if (!Ms(o.tileAvailability, F)) return g;\n  Ms(o.contentAvailability, F) && (g.contentUrl = qs(f, p, Y, D, at));\n  const ge = a + 1,\n        Ft = {\n    mortonIndex: O,\n    x,\n    y: v,\n    z: K\n  };\n\n  for (let nt = 0; nt < C; nt++) {\n    const vt = Qp(r, nt, u),\n          jt = await hc({\n      subtree: o,\n      implicitOptions: t,\n      loaderOptions: i,\n      parentData: Ft,\n      childIndex: nt,\n      level: ge,\n      globalData: { ...c\n      },\n      s2VolumeBox: vt\n    });\n\n    if (jt.contentUrl || jt.children.length) {\n      const Ae = p + 1,\n            zn = qp(jt, Ae, {\n        childTileX: x,\n        childTileY: v,\n        childTileZ: K\n      }, t, r);\n      g.children.push(zn);\n    }\n  }\n\n  return g;\n}\n\nfunction Ms(e, t) {\n  let n;\n  return Array.isArray(e) ? (n = e[0], e.length > 1 && Ko.once('Not supported extension \"3DTILES_multiple_contents\" has been detected')) : n = e, \"constant\" in n ? !!n.constant : n.explicitBitstream ? Zp(t, n.explicitBitstream) : !1;\n}\n\nfunction qp(e, t, n, s, r) {\n  const {\n    basePath: i,\n    refine: o,\n    getRefine: a,\n    lodMetricType: c,\n    getTileType: u,\n    rootLodMetricValue: l,\n    rootBoundingVolume: h\n  } = s,\n        f = e.contentUrl && e.contentUrl.replace(`${i}/`, \"\"),\n        d = l / 2 ** t,\n        m = r != null && r.box ? {\n    box: r.box\n  } : h,\n        g = Yp(t, m, n);\n  return {\n    children: e.children,\n    contentUrl: e.contentUrl,\n    content: {\n      uri: f\n    },\n    id: e.contentUrl,\n    refine: a(o),\n    type: u(e),\n    lodMetricType: c,\n    lodMetricValue: d,\n    geometricError: d,\n    transform: e.transform,\n    boundingVolume: g\n  };\n}\n\nfunction Yp(e, t, n) {\n  if (t.region) {\n    const {\n      childTileX: s,\n      childTileY: r,\n      childTileZ: i\n    } = n,\n          [o, a, c, u, l, h] = t.region,\n          f = 2 ** e,\n          d = (c - o) / f,\n          m = (u - a) / f,\n          g = (h - l) / f,\n          [p, C] = [o + d * s, o + d * (s + 1)],\n          [w, y] = [a + m * r, a + m * (r + 1)],\n          [B, R] = [l + g * i, l + g * (i + 1)];\n    return {\n      region: [p, w, C, y, B, R]\n    };\n  }\n\n  if (t.box) return t;\n  throw new Error(`Unsupported bounding volume type ${t}`);\n}\n\nfunction Kt(e, t, n) {\n  return (e << n) + t;\n}\n\nfunction qs(e, t, n, s, r) {\n  const i = $p({\n    level: t,\n    x: n,\n    y: s,\n    z: r\n  });\n  return e.replace(/{level}|{x}|{y}|{z}/gi, o => i[o]);\n}\n\nfunction $p(e) {\n  const t = {};\n\n  for (const n in e) t[`{${n}}`] = e[n];\n\n  return t;\n}\n\nfunction Zp(e, t) {\n  const n = Math.floor(e / 8),\n        s = e % 8;\n  return (t[n] >> s & 1) === 1;\n}\n\nfunction Sr(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n  if (!t) return zt.EMPTY;\n  const s = t.split(\"?\")[0].split(\".\").pop();\n\n  switch (s) {\n    case \"pnts\":\n      return zt.POINTCLOUD;\n\n    case \"i3dm\":\n    case \"b3dm\":\n    case \"glb\":\n    case \"gltf\":\n      return zt.SCENEGRAPH;\n\n    default:\n      return s || zt.EMPTY;\n  }\n}\n\nfunction xr(e) {\n  switch (e) {\n    case \"REPLACE\":\n    case \"replace\":\n      return Pt.REPLACE;\n\n    case \"ADD\":\n    case \"add\":\n      return Pt.ADD;\n\n    default:\n      return e;\n  }\n}\n\nfunction Ys(e, t) {\n  if (/^[a-z][0-9a-z+.-]*:/i.test(t)) {\n    const s = new URL(e, `${t}/`);\n    return decodeURI(s.toString());\n  } else if (e.startsWith(\"/\")) return e;\n\n  return xu(t, e);\n}\n\nfunction po(e, t) {\n  if (!e) return null;\n  let n;\n\n  if (e.content) {\n    var s;\n    const i = e.content.uri || ((s = e.content) === null || s === void 0 ? void 0 : s.url);\n    typeof i < \"u\" && (n = Ys(i, t));\n  }\n\n  return { ...e,\n    id: n,\n    contentUrl: n,\n    lodMetricType: Hn.GEOMETRIC_ERROR,\n    lodMetricValue: e.geometricError,\n    transformMatrix: e.transform,\n    type: Sr(e, n),\n    refine: xr(e.refine)\n  };\n}\n\nasync function ty(e, t, n) {\n  let s = null;\n  const r = Bo(e.root);\n  r && e.root ? s = await yo(e.root, e, t, r, n) : s = po(e.root, t);\n  const i = [];\n\n  for (i.push(s); i.length > 0;) {\n    const o = i.pop() || {},\n          a = o.children || [],\n          c = [];\n\n    for (const u of a) {\n      const l = Bo(u);\n      let h;\n      l ? h = await yo(u, e, t, l, n) : h = po(u, t), h && (c.push(h), i.push(h));\n    }\n\n    o.children = c;\n  }\n\n  return s;\n}\n\nasync function yo(e, t, n, s, r) {\n  var i, o, a;\n  const {\n    subdivisionScheme: c,\n    maximumLevel: u,\n    availableLevels: l,\n    subtreeLevels: h,\n    subtrees: {\n      uri: f\n    }\n  } = s,\n        d = qs(f, 0, 0, 0, 0),\n        m = Ys(d, n),\n        g = await fe(m, tc, r),\n        p = (i = e.content) === null || i === void 0 ? void 0 : i.uri,\n        C = p ? Ys(p, n) : \"\",\n        w = t == null || (o = t.root) === null || o === void 0 ? void 0 : o.refine,\n        y = e.geometricError,\n        B = (a = e.boundingVolume.extensions) === null || a === void 0 ? void 0 : a[\"3DTILES_bounding_volume_S2\"];\n\n  if (B) {\n    const F = {\n      box: lc(B),\n      s2VolumeInfo: B\n    };\n    e.boundingVolume = F;\n  }\n\n  const R = e.boundingVolume,\n        E = {\n    contentUrlTemplate: C,\n    subtreesUriTemplate: f,\n    subdivisionScheme: c,\n    subtreeLevels: h,\n    maximumLevel: Number.isFinite(l) ? l - 1 : u,\n    refine: w,\n    basePath: n,\n    lodMetricType: Hn.GEOMETRIC_ERROR,\n    rootLodMetricValue: y,\n    rootBoundingVolume: R,\n    getTileType: Sr,\n    getRefine: xr\n  };\n  return await ey(e, n, g, E, r);\n}\n\nasync function ey(e, t, n, s, r) {\n  if (!e) return null;\n  const {\n    children: i,\n    contentUrl: o\n  } = await hc({\n    subtree: n,\n    implicitOptions: s,\n    loaderOptions: r\n  });\n  let a,\n      c = null;\n  return o && (a = o, c = {\n    uri: o.replace(`${t}/`, \"\")\n  }), { ...e,\n    id: a,\n    contentUrl: a,\n    lodMetricType: Hn.GEOMETRIC_ERROR,\n    lodMetricValue: e.geometricError,\n    transformMatrix: e.transform,\n    type: Sr(e, a),\n    refine: xr(e.refine),\n    content: c || e.content,\n    children: i\n  };\n}\n\nfunction Bo(e) {\n  var t;\n  return (e == null || (t = e.extensions) === null || t === void 0 ? void 0 : t[\"3DTILES_implicit_tiling\"]) || (e == null ? void 0 : e.implicitTiling);\n}\n\nconst Oe = {\n  id: \"3d-tiles\",\n  name: \"3D Tiles\",\n  module: \"3d-tiles\",\n  version: Ea,\n  extensions: [\"cmpt\", \"pnts\", \"b3dm\", \"i3dm\"],\n  mimeTypes: [\"application/octet-stream\"],\n  tests: [\"cmpt\", \"pnts\", \"b3dm\", \"i3dm\"],\n  parse: ny,\n  options: {\n    \"3d-tiles\": {\n      loadGLTF: !0,\n      decodeQuantizedPositions: !1,\n      isTileset: \"auto\",\n      assetGltfUpAxis: null\n    }\n  }\n};\n\nasync function ny(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},\n      n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = t[\"3d-tiles\"] || {};\n  let r;\n  return s.isTileset === \"auto\" ? r = (n == null ? void 0 : n.url) && n.url.indexOf(\".json\") !== -1 : r = s.isTileset, r ? sy(e, t, n) : ry(e, t, n);\n}\n\nasync function sy(e, t, n) {\n  var s;\n  const r = JSON.parse(new TextDecoder().decode(e)),\n        i = (n == null ? void 0 : n.url) || \"\",\n        o = iy(i),\n        a = await ty(r, o, t || {});\n  return { ...r,\n    shape: \"tileset3d\",\n    loader: Oe,\n    url: i,\n    queryString: (n == null ? void 0 : n.queryString) || \"\",\n    basePath: o,\n    root: a || r.root,\n    type: At.TILES3D,\n    lodMetricType: Hn.GEOMETRIC_ERROR,\n    lodMetricValue: ((s = r.root) === null || s === void 0 ? void 0 : s.geometricError) || 0\n  };\n}\n\nasync function ry(e, t, n) {\n  const s = {\n    content: {\n      shape: \"tile3d\",\n      featureIds: null\n    }\n  };\n  return await Za(e, 0, t, n, s.content), s.content;\n}\n\nfunction iy(e) {\n  return rr(e);\n}\n\nconst fc = \"https://api.cesium.com/v1/assets\";\n\nasync function oy(e, t) {\n  if (!t) {\n    const i = await ay(e);\n\n    for (const o of i.items) o.type === \"3DTILES\" && (t = o.id);\n  }\n\n  const n = await cy(e, t),\n        {\n    type: s,\n    url: r\n  } = n;\n  return U(s === \"3DTILES\" && r), n.headers = {\n    Authorization: `Bearer ${n.accessToken}`\n  }, n;\n}\n\nasync function ay(e) {\n  U(e);\n  const t = fc,\n        n = {\n    Authorization: `Bearer ${e}`\n  },\n        s = await Fe(t, {\n    headers: n\n  });\n  if (!s.ok) throw new Error(s.statusText);\n  return await s.json();\n}\n\nasync function cy(e, t) {\n  U(e, t);\n  const n = {\n    Authorization: `Bearer ${e}`\n  },\n        s = `${fc}/${t}`;\n  let r = await Fe(`${s}`, {\n    headers: n\n  });\n  if (!r.ok) throw new Error(r.statusText);\n  let i = await r.json();\n  if (r = await Fe(`${s}/endpoint`, {\n    headers: n\n  }), !r.ok) throw new Error(r.statusText);\n  const o = await r.json();\n  return i = { ...i,\n    ...o\n  }, i;\n}\n\nasync function uy(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  t = t[\"cesium-ion\"] || {};\n  const {\n    accessToken: n\n  } = t;\n  let s = t.assetId;\n\n  if (!Number.isFinite(s)) {\n    const r = e.match(/\\/([0-9]+)\\/tileset.json/);\n    s = r && r[1];\n  }\n\n  return oy(n, s);\n}\n\nconst dc = { ...Oe,\n  id: \"cesium-ion\",\n  name: \"Cesium Ion\",\n  preload: uy,\n  parse: async (e, t, n) => (t = { ...t\n  }, t[\"3d-tiles\"] = t[\"cesium-ion\"], t.loader = dc, Oe.parse(e, t, n)),\n  options: {\n    \"cesium-ion\": { ...Oe.options[\"3d-tiles\"],\n      accessToken: null\n    }\n  }\n},\n      Co = 100;\n\nclass ly {\n  constructor(t, n) {\n    if (this.schema = void 0, this.options = void 0, this.shape = void 0, this.length = 0, this.rows = null, this.cursor = 0, this._headers = [], this.options = n, this.schema = t, !Array.isArray(t)) {\n      this._headers = [];\n\n      for (const s in t) this._headers[t[s].index] = t[s].name;\n    }\n  }\n\n  rowCount() {\n    return this.length;\n  }\n\n  addArrayRow(t, n) {\n    Number.isFinite(n) && (this.cursor = n), this.shape = \"array-row-table\", this.rows = this.rows || new Array(Co), this.rows[this.length] = t, this.length++;\n  }\n\n  addObjectRow(t, n) {\n    Number.isFinite(n) && (this.cursor = n), this.shape = \"object-row-table\", this.rows = this.rows || new Array(Co), this.rows[this.length] = t, this.length++;\n  }\n\n  getBatch() {\n    let t = this.rows;\n    return t ? (t = t.slice(0, this.length), this.rows = null, {\n      shape: this.shape || \"array-row-table\",\n      batchType: \"data\",\n      data: t,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    }) : null;\n  }\n\n}\n\nfunction hy(e, t) {\n  if (!e) throw new Error(\"null row\");\n  const n = {};\n  if (t) for (let s = 0; s < t.length; s++) n[t[s]] = e[s];else for (let s = 0; s < e.length; s++) {\n    const r = `column-${s}`;\n    n[r] = e[s];\n  }\n  return n;\n}\n\nfunction fy(e, t) {\n  if (!e) throw new Error(\"null row\");\n\n  if (t) {\n    const n = new Array(t.length);\n\n    for (let s = 0; s < t.length; s++) n[s] = e[t[s]];\n\n    return n;\n  }\n\n  return Object.values(e);\n}\n\nfunction dy(e) {\n  const t = [];\n\n  for (let n = 0; n < e.length; n++) {\n    const s = `column-${n}`;\n    t.push(s);\n  }\n\n  return t;\n}\n\nfunction my(e) {\n  return Object.keys(e);\n}\n\nconst Eo = 100;\n\nclass gy {\n  constructor(t, n) {\n    if (this.schema = void 0, this.options = void 0, this.length = 0, this.objectRows = null, this.arrayRows = null, this.cursor = 0, this._headers = null, this.options = n, this.schema = t, t) {\n      this._headers = [];\n\n      for (const s in t) this._headers[t[s].index] = t[s].name;\n    }\n  }\n\n  rowCount() {\n    return this.length;\n  }\n\n  addArrayRow(t, n) {\n    switch (Number.isFinite(n) && (this.cursor = n), this._headers || (this._headers = dy(t)), this.options.shape) {\n      case \"object-row-table\":\n        const s = hy(t, this._headers);\n        this.addObjectRow(s, n);\n        break;\n\n      case \"array-row-table\":\n        this.arrayRows = this.arrayRows || new Array(Eo), this.arrayRows[this.length] = t, this.length++;\n        break;\n    }\n  }\n\n  addObjectRow(t, n) {\n    switch (Number.isFinite(n) && (this.cursor = n), this._headers || (this._headers = my(t)), this.options.shape) {\n      case \"array-row-table\":\n        const s = fy(t, this._headers);\n        this.addArrayRow(s, n);\n        break;\n\n      case \"object-row-table\":\n        this.objectRows = this.objectRows || new Array(Eo), this.objectRows[this.length] = t, this.length++;\n        break;\n    }\n  }\n\n  getBatch() {\n    let t = this.arrayRows || this.objectRows;\n    return t ? (t = t.slice(0, this.length), this.arrayRows = null, this.objectRows = null, {\n      shape: this.options.shape,\n      batchType: \"data\",\n      data: t,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    }) : null;\n  }\n\n}\n\nconst Ay = 100;\n\nclass py {\n  constructor(t, n) {\n    this.schema = void 0, this.length = 0, this.allocated = 0, this.columns = {}, this.schema = t, this._reallocateColumns();\n  }\n\n  rowCount() {\n    return this.length;\n  }\n\n  addArrayRow(t) {\n    this._reallocateColumns();\n\n    let n = 0;\n\n    for (const s in this.columns) this.columns[s][this.length] = t[n++];\n\n    this.length++;\n  }\n\n  addObjectRow(t) {\n    this._reallocateColumns();\n\n    for (const n in t) this.columns[n][this.length] = t[n];\n\n    this.length++;\n  }\n\n  getBatch() {\n    this._pruneColumns();\n\n    const t = Array.isArray(this.schema) ? this.columns : {};\n    if (!Array.isArray(this.schema)) for (const s in this.schema) {\n      const r = this.schema[s];\n      t[r.name] = this.columns[r.index];\n    }\n    return this.columns = {}, {\n      shape: \"columnar-table\",\n      batchType: \"data\",\n      data: t,\n      schema: this.schema,\n      length: this.length\n    };\n  }\n\n  _reallocateColumns() {\n    if (!(this.length < this.allocated)) {\n      this.allocated = this.allocated > 0 ? this.allocated *= 2 : Ay, this.columns = {};\n\n      for (const t in this.schema) {\n        const n = this.schema[t],\n              s = n.type || Float32Array,\n              r = this.columns[n.index];\n\n        if (r && ArrayBuffer.isView(r)) {\n          const i = new s(this.allocated);\n          i.set(r), this.columns[n.index] = i;\n        } else r ? (r.length = this.allocated, this.columns[n.index] = r) : this.columns[n.index] = new s(this.allocated);\n      }\n    }\n  }\n\n  _pruneColumns() {\n    for (const [t, n] of Object.entries(this.columns)) this.columns[t] = n.slice(0, this.length);\n  }\n\n}\n\nconst yy = {\n  shape: void 0,\n  batchSize: \"auto\",\n  batchDebounceMs: 0,\n  limit: 0,\n  _limitMB: 0\n},\n      By = \"TableBatchBuilder\";\n\nclass Le {\n  constructor(t, n) {\n    this.schema = void 0, this.options = void 0, this.aggregator = null, this.batchCount = 0, this.bytesUsed = 0, this.isChunkComplete = !1, this.lastBatchEmittedMs = Date.now(), this.totalLength = 0, this.totalBytes = 0, this.rowBytes = 0, this.schema = t, this.options = { ...yy,\n      ...n\n    };\n  }\n\n  limitReached() {\n    var t, n;\n    return !!(!((t = this.options) === null || t === void 0) && t.limit && this.totalLength >= this.options.limit || !((n = this.options) === null || n === void 0) && n._limitMB && this.totalBytes / 1e6 >= this.options._limitMB);\n  }\n\n  addRow(t) {\n    this.limitReached() || (this.totalLength++, this.rowBytes = this.rowBytes || this._estimateRowMB(t), this.totalBytes += this.rowBytes, Array.isArray(t) ? this.addArrayRow(t) : this.addObjectRow(t));\n  }\n\n  addArrayRow(t) {\n    if (!this.aggregator) {\n      const n = this._getTableBatchType();\n\n      this.aggregator = new n(this.schema, this.options);\n    }\n\n    this.aggregator.addArrayRow(t);\n  }\n\n  addObjectRow(t) {\n    if (!this.aggregator) {\n      const n = this._getTableBatchType();\n\n      this.aggregator = new n(this.schema, this.options);\n    }\n\n    this.aggregator.addObjectRow(t);\n  }\n\n  chunkComplete(t) {\n    t instanceof ArrayBuffer && (this.bytesUsed += t.byteLength), typeof t == \"string\" && (this.bytesUsed += t.length), this.isChunkComplete = !0;\n  }\n\n  getFullBatch(t) {\n    return this._isFull() ? this._getBatch(t) : null;\n  }\n\n  getFinalBatch(t) {\n    return this._getBatch(t);\n  }\n\n  _estimateRowMB(t) {\n    return Array.isArray(t) ? t.length * 8 : Object.keys(t).length * 8;\n  }\n\n  _isFull() {\n    if (!this.aggregator || this.aggregator.rowCount() === 0) return !1;\n\n    if (this.options.batchSize === \"auto\") {\n      if (!this.isChunkComplete) return !1;\n    } else if (this.options.batchSize > this.aggregator.rowCount()) return !1;\n\n    return this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs ? !1 : (this.isChunkComplete = !1, this.lastBatchEmittedMs = Date.now(), !0);\n  }\n\n  _getBatch(t) {\n    if (!this.aggregator) return null;\n    t != null && t.bytesUsed && (this.bytesUsed = t.bytesUsed);\n    const n = this.aggregator.getBatch();\n    return n.count = this.batchCount, n.bytesUsed = this.bytesUsed, Object.assign(n, t), this.batchCount++, this.aggregator = null, n;\n  }\n\n  _getTableBatchType() {\n    switch (this.options.shape) {\n      case \"array-row-table\":\n      case \"object-row-table\":\n        return gy;\n\n      case \"columnar-table\":\n        return py;\n\n      case \"arrow-table\":\n        if (!Le.ArrowBatch) throw new Error(By);\n        return Le.ArrowBatch;\n\n      default:\n        return ly;\n    }\n  }\n\n}\n\nLe.ArrowBatch = void 0;\n\nfunction Cy(e) {\n  try {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return async function* () {\n      const n = new TextDecoder(void 0, t);\n\n      for await (const s of e) yield typeof s == \"string\" ? s : n.decode(s, {\n        stream: !0\n      });\n    }();\n  } catch (t) {\n    return Promise.reject(t);\n  }\n}\n\nconst $s = Number.MAX_SAFE_INTEGER;\n\nvar M = function (e) {\n  return e[e.BEGIN = 0] = \"BEGIN\", e[e.VALUE = 1] = \"VALUE\", e[e.OPEN_OBJECT = 2] = \"OPEN_OBJECT\", e[e.CLOSE_OBJECT = 3] = \"CLOSE_OBJECT\", e[e.OPEN_ARRAY = 4] = \"OPEN_ARRAY\", e[e.CLOSE_ARRAY = 5] = \"CLOSE_ARRAY\", e[e.TEXT_ESCAPE = 6] = \"TEXT_ESCAPE\", e[e.STRING = 7] = \"STRING\", e[e.BACKSLASH = 8] = \"BACKSLASH\", e[e.END = 9] = \"END\", e[e.OPEN_KEY = 10] = \"OPEN_KEY\", e[e.CLOSE_KEY = 11] = \"CLOSE_KEY\", e[e.TRUE = 12] = \"TRUE\", e[e.TRUE2 = 13] = \"TRUE2\", e[e.TRUE3 = 14] = \"TRUE3\", e[e.FALSE = 15] = \"FALSE\", e[e.FALSE2 = 16] = \"FALSE2\", e[e.FALSE3 = 17] = \"FALSE3\", e[e.FALSE4 = 18] = \"FALSE4\", e[e.NULL = 19] = \"NULL\", e[e.NULL2 = 20] = \"NULL2\", e[e.NULL3 = 21] = \"NULL3\", e[e.NUMBER_DECIMAL_POINT = 22] = \"NUMBER_DECIMAL_POINT\", e[e.NUMBER_DIGIT = 23] = \"NUMBER_DIGIT\", e;\n}(M || {});\n\nconst I = {\n  tab: 9,\n  lineFeed: 10,\n  carriageReturn: 13,\n  space: 32,\n  doubleQuote: 34,\n  plus: 43,\n  comma: 44,\n  minus: 45,\n  period: 46,\n  _0: 48,\n  _9: 57,\n  colon: 58,\n  E: 69,\n  openBracket: 91,\n  backslash: 92,\n  closeBracket: 93,\n  a: 97,\n  b: 98,\n  e: 101,\n  f: 102,\n  l: 108,\n  n: 110,\n  r: 114,\n  s: 115,\n  t: 116,\n  u: 117,\n  openBrace: 123,\n  closeBrace: 125\n},\n      To = /[\\\\\"\\n]/g,\n      bo = {\n  onready: () => {},\n  onopenobject: () => {},\n  onkey: () => {},\n  oncloseobject: () => {},\n  onopenarray: () => {},\n  onclosearray: () => {},\n  onvalue: () => {},\n  onerror: () => {},\n  onend: () => {},\n  onchunkparsed: () => {}\n};\n\nclass Ey {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    this.options = bo, this.bufferCheckPosition = $s, this.q = \"\", this.c = \"\", this.p = \"\", this.closed = !1, this.closedRoot = !1, this.sawRoot = !1, this.error = null, this.state = M.BEGIN, this.stack = [], this.position = 0, this.column = 0, this.line = 1, this.slashed = !1, this.unicodeI = 0, this.unicodeS = null, this.depth = 0, this.textNode = void 0, this.numberNode = void 0, this.options = { ...bo,\n      ...t\n    }, this.textNode = void 0, this.numberNode = \"\", this.emit(\"onready\");\n  }\n\n  end() {\n    return (this.state !== M.VALUE || this.depth !== 0) && this._error(\"Unexpected end\"), this._closeValue(), this.c = \"\", this.closed = !0, this.emit(\"onend\"), this;\n  }\n\n  resume() {\n    return this.error = null, this;\n  }\n\n  close() {\n    return this.write(null);\n  }\n\n  emit(t, n) {\n    var s, r;\n    (s = (r = this.options)[t]) === null || s === void 0 || s.call(r, n, this);\n  }\n\n  emitNode(t, n) {\n    this._closeValue(), this.emit(t, n);\n  }\n\n  write(t) {\n    if (this.error) throw this.error;\n    if (this.closed) return this._error(\"Cannot write after close. Assign an onready handler.\");\n    if (t === null) return this.end();\n    let n = 0,\n        s = t.charCodeAt(0),\n        r = this.p;\n\n    for (; s && (r = s, this.c = s = t.charCodeAt(n++), r !== s ? this.p = r : r = this.p, !!s);) switch (this.position++, s === I.lineFeed ? (this.line++, this.column = 0) : this.column++, this.state) {\n      case M.BEGIN:\n        s === I.openBrace ? this.state = M.OPEN_OBJECT : s === I.openBracket ? this.state = M.OPEN_ARRAY : _e(s) || this._error(\"Non-whitespace before {[.\");\n        continue;\n\n      case M.OPEN_KEY:\n      case M.OPEN_OBJECT:\n        if (_e(s)) continue;\n        if (this.state === M.OPEN_KEY) this.stack.push(M.CLOSE_KEY);else if (s === I.closeBrace) {\n          this.emit(\"onopenobject\"), this.depth++, this.emit(\"oncloseobject\"), this.depth--, this.state = this.stack.pop() || M.VALUE;\n          continue;\n        } else this.stack.push(M.CLOSE_OBJECT);\n        s === I.doubleQuote ? this.state = M.STRING : this._error('Malformed object key should start with \"');\n        continue;\n\n      case M.CLOSE_KEY:\n      case M.CLOSE_OBJECT:\n        if (_e(s)) continue;\n        s === I.colon ? (this.state === M.CLOSE_OBJECT ? (this.stack.push(M.CLOSE_OBJECT), this._closeValue(\"onopenobject\"), this.depth++) : this._closeValue(\"onkey\"), this.state = M.VALUE) : s === I.closeBrace ? (this.emitNode(\"oncloseobject\"), this.depth--, this.state = this.stack.pop() || M.VALUE) : s === I.comma ? (this.state === M.CLOSE_OBJECT && this.stack.push(M.CLOSE_OBJECT), this._closeValue(), this.state = M.OPEN_KEY) : this._error(\"Bad object\");\n        continue;\n\n      case M.OPEN_ARRAY:\n      case M.VALUE:\n        if (_e(s)) continue;\n        if (this.state === M.OPEN_ARRAY) if (this.emit(\"onopenarray\"), this.depth++, this.state = M.VALUE, s === I.closeBracket) {\n          this.emit(\"onclosearray\"), this.depth--, this.state = this.stack.pop() || M.VALUE;\n          continue;\n        } else this.stack.push(M.CLOSE_ARRAY);\n        s === I.doubleQuote ? this.state = M.STRING : s === I.openBrace ? this.state = M.OPEN_OBJECT : s === I.openBracket ? this.state = M.OPEN_ARRAY : s === I.t ? this.state = M.TRUE : s === I.f ? this.state = M.FALSE : s === I.n ? this.state = M.NULL : s === I.minus ? this.numberNode += \"-\" : I._0 <= s && s <= I._9 ? (this.numberNode += String.fromCharCode(s), this.state = M.NUMBER_DIGIT) : this._error(\"Bad value\");\n        continue;\n\n      case M.CLOSE_ARRAY:\n        if (s === I.comma) this.stack.push(M.CLOSE_ARRAY), this._closeValue(\"onvalue\"), this.state = M.VALUE;else if (s === I.closeBracket) this.emitNode(\"onclosearray\"), this.depth--, this.state = this.stack.pop() || M.VALUE;else {\n          if (_e(s)) continue;\n\n          this._error(\"Bad array\");\n        }\n        continue;\n\n      case M.STRING:\n        this.textNode === void 0 && (this.textNode = \"\");\n        let i = n - 1,\n            o = this.slashed,\n            a = this.unicodeI;\n\n        t: for (;;) {\n          for (; a > 0;) if (this.unicodeS += String.fromCharCode(s), s = t.charCodeAt(n++), this.position++, a === 4 ? (this.textNode += String.fromCharCode(parseInt(this.unicodeS, 16)), a = 0, i = n - 1) : a++, !s) break t;\n\n          if (s === I.doubleQuote && !o) {\n            this.state = this.stack.pop() || M.VALUE, this.textNode += t.substring(i, n - 1), this.position += n - 1 - i;\n            break;\n          }\n\n          if (s === I.backslash && !o && (o = !0, this.textNode += t.substring(i, n - 1), this.position += n - 1 - i, s = t.charCodeAt(n++), this.position++, !s)) break;\n\n          if (o) {\n            if (o = !1, s === I.n ? this.textNode += `\n` : s === I.r ? this.textNode += \"\\r\" : s === I.t ? this.textNode += \"\t\" : s === I.f ? this.textNode += \"\\f\" : s === I.b ? this.textNode += \"\\b\" : s === I.u ? (a = 1, this.unicodeS = \"\") : this.textNode += String.fromCharCode(s), s = t.charCodeAt(n++), this.position++, i = n - 1, s) continue;\n            break;\n          }\n\n          To.lastIndex = n;\n          const c = To.exec(t);\n\n          if (c === null) {\n            n = t.length + 1, this.textNode += t.substring(i, n - 1), this.position += n - 1 - i;\n            break;\n          }\n\n          if (n = c.index + 1, s = t.charCodeAt(c.index), !s) {\n            this.textNode += t.substring(i, n - 1), this.position += n - 1 - i;\n            break;\n          }\n        }\n\n        this.slashed = o, this.unicodeI = a;\n        continue;\n\n      case M.TRUE:\n        s === I.r ? this.state = M.TRUE2 : this._error(`Invalid true started with t${s}`);\n        continue;\n\n      case M.TRUE2:\n        s === I.u ? this.state = M.TRUE3 : this._error(`Invalid true started with tr${s}`);\n        continue;\n\n      case M.TRUE3:\n        s === I.e ? (this.emit(\"onvalue\", !0), this.state = this.stack.pop() || M.VALUE) : this._error(`Invalid true started with tru${s}`);\n        continue;\n\n      case M.FALSE:\n        s === I.a ? this.state = M.FALSE2 : this._error(`Invalid false started with f${s}`);\n        continue;\n\n      case M.FALSE2:\n        s === I.l ? this.state = M.FALSE3 : this._error(`Invalid false started with fa${s}`);\n        continue;\n\n      case M.FALSE3:\n        s === I.s ? this.state = M.FALSE4 : this._error(`Invalid false started with fal${s}`);\n        continue;\n\n      case M.FALSE4:\n        s === I.e ? (this.emit(\"onvalue\", !1), this.state = this.stack.pop() || M.VALUE) : this._error(`Invalid false started with fals${s}`);\n        continue;\n\n      case M.NULL:\n        s === I.u ? this.state = M.NULL2 : this._error(`Invalid null started with n${s}`);\n        continue;\n\n      case M.NULL2:\n        s === I.l ? this.state = M.NULL3 : this._error(`Invalid null started with nu${s}`);\n        continue;\n\n      case M.NULL3:\n        s === I.l ? (this.emit(\"onvalue\", null), this.state = this.stack.pop() || M.VALUE) : this._error(`Invalid null started with nul${s}`);\n        continue;\n\n      case M.NUMBER_DECIMAL_POINT:\n        s === I.period ? (this.numberNode += \".\", this.state = M.NUMBER_DIGIT) : this._error(\"Leading zero not followed by .\");\n        continue;\n\n      case M.NUMBER_DIGIT:\n        I._0 <= s && s <= I._9 ? this.numberNode += String.fromCharCode(s) : s === I.period ? (this.numberNode.indexOf(\".\") !== -1 && this._error(\"Invalid number has two dots\"), this.numberNode += \".\") : s === I.e || s === I.E ? ((this.numberNode.indexOf(\"e\") !== -1 || this.numberNode.indexOf(\"E\") !== -1) && this._error(\"Invalid number has two exponential\"), this.numberNode += \"e\") : s === I.plus || s === I.minus ? (r === I.e || r === I.E || this._error(\"Invalid symbol in number\"), this.numberNode += String.fromCharCode(s)) : (this._closeNumber(), n--, this.state = this.stack.pop() || M.VALUE);\n        continue;\n\n      default:\n        this._error(`Unknown state: ${this.state}`);\n\n    }\n\n    return this.position >= this.bufferCheckPosition && Ty(this), this.emit(\"onchunkparsed\"), this;\n  }\n\n  _closeValue() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"onvalue\";\n    this.textNode !== void 0 && this.emit(t, this.textNode), this.textNode = void 0;\n  }\n\n  _closeNumber() {\n    this.numberNode && this.emit(\"onvalue\", parseFloat(this.numberNode)), this.numberNode = \"\";\n  }\n\n  _error() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n    this._closeValue(), t += `\nLine: ${this.line}\nColumn: ${this.column}\nChar: ${this.c}`;\n    const n = new Error(t);\n    this.error = n, this.emit(\"onerror\", n);\n  }\n\n}\n\nfunction _e(e) {\n  return e === I.carriageReturn || e === I.lineFeed || e === I.space || e === I.tab;\n}\n\nfunction Ty(e) {\n  const t = Math.max($s, 10);\n  let n = 0;\n\n  for (const s of [\"textNode\", \"numberNode\"]) {\n    const r = e[s] === void 0 ? 0 : e[s].length;\n    if (r > t) switch (s) {\n      case \"text\":\n        break;\n\n      default:\n        e._error(`Max buffer length exceeded: ${s}`);\n\n    }\n    n = Math.max(n, r);\n  }\n\n  e.bufferCheckPosition = $s - n + e.position;\n}\n\nclass Qt {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n\n    if (this.path = void 0, this.path = [\"$\"], t instanceof Qt) {\n      this.path = [...t.path];\n      return;\n    }\n\n    if (Array.isArray(t)) {\n      this.path.push(...t);\n      return;\n    }\n\n    if (typeof t == \"string\" && (this.path = t.split(\".\"), this.path[0] !== \"$\")) throw new Error(\"JSONPaths must start with $\");\n  }\n\n  clone() {\n    return new Qt(this);\n  }\n\n  toString() {\n    return this.path.join(\".\");\n  }\n\n  push(t) {\n    this.path.push(t);\n  }\n\n  pop() {\n    return this.path.pop();\n  }\n\n  set(t) {\n    this.path[this.path.length - 1] = t;\n  }\n\n  equals(t) {\n    if (!this || !t || this.path.length !== t.path.length) return !1;\n\n    for (let n = 0; n < this.path.length; ++n) if (this.path[n] !== t.path[n]) return !1;\n\n    return !0;\n  }\n\n  setFieldAtPath(t, n) {\n    const s = [...this.path];\n    s.shift();\n    const r = s.pop();\n\n    for (const i of s) t = t[i];\n\n    t[r] = n;\n  }\n\n  getFieldAtPath(t) {\n    const n = [...this.path];\n    n.shift();\n    const s = n.pop();\n\n    for (const r of n) t = t[r];\n\n    return t[s];\n  }\n\n}\n\nclass by {\n  constructor(t) {\n    this.parser = void 0, this.result = void 0, this.previousStates = [], this.currentState = Object.freeze({\n      container: [],\n      key: null\n    }), this.jsonpath = new Qt(), this.reset(), this.parser = new Ey({\n      onready: () => {\n        this.jsonpath = new Qt(), this.previousStates.length = 0, this.currentState.container.length = 0;\n      },\n      onopenobject: n => {\n        this._openObject({}), typeof n < \"u\" && this.parser.emit(\"onkey\", n);\n      },\n      onkey: n => {\n        this.jsonpath.set(n), this.currentState.key = n;\n      },\n      oncloseobject: () => {\n        this._closeObject();\n      },\n      onopenarray: () => {\n        this._openArray();\n      },\n      onclosearray: () => {\n        this._closeArray();\n      },\n      onvalue: n => {\n        this._pushOrSet(n);\n      },\n      onerror: n => {\n        throw n;\n      },\n      onend: () => {\n        this.result = this.currentState.container.pop();\n      },\n      ...t\n    });\n  }\n\n  reset() {\n    this.result = void 0, this.previousStates = [], this.currentState = Object.freeze({\n      container: [],\n      key: null\n    }), this.jsonpath = new Qt();\n  }\n\n  write(t) {\n    this.parser.write(t);\n  }\n\n  close() {\n    this.parser.close();\n  }\n\n  _pushOrSet(t) {\n    const {\n      container: n,\n      key: s\n    } = this.currentState;\n    s !== null ? (n[s] = t, this.currentState.key = null) : n.push(t);\n  }\n\n  _openArray() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    this.jsonpath.push(null), this._pushOrSet(t), this.previousStates.push(this.currentState), this.currentState = {\n      container: t,\n      isArray: !0,\n      key: null\n    };\n  }\n\n  _closeArray() {\n    this.jsonpath.pop(), this.currentState = this.previousStates.pop();\n  }\n\n  _openObject() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    this.jsonpath.push(null), this._pushOrSet(t), this.previousStates.push(this.currentState), this.currentState = {\n      container: t,\n      isArray: !1,\n      key: null\n    };\n  }\n\n  _closeObject() {\n    this.jsonpath.pop(), this.currentState = this.previousStates.pop();\n  }\n\n}\n\nclass _y extends by {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    super({\n      onopenarray: () => {\n        if (!this.streamingArray && this._matchJSONPath()) {\n          this.streamingJsonPath = this.getJsonPath().clone(), this.streamingArray = [], this._openArray(this.streamingArray);\n          return;\n        }\n\n        this._openArray();\n      },\n      onopenobject: s => {\n        this.topLevelObject ? this._openObject({}) : (this.topLevelObject = {}, this._openObject(this.topLevelObject)), typeof s < \"u\" && this.parser.emit(\"onkey\", s);\n      }\n    }), this.jsonPaths = void 0, this.streamingJsonPath = null, this.streamingArray = null, this.topLevelObject = null;\n    const n = t.jsonpaths || [];\n    this.jsonPaths = n.map(s => new Qt(s));\n  }\n\n  write(t) {\n    super.write(t);\n    let n = [];\n    return this.streamingArray && (n = [...this.streamingArray], this.streamingArray.length = 0), n;\n  }\n\n  getPartialResult() {\n    return this.topLevelObject;\n  }\n\n  getStreamingJsonPath() {\n    return this.streamingJsonPath;\n  }\n\n  getStreamingJsonPathAsString() {\n    return this.streamingJsonPath && this.streamingJsonPath.toString();\n  }\n\n  getJsonPath() {\n    return this.jsonpath;\n  }\n\n  _matchJSONPath() {\n    const t = this.getJsonPath();\n    if (this.jsonPaths.length === 0) return !0;\n\n    for (const n of this.jsonPaths) if (n.equals(t)) return !0;\n\n    return !1;\n  }\n\n}\n\nasync function* wy(e, t) {\n  const n = Cy(e),\n        {\n    metadata: s\n  } = t,\n        {\n    jsonpaths: r\n  } = t.json || {};\n  let i = !0;\n  const o = null,\n        a = new Le(o, t),\n        c = new _y({\n    jsonpaths: r\n  });\n\n  for await (const f of n) {\n    const d = c.write(f),\n          m = d.length > 0 && c.getStreamingJsonPathAsString();\n\n    if (d.length > 0 && i) {\n      if (s) {\n        var u;\n        yield {\n          shape: (t == null || (u = t.json) === null || u === void 0 ? void 0 : u.shape) || \"array-row-table\",\n          batchType: \"partial-result\",\n          data: [],\n          length: 0,\n          bytesUsed: 0,\n          container: c.getPartialResult(),\n          jsonpath: m\n        };\n      }\n\n      i = !1;\n    }\n\n    for (const p of d) {\n      a.addRow(p);\n      const C = a.getFullBatch({\n        jsonpath: m\n      });\n      C && (yield C);\n    }\n\n    a.chunkComplete(f);\n    const g = a.getFullBatch({\n      jsonpath: m\n    });\n    g && (yield g);\n  }\n\n  const l = c.getStreamingJsonPathAsString(),\n        h = a.getFinalBatch({\n    jsonpath: l\n  });\n  h && (yield h), s && (yield {\n    shape: \"json\",\n    batchType: \"final-result\",\n    container: c.getPartialResult(),\n    jsonpath: c.getStreamingJsonPathAsString(),\n    data: [],\n    length: 0\n  });\n}\n\nconst vn = {\n  x: 0,\n  y: 1,\n  z: 2\n};\n\nfunction mc(e, t = {}) {\n  const {\n    start: n = 0,\n    end: s = e.length,\n    plane: r = \"xy\"\n  } = t,\n        i = t.size || 2;\n  let o = 0;\n  const a = vn[r[0]],\n        c = vn[r[1]];\n\n  for (let u = n, l = s - i; u < s; u += i) o += (e[u + a] - e[l + a]) * (e[u + c] + e[l + c]), l = u;\n\n  return o / 2;\n}\n\nfunction Ry(e, t, n = 2, s, r = \"xy\") {\n  const i = t && t.length,\n        o = i ? t[0] * n : e.length;\n  let a = gc(e, 0, o, n, !0, s && s[0], r);\n  const c = [];\n  if (!a || a.next === a.prev) return c;\n  let u, l, h, f, d, m, g;\n\n  if (i && (a = Oy(e, t, a, n, s, r)), e.length > 80 * n) {\n    f = l = e[0], d = h = e[1];\n\n    for (let p = n; p < o; p += n) m = e[p], g = e[p + 1], m < f && (f = m), g < d && (d = g), m > l && (l = m), g > h && (h = g);\n\n    u = Math.max(l - f, h - d), u = u !== 0 ? 32767 / u : 0;\n  }\n\n  return Ge(a, c, n, f, d, u, 0), c;\n}\n\nfunction gc(e, t, n, s, r, i, o) {\n  let a, c;\n  i === void 0 && (i = mc(e, {\n    start: t,\n    end: n,\n    size: s,\n    plane: o\n  }));\n  let u = vn[o[0]],\n      l = vn[o[1]];\n  if (r === i < 0) for (a = t; a < n; a += s) c = _o(a, e[a + u], e[a + l], c);else for (a = n - s; a >= t; a -= s) c = _o(a, e[a + u], e[a + l], c);\n  return c && Kn(c, c.next) && (Ne(c), c = c.next), c;\n}\n\nfunction Yt(e, t) {\n  if (!e) return e;\n  t || (t = e);\n  let n = e,\n      s;\n\n  do if (s = !1, !n.steiner && (Kn(n, n.next) || X(n.prev, n, n.next) === 0)) {\n    if (Ne(n), n = t = n.prev, n === n.next) break;\n    s = !0;\n  } else n = n.next; while (s || n !== t);\n\n  return t;\n}\n\nfunction Ge(e, t, n, s, r, i, o) {\n  if (!e) return;\n  !o && i && Gy(e, s, r, i);\n  let a = e,\n      c,\n      u;\n\n  for (; e.prev !== e.next;) {\n    if (c = e.prev, u = e.next, i ? Iy(e, s, r, i) : My(e)) {\n      t.push(c.i / n | 0), t.push(e.i / n | 0), t.push(u.i / n | 0), Ne(e), e = u.next, a = u.next;\n      continue;\n    }\n\n    if (e = u, e === a) {\n      o ? o === 1 ? (e = Sy(Yt(e), t, n), Ge(e, t, n, s, r, i, 2)) : o === 2 && xy(e, t, n, s, r, i) : Ge(Yt(e), t, n, s, r, i, 1);\n      break;\n    }\n  }\n}\n\nfunction My(e) {\n  const t = e.prev,\n        n = e,\n        s = e.next;\n  if (X(t, n, s) >= 0) return !1;\n  const r = t.x,\n        i = n.x,\n        o = s.x,\n        a = t.y,\n        c = n.y,\n        u = s.y,\n        l = r < i ? r < o ? r : o : i < o ? i : o,\n        h = a < c ? a < u ? a : u : c < u ? c : u,\n        f = r > i ? r > o ? r : o : i > o ? i : o,\n        d = a > c ? a > u ? a : u : c > u ? c : u;\n  let m = s.next;\n\n  for (; m !== t;) {\n    if (m.x >= l && m.x <= f && m.y >= h && m.y <= d && he(r, a, i, c, o, u, m.x, m.y) && X(m.prev, m, m.next) >= 0) return !1;\n    m = m.next;\n  }\n\n  return !0;\n}\n\nfunction Iy(e, t, n, s) {\n  const r = e.prev,\n        i = e,\n        o = e.next;\n  if (X(r, i, o) >= 0) return !1;\n  const a = r.x,\n        c = i.x,\n        u = o.x,\n        l = r.y,\n        h = i.y,\n        f = o.y,\n        d = a < c ? a < u ? a : u : c < u ? c : u,\n        m = l < h ? l < f ? l : f : h < f ? h : f,\n        g = a > c ? a > u ? a : u : c > u ? c : u,\n        p = l > h ? l > f ? l : f : h > f ? h : f,\n        C = Zs(d, m, t, n, s),\n        w = Zs(g, p, t, n, s);\n  let y = e.prevZ,\n      B = e.nextZ;\n\n  for (; y && y.z >= C && B && B.z <= w;) {\n    if (y.x >= d && y.x <= g && y.y >= m && y.y <= p && y !== r && y !== o && he(a, l, c, h, u, f, y.x, y.y) && X(y.prev, y, y.next) >= 0 || (y = y.prevZ, B.x >= d && B.x <= g && B.y >= m && B.y <= p && B !== r && B !== o && he(a, l, c, h, u, f, B.x, B.y) && X(B.prev, B, B.next) >= 0)) return !1;\n    B = B.nextZ;\n  }\n\n  for (; y && y.z >= C;) {\n    if (y.x >= d && y.x <= g && y.y >= m && y.y <= p && y !== r && y !== o && he(a, l, c, h, u, f, y.x, y.y) && X(y.prev, y, y.next) >= 0) return !1;\n    y = y.prevZ;\n  }\n\n  for (; B && B.z <= w;) {\n    if (B.x >= d && B.x <= g && B.y >= m && B.y <= p && B !== r && B !== o && he(a, l, c, h, u, f, B.x, B.y) && X(B.prev, B, B.next) >= 0) return !1;\n    B = B.nextZ;\n  }\n\n  return !0;\n}\n\nfunction Sy(e, t, n) {\n  let s = e;\n\n  do {\n    const r = s.prev,\n          i = s.next.next;\n    !Kn(r, i) && Ac(r, s, s.next, i) && Pe(r, i) && Pe(i, r) && (t.push(r.i / n | 0), t.push(s.i / n | 0), t.push(i.i / n | 0), Ne(s), Ne(s.next), s = e = i), s = s.next;\n  } while (s !== e);\n\n  return Yt(s);\n}\n\nfunction xy(e, t, n, s, r, i) {\n  let o = e;\n\n  do {\n    let a = o.next.next;\n\n    for (; a !== o.prev;) {\n      if (o.i !== a.i && Uy(o, a)) {\n        let c = pc(o, a);\n        o = Yt(o, o.next), c = Yt(c, c.next), Ge(o, t, n, s, r, i, 0), Ge(c, t, n, s, r, i, 0);\n        return;\n      }\n\n      a = a.next;\n    }\n\n    o = o.next;\n  } while (o !== e);\n}\n\nfunction Oy(e, t, n, s, r, i) {\n  const o = [];\n  let a, c, u, l, h;\n\n  for (a = 0, c = t.length; a < c; a++) u = t[a] * s, l = a < c - 1 ? t[a + 1] * s : e.length, h = gc(e, u, l, s, !1, r && r[a + 1], i), h === h.next && (h.steiner = !0), o.push(Ny(h));\n\n  for (o.sort(Fy), a = 0; a < o.length; a++) n = vy(o[a], n);\n\n  return n;\n}\n\nfunction Fy(e, t) {\n  return e.x - t.x;\n}\n\nfunction vy(e, t) {\n  const n = Dy(e, t);\n  if (!n) return t;\n  const s = pc(n, e);\n  return Yt(s, s.next), Yt(n, n.next);\n}\n\nfunction Dy(e, t) {\n  let n = t;\n  const s = e.x,\n        r = e.y;\n  let i = -1 / 0,\n      o;\n\n  do {\n    if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {\n      const f = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);\n      if (f <= s && f > i && (i = f, o = n.x < n.next.x ? n : n.next, f === s)) return o;\n    }\n\n    n = n.next;\n  } while (n !== t);\n\n  if (!o) return null;\n  const a = o,\n        c = o.x,\n        u = o.y;\n  let l = 1 / 0,\n      h;\n  n = o;\n\n  do s >= n.x && n.x >= c && s !== n.x && he(r < u ? s : i, r, c, u, r < u ? i : s, r, n.x, n.y) && (h = Math.abs(r - n.y) / (s - n.x), Pe(n, e) && (h < l || h === l && (n.x > o.x || n.x === o.x && Ly(o, n))) && (o = n, l = h)), n = n.next; while (n !== a);\n\n  return o;\n}\n\nfunction Ly(e, t) {\n  return X(e.prev, e, t.prev) < 0 && X(t.next, e, e.next) < 0;\n}\n\nfunction Gy(e, t, n, s) {\n  let r = e;\n\n  do r.z === 0 && (r.z = Zs(r.x, r.y, t, n, s)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next; while (r !== e);\n\n  r.prevZ.nextZ = null, r.prevZ = null, Py(r);\n}\n\nfunction Py(e) {\n  let t,\n      n,\n      s = 1,\n      r,\n      i,\n      o,\n      a,\n      c,\n      u;\n\n  do {\n    for (i = e, e = null, u = null, r = 0; i;) {\n      for (r++, a = i, o = 0, n = 0; n < s && (o++, a = a.nextZ, !!a); n++);\n\n      for (c = s; o > 0 || c > 0 && a;) o !== 0 && (c === 0 || !a || i.z <= a.z) ? (t = i, i = i.nextZ, o--) : (t = a, a = a.nextZ, c--), u ? u.nextZ = t : e = t, t.prevZ = u, u = t;\n\n      i = a;\n    }\n\n    u.nextZ = null, s *= 2;\n  } while (r > 1);\n\n  return e;\n}\n\nfunction Zs(e, t, n, s, r) {\n  return e = (e - n) * r | 0, t = (t - s) * r | 0, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e | t << 1;\n}\n\nfunction Ny(e) {\n  let t = e,\n      n = e;\n\n  do (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next; while (t !== e);\n\n  return n;\n}\n\nfunction he(e, t, n, s, r, i, o, a) {\n  return (r - o) * (t - a) >= (e - o) * (i - a) && (e - o) * (s - a) >= (n - o) * (t - a) && (n - o) * (i - a) >= (r - o) * (s - a);\n}\n\nfunction Uy(e, t) {\n  return e.next.i !== t.i && e.prev.i !== t.i && !Hy(e, t) && ( // dones't intersect other edges\n  Pe(e, t) && Pe(t, e) && Jy(e, t) && ( // locally visible\n  X(e.prev, e, t.prev) || X(e, t.prev, t)) || // does not create opposite-facing sectors\n  Kn(e, t) && X(e.prev, e, e.next) > 0 && X(t.prev, t, t.next) > 0);\n}\n\nfunction X(e, t, n) {\n  return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);\n}\n\nfunction Kn(e, t) {\n  return e.x === t.x && e.y === t.y;\n}\n\nfunction Ac(e, t, n, s) {\n  const r = mn(X(e, t, n)),\n        i = mn(X(e, t, s)),\n        o = mn(X(n, s, e)),\n        a = mn(X(n, s, t));\n  return !!(r !== i && o !== a || r === 0 && dn(e, n, t) || i === 0 && dn(e, s, t) || o === 0 && dn(n, e, s) || a === 0 && dn(n, t, s));\n}\n\nfunction dn(e, t, n) {\n  return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y);\n}\n\nfunction mn(e) {\n  return e > 0 ? 1 : e < 0 ? -1 : 0;\n}\n\nfunction Hy(e, t) {\n  let n = e;\n\n  do {\n    if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && Ac(n, n.next, e, t)) return !0;\n    n = n.next;\n  } while (n !== e);\n\n  return !1;\n}\n\nfunction Pe(e, t) {\n  return X(e.prev, e, e.next) < 0 ? X(e, t, e.next) >= 0 && X(e, e.prev, t) >= 0 : X(e, t, e.prev) < 0 || X(e, e.next, t) < 0;\n}\n\nfunction Jy(e, t) {\n  let n = e,\n      s = !1;\n  const r = (e.x + t.x) / 2,\n        i = (e.y + t.y) / 2;\n\n  do n.y > i != n.next.y > i && n.next.y !== n.y && r < (n.next.x - n.x) * (i - n.y) / (n.next.y - n.y) + n.x && (s = !s), n = n.next; while (n !== e);\n\n  return s;\n}\n\nfunction pc(e, t) {\n  const n = new tr(e.i, e.x, e.y),\n        s = new tr(t.i, t.x, t.y),\n        r = e.next,\n        i = t.prev;\n  return e.next = t, t.prev = e, n.next = r, r.prev = n, s.next = n, n.prev = s, i.next = s, s.prev = i, s;\n}\n\nfunction _o(e, t, n, s) {\n  const r = new tr(e, t, n);\n  return s ? (r.next = s.next, r.prev = s, s.next.prev = r, s.next = r) : (r.prev = r, r.next = r), r;\n}\n\nfunction Ne(e) {\n  e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ);\n}\n\nclass tr {\n  constructor(t, n, s) {\n    this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1, this.i = t, this.x = n, this.y = s;\n  }\n\n}\n\nfunction Vy(e, t, n) {\n  const s = jy(e),\n        r = Object.keys(s).filter(i => s[i] !== Array);\n  return ky(e, {\n    propArrayTypes: s,\n    ...t\n  }, {\n    numericPropKeys: n && n.numericPropKeys || r,\n    PositionDataType: n ? n.PositionDataType : Float32Array,\n    triangulate: n ? n.triangulate : !0\n  });\n}\n\nfunction jy(e) {\n  const t = {};\n\n  for (const n of e) if (n.properties) for (const s in n.properties) {\n    const r = n.properties[s];\n    t[s] = qy(r, t[s]);\n  }\n\n  return t;\n}\n\nfunction ky(e, t, n) {\n  const {\n    pointPositionsCount: s,\n    pointFeaturesCount: r,\n    linePositionsCount: i,\n    linePathsCount: o,\n    lineFeaturesCount: a,\n    polygonPositionsCount: c,\n    polygonObjectsCount: u,\n    polygonRingsCount: l,\n    polygonFeaturesCount: h,\n    propArrayTypes: f,\n    coordLength: d\n  } = t,\n        {\n    numericPropKeys: m = [],\n    PositionDataType: g = Float32Array,\n    triangulate: p = !0\n  } = n,\n        C = e[0] && \"id\" in e[0],\n        w = e.length > 65535 ? Uint32Array : Uint16Array,\n        y = {\n    type: \"Point\",\n    positions: new g(s * d),\n    globalFeatureIds: new w(s),\n    featureIds: r > 65535 ? new Uint32Array(s) : new Uint16Array(s),\n    numericProps: {},\n    properties: [],\n    fields: []\n  },\n        B = {\n    type: \"LineString\",\n    pathIndices: i > 65535 ? new Uint32Array(o + 1) : new Uint16Array(o + 1),\n    positions: new g(i * d),\n    globalFeatureIds: new w(i),\n    featureIds: a > 65535 ? new Uint32Array(i) : new Uint16Array(i),\n    numericProps: {},\n    properties: [],\n    fields: []\n  },\n        R = {\n    type: \"Polygon\",\n    polygonIndices: c > 65535 ? new Uint32Array(u + 1) : new Uint16Array(u + 1),\n    primitivePolygonIndices: c > 65535 ? new Uint32Array(l + 1) : new Uint16Array(l + 1),\n    positions: new g(c * d),\n    globalFeatureIds: new w(c),\n    featureIds: h > 65535 ? new Uint32Array(c) : new Uint16Array(c),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  p && (R.triangles = []);\n\n  for (const O of [y, B, R]) for (const F of m) {\n    const x = f[F];\n    O.numericProps[F] = new x(O.positions.length / d);\n  }\n\n  B.pathIndices[o] = i, R.polygonIndices[u] = c, R.primitivePolygonIndices[l] = c;\n  const E = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n\n  for (const O of e) {\n    const F = O.geometry,\n          x = O.properties || {};\n\n    switch (F.type) {\n      case \"Point\":\n        Ky(F, y, E, d, x), y.properties.push(Ss(x, m)), C && y.fields.push({\n          id: O.id\n        }), E.pointFeature++;\n        break;\n\n      case \"LineString\":\n        zy(F, B, E, d, x), B.properties.push(Ss(x, m)), C && B.fields.push({\n          id: O.id\n        }), E.lineFeature++;\n        break;\n\n      case \"Polygon\":\n        Wy(F, R, E, d, x), R.properties.push(Ss(x, m)), C && R.fields.push({\n          id: O.id\n        }), E.polygonFeature++;\n        break;\n\n      default:\n        throw new Error(\"Invalid geometry type\");\n    }\n\n    E.feature++;\n  }\n\n  return Qy(y, B, R, d);\n}\n\nfunction Ky(e, t, n, s, r) {\n  t.positions.set(e.data, n.pointPosition * s);\n  const i = e.data.length / s;\n  Or(t, r, n.pointPosition, i), t.globalFeatureIds.fill(n.feature, n.pointPosition, n.pointPosition + i), t.featureIds.fill(n.pointFeature, n.pointPosition, n.pointPosition + i), n.pointPosition += i;\n}\n\nfunction zy(e, t, n, s, r) {\n  t.positions.set(e.data, n.linePosition * s);\n  const i = e.data.length / s;\n  Or(t, r, n.linePosition, i), t.globalFeatureIds.fill(n.feature, n.linePosition, n.linePosition + i), t.featureIds.fill(n.lineFeature, n.linePosition, n.linePosition + i);\n\n  for (let o = 0, a = e.indices.length; o < a; ++o) {\n    const c = e.indices[o],\n          u = o === a - 1 ? e.data.length : e.indices[o + 1];\n    t.pathIndices[n.linePath++] = n.linePosition, n.linePosition += (u - c) / s;\n  }\n}\n\nfunction Wy(e, t, n, s, r) {\n  t.positions.set(e.data, n.polygonPosition * s);\n  const i = e.data.length / s;\n  Or(t, r, n.polygonPosition, i), t.globalFeatureIds.fill(n.feature, n.polygonPosition, n.polygonPosition + i), t.featureIds.fill(n.polygonFeature, n.polygonPosition, n.polygonPosition + i);\n\n  for (let o = 0, a = e.indices.length; o < a; ++o) {\n    const c = n.polygonPosition;\n    t.polygonIndices[n.polygonObject++] = c;\n    const u = e.areas[o],\n          l = e.indices[o],\n          h = e.indices[o + 1];\n\n    for (let d = 0, m = l.length; d < m; ++d) {\n      const g = l[d],\n            p = d === m - 1 ? h === void 0 ? e.data.length : h[0] : l[d + 1];\n      t.primitivePolygonIndices[n.polygonRing++] = n.polygonPosition, n.polygonPosition += (p - g) / s;\n    }\n\n    const f = n.polygonPosition;\n    Xy(t, u, l, {\n      startPosition: c,\n      endPosition: f,\n      coordLength: s\n    });\n  }\n}\n\nfunction Xy(e, t, n, s) {\n  let {\n    startPosition: r,\n    endPosition: i,\n    coordLength: o\n  } = s;\n  if (!e.triangles) return;\n  const a = r * o,\n        c = i * o,\n        u = e.positions.subarray(a, c),\n        l = n[0],\n        h = n.slice(1).map(d => (d - l) / o),\n        f = Ry(u, h, o, t);\n\n  for (let d = 0, m = f.length; d < m; ++d) e.triangles.push(r + f[d]);\n}\n\nfunction Is(e, t) {\n  const n = {};\n\n  for (const s in e) n[s] = {\n    value: e[s],\n    size: t\n  };\n\n  return n;\n}\n\nfunction Qy(e, t, n, s) {\n  const r = {\n    shape: \"binary-feature-collection\",\n    points: { ...e,\n      positions: {\n        value: e.positions,\n        size: s\n      },\n      globalFeatureIds: {\n        value: e.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: e.featureIds,\n        size: 1\n      },\n      numericProps: Is(e.numericProps, 1)\n    },\n    lines: { ...t,\n      positions: {\n        value: t.positions,\n        size: s\n      },\n      pathIndices: {\n        value: t.pathIndices,\n        size: 1\n      },\n      globalFeatureIds: {\n        value: t.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: t.featureIds,\n        size: 1\n      },\n      numericProps: Is(t.numericProps, 1)\n    },\n    polygons: { ...n,\n      positions: {\n        value: n.positions,\n        size: s\n      },\n      polygonIndices: {\n        value: n.polygonIndices,\n        size: 1\n      },\n      primitivePolygonIndices: {\n        value: n.primitivePolygonIndices,\n        size: 1\n      },\n      globalFeatureIds: {\n        value: n.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: n.featureIds,\n        size: 1\n      },\n      numericProps: Is(n.numericProps, 1)\n    }\n  };\n  return r.polygons && n.triangles && (r.polygons.triangles = {\n    value: new Uint32Array(n.triangles),\n    size: 1\n  }), r;\n}\n\nfunction Or(e, t, n, s) {\n  for (const r in e.numericProps) if (r in t) {\n    const i = t[r];\n    e.numericProps[r].fill(i, n, n + s);\n  }\n}\n\nfunction Ss(e, t) {\n  const n = {};\n\n  for (const s in e) t.includes(s) || (n[s] = e[s]);\n\n  return n;\n}\n\nfunction qy(e, t) {\n  return t === Array || !Number.isFinite(e) ? Array : t === Float64Array || Math.fround(e) !== e ? Float64Array : Float32Array;\n}\n\nfunction Yy(e) {\n  let t = 0,\n      n = 0,\n      s = 0,\n      r = 0,\n      i = 0,\n      o = 0,\n      a = 0,\n      c = 0,\n      u = 0;\n  const l = /* @__PURE__ */new Set();\n\n  for (const h of e) {\n    const f = h.geometry;\n\n    switch (f.type) {\n      case \"Point\":\n        n++, t++, l.add(f.coordinates.length);\n        break;\n\n      case \"MultiPoint\":\n        n++, t += f.coordinates.length;\n\n        for (const m of f.coordinates) l.add(m.length);\n\n        break;\n\n      case \"LineString\":\n        i++, s += f.coordinates.length, r++;\n\n        for (const m of f.coordinates) l.add(m.length);\n\n        break;\n\n      case \"MultiLineString\":\n        i++;\n\n        for (const m of f.coordinates) {\n          s += m.length, r++;\n\n          for (const g of m) l.add(g.length);\n        }\n\n        break;\n\n      case \"Polygon\":\n        u++, a++, c += f.coordinates.length;\n        const d = f.coordinates.flat();\n        o += d.length;\n\n        for (const m of d) l.add(m.length);\n\n        break;\n\n      case \"MultiPolygon\":\n        u++;\n\n        for (const m of f.coordinates) {\n          a++, c += m.length;\n          const g = m.flat();\n          o += g.length;\n\n          for (const p of g) l.add(p.length);\n        }\n\n        break;\n\n      default:\n        throw new Error(`Unsupported geometry type: ${f.type}`);\n    }\n  }\n\n  return {\n    coordLength: l.size > 0 ? Math.max(...l) : 2,\n    pointPositionsCount: t,\n    pointFeaturesCount: n,\n    linePositionsCount: s,\n    linePathsCount: r,\n    lineFeaturesCount: i,\n    polygonPositionsCount: o,\n    polygonObjectsCount: a,\n    polygonRingsCount: c,\n    polygonFeaturesCount: u\n  };\n}\n\nfunction $y(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n    coordLength: 2,\n    fixRingWinding: !0\n  };\n  return e.map(n => Zy(n, t));\n}\n\nfunction wo(e, t, n, s) {\n  n.push(t.length), t.push(...e);\n\n  for (let r = e.length; r < s.coordLength; r++) t.push(0);\n}\n\nfunction er(e, t, n, s) {\n  n.push(t.length);\n\n  for (const r of e) {\n    t.push(...r);\n\n    for (let i = r.length; i < s.coordLength; i++) t.push(0);\n  }\n}\n\nfunction Ro(e, t, n, s, r) {\n  let i = 0;\n  const o = [],\n        a = [];\n\n  for (const c of e) {\n    const u = c.map(f => f.slice(0, 2));\n    let l = mc(u.flat());\n    const h = l < 0;\n    r.fixRingWinding && (i === 0 && !h || i > 0 && h) && (c.reverse(), l = -l), o.push(l), er(c, t, a, r), i++;\n  }\n\n  i > 0 && (s.push(o), n.push(a));\n}\n\nfunction Zy(e, t) {\n  const {\n    geometry: n\n  } = e;\n  if (n.type === \"GeometryCollection\") throw new Error(\"GeometryCollection type not supported\");\n  const s = [],\n        r = [];\n  let i, o;\n\n  switch (n.type) {\n    case \"Point\":\n      o = \"Point\", wo(n.coordinates, s, r, t);\n      break;\n\n    case \"MultiPoint\":\n      o = \"Point\", n.coordinates.map(a => wo(a, s, r, t));\n      break;\n\n    case \"LineString\":\n      o = \"LineString\", er(n.coordinates, s, r, t);\n      break;\n\n    case \"MultiLineString\":\n      o = \"LineString\", n.coordinates.map(a => er(a, s, r, t));\n      break;\n\n    case \"Polygon\":\n      o = \"Polygon\", i = [], Ro(n.coordinates, s, r, i, t);\n      break;\n\n    case \"MultiPolygon\":\n      o = \"Polygon\", i = [], n.coordinates.map(a => Ro(a, s, r, i, t));\n      break;\n\n    default:\n      throw new Error(`Unknown type: ${o}`);\n  }\n\n  return { ...e,\n    geometry: {\n      type: o,\n      indices: r,\n      data: s,\n      areas: i\n    }\n  };\n}\n\nfunction yc(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n    fixRingWinding: !0,\n    triangulate: !0\n  };\n  const n = Yy(e),\n        s = n.coordLength,\n        {\n    fixRingWinding: r\n  } = t,\n        i = $y(e, {\n    coordLength: s,\n    fixRingWinding: r\n  });\n  return Vy(i, n, {\n    numericPropKeys: t.numericPropKeys,\n    PositionDataType: t.PositionDataType || Float32Array,\n    triangulate: t.triangulate\n  });\n}\n\nconst tB = \"4.1.4\",\n      eB = {\n  name: \"GeoJSON\",\n  id: \"geojson\",\n  module: \"geojson\",\n  version: tB,\n  worker: !0,\n  extensions: [\"geojson\"],\n  mimeTypes: [\"application/geo+json\"],\n  category: \"geometry\",\n  text: !0,\n  options: {\n    geojson: {\n      shape: \"object-row-table\"\n    },\n    json: {\n      shape: \"object-row-table\",\n      jsonpaths: [\"$\", \"$.features\"]\n    },\n    gis: {\n      format: \"geojson\"\n    }\n  }\n},\n      Ue = { ...eB,\n  parse: nB,\n  parseTextSync: Bc,\n  parseInBatches: sB\n};\n\nasync function nB(e, t) {\n  return Bc(new TextDecoder().decode(e), t);\n}\n\nfunction Bc(e, t) {\n  var n;\n  t = { ...Ue.options,\n    ...t\n  }, t.geojson = { ...Ue.options.geojson,\n    ...t.geojson\n  }, t.gis = t.gis || {};\n  let s;\n\n  try {\n    s = JSON.parse(e);\n  } catch {\n    s = {};\n  }\n\n  const r = {\n    shape: \"geojson-table\",\n    type: \"FeatureCollection\",\n    features: ((n = s) === null || n === void 0 ? void 0 : n.features) || []\n  };\n\n  switch (t.gis.format) {\n    case \"binary\":\n      return yc(r.features);\n\n    default:\n      return r;\n  }\n}\n\nfunction sB(e, t) {\n  t = { ...Ue.options,\n    ...t\n  }, t.json = { ...Ue.options.geojson,\n    ...t.geojson\n  };\n  const n = wy(e, t);\n\n  switch (t.gis.format) {\n    case \"binary\":\n      return rB(n);\n\n    default:\n      return n;\n  }\n}\n\nasync function* rB(e) {\n  for await (const t of e) t.data = yc(t.data), yield t;\n}\n\nfunction iB(e) {\n  let t = 0;\n\n  for (const s in e.attributes) {\n    const r = e.getAttribute(s);\n    t += r.count * r.itemSize * r.array.BYTES_PER_ELEMENT;\n  }\n\n  const n = e.getIndex();\n  return t += n ? n.count * n.itemSize * n.array.BYTES_PER_ELEMENT : 0, t;\n}\n\nfunction Cc(e) {\n  const n = document.createElement(\"canvas\");\n  n.width = 64, n.height = 64;\n  const s = n.getContext(\"2d\");\n  s.rect(0, 0, 64, 64);\n  const r = s.createLinearGradient(0, 0, 64, 64);\n\n  for (let o = 0; o < e.length; o++) {\n    const a = e[o];\n    r.addColorStop(a[0], \"#\" + a[1].getHexString());\n  }\n\n  s.fillStyle = r, s.fill();\n  const i = new three__WEBPACK_IMPORTED_MODULE_0__.CanvasTexture(n);\n  return i.needsUpdate = !0, i.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, i.wrapS = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping, i.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping, i.repeat.set(2, 2), i;\n}\n\nfunction Mo(e) {\n  e.updateMatrix(), e.updateMatrixWorld(), e.matrixWorldInverse.copy(e.matrixWorld).invert();\n  const t = new three__WEBPACK_IMPORTED_MODULE_0__.Frustum();\n  return t.setFromProjectionMatrix(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse)), t;\n}\n\nfunction oB(e) {\n  const t = new three__WEBPACK_IMPORTED_MODULE_0__.Group(),\n        n = new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(10, 5),\n        s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(...e.projectPointOntoPlane([0, 0, 0])),\n        r = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(e.normal.x, e.normal.y, e.normal.z),\n        i = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(s).add(r);\n  n.lookAt(i), n.translate(s.x, s.y, s.z);\n  const o = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n    color: 65535,\n    side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide\n  }),\n        a = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(n, o),\n        c = new three__WEBPACK_IMPORTED_MODULE_0__.ArrowHelper(r, s, 5, 16776960);\n  return t.add(c), t.add(a), t;\n}\n\nfunction Io(e) {\n  const {\n    boundingVolume: t\n  } = e;\n  let n = 0;\n  e.content && (n = Math.min(e.content.byteLength / 5e5, 1));\n  const s = new three__WEBPACK_IMPORTED_MODULE_0__.Color(n, 1, 0),\n        r = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(1, 1, 1),\n        i = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n  t.halfAxes ? i.copy(Ec(t.halfAxes)) : t.radius && r.scale(t.radius * 2, t.radius * 2, t.radius * 2), r.applyMatrix4(i);\n  const o = new three__WEBPACK_IMPORTED_MODULE_0__.EdgesGeometry(r),\n        a = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(o, new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({\n    color: s\n  }));\n  return a.position.copy(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(...t.center)), a;\n}\n\nfunction Ec(e) {\n  const t = e;\n  return new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray([t[0] * 2, t[1] * 2, t[2] * 2, 0, t[3] * 2, t[4] * 2, t[5] * 2, 0, t[6] * 2, t[7] * 2, t[8] * 2, 0, 0, 0, 0, 1]);\n}\n\nfunction aB(e, t) {\n  const r = 2 * Math.PI * 6378137 / 2,\n        i = t * r / 180;\n  let o = Math.log(Math.tan((90 + e) * Math.PI / 360)) / (Math.PI / 180);\n  return o = o * r / 180, new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(i, o);\n}\n\nfunction cB(e) {\n  let t = 0;\n\n  if (e.userData.mimeType == \"image/ktx2\" && e.mipmaps) {\n    for (let n = 0; n < e.mipmaps.length; n++) t += e.mipmaps[n].data.byteLength;\n\n    return t;\n  } else if (e.image) {\n    const {\n      image: n\n    } = e,\n          s = 4;\n    let r = [n.width, n.height];\n\n    for (; r[0] > 1 || r[1] > 1;) t += r[0] * r[1] * s, r[0] = Math.max(Math.floor(r[0] / 2), 1), r[1] = Math.max(Math.floor(r[1] / 2), 1);\n\n    return t += 1 * 1 * s, t;\n  } else return;\n}\n\nfunction Tc(e) {\n  return iB(e);\n}\n\nconst bc = {\n  // From chroma spectral http://gka.github.io/chroma.js/\n  SPECTRAL: [[0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.3686, 0.3098, 0.6353)], [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.1961, 0.5333, 0.7412)], [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.4, 0.7608, 0.6471)], [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.6706, 0.8667, 0.6431)], [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.902, 0.9608, 0.5961)], [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 0.749)], [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9961, 0.8784, 0.5451)], [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9922, 0.6824, 0.3804)], [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9569, 0.4275, 0.2627)], [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.8353, 0.2431, 0.3098)], [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.6196, 39e-4, 0.2588)]],\n  PLASMA: [[0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.241, 0.015, 0.61)], [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.387, 1e-3, 0.654)], [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.524, 0.025, 0.653)], [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.651, 0.125, 0.596)], [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.752, 0.227, 0.513)], [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.837, 0.329, 0.431)], [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.907, 0.435, 0.353)], [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.963, 0.554, 0.272)], [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.992, 0.681, 0.195)], [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.987, 0.822, 0.144)], [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.94, 0.975, 0.131)]],\n  YELLOW_GREEN: [[0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.1647, 0.2824, 0.3451)], [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.1338, 0.3555, 0.4227)], [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.061, 0.4319, 0.4864)], [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0.5099, 0.5319)], [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0.5881, 0.5569)], [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.137, 0.665, 0.5614)], [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.2906, 0.7395, 0.5477)], [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.4453, 0.8099, 0.5201)], [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.6102, 0.8748, 0.485)], [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.7883, 0.9323, 0.4514)], [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9804, 0.9804, 0.4314)]],\n  VIRIDIS: [[0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.267, 5e-3, 0.329)], [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.283, 0.141, 0.458)], [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.254, 0.265, 0.53)], [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.207, 0.372, 0.553)], [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.164, 0.471, 0.558)], [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.128, 0.567, 0.551)], [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.135, 0.659, 0.518)], [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.267, 0.749, 0.441)], [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.478, 0.821, 0.318)], [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.741, 0.873, 0.15)], [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.993, 0.906, 0.144)]],\n  INFERNO: [[0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.077, 0.042, 0.206)], [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.225, 0.036, 0.388)], [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.373, 0.074, 0.432)], [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.522, 0.128, 0.42)], [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.665, 0.182, 0.37)], [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.797, 0.255, 0.287)], [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.902, 0.364, 0.184)], [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.969, 0.516, 0.063)], [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.988, 0.683, 0.072)], [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.961, 0.859, 0.298)], [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.988, 0.998, 0.645)]],\n  GRAYSCALE: [[0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0)], [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1)]],\n  // 16 samples of the TURBU color scheme\n  // values taken from: https://gist.github.com/mikhailov-work/ee72ba4191942acecc03fe6da94fc73f\n  // original file licensed under Apache-2.0\n  TURBO: [[0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.18995, 0.07176, 0.23217)], [0.07, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.25107, 0.25237, 0.63374)], [0.13, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.27628, 0.42118, 0.89123)], [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.25862, 0.57958, 0.99876)], [0.27, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.15844, 0.73551, 0.92305)], [0.33, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.09267, 0.86554, 0.7623)], [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.19659, 0.94901, 0.59466)], [0.47, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.42778, 0.99419, 0.38575)], [0.53, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.64362, 0.98999, 0.23356)], [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.80473, 0.92452, 0.20459)], [0.67, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.93301, 0.81236, 0.22667)], [0.73, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.99314, 0.67408, 0.20348)], [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9836, 0.49291, 0.12849)], [0.87, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.92105, 0.31489, 0.05475)], [0.93, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.81608, 0.18462, 0.01809)], [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.66449, 0.08436, 424e-5)]],\n  RAINBOW: [[0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.278, 0, 0.714)], [1 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 1)], [2 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 1, 1)], [3 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 1, 0)], [4 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 0)], [5 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 0.64, 0)], [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 0, 0)]],\n  CONTOUR: [[0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0)], [0.03, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0)], [0.04, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1)], [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1)]]\n},\n      uB = `\n  varying vec3 vColor;\n  uniform float alpha;\n\n  void main() {\n    if (vColor == vec3(0.0, 0.0, 0.0)) {\n      discard;\n    } else {\n      gl_FragColor = vec4( vColor, alpha);\n    }\n  }\n`,\n      lB = `\n  varying vec3 vColor;\n  uniform sampler2D gradient;\n  uniform sampler2D grayscale;\n  attribute float intensity;\n  attribute float classification;\n  uniform vec3 rootCenter;\n  uniform vec3 rootNormal;\n  uniform vec2 elevationRange;\n  uniform int coloring;\n  uniform bool hideGround;\n  uniform float maxIntensity;\n  uniform float intensityContrast;\n  uniform float pointSize;\n\n  #ifdef USE_COLOR\n  vec3 getRGB() {\n      vec3 rgb = color;\n      return rgb;\n  }\n  #endif\n\n  vec3 getElevation(){\n    vec4 world = modelMatrix * vec4( position, 1.0 );\n    float diff = abs(dot(rootNormal, (vec3(world) - rootCenter)));\n    float w = max(diff - elevationRange.x,0.0) / max(elevationRange.y - elevationRange.x,1.0);\n    vec3 cElevation = texture2D(gradient, vec2(w,1.0-w)).rgb;\n\n    return cElevation;\n  }\n\n  vec3 getIntensity(){\n    // TODO: real contrast enhancement. Check https://github.com/yuki-koyama/enhancer/blob/master/shaders/enhancer.fs\n    float intmod = pow(intensity, intensityContrast);\n    vec3 cIntensity = texture2D(grayscale, vec2(intmod / maxIntensity ,1.0-(intmod / maxIntensity))).rgb;\n    return cIntensity;\n  }\n\n  vec3 getClassification(){\n    float classNormalized = classification / 255.0;\n    vec3 cClassification = texture2D(gradient, vec2(classNormalized * 5.0,1.0-classNormalized * 5.0)).rgb;\n    return cClassification;\n  }\n\n  vec3 getColor(){\n      vec3 color;\n      if (hideGround && classification == 2.0) {\n         return vec3(0.0, 0.0, 0.0);               \n      }\n\n      if (coloring == 1) {\n        color = getIntensity();\n      }\n      else if (coloring == 2) {\n        color = getClassification();\n      } else if (coloring == 3) {\n        color = getElevation();\n      } \n      #ifdef USE_COLOR\n      else if (coloring == 4) {\n        color = getRGB();\n      }\n      #endif\n      else {\n        color = vec3(1.0, 1.0, 1.0);\n      }\n      return color;\n  }\n\n  void main() {\n      vColor = getColor();\n\n      gl_PointSize = pointSize;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  }\n`;\n\nvar _c = /* @__PURE__ */(e => (e[e.Intensity = 1] = \"Intensity\", e[e.Classification = 2] = \"Classification\", e[e.Elevation = 3] = \"Elevation\", e[e.RGB = 4] = \"RGB\", e[e.White = 5] = \"White\", e))(_c || {}),\n    Dn = /* @__PURE__ */(e => (e[e.FlatTexture = 1] = \"FlatTexture\", e[e.ShadedTexture = 2] = \"ShadedTexture\", e[e.ShadedNoTexture = 3] = \"ShadedNoTexture\", e))(Dn || {});\n\nconst hB = bc.RAINBOW,\n      fB = typeof document < \"u\" ? Cc(hB) : null,\n      dB = bc.GRAYSCALE,\n      mB = typeof document < \"u\" ? Cc(dB) : null,\n      gB = {\n  throttleRequests: !0,\n  maxRequests: 64,\n  updateInterval: 0.1,\n  maxConcurrency: 1,\n  maximumScreenSpaceError: 16,\n  memoryAdjustedScreenSpaceError: !0,\n  maximumMemoryUsage: 400,\n  memoryCacheOverflow: 128,\n  viewDistanceScale: 1,\n  skipLevelOfDetail: !1,\n  resetTransform: !1,\n  updateTransforms: !0,\n  shading: Dn.FlatTexture,\n  transparent: !1,\n  pointCloudColoring: _c.White,\n  pointSize: 1,\n  worker: !0,\n  wireframe: !1,\n  debug: !1,\n  gltfLoader: null,\n  basisTranscoderPath: null,\n  dracoDecoderPath: null,\n  material: null,\n  contentPostProcess: void 0,\n  preloadTilesCount: null,\n  collectAttributions: !1\n};\n\nclass _B {\n  /**\r\n  * Loads a tileset of 3D Tiles according to the given {@link LoaderProps}\r\n  * @public\r\n  *\r\n  * @param props - Properties for this load call {@link LoaderProps}.\r\n  * @returns An object containing the 3D Model to be added to the scene\r\n  * and a runtime engine to be updated every frame.\r\n  */\n  static async load(t) {\n    const n = { ...gB,\n      ...t.options\n    },\n          {\n      url: s\n    } = t,\n          r = n.updateInterval,\n          i = 5,\n          o = {};\n\n    if (n.cesiumIONToken) {\n      o[\"cesium-ion\"] = {\n        accessToken: n.cesiumIONToken\n      };\n      const T = await dc.preload(s, o);\n      o.fetch = {\n        headers: T.headers\n      };\n    }\n\n    n.googleApiKey && (o.fetch = {\n      headers: {\n        \"X-GOOG-API-KEY\": n.googleApiKey\n      }\n    }, t.options.hasOwnProperty(\"collectAttributions\") || (n.collectAttributions = !0)), t.loadingManager && t.loadingManager.itemStart(s);\n    const a = await fe(s, Oe, { ...o\n    }),\n          c = {},\n          u = {},\n          l = [],\n          h = new three__WEBPACK_IMPORTED_MODULE_0__.Group(),\n          f = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n    n.debug || (f.visible = !1);\n    const d = {\n      pointSize: {\n        type: \"f\",\n        value: n.pointSize\n      },\n      gradient: {\n        type: \"t\",\n        value: fB\n      },\n      grayscale: {\n        type: \"t\",\n        value: mB\n      },\n      rootCenter: {\n        type: \"vec3\",\n        value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n      },\n      rootNormal: {\n        type: \"vec3\",\n        value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n      },\n      coloring: {\n        type: \"i\",\n        value: n.pointCloudColoring\n      },\n      hideGround: {\n        type: \"b\",\n        value: !0\n      },\n      elevationRange: {\n        type: \"vec2\",\n        value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 400)\n      },\n      maxIntensity: {\n        type: \"f\",\n        value: 1\n      },\n      intensityContrast: {\n        type: \"f\",\n        value: 1\n      },\n      alpha: {\n        type: \"f\",\n        value: 1\n      }\n    },\n          m = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n      uniforms: d,\n      vertexShader: lB,\n      fragmentShader: uB,\n      transparent: n.transparent,\n      vertexColors: !0\n    });\n    let g = null,\n        p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(),\n        C,\n        w,\n        y;\n    n.gltfLoader ? C = n.gltfLoader : (C = new three__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader(), n.basisTranscoderPath && (w = new three__WEBPACK_IMPORTED_MODULE_0__.KTX2Loader(), w.detectSupport(t.renderer), w.setTranscoderPath(n.basisTranscoderPath + \"/\"), w.setWorkerLimit(1), C.setKTX2Loader(w)), n.dracoDecoderPath && (y = new three__WEBPACK_IMPORTED_MODULE_0__.DRACOLoader(), y.setDecoderPath(n.dracoDecoderPath + \"/\"), y.setWorkerLimit(n.maxConcurrency), C.setDRACOLoader(y)));\n    const B = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n      transparent: n.transparent\n    }),\n          R = {\n      maximumMemoryUsage: n.maximumMemoryUsage,\n      maximumScreenSpaceError: n.maximumScreenSpaceError,\n      memoryAdjustedScreenSpaceError: n.memoryAdjustedScreenSpaceError,\n      memoryCacheOverflow: n.memoryCacheOverflow,\n      viewDistanceScale: n.viewDistanceScale,\n      skipLevelOfDetail: n.skipLevelOfDetail,\n      updateTransforms: n.updateTransforms,\n      throttleRequests: n.throttleRequests,\n      maxRequests: n.maxRequests,\n      contentLoader: async T => {\n        let L = null;\n\n        switch (T.type) {\n          case zt.POINTCLOUD:\n            {\n              L = pB(T, m, n, vt);\n              break;\n            }\n\n          case zt.SCENEGRAPH:\n          case zt.MESH:\n            {\n              L = await AB(C, T, B, n, vt);\n              break;\n            }\n        }\n\n        if (L && (L.visible = !1, c[T.id] = L, h.add(c[T.id]), n.debug)) {\n          const z = Io(T);\n          f.add(z), u[T.id] = z;\n        }\n      },\n      onTileLoad: async T => {\n        E && (n.resetTransform && !v && (T == null ? void 0 : T.depth) <= i && jt(T), ne = !0);\n      },\n      onTileUnload: T => {\n        l.push(T);\n      },\n      onTileError: (T, L) => {\n        console.error(\"Tile error\", T.id, L);\n      },\n\n      onTraversalComplete(T) {\n        return n.collectAttributions && (K = BB(T)), T;\n      }\n\n    },\n          E = new zd(a, { ...R,\n      loadOptions: { ...o,\n        maxConcurrency: n.maxConcurrency,\n        worker: n.worker,\n        gltf: {\n          loadImages: !1\n        },\n        \"3d-tiles\": {\n          loadGLTF: !1\n        }\n      }\n    }),\n          O = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(),\n          F = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(),\n          x = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    let v = !1,\n        K = \"\";\n\n    if (E.root.boundingVolume ? (E.root.header.boundingVolume.region && console.warn(\"Cannot apply a model matrix to bounding volumes of type region. Tileset stays in original geo-coordinates.\"), F.setPosition(E.root.boundingVolume.center[0], E.root.boundingVolume.center[1], E.root.boundingVolume.center[2])) : console.warn(\"Bounding volume not found, no transformations applied\"), n.debug) {\n      const T = Io(E.root);\n      f.add(T), u[E.root.id] = T;\n    }\n\n    let q = !1,\n        Y = !1;\n    d.rootCenter.value.copy(x), d.rootNormal.value.copy(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1).normalize()), E.stats.get(\"Loader concurrency\").count = n.maxConcurrency, E.stats.get(\"Maximum mem usage\").count = n.maximumMemoryUsage;\n    let D = 0,\n        at = null,\n        ee = null,\n        ne = !1;\n    const ge = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1 / 0, 1 / 0, 1 / 0);\n    let Ft = null;\n    h.updateMatrixWorld(!0);\n    const nt = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(h.matrixWorld),\n          vt = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(nt).invert();\n    n.resetTransform && jt(E.root), n.debug && (u[E.root.id].applyMatrix4(O), f.matrixWorld.copy(h.matrixWorld));\n\n    function jt(T) {\n      if (!T.boundingVolume.halfAxes) return;\n      const L = T.boundingVolume.halfAxes,\n            z = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().extractRotation(Ec(L)).premultiply(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().extractRotation(vt));\n\n      if (!new three__WEBPACK_IMPORTED_MODULE_0__.Euler().setFromRotationMatrix(z).equals(new three__WEBPACK_IMPORTED_MODULE_0__.Euler())) {\n        v = !0;\n        const Tt = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(F.elements[12], F.elements[13], F.elements[14]);\n        F.extractRotation(z), F.setPosition(Tt);\n      }\n\n      Ae();\n    }\n\n    function Ae() {\n      O.copy(nt), n.resetTransform && O.multiply(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(F).invert()), E.modelMatrix = new V(O.toArray());\n    }\n\n    function We(T, L, z, j) {\n      if (q || !j) return;\n\n      if (!Ft || j.aspect != ee) {\n        if (j instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) Ft = new Mn({\n          fov: j.fov / 180 * Math.PI,\n          aspectRatio: j.aspect,\n          near: j.near,\n          far: j.far\n        }).sseDenominator;else if (j instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera) {\n          const W = j.right - j.left,\n                Dr = j.top - j.bottom,\n                Rc = W / Dr;\n          Ft = Math.max(Dr / z, W / (z * Rc));\n        }\n        ee = j.aspect, n.debug && console.log(\"Updated sse denonimator:\", Ft);\n      }\n\n      const Wn = Mo(j).planes.map(W => new et(W.normal.toArray(), W.constant)),\n            wc = new ht(Wn),\n            Fr = {\n        camera: {\n          position: ge.toArray()\n        },\n        height: z,\n        frameNumber: T._frameNumber,\n        sseDenominator: Ft,\n        cullingVolume: wc,\n        viewport: {\n          id: 0\n        }\n      };\n      T._cache.reset(), T._traverser.traverse(T.root, Fr, T.options);\n\n      for (const W of T.tiles) W.selected ? L[W.id] ? L[W.id].visible = !0 : console.error(\"TILE SELECTED BUT NOT LOADED!!\", W.id) : L[W.id] && (L[W.id].visible = !1);\n\n      for (; l.length > 0;) {\n        const W = l.pop();\n        L[W.id] && W.contentState == ut.UNLOADED && (h.remove(L[W.id]), xs(L[W.id]), delete L[W.id]), u[W.id] && (xs(u[W.id]), f.remove(u[W.id]), delete u[W.id]);\n      }\n\n      const Xn = T.stats.get(\"Tiles Loaded\").count,\n            vr = T.stats.get(\"Tiles Loading\").count;\n      return t.onProgress && t.onProgress(Xn, Xn + vr), t.loadingManager && !Y && vr == 0 && (n.preloadTilesCount == null || Xn >= n.preloadTilesCount) && (Y = !0, t.loadingManager.itemEnd(t.url)), Fr;\n    }\n\n    function zn(T) {\n      const L = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n            z = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion(),\n            j = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      T.decompose(L, z, j), h.position.copy(L), h.quaternion.copy(z), h.scale.copy(j), h.updateMatrix(), h.updateMatrixWorld(!0), nt.copy(h.matrixWorld), vt.copy(nt).invert(), Ae();\n    }\n\n    return {\n      model: h,\n      runtime: {\n        getTileset: () => E,\n        getStats: () => E.stats,\n        getDataAttributions: () => K,\n        showTiles: T => {\n          f.visible = T;\n        },\n        setWireframe: T => {\n          n.wireframe = T, h.traverse(L => {\n            L instanceof three__WEBPACK_IMPORTED_MODULE_0__.Mesh && (L.material.wireframe = T);\n          });\n        },\n        setDebug: T => {\n          n.debug = T, f.visible = T;\n        },\n        setShading: T => {\n          n.shading = T;\n        },\n        getTileBoxes: () => f,\n        setViewDistanceScale: T => {\n          E.options.viewDistanceScale = T, E._frameNumber++, We(E, c, p.y, g);\n        },\n        setMaximumScreenSpaceError: T => {\n          E.options.maximumScreenSpaceError = T, E._frameNumber++, We(E, c, p.y, g);\n        },\n        setHideGround: T => {\n          d.hideGround.value = T;\n        },\n        setPointCloudColoring: T => {\n          d.coloring.value = T;\n        },\n        setElevationRange: T => {\n          d.elevationRange.value.set(T[0], T[1]);\n        },\n        setMaxIntensity: T => {\n          d.maxIntensity.value = T;\n        },\n        setIntensityContrast: T => {\n          d.intensityContrast.value = T;\n        },\n        setPointAlpha: T => {\n          d.alpha.value = T;\n        },\n        getLatLongHeightFromPosition: T => {\n          const L = E.ellipsoid.cartesianToCartographic(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(T).applyMatrix4(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(O).invert()).toArray());\n          return {\n            lat: L[1],\n            long: L[0],\n            height: L[2]\n          };\n        },\n        getPositionFromLatLongHeight: T => {\n          const L = E.ellipsoid.cartographicToCartesian([T.long, T.lat, T.height]);\n          return new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(...L).applyMatrix4(O);\n        },\n        orientToGeocoord: T => {\n          const L = [T.long, T.lat, T.height],\n                z = E.ellipsoid.cartographicToCartesian(L),\n                j = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray(E.ellipsoid.eastNorthUpToFixedFrame(z)),\n                Tt = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeRotationFromEuler(new three__WEBPACK_IMPORTED_MODULE_0__.Euler(Math.PI / 2, Math.PI / 2, 0)),\n                Wn = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(j).multiply(Tt).invert();\n          zn(Wn);\n        },\n        getWebMercatorCoord: T => aB(T.lat, T.long),\n        getCameraFrustum: T => {\n          const z = Mo(T).planes.map(Tt => new et(Tt.normal.toArray(), Tt.constant)).map(Tt => oB(Tt)),\n                j = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\n          for (const Tt of z) j.add(Tt);\n\n          return j;\n        },\n        overlayGeoJSON: T => (T.applyMatrix4(O), T.updateMatrixWorld(), T),\n        update: function (T, L, z) {\n          if (g = z, p.copy(L), D += T, E && D >= r) {\n            if (!nt.equals(h.matrixWorld)) {\n              D = 0, nt.copy(h.matrixWorld), n.updateTransforms && Ae();\n              const j = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().setFromMatrixPosition(nt);\n              d.rootCenter.value.copy(j), d.rootNormal.value.copy(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1).applyMatrix4(nt).normalize()), vt.copy(nt).invert(), n.debug && (u[E.root.id].matrixWorld.copy(O), u[E.root.id].applyMatrix4(nt));\n            }\n\n            at == null ? at = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(z.matrixWorld) : (ne || yB(z, at, ee)) && (D = 0, ne = !1, E._frameNumber++, z.getWorldPosition(ge), at.copy(z.matrixWorld), We(E, c, p.y, z));\n          }\n        },\n        dispose: function () {\n          for (q = !0, E._destroy(); h.children.length > 0;) {\n            const T = h.children[0];\n            xs(T), h.remove(T);\n          }\n\n          for (; f.children.length > 0;) {\n            const T = f.children[0];\n            f.remove(T), T.geometry.dispose(), T.material.dispose();\n          }\n\n          w && w.dispose(), y && y.dispose();\n        }\n      }\n    };\n  }\n  /**\r\n  * Loads a tileset of 3D Tiles according to the given {@link GeoJSONLoaderProps}\r\n  * Could be overlayed on geograpical 3D Tiles using {@link Runtime.overlayGeoJSON}\r\n  * @public\r\n  *\r\n  * @param props - Properties for this load call {@link GeoJSONLoaderProps}.\r\n  * @returns An object containing the 3D Model to be added to the scene\r\n  */\n\n\n  static async loadGeoJSON(t) {\n    const {\n      url: n,\n      height: s,\n      featureToColor: r\n    } = t;\n    return fe(n, Ue, {\n      worker: !1,\n      gis: {\n        format: \"binary\"\n      }\n    }).then(i => {\n      const o = i,\n            a = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(),\n            c = o.polygons.positions.value.reduce((h, f, d, m) => {\n        if (d % 2 == 0) {\n          const g = [f, m[d + 1], s],\n                p = J.WGS84.cartographicToCartesian(g);\n          h.push(...p);\n        }\n\n        return h;\n      }, []);\n\n      if (r) {\n        const h = o.polygons.numericProps[r.feature].value.reduce((f, d, m, g) => {\n          const p = r.colorMap(d);\n          return f[m * 3] = p.r, f[m * 3 + 1] = p.g, f[m * 3 + 2] = p.b, f;\n        }, []);\n        a.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(h, 3));\n      }\n\n      a.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(c, 3)), a.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(o.polygons.triangles.value, 1));\n      const u = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n        transparent: !0\n      });\n      return u.vertexColors = !0, new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(a, u);\n    });\n  }\n\n}\n\nasync function AB(e, t, n, s, r) {\n  return new Promise((i, o) => {\n    const a = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeRotationAxis(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0), Math.PI / 2),\n          c = t.content.gltfUpAxis !== \"Z\",\n          u = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray(t.computedTransform).premultiply(r);\n    c && u.multiply(a), t.content.byteLength || (t.content.byteLength = t.content.gltfArrayBuffer.byteLength), e.parse(t.content.gltfArrayBuffer, t.contentUrl ? t.contentUrl.substr(0, t.contentUrl.lastIndexOf(\"/\") + 1) : \"\", l => {\n      t.userData.asset = l.asset;\n      const h = l.scenes[0];\n      h.applyMatrix4(u), t.content.texturesByteLength = 0, t.content.geometriesByteLength = 0, h.traverse(f => {\n        if (f.type == \"Mesh\") {\n          const d = f;\n          t.content.geometriesByteLength += Tc(d.geometry);\n          const m = d.material,\n                g = m.map,\n                p = cB(g);\n          p && (t.content.texturesByteLength += p), s.material ? (d.material = s.material.clone(), m.dispose()) : s.shading == Dn.FlatTexture && d.material.type !== \"MeshBasicMaterial\" && (d.material = n.clone(), m.dispose()), s.shading != Dn.ShadedNoTexture ? d.material.type == \"ShaderMaterial\" ? d.material.uniforms.map = {\n            value: g\n          } : d.material.map = g : (g && g.dispose(), d.material.map = null), d.material.wireframe = s.wireframe, s.contentPostProcess && s.contentPostProcess(d);\n        }\n      }), t.content.gpuMemoryUsageInBytes = t.content.texturesByteLength + t.content.geometriesByteLength, i(h);\n    }, l => {\n      o(new Error(`error parsing gltf in tile ${t.id}: ${l}`));\n    });\n  });\n}\n\nfunction pB(e, t, n, s) {\n  const r = {\n    rtc_center: e.content.rtcCenter,\n    // eslint-disable-line camelcase\n    points: e.content.attributes.positions,\n    intensities: e.content.attributes.intensity,\n    classifications: e.content.attributes.classification,\n    rgb: null,\n    rgba: null\n  },\n        {\n    colors: i\n  } = e.content.attributes;\n  i && i.size === 3 && (r.rgb = i.value), i && i.size === 4 && (r.rgba = i.value);\n  const o = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n  o.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(r.points, 3));\n  const a = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray(e.computedTransform).premultiply(s);\n  r.rgba ? o.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(r.rgba, 4)) : r.rgb && o.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_0__.Uint8BufferAttribute(r.rgb, 3, !0)), r.intensities && o.setAttribute(\"intensity\", // Handles both 16bit or 8bit intensity values\n  new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(r.intensities, 1, !0)), r.classifications && o.setAttribute(\"classification\", new three__WEBPACK_IMPORTED_MODULE_0__.Uint8BufferAttribute(r.classifications, 1, !1)), e.content.geometriesByteLength = Tc(o), e.content.gpuMemoryUsageInBytes = e.content.geometriesByteLength;\n  const c = new three__WEBPACK_IMPORTED_MODULE_0__.Points(o, n.material || t);\n\n  if (r.rtc_center) {\n    const u = r.rtc_center;\n    a.multiply(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeTranslation(u[0], u[1], u[2]));\n  }\n\n  return c.applyMatrix4(a), n.contentPostProcess && n.contentPostProcess(c), c;\n}\n\nfunction So(e) {\n  var t, n, s, r;\n  (t = e == null ? void 0 : e.uniforms) != null && t.map ? (s = (n = e == null ? void 0 : e.uniforms) == null ? void 0 : n.map.value) == null || s.dispose() : e.map && ((r = e.map) == null || r.dispose()), e.dispose();\n}\n\nfunction xs(e) {\n  e.traverse(t => {\n    if (t.isMesh) if (t.geometry.dispose(), t.material.isMaterial) So(t.material);else for (const n of t.material) So(n);\n  });\n\n  for (let t = e.children.length - 1; t >= 0; t--) {\n    const n = e.children[t];\n    e.remove(n);\n  }\n}\n\nfunction yB(e, t, n) {\n  const s = !e.matrixWorld.equals(t);\n  return e instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera ? s || e.aspect !== n : s;\n}\n\nfunction BB(e) {\n  const t = /* @__PURE__ */new Map();\n  return e.forEach(r => {\n    var o, a;\n    const i = (a = (o = r == null ? void 0 : r.userData) == null ? void 0 : o.asset) == null ? void 0 : a.copyright;\n    i && i.split(/;/g).map(u => u.trim()).forEach(u => {\n      u && t.set(u, (t.get(u) || 0) + 1);\n    });\n  }), Array.from(t).sort((r, i) => i[1] - r[1]).map(([r]) => r).join(\"; \");\n}\n\n\n\n//# sourceURL=webpack://aframe-loader-3dtiles-component/./dist/three-loader-3dtiles.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dist_three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/three-loader-3dtiles */ \"./dist/three-loader-3dtiles.js\");\n/* harmony import */ var _textarea__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./textarea */ \"./textarea.js\");\n/* harmony import */ var _textarea__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_textarea__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\nconst POINT_CLOUD_COLORING = {\n  white: _dist_three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.White,\n  intensity: _dist_three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.Intensity,\n  classification: _dist_three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.Classification,\n  elevation: _dist_three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.Elevation,\n  rgb: _dist_three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.RGB\n};\n/**\r\n * 3D Tiles component for A-Frame.\r\n */\n\nAFRAME.registerComponent('loader-3dtiles', {\n  schema: {\n    url: {\n      type: 'string'\n    },\n    cameraEl: {\n      type: 'selector'\n    },\n    maximumSSE: {\n      type: 'int',\n      default: 16\n    },\n    maximumMem: {\n      type: 'int',\n      default: 32\n    },\n    distanceScale: {\n      type: 'number',\n      default: 1.0\n    },\n    pointcloudColoring: {\n      type: 'string',\n      default: 'white'\n    },\n    pointcloudElevationRange: {\n      type: 'array',\n      default: ['0', '400']\n    },\n    wireframe: {\n      type: 'boolean',\n      default: false\n    },\n    showStats: {\n      type: 'boolean',\n      default: false\n    },\n    cesiumIONToken: {\n      type: 'string'\n    },\n    googleApiKey: {\n      type: 'string'\n    },\n    lat: {\n      type: 'number'\n    },\n    long: {\n      type: 'number'\n    },\n    height: {\n      type: 'number'\n    },\n    copyrightEl: {\n      type: 'selector'\n    }\n  },\n  init: async function () {\n    const sceneEl = this.el.sceneEl;\n    const data = this.data;\n    this.camera = data.cameraEl?.object3D.children[0] ?? document.querySelector('a-scene').camera;\n\n    if (!this.camera) {\n      throw new Error('3D Tiles: Please add an active camera or specify the target camera via the cameraEl property');\n    }\n\n    this.viewportSize = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2(sceneEl.clientWidth, sceneEl.clientHeight);\n    const {\n      model,\n      runtime\n    } = await this._initTileset();\n    this.el.setObject3D('tileset', model);\n    this.originalCamera = this.camera;\n    sceneEl.addEventListener('camera-set-active', e => {\n      // TODO: For some reason after closing the inspector this event is fired with an empty camera,\n      // so revert to the original camera used.\n      //\n      // TODO: Does not provide the right Inspector perspective camera\n      this.camera = e.detail.cameraEl.object3D.children[0] ?? this.originalCamera;\n    });\n    this.el.addEventListener('cameraChange', e => {\n      this.camera = e.detail;\n\n      if (this.camera.type === 'OrthographicCamera') {\n        if (this.camera.rotation.x < -1) {\n          // Plan View mode\n          // raise the camera to increase the field of view and update a larger area of tiles\n          this.camera.position.y = 100;\n        } else {\n          // Cross Section mode\n          this.camera.position.y = 10; // default value for ortho camera in Editor\n        }\n      }\n    });\n    sceneEl.addEventListener('enter-vr', e => {\n      this.originalCamera = this.camera;\n\n      try {\n        this.camera = sceneEl.renderer.xr.getCamera(this.camera); // FOV Code from https://github.com/mrdoob/three.js/issues/21869\n\n        sceneEl.renderer.xr.getSession().requestAnimationFrame((time, frame) => {\n          const ref = sceneEl.renderer.xr.getReferenceSpace();\n          const pose = frame.getViewerPose(ref);\n\n          if (pose) {\n            const fovi = pose.views[0].projectionMatrix[5];\n            this.camera.fov = Math.atan2(1, fovi) * 2 * 180 / Math.PI;\n          }\n        });\n      } catch (e) {\n        console.warn('Could not get VR camera');\n      }\n    });\n    sceneEl.addEventListener('exit-vr', e => {\n      this.camera = this.originalCamera;\n    });\n\n    if (data.showStats) {\n      this.stats = this._initStats();\n    }\n\n    if (THREE.Cache.enabled) {\n      console.warn('3D Tiles loader cannot work with THREE.Cache, disabling.');\n      THREE.Cache.enabled = false;\n    }\n\n    await this._nextFrame();\n    this.runtime = runtime;\n    this.runtime.setElevationRange(data.pointcloudElevationRange.map(n => Number(n)));\n    window.addEventListener('resize', this.onWindowResize.bind(this));\n    /*\r\n        if (AFRAME.INSPECTOR && AFRAME.INSPECTOR.opened) {\r\n          // set active inspector camera\r\n          this.camera = AFRAME.INSPECTOR.camera;\r\n          // emit play event to start load tiles in aframe-inspector\r\n          \r\n        }*/\n  },\n  onWindowResize: function () {\n    const sceneEl = this.el.sceneEl;\n    this.viewportSize.set(sceneEl.clientWidth, sceneEl.clientHeight);\n    this.camera.aspect = sceneEl.clientWidth / sceneEl.clientHeight;\n    this.camera.updateProjectionMatrix();\n  },\n  update: async function (oldData) {\n    if (oldData.url !== this.data.url) {\n      if (this.runtime) {\n        this.runtime.dispose();\n        this.runtime = null;\n      }\n\n      const {\n        model,\n        runtime\n      } = await this._initTileset();\n      this.el.setObject3D('tileset', model);\n      await this._nextFrame();\n      this.runtime = runtime;\n    } else if (this.runtime) {\n      this.runtime.setPointCloudColoring(this._resolvePointcloudColoring(this.data.pointCloudColoring));\n      this.runtime.setWireframe(this.data.wireframe);\n      this.runtime.setViewDistanceScale(this.data.distanceScale);\n      this.runtime.setElevationRange(this.data.pointcloudElevationRange.map(n => Number(n)));\n    }\n\n    if (this.data.showStats && !this.stats) {\n      this.stats = this._initStats();\n    }\n\n    if (!this.data.showStats && this.stats) {\n      this.el.sceneEl.removeChild(this.stats);\n      this.stats = null;\n    } // set parameters for google 3dtiles API\n\n\n    if (this.data.lat && this.data.long && this.data.height) {\n      // eslint-disable-next-line no-unused-vars\n      const {\n        model,\n        runtime\n      } = await this._initTileset();\n      console.log(this.data.lat, this.data.long, this.data.height);\n      this.runtime.orientToGeocoord({\n        lat: Number(this.data.lat),\n        long: Number(this.data.long),\n        height: Number(this.data.height)\n      });\n    }\n\n    this.play();\n  },\n  tick: function (t, dt) {\n    if (this.runtime) {\n      this.runtime.update(dt, this.viewportSize, this.camera);\n\n      if (this.stats) {\n        const worldPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        this.camera.getWorldPosition(worldPos);\n        const stats = this.runtime.getStats();\n        this.stats.setAttribute('textarea', 'text', Object.values(stats.stats).map(s => `${s.name}: ${s.count}`).join('\\n'));\n        const newPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        newPos.copy(worldPos);\n        newPos.z -= 2;\n        this.stats.setAttribute('position', newPos);\n      }\n\n      if (this.data.copyrightEl) {\n        this.data.copyrightEl.innerHTML = this.runtime.getDataAttributions() ?? '';\n      }\n    }\n  },\n  remove: function () {\n    if (this.runtime) {\n      this.runtime.dispose();\n    }\n  },\n\n  _resolvePointcloudColoring() {\n    const pointCloudColoring = POINT_CLOUD_COLORING[this.data.pointcloudColoring];\n\n    if (!pointCloudColoring) {\n      console.warn('Invalid value for point cloud coloring');\n      return _dist_three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.White;\n    } else {\n      return pointCloudColoring;\n    }\n  },\n\n  _initTileset: async function () {\n    const pointCloudColoring = this._resolvePointcloudColoring(this.data.pointcloudColoring);\n\n    return _dist_three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.Loader3DTiles.load({\n      url: this.data.url,\n      renderer: this.el.sceneEl.renderer,\n      options: {\n        googleApiKey: this.data.googleApiKey,\n        cesiumIONToken: this.data.cesiumIONToken,\n        dracoDecoderPath: 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/draco',\n        basisTranscoderPath: 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/basis',\n        maximumScreenSpaceError: this.data.maximumSSE,\n        maximumMemoryUsage: this.data.maximumMem,\n        memoryCacheOverflow: 128,\n        pointCloudColoring: pointCloudColoring,\n        viewDistanceScale: this.data.distanceScale,\n        wireframe: this.data.wireframe,\n        updateTransforms: true\n      }\n    });\n  },\n  _initStats: function () {\n    const stats = document.createElement('a-entity');\n    this.el.sceneEl.appendChild(stats);\n    stats.setAttribute('position', '-0.5 0 -1');\n    stats.setAttribute('textarea', {\n      cols: 30,\n      rows: 15,\n      text: '',\n      color: 'white',\n      disabledBackgroundColor: '#0c1e2c',\n      disabled: true\n    });\n    return stats;\n  },\n  _nextFrame: async function () {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        resolve();\n      }, 0);\n    });\n  }\n});\n\n//# sourceURL=webpack://aframe-loader-3dtiles-component/./index.js?");

/***/ }),

/***/ "./textarea.js":
/*!*********************!*\
  !*** ./textarea.js ***!
  \*********************/
/***/ (() => {

eval("if (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n/**\r\n * Textarea component for A-Frame.\r\n *\r\n * Ripped from: https://github.com/brianpeiris/aframe-textarea-component\r\n */\n\n\nAFRAME.registerComponent('textarea', {\n  schema: {\n    transparentBG: {\n      type: 'boolean',\n      default: false\n    },\n    cols: {\n      type: 'int',\n      default: 40\n    },\n    rows: {\n      type: 'int',\n      default: 20\n    },\n    color: {\n      type: 'color',\n      default: 'black'\n    },\n    backgroundColor: {\n      type: 'color',\n      default: 'white'\n    },\n    disabledBackgroundColor: {\n      type: 'color',\n      default: 'lightgrey'\n    },\n    disabled: {\n      type: 'boolean',\n      default: false\n    },\n    text: {\n      type: 'string',\n      default: ''\n    }\n  },\n  init: function () {\n    this.text = null;\n    this.lines = [];\n    this.lastBlink = 0;\n    this.blinkEnabled = !this.data.disabled;\n    this.charWidth = this.charHeight = null;\n    this.selectionStart = this.selectionEnd = 0;\n    this.endIndexInfo = this.startIndexInfo = null;\n    this.origin = {\n      x: 0,\n      y: 0\n    };\n    this.background = document.createElement('a-plane');\n    this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    this.el.appendChild(this.background);\n\n    if (this.data.transparentBG) {\n      this.background.setAttribute('material', {\n        opacity: 0,\n        transparent: true\n      });\n    }\n\n    this.textAnchor = document.createElement('a-entity');\n    this.el.appendChild(this.textAnchor);\n    this.textAnchor.setAttribute('text', {\n      mode: 'pre',\n      baseline: 'top',\n      anchor: 'center',\n      font: 'dejavu',\n      wrapCount: this.data.cols,\n      height: this.data.rows,\n      color: this.data.color\n    });\n\n    this._initTextarea();\n\n    this.el.addEventListener('textfontset', this._updateCharMetrics.bind(this));\n    this.el.addEventListener('char-metrics-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('text-changed', this._updateLines.bind(this));\n    this.el.addEventListener('text-changed', this._updateDisplayText.bind(this));\n    this.el.addEventListener('selection-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('selection-changed', this._updateHorizontalOrigin.bind(this));\n    this.el.addEventListener('lines-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('index-info-changed', this._updateOrigin.bind(this));\n    this.el.addEventListener('index-info-changed', this._updateHorizontalOrigin.bind(this));\n    this.el.addEventListener('origin-changed', this._updateDisplayText.bind(this));\n    this.el.addEventListener('click', this.focus.bind(this));\n  },\n  update: function (oldData) {\n    if (this.data.text !== oldData.text) {\n      this._updateTextarea();\n    }\n\n    if (this.data.backgroundColor !== oldData.backgroundColor || this.data.disabledBackgroundColor !== oldData.disabledBackgroundColor) {\n      this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    }\n\n    if (this.data.disabled !== oldData.disabled) {\n      this.blinkEnabled = !this.data.disabled;\n      this.textarea.disabled = this.data.disabled;\n      this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    }\n  },\n  focus: function () {\n    this.textarea.focus();\n  },\n  _initTextarea: function () {\n    this.textarea = document.createElement('textarea');\n    document.body.appendChild(this.textarea);\n\n    this._updateTextarea();\n  },\n  _updateTextarea: function () {\n    this.textarea.style.whiteSpace = 'pre';\n    this.textarea.style.overflow = 'hidden';\n    this.textarea.style.opacity = '0';\n    this.textarea.cols = this.data.cols;\n    this.textarea.rows = this.data.rows;\n    this.textarea.value = this.data.text;\n    this.textarea.selectionStart = 0;\n    this.textarea.selectionEnd = 0;\n\n    this._updateIndexInfo();\n  },\n  _emit: function (eventName, detail) {\n    this.el.emit(eventName, detail);\n  },\n  _updateCharMetrics: function (event) {\n    const layout = this.textAnchor.components.text.geometry.layout;\n    const fontWidthFactor = event.detail.fontObj.widthFactor;\n    this.charWidth = fontWidthFactor * this.textAnchor.object3DMap.text.scale.x;\n    this.charHeight = this.charWidth * layout.lineHeight / fontWidthFactor;\n    this.textAnchor.setAttribute('position', {\n      x: 0,\n      y: this.charHeight * this.data.rows / 2,\n      z: 0\n    });\n\n    if (!this.data.transparentBG) {\n      this.background.setAttribute('scale', {\n        x: 1.05,\n        y: this.charHeight * this.data.rows * 1.05,\n        z: 1\n      });\n      this.background.setAttribute('position', {\n        x: 0,\n        y: 0,\n        z: 0\n      });\n    }\n\n    this._emit('char-metrics-changed');\n  },\n  _checkAndUpdateSelection: function () {\n    if (this.selectionStart === this.textarea.selectionStart && this.selectionEnd === this.textarea.selectionEnd) {\n      return;\n    }\n\n    const lastStart = this.selectionStart;\n    const lastEnd = this.selectionEnd;\n    this.selectionStart = this.textarea.selectionStart;\n    this.selectionEnd = this.textarea.selectionEnd;\n\n    this._emit('selection-changed', {\n      start: {\n        old: lastStart,\n        new: this.selectionStart,\n        changed: this.selectionStart !== lastStart\n      },\n      end: {\n        old: lastEnd,\n        new: this.selectionEnd,\n        changed: this.selectionEnd !== lastEnd\n      }\n    });\n  },\n  tick: function (time) {\n    if (time - this.lastBlink > 500 && this.blinkEnabled) {\n      this.lastBlink = time;\n    }\n\n    this._checkAndUpdateSelection();\n\n    this._checkAndUpdateText();\n  },\n  _getIndexInfo: function (lineIndex, textIndex) {\n    const y = Math.max(0, lineIndex);\n    const line = this.lines[y];\n    const x = textIndex - line.start;\n    return {\n      line: line,\n      x: x * this.charWidth,\n      y: -this.charHeight * y + -this.charHeight / 2\n    };\n  },\n  _updateIndexInfo: function () {\n    if (!this.lines.length) {\n      return;\n    }\n\n    const lastStart = this.startIndexInfo && this.startIndexInfo.line.index;\n    const lastEnd = this.endIndexInfo && this.endIndexInfo.line.index;\n    this.startIndexInfo = null;\n    this.endIndexInfo = null;\n    let i;\n    let startChanged = false;\n    let endChanged = false;\n\n    for (i = 0; i <= this.lines.length; i++) {\n      const prevLine = this.lines[i - 1];\n      const lineStart = i === this.lines.length ? prevLine.start + prevLine.length + 1 : this.lines[i].start;\n\n      if (lineStart > this.selectionStart && !this.startIndexInfo) {\n        this.startIndexInfo = this._getIndexInfo(i - 1, this.selectionStart);\n\n        if (this.startIndexInfo.line.index !== lastStart) {\n          startChanged = true;\n        }\n      }\n\n      if (lineStart > this.selectionEnd) {\n        this.endIndexInfo = this._getIndexInfo(i - 1, this.selectionEnd);\n\n        if (this.endIndexInfo.line.index !== lastEnd) {\n          endChanged = true;\n        }\n\n        break;\n      }\n    }\n\n    if (startChanged || endChanged) {\n      this._emit('index-info-changed', {\n        start: {\n          changed: startChanged\n        },\n        end: {\n          changed: endChanged\n        }\n      });\n    }\n  },\n  _updateOrigin: function (event) {\n    let changed = false;\n\n    if (event.detail.end.changed) {\n      const end = this.origin.y + this.data.rows - 1;\n\n      if (this.endIndexInfo.line.index > end) {\n        this.origin.y = this.endIndexInfo.line.index + 1 - this.data.rows;\n        changed = true;\n      } else if (this.endIndexInfo.line.index < this.origin.y) {\n        this.origin.y = this.endIndexInfo.line.index;\n        changed = true;\n      }\n    }\n\n    if (event.detail.start.changed) {\n      if (this.startIndexInfo.line.index < this.origin.y) {\n        this.origin.y = this.startIndexInfo.line.index;\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      this._emit('origin-changed');\n    }\n  },\n  _updateHorizontalOrigin: function (event) {\n    if (!this.endIndexInfo) {\n      return;\n    }\n\n    let changed = true;\n\n    if (event.detail.end.changed) {\n      const endIndex = this.selectionEnd - this.endIndexInfo.line.start;\n\n      if (endIndex > this.origin.x + this.data.cols) {\n        this.origin.x = endIndex - this.data.cols;\n        changed = true;\n      } else if (endIndex < this.origin.x) {\n        this.origin.x = endIndex;\n        changed = true;\n      }\n    }\n\n    const startIndex = this.selectionStart - this.startIndexInfo.line.start;\n\n    if (event.detail.start.changed) {\n      if (startIndex > this.origin.x + this.data.cols) {\n        this.origin.x = startIndex - this.data.cols;\n        changed = true;\n      } else if (startIndex < this.origin.x) {\n        this.origin.x = startIndex;\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      this._emit('origin-changed');\n    }\n  },\n  _updateLines: function () {\n    this.lines = [];\n    const lines = this.text.split('\\n');\n    let counter = 0;\n\n    for (let i = 0; i < lines.length; i++) {\n      this.lines[i] = {\n        index: i,\n        length: lines[i].length,\n        start: counter\n      };\n      counter += lines[i].length + 1;\n    }\n\n    this._emit('lines-changed');\n  },\n  _getViewportText: function () {\n    return this.text.split('\\n').slice(this.origin.y, this.origin.y + this.data.rows).map(function (line) {\n      return line.substr(this.origin.x, this.data.cols) || ' ';\n    }.bind(this)).join('\\n');\n  },\n  _updateDisplayText: function () {\n    this.textAnchor.setAttribute('text', {\n      value: this._getViewportText()\n    });\n  },\n  _checkAndUpdateText: function () {\n    const text = this.textarea.value;\n\n    if (text === this.text) {\n      return;\n    }\n\n    this.text = text;\n\n    this._emit('text-changed');\n  }\n});\n\n//# sourceURL=webpack://aframe-loader-3dtiles-component/./textarea.js?");

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_three__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});