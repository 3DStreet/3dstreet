/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("THREE"));
	else if(typeof define === 'function' && define.amd)
		define(["THREE"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("THREE")) : factory(root["THREE"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, (__WEBPACK_EXTERNAL_MODULE_three__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three-loader-3dtiles */ \"./node_modules/three-loader-3dtiles/dist/lib/three-loader-3dtiles.js\");\n/* harmony import */ var _textarea__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./textarea */ \"./textarea.js\");\n/* harmony import */ var _textarea__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_textarea__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\nconst POINT_CLOUD_COLORING = {\n  white: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.White,\n  intensity: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.Intensity,\n  classification: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.Classification,\n  elevation: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.Elevation,\n  rgb: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.RGB\n};\n/**\r\n * 3D Tiles component for A-Frame.\r\n */\n\nAFRAME.registerComponent('loader-3dtiles', {\n  schema: {\n    url: {\n      type: 'string'\n    },\n    cameraEl: {\n      type: 'selector'\n    },\n    maximumSSE: {\n      type: 'int',\n      default: 16\n    },\n    maximumMem: {\n      type: 'int',\n      default: 32\n    },\n    distanceScale: {\n      type: 'number',\n      default: 1.0\n    },\n    pointcloudColoring: {\n      type: 'string',\n      default: 'white'\n    },\n    pointcloudElevationRange: {\n      type: 'array',\n      default: ['0', '400']\n    },\n    wireframe: {\n      type: 'boolean',\n      default: false\n    },\n    showStats: {\n      type: 'boolean',\n      default: false\n    },\n    cesiumIONToken: {\n      type: 'string'\n    },\n    googleApiKey: {\n      type: 'string'\n    },\n    lat: {\n      type: 'number'\n    },\n    long: {\n      type: 'number'\n    },\n    height: {\n      type: 'number',\n      default: 0\n    },\n    copyrightEl: {\n      type: 'selector'\n    }\n  },\n  init: async function () {\n    const sceneEl = this.el.sceneEl;\n    const data = this.data;\n    this.camera = data.cameraEl?.object3D.children[0] ?? document.querySelector('a-scene').camera;\n\n    if (!this.camera) {\n      throw new Error('3D Tiles: Please add an active camera or specify the target camera via the cameraEl property');\n    }\n\n    const {\n      model,\n      runtime\n    } = await this._initTileset();\n    this.el.setObject3D('tileset', model);\n    this.originalCamera = this.camera;\n\n    if (AFRAME.INSPECTOR && AFRAME.INSPECTOR.opened) {\n      // set active inspector camera\n      this.camera = AFRAME.INSPECTOR.camera;\n    }\n\n    sceneEl.addEventListener('camera-set-active', e => {\n      // TODO: For some reason after closing the inspector this event is fired with an empty camera,\n      // so revert to the original camera used.\n      //\n      // TODO: Does not provide the right Inspector perspective camera\n      this.camera = e.detail.cameraEl.object3D.children[0] ?? this.originalCamera;\n    });\n    this.el.addEventListener('cameraChange', e => {\n      this.camera = e.detail;\n\n      if (this.camera.type === 'OrthographicCamera') {\n        if (this.camera.rotation.x < -1) {\n          // Plan View mode\n          // raise the camera to increase the field of view and update a larger area of tiles\n          this.camera.position.y = 100;\n        } else {\n          // Cross Section mode\n          this.camera.position.y = 10; // default value for ortho camera in Editor\n        }\n      }\n    });\n    sceneEl.addEventListener('enter-vr', e => {\n      this.originalCamera = this.camera;\n\n      try {\n        this.camera = sceneEl.renderer.xr.getCamera(this.camera); // FOV Code from https://github.com/mrdoob/three.js/issues/21869\n\n        sceneEl.renderer.xr.getSession().requestAnimationFrame((time, frame) => {\n          const ref = sceneEl.renderer.xr.getReferenceSpace();\n          const pose = frame.getViewerPose(ref);\n\n          if (pose) {\n            const fovi = pose.views[0].projectionMatrix[5];\n            this.camera.fov = Math.atan2(1, fovi) * 2 * 180 / Math.PI;\n          }\n        });\n      } catch (e) {\n        console.warn('Could not get VR camera');\n      }\n    });\n    sceneEl.addEventListener('exit-vr', e => {\n      this.camera = this.originalCamera;\n    });\n\n    if (data.showStats) {\n      this.stats = this._initStats();\n    }\n\n    if (THREE.Cache.enabled) {\n      console.warn('3D Tiles loader cannot work with THREE.Cache, disabling.');\n      THREE.Cache.enabled = false;\n    }\n\n    await this._nextFrame();\n    this.runtime = runtime;\n    this.runtime.setElevationRange(data.pointcloudElevationRange.map(n => Number(n)));\n    this.viewportSize = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2(sceneEl.clientWidth, sceneEl.clientHeight);\n    window.addEventListener('resize', this.onWindowResize.bind(this));\n  },\n  onWindowResize: function () {\n    const sceneEl = this.el.sceneEl;\n    this.viewportSize.set(sceneEl.clientWidth, sceneEl.clientHeight);\n    this.camera.aspect = sceneEl.clientWidth / sceneEl.clientHeight;\n    this.camera.updateProjectionMatrix();\n  },\n  update: async function (oldData) {\n    if (oldData.url !== this.data.url) {\n      if (this.runtime) {\n        this.runtime.dispose();\n        this.runtime = null;\n      }\n\n      const {\n        model,\n        runtime\n      } = await this._initTileset();\n      this.el.setObject3D('tileset', model);\n      await this._nextFrame();\n      this.runtime = runtime;\n    } else if (this.runtime) {\n      this.runtime.setPointCloudColoring(this._resolvePointcloudColoring(this.data.pointCloudColoring));\n      this.runtime.setWireframe(this.data.wireframe);\n      this.runtime.setViewDistanceScale(this.data.distanceScale);\n      this.runtime.setElevationRange(this.data.pointcloudElevationRange.map(n => Number(n)));\n    }\n\n    if (this.data.showStats && !this.stats) {\n      this.stats = this._initStats();\n    }\n\n    if (!this.data.showStats && this.stats) {\n      this.el.sceneEl.removeChild(this.stats);\n      this.stats = null;\n    } // set parameters for google 3dtiles API\n\n\n    if (this.data.lat && this.data.long || this.data.height) {\n      this.runtime.orientToGeocoord({\n        lat: Number(this.data.lat),\n        long: Number(this.data.long),\n        height: Number(this.data.height)\n      });\n    }\n  },\n  tick: function (t, dt) {\n    if (this.runtime) {\n      this.runtime.update(dt, this.viewportSize, this.camera);\n\n      if (this.stats) {\n        const worldPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        this.camera.getWorldPosition(worldPos);\n        const stats = this.runtime.getStats();\n        this.stats.setAttribute('textarea', 'text', Object.values(stats.stats).map(s => `${s.name}: ${s.count}`).join('\\n'));\n        const newPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        newPos.copy(worldPos);\n        newPos.z -= 2;\n        this.stats.setAttribute('position', newPos);\n      }\n\n      if (this.data.copyrightEl) {\n        this.data.copyrightEl.innerHTML = this.runtime.getDataAttributions() ?? '';\n      }\n    }\n  },\n  remove: function () {\n    if (this.runtime) {\n      this.runtime.dispose();\n    }\n  },\n\n  _resolvePointcloudColoring() {\n    const pointCloudColoring = POINT_CLOUD_COLORING[this.data.pointcloudColoring];\n\n    if (!pointCloudColoring) {\n      console.warn('Invalid value for point cloud coloring');\n      return three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.White;\n    } else {\n      return pointCloudColoring;\n    }\n  },\n\n  _initTileset: async function () {\n    const pointCloudColoring = this._resolvePointcloudColoring(this.data.pointcloudColoring);\n\n    return three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.Loader3DTiles.load({\n      url: this.data.url,\n      renderer: this.el.sceneEl.renderer,\n      options: {\n        googleApiKey: this.data.googleApiKey,\n        cesiumIONToken: this.data.cesiumIONToken,\n        dracoDecoderPath: 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/draco',\n        basisTranscoderPath: 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/basis',\n        maximumScreenSpaceError: this.data.maximumSSE,\n        maximumMemoryUsage: this.data.maximumMem,\n        memoryCacheOverflow: 128,\n        pointCloudColoring: pointCloudColoring,\n        viewDistanceScale: this.data.distanceScale,\n        wireframe: this.data.wireframe,\n        updateTransforms: true\n      }\n    });\n  },\n  _initStats: function () {\n    const stats = document.createElement('a-entity');\n    this.el.sceneEl.appendChild(stats);\n    stats.setAttribute('position', '-0.5 0 -1');\n    stats.setAttribute('textarea', {\n      cols: 30,\n      rows: 15,\n      text: '',\n      color: 'white',\n      disabledBackgroundColor: '#0c1e2c',\n      disabled: true\n    });\n    return stats;\n  },\n  _nextFrame: async function () {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        resolve();\n      }, 0);\n    });\n  }\n});\n\n//# sourceURL=webpack://aframe-loader-3dtiles-component/./index.js?");

/***/ }),

/***/ "./textarea.js":
/*!*********************!*\
  !*** ./textarea.js ***!
  \*********************/
/***/ (() => {

eval("if (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n/**\r\n * Textarea component for A-Frame.\r\n *\r\n * Ripped from: https://github.com/brianpeiris/aframe-textarea-component\r\n */\n\n\nAFRAME.registerComponent('textarea', {\n  schema: {\n    transparentBG: {\n      type: 'boolean',\n      default: false\n    },\n    cols: {\n      type: 'int',\n      default: 40\n    },\n    rows: {\n      type: 'int',\n      default: 20\n    },\n    color: {\n      type: 'color',\n      default: 'black'\n    },\n    backgroundColor: {\n      type: 'color',\n      default: 'white'\n    },\n    disabledBackgroundColor: {\n      type: 'color',\n      default: 'lightgrey'\n    },\n    disabled: {\n      type: 'boolean',\n      default: false\n    },\n    text: {\n      type: 'string',\n      default: ''\n    }\n  },\n  init: function () {\n    this.text = null;\n    this.lines = [];\n    this.lastBlink = 0;\n    this.blinkEnabled = !this.data.disabled;\n    this.charWidth = this.charHeight = null;\n    this.selectionStart = this.selectionEnd = 0;\n    this.endIndexInfo = this.startIndexInfo = null;\n    this.origin = {\n      x: 0,\n      y: 0\n    };\n    this.background = document.createElement('a-plane');\n    this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    this.el.appendChild(this.background);\n\n    if (this.data.transparentBG) {\n      this.background.setAttribute('material', {\n        opacity: 0,\n        transparent: true\n      });\n    }\n\n    this.textAnchor = document.createElement('a-entity');\n    this.el.appendChild(this.textAnchor);\n    this.textAnchor.setAttribute('text', {\n      mode: 'pre',\n      baseline: 'top',\n      anchor: 'center',\n      font: 'dejavu',\n      wrapCount: this.data.cols,\n      height: this.data.rows,\n      color: this.data.color\n    });\n\n    this._initTextarea();\n\n    this.el.addEventListener('textfontset', this._updateCharMetrics.bind(this));\n    this.el.addEventListener('char-metrics-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('text-changed', this._updateLines.bind(this));\n    this.el.addEventListener('text-changed', this._updateDisplayText.bind(this));\n    this.el.addEventListener('selection-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('selection-changed', this._updateHorizontalOrigin.bind(this));\n    this.el.addEventListener('lines-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('index-info-changed', this._updateOrigin.bind(this));\n    this.el.addEventListener('index-info-changed', this._updateHorizontalOrigin.bind(this));\n    this.el.addEventListener('origin-changed', this._updateDisplayText.bind(this));\n    this.el.addEventListener('click', this.focus.bind(this));\n  },\n  update: function (oldData) {\n    if (this.data.text !== oldData.text) {\n      this._updateTextarea();\n    }\n\n    if (this.data.backgroundColor !== oldData.backgroundColor || this.data.disabledBackgroundColor !== oldData.disabledBackgroundColor) {\n      this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    }\n\n    if (this.data.disabled !== oldData.disabled) {\n      this.blinkEnabled = !this.data.disabled;\n      this.textarea.disabled = this.data.disabled;\n      this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    }\n  },\n  focus: function () {\n    this.textarea.focus();\n  },\n  _initTextarea: function () {\n    this.textarea = document.createElement('textarea');\n    document.body.appendChild(this.textarea);\n\n    this._updateTextarea();\n  },\n  _updateTextarea: function () {\n    this.textarea.style.whiteSpace = 'pre';\n    this.textarea.style.overflow = 'hidden';\n    this.textarea.style.opacity = '0';\n    this.textarea.cols = this.data.cols;\n    this.textarea.rows = this.data.rows;\n    this.textarea.value = this.data.text;\n    this.textarea.selectionStart = 0;\n    this.textarea.selectionEnd = 0;\n\n    this._updateIndexInfo();\n  },\n  _emit: function (eventName, detail) {\n    this.el.emit(eventName, detail);\n  },\n  _updateCharMetrics: function (event) {\n    const layout = this.textAnchor.components.text.geometry.layout;\n    const fontWidthFactor = event.detail.fontObj.widthFactor;\n    this.charWidth = fontWidthFactor * this.textAnchor.object3DMap.text.scale.x;\n    this.charHeight = this.charWidth * layout.lineHeight / fontWidthFactor;\n    this.textAnchor.setAttribute('position', {\n      x: 0,\n      y: this.charHeight * this.data.rows / 2,\n      z: 0\n    });\n\n    if (!this.data.transparentBG) {\n      this.background.setAttribute('scale', {\n        x: 1.05,\n        y: this.charHeight * this.data.rows * 1.05,\n        z: 1\n      });\n      this.background.setAttribute('position', {\n        x: 0,\n        y: 0,\n        z: 0\n      });\n    }\n\n    this._emit('char-metrics-changed');\n  },\n  _checkAndUpdateSelection: function () {\n    if (this.selectionStart === this.textarea.selectionStart && this.selectionEnd === this.textarea.selectionEnd) {\n      return;\n    }\n\n    const lastStart = this.selectionStart;\n    const lastEnd = this.selectionEnd;\n    this.selectionStart = this.textarea.selectionStart;\n    this.selectionEnd = this.textarea.selectionEnd;\n\n    this._emit('selection-changed', {\n      start: {\n        old: lastStart,\n        new: this.selectionStart,\n        changed: this.selectionStart !== lastStart\n      },\n      end: {\n        old: lastEnd,\n        new: this.selectionEnd,\n        changed: this.selectionEnd !== lastEnd\n      }\n    });\n  },\n  tick: function (time) {\n    if (time - this.lastBlink > 500 && this.blinkEnabled) {\n      this.lastBlink = time;\n    }\n\n    this._checkAndUpdateSelection();\n\n    this._checkAndUpdateText();\n  },\n  _getIndexInfo: function (lineIndex, textIndex) {\n    const y = Math.max(0, lineIndex);\n    const line = this.lines[y];\n    const x = textIndex - line.start;\n    return {\n      line: line,\n      x: x * this.charWidth,\n      y: -this.charHeight * y + -this.charHeight / 2\n    };\n  },\n  _updateIndexInfo: function () {\n    if (!this.lines.length) {\n      return;\n    }\n\n    const lastStart = this.startIndexInfo && this.startIndexInfo.line.index;\n    const lastEnd = this.endIndexInfo && this.endIndexInfo.line.index;\n    this.startIndexInfo = null;\n    this.endIndexInfo = null;\n    let i;\n    let startChanged = false;\n    let endChanged = false;\n\n    for (i = 0; i <= this.lines.length; i++) {\n      const prevLine = this.lines[i - 1];\n      const lineStart = i === this.lines.length ? prevLine.start + prevLine.length + 1 : this.lines[i].start;\n\n      if (lineStart > this.selectionStart && !this.startIndexInfo) {\n        this.startIndexInfo = this._getIndexInfo(i - 1, this.selectionStart);\n\n        if (this.startIndexInfo.line.index !== lastStart) {\n          startChanged = true;\n        }\n      }\n\n      if (lineStart > this.selectionEnd) {\n        this.endIndexInfo = this._getIndexInfo(i - 1, this.selectionEnd);\n\n        if (this.endIndexInfo.line.index !== lastEnd) {\n          endChanged = true;\n        }\n\n        break;\n      }\n    }\n\n    if (startChanged || endChanged) {\n      this._emit('index-info-changed', {\n        start: {\n          changed: startChanged\n        },\n        end: {\n          changed: endChanged\n        }\n      });\n    }\n  },\n  _updateOrigin: function (event) {\n    let changed = false;\n\n    if (event.detail.end.changed) {\n      const end = this.origin.y + this.data.rows - 1;\n\n      if (this.endIndexInfo.line.index > end) {\n        this.origin.y = this.endIndexInfo.line.index + 1 - this.data.rows;\n        changed = true;\n      } else if (this.endIndexInfo.line.index < this.origin.y) {\n        this.origin.y = this.endIndexInfo.line.index;\n        changed = true;\n      }\n    }\n\n    if (event.detail.start.changed) {\n      if (this.startIndexInfo.line.index < this.origin.y) {\n        this.origin.y = this.startIndexInfo.line.index;\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      this._emit('origin-changed');\n    }\n  },\n  _updateHorizontalOrigin: function (event) {\n    if (!this.endIndexInfo) {\n      return;\n    }\n\n    let changed = true;\n\n    if (event.detail.end.changed) {\n      const endIndex = this.selectionEnd - this.endIndexInfo.line.start;\n\n      if (endIndex > this.origin.x + this.data.cols) {\n        this.origin.x = endIndex - this.data.cols;\n        changed = true;\n      } else if (endIndex < this.origin.x) {\n        this.origin.x = endIndex;\n        changed = true;\n      }\n    }\n\n    const startIndex = this.selectionStart - this.startIndexInfo.line.start;\n\n    if (event.detail.start.changed) {\n      if (startIndex > this.origin.x + this.data.cols) {\n        this.origin.x = startIndex - this.data.cols;\n        changed = true;\n      } else if (startIndex < this.origin.x) {\n        this.origin.x = startIndex;\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      this._emit('origin-changed');\n    }\n  },\n  _updateLines: function () {\n    this.lines = [];\n    const lines = this.text.split('\\n');\n    let counter = 0;\n\n    for (let i = 0; i < lines.length; i++) {\n      this.lines[i] = {\n        index: i,\n        length: lines[i].length,\n        start: counter\n      };\n      counter += lines[i].length + 1;\n    }\n\n    this._emit('lines-changed');\n  },\n  _getViewportText: function () {\n    return this.text.split('\\n').slice(this.origin.y, this.origin.y + this.data.rows).map(function (line) {\n      return line.substr(this.origin.x, this.data.cols) || ' ';\n    }.bind(this)).join('\\n');\n  },\n  _updateDisplayText: function () {\n    this.textAnchor.setAttribute('text', {\n      value: this._getViewportText()\n    });\n  },\n  _checkAndUpdateText: function () {\n    const text = this.textarea.value;\n\n    if (text === this.text) {\n      return;\n    }\n\n    this.text = text;\n\n    this._emit('text-changed');\n  }\n});\n\n//# sourceURL=webpack://aframe-loader-3dtiles-component/./textarea.js?");

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_three__;

/***/ }),

/***/ "./node_modules/three-loader-3dtiles/dist/lib/three-loader-3dtiles.js":
/*!****************************************************************************!*\
  !*** ./node_modules/three-loader-3dtiles/dist/lib/three-loader-3dtiles.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Loader3DTiles\": () => (/* binding */ CB),\n/* harmony export */   \"PointCloudColoring\": () => (/* binding */ Tc),\n/* harmony export */   \"Shading\": () => (/* binding */ Dn)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three/examples/jsm/loaders/KTX2Loader.js */ \"three\");\n\n\n\n\nasync function He(e, t, n, s) {\n  return s._parse(e, t, n, s);\n}\nfunction U(e, t) {\n  if (!e)\n    throw new Error(t || \"loader assertion failed.\");\n}\nconst Ln = !!(typeof process != \"object\" || String(process) !== \"[object process]\" || process.browser), Gr = typeof process < \"u\" && process.version && /v([0-9]*)/.exec(process.version);\nGr && parseFloat(Gr[1]);\nfunction Hc(e, t) {\n  return Oo(e || {}, t);\n}\nfunction Oo(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  if (n > 3)\n    return t;\n  const s = {\n    ...e\n  };\n  for (const [r, i] of Object.entries(t))\n    i && typeof i == \"object\" && !Array.isArray(i) ? s[r] = Oo(s[r] || {}, t[r], n + 1) : s[r] = t[r];\n  return s;\n}\nconst Jc = \"latest\";\nfunction Vc() {\n  var e;\n  return (e = globalThis._loadersgl_) !== null && e !== void 0 && e.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = \"4.1.1\"), globalThis._loadersgl_.version;\n}\nconst Fo = Vc();\nfunction Pt(e, t) {\n  if (!e)\n    throw new Error(t || \"loaders.gl assertion failed.\");\n}\nconst Et = typeof process != \"object\" || String(process) !== \"[object process]\" || process.browser, nr = typeof importScripts == \"function\", jc = typeof window < \"u\" && typeof window.orientation < \"u\", Pr = typeof process < \"u\" && process.version && /v([0-9]*)/.exec(process.version);\nPr && parseFloat(Pr[1]);\nclass kc {\n  constructor(t, n) {\n    this.name = void 0, this.workerThread = void 0, this.isRunning = !0, this.result = void 0, this._resolve = () => {\n    }, this._reject = () => {\n    }, this.name = t, this.workerThread = n, this.result = new Promise((s, r) => {\n      this._resolve = s, this._reject = r;\n    });\n  }\n  postMessage(t, n) {\n    this.workerThread.postMessage({\n      source: \"loaders.gl\",\n      type: t,\n      payload: n\n    });\n  }\n  done(t) {\n    Pt(this.isRunning), this.isRunning = !1, this._resolve(t);\n  }\n  error(t) {\n    Pt(this.isRunning), this.isRunning = !1, this._reject(t);\n  }\n}\nclass qn {\n  terminate() {\n  }\n}\nconst Yn = /* @__PURE__ */ new Map();\nfunction Kc(e) {\n  Pt(e.source && !e.url || !e.source && e.url);\n  let t = Yn.get(e.source || e.url);\n  return t || (e.url && (t = zc(e.url), Yn.set(e.url, t)), e.source && (t = vo(e.source), Yn.set(e.source, t))), Pt(t), t;\n}\nfunction zc(e) {\n  if (!e.startsWith(\"http\"))\n    return e;\n  const t = Wc(e);\n  return vo(t);\n}\nfunction vo(e) {\n  const t = new Blob([e], {\n    type: \"application/javascript\"\n  });\n  return URL.createObjectURL(t);\n}\nfunction Wc(e) {\n  return `try {\n  importScripts('${e}');\n} catch (error) {\n  console.error(error);\n  throw error;\n}`;\n}\nfunction Do(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = n || /* @__PURE__ */ new Set();\n  if (e) {\n    if (Nr(e))\n      s.add(e);\n    else if (Nr(e.buffer))\n      s.add(e.buffer);\n    else if (!ArrayBuffer.isView(e)) {\n      if (t && typeof e == \"object\")\n        for (const r in e)\n          Do(e[r], t, s);\n    }\n  }\n  return n === void 0 ? Array.from(s) : [];\n}\nfunction Nr(e) {\n  return e ? e instanceof ArrayBuffer || typeof MessagePort < \"u\" && e instanceof MessagePort || typeof ImageBitmap < \"u\" && e instanceof ImageBitmap || typeof OffscreenCanvas < \"u\" && e instanceof OffscreenCanvas : !1;\n}\nconst $n = () => {\n};\nclass Ds {\n  static isSupported() {\n    return typeof Worker < \"u\" && Et || typeof qn < \"u\" && !Et;\n  }\n  constructor(t) {\n    this.name = void 0, this.source = void 0, this.url = void 0, this.terminated = !1, this.worker = void 0, this.onMessage = void 0, this.onError = void 0, this._loadableURL = \"\";\n    const {\n      name: n,\n      source: s,\n      url: r\n    } = t;\n    Pt(s || r), this.name = n, this.source = s, this.url = r, this.onMessage = $n, this.onError = (i) => console.log(i), this.worker = Et ? this._createBrowserWorker() : this._createNodeWorker();\n  }\n  destroy() {\n    this.onMessage = $n, this.onError = $n, this.worker.terminate(), this.terminated = !0;\n  }\n  get isRunning() {\n    return !!this.onMessage;\n  }\n  postMessage(t, n) {\n    n = n || Do(t), this.worker.postMessage(t, n);\n  }\n  _getErrorFromErrorEvent(t) {\n    let n = \"Failed to load \";\n    return n += `worker ${this.name} from ${this.url}. `, t.message && (n += `${t.message} in `), t.lineno && (n += `:${t.lineno}:${t.colno}`), new Error(n);\n  }\n  _createBrowserWorker() {\n    this._loadableURL = Kc({\n      source: this.source,\n      url: this.url\n    });\n    const t = new Worker(this._loadableURL, {\n      name: this.name\n    });\n    return t.onmessage = (n) => {\n      n.data ? this.onMessage(n.data) : this.onError(new Error(\"No data received\"));\n    }, t.onerror = (n) => {\n      this.onError(this._getErrorFromErrorEvent(n)), this.terminated = !0;\n    }, t.onmessageerror = (n) => console.error(n), t;\n  }\n  _createNodeWorker() {\n    let t;\n    if (this.url) {\n      const s = this.url.includes(\":/\") || this.url.startsWith(\"/\") ? this.url : `./${this.url}`;\n      t = new qn(s, {\n        eval: !1\n      });\n    } else if (this.source)\n      t = new qn(this.source, {\n        eval: !0\n      });\n    else\n      throw new Error(\"no worker\");\n    return t.on(\"message\", (n) => {\n      this.onMessage(n);\n    }), t.on(\"error\", (n) => {\n      this.onError(n);\n    }), t.on(\"exit\", (n) => {\n    }), t;\n  }\n}\nclass Xc {\n  static isSupported() {\n    return Ds.isSupported();\n  }\n  constructor(t) {\n    this.name = \"unnamed\", this.source = void 0, this.url = void 0, this.maxConcurrency = 1, this.maxMobileConcurrency = 1, this.onDebug = () => {\n    }, this.reuseWorkers = !0, this.props = {}, this.jobQueue = [], this.idleQueue = [], this.count = 0, this.isDestroyed = !1, this.source = t.source, this.url = t.url, this.setProps(t);\n  }\n  destroy() {\n    this.idleQueue.forEach((t) => t.destroy()), this.isDestroyed = !0;\n  }\n  setProps(t) {\n    this.props = {\n      ...this.props,\n      ...t\n    }, t.name !== void 0 && (this.name = t.name), t.maxConcurrency !== void 0 && (this.maxConcurrency = t.maxConcurrency), t.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = t.maxMobileConcurrency), t.reuseWorkers !== void 0 && (this.reuseWorkers = t.reuseWorkers), t.onDebug !== void 0 && (this.onDebug = t.onDebug);\n  }\n  async startJob(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (i, o, a) => i.done(a), s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (i, o) => i.error(o);\n    const r = new Promise((i) => (this.jobQueue.push({\n      name: t,\n      onMessage: n,\n      onError: s,\n      onStart: i\n    }), this));\n    return this._startQueuedJob(), await r;\n  }\n  async _startQueuedJob() {\n    if (!this.jobQueue.length)\n      return;\n    const t = this._getAvailableWorker();\n    if (!t)\n      return;\n    const n = this.jobQueue.shift();\n    if (n) {\n      this.onDebug({\n        message: \"Starting job\",\n        name: n.name,\n        workerThread: t,\n        backlog: this.jobQueue.length\n      });\n      const s = new kc(n.name, t);\n      t.onMessage = (r) => n.onMessage(s, r.type, r.payload), t.onError = (r) => n.onError(s, r), n.onStart(s);\n      try {\n        await s.result;\n      } catch (r) {\n        console.error(`Worker exception: ${r}`);\n      } finally {\n        this.returnWorkerToQueue(t);\n      }\n    }\n  }\n  returnWorkerToQueue(t) {\n    !Et || this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency() ? (t.destroy(), this.count--) : this.idleQueue.push(t), this.isDestroyed || this._startQueuedJob();\n  }\n  _getAvailableWorker() {\n    if (this.idleQueue.length > 0)\n      return this.idleQueue.shift() || null;\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const t = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new Ds({\n        name: t,\n        source: this.source,\n        url: this.url\n      });\n    }\n    return null;\n  }\n  _getMaxConcurrency() {\n    return jc ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n}\nconst Qc = {\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  reuseWorkers: !0,\n  onDebug: () => {\n  }\n};\nclass Dt {\n  static isSupported() {\n    return Ds.isSupported();\n  }\n  static getWorkerFarm() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    return Dt._workerFarm = Dt._workerFarm || new Dt({}), Dt._workerFarm.setProps(t), Dt._workerFarm;\n  }\n  constructor(t) {\n    this.props = void 0, this.workerPools = /* @__PURE__ */ new Map(), this.props = {\n      ...Qc\n    }, this.setProps(t), this.workerPools = /* @__PURE__ */ new Map();\n  }\n  destroy() {\n    for (const t of this.workerPools.values())\n      t.destroy();\n    this.workerPools = /* @__PURE__ */ new Map();\n  }\n  setProps(t) {\n    this.props = {\n      ...this.props,\n      ...t\n    };\n    for (const n of this.workerPools.values())\n      n.setProps(this._getWorkerPoolProps());\n  }\n  getWorkerPool(t) {\n    const {\n      name: n,\n      source: s,\n      url: r\n    } = t;\n    let i = this.workerPools.get(n);\n    return i || (i = new Xc({\n      name: n,\n      source: s,\n      url: r\n    }), i.setProps(this._getWorkerPoolProps()), this.workerPools.set(n, i)), i;\n  }\n  _getWorkerPoolProps() {\n    return {\n      maxConcurrency: this.props.maxConcurrency,\n      maxMobileConcurrency: this.props.maxMobileConcurrency,\n      reuseWorkers: this.props.reuseWorkers,\n      onDebug: this.props.onDebug\n    };\n  }\n}\nDt._workerFarm = void 0;\nfunction qc(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  const n = t[e.id] || {}, s = Et ? `${e.id}-worker.js` : `${e.id}-worker-node.js`;\n  let r = n.workerUrl;\n  if (!r && e.id === \"compression\" && (r = t.workerUrl), t._workerType === \"test\" && (Et ? r = `modules/${e.module}/dist/${s}` : r = `modules/${e.module}/src/workers/${e.id}-worker-node.ts`), !r) {\n    let i = e.version;\n    i === \"latest\" && (i = Jc);\n    const o = i ? `@${i}` : \"\";\n    r = `https://unpkg.com/@loaders.gl/${e.module}${o}/dist/${s}`;\n  }\n  return Pt(r), r;\n}\nfunction Yc(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Fo;\n  Pt(e, \"no worker provided\");\n  const n = e.version;\n  return !(!t || !n);\n}\nconst $c = {}, Zc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  default: $c\n}, Symbol.toStringTag, { value: \"Module\" })), Zn = {};\nasync function Xt(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n  return t && (e = tu(e, t, n, s)), Zn[e] = Zn[e] || eu(e), await Zn[e];\n}\nfunction tu(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n  if (!n.useLocalLibraries && e.startsWith(\"http\"))\n    return e;\n  s = s || e;\n  const r = n.modules || {};\n  return r[s] ? r[s] : Et ? n.CDN ? (Pt(n.CDN.startsWith(\"http\")), `${n.CDN}/${t}@${Fo}/dist/libs/${s}`) : nr ? `../src/libs/${s}` : `modules/${t}/src/libs/${s}` : `modules/${t}/dist/libs/${s}`;\n}\nasync function eu(e) {\n  if (e.endsWith(\"wasm\"))\n    return await su(e);\n  if (!Et)\n    try {\n      return Zc && void 0;\n    } catch (n) {\n      return console.error(n), null;\n    }\n  if (nr)\n    return importScripts(e);\n  const t = await ru(e);\n  return nu(t, e);\n}\nfunction nu(e, t) {\n  if (!Et)\n    return;\n  if (nr)\n    return eval.call(globalThis, e), null;\n  const n = document.createElement(\"script\");\n  n.id = t;\n  try {\n    n.appendChild(document.createTextNode(e));\n  } catch {\n    n.text = e;\n  }\n  return document.body.appendChild(n), null;\n}\nasync function su(e) {\n  return await (await fetch(e)).arrayBuffer();\n}\nasync function ru(e) {\n  return await (await fetch(e)).text();\n}\nfunction iu(e, t) {\n  return !Dt.isSupported() || !Et && !(t != null && t._nodeWorkers) ? !1 : e.worker && (t == null ? void 0 : t.worker);\n}\nasync function ou(e, t, n, s, r) {\n  const i = e.id, o = qc(e, n), c = Dt.getWorkerFarm(n).getWorkerPool({\n    name: i,\n    url: o\n  });\n  n = JSON.parse(JSON.stringify(n)), s = JSON.parse(JSON.stringify(s || {}));\n  const u = await c.startJob(\"process-on-worker\", au.bind(null, r));\n  return u.postMessage(\"process\", {\n    input: t,\n    options: n,\n    context: s\n  }), await (await u.result).result;\n}\nasync function au(e, t, n, s) {\n  switch (n) {\n    case \"done\":\n      t.done(s);\n      break;\n    case \"error\":\n      t.error(new Error(s.error));\n      break;\n    case \"process\":\n      const {\n        id: r,\n        input: i,\n        options: o\n      } = s;\n      try {\n        const a = await e(i, o);\n        t.postMessage(\"done\", {\n          id: r,\n          result: a\n        });\n      } catch (a) {\n        const c = a instanceof Error ? a.message : \"unknown error\";\n        t.postMessage(\"error\", {\n          id: r,\n          error: c\n        });\n      }\n      break;\n    default:\n      console.warn(`parse-with-worker unknown message ${n}`);\n  }\n}\nfunction cu(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;\n  return typeof e == \"string\" ? e.slice(0, t) : ArrayBuffer.isView(e) ? Ur(e.buffer, e.byteOffset, t) : e instanceof ArrayBuffer ? Ur(e, 0, t) : \"\";\n}\nfunction Ur(e, t, n) {\n  if (e.byteLength <= t + n)\n    return \"\";\n  const s = new DataView(e);\n  let r = \"\";\n  for (let i = 0; i < n; i++)\n    r += String.fromCharCode(s.getUint8(t + i));\n  return r;\n}\nfunction uu(e) {\n  try {\n    return JSON.parse(e);\n  } catch {\n    throw new Error(`Failed to parse JSON from data starting with \"${cu(e)}\"`);\n  }\n}\nfunction lu(e, t, n) {\n  if (n = n || e.byteLength, e.byteLength < n || t.byteLength < n)\n    return !1;\n  const s = new Uint8Array(e), r = new Uint8Array(t);\n  for (let i = 0; i < s.length; ++i)\n    if (s[i] !== r[i])\n      return !1;\n  return !0;\n}\nfunction hu() {\n  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)\n    t[n] = arguments[n];\n  return fu(t);\n}\nfunction fu(e) {\n  const t = e.map((i) => i instanceof ArrayBuffer ? new Uint8Array(i) : i), n = t.reduce((i, o) => i + o.byteLength, 0), s = new Uint8Array(n);\n  let r = 0;\n  for (const i of t)\n    s.set(i, r), r += i.byteLength;\n  return s.buffer;\n}\nfunction sr(e, t, n) {\n  const s = n !== void 0 ? new Uint8Array(e).subarray(t, t + n) : new Uint8Array(e).subarray(t);\n  return new Uint8Array(s).buffer;\n}\nfunction Je(e, t) {\n  return U(e >= 0), U(t > 0), e + (t - 1) & ~(t - 1);\n}\nfunction du(e, t, n) {\n  let s;\n  if (e instanceof ArrayBuffer)\n    s = new Uint8Array(e);\n  else {\n    const r = e.byteOffset, i = e.byteLength;\n    s = new Uint8Array(e.buffer || e.arrayBuffer, r, i);\n  }\n  return t.set(s, n), n + Je(s.byteLength, 4);\n}\nasync function mu(e) {\n  const t = [];\n  for await (const n of e)\n    t.push(n);\n  return hu(...t);\n}\nfunction Hr() {\n  let e;\n  if (typeof window < \"u\" && window.performance)\n    e = window.performance.now();\n  else if (typeof process < \"u\" && process.hrtime) {\n    const t = process.hrtime();\n    e = t[0] * 1e3 + t[1] / 1e6;\n  } else\n    e = Date.now();\n  return e;\n}\nclass Jr {\n  constructor(t, n) {\n    this.name = void 0, this.type = void 0, this.sampleSize = 1, this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this.name = t, this.type = n, this.reset();\n  }\n  reset() {\n    return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this;\n  }\n  setSampleSize(t) {\n    return this.sampleSize = t, this;\n  }\n  incrementCount() {\n    return this.addCount(1), this;\n  }\n  decrementCount() {\n    return this.subtractCount(1), this;\n  }\n  addCount(t) {\n    return this._count += t, this._samples++, this._checkSampling(), this;\n  }\n  subtractCount(t) {\n    return this._count -= t, this._samples++, this._checkSampling(), this;\n  }\n  addTime(t) {\n    return this._time += t, this.lastTiming = t, this._samples++, this._checkSampling(), this;\n  }\n  timeStart() {\n    return this._startTime = Hr(), this._timerPending = !0, this;\n  }\n  timeEnd() {\n    return this._timerPending ? (this.addTime(Hr() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this;\n  }\n  getSampleAverageCount() {\n    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;\n  }\n  getSampleAverageTime() {\n    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;\n  }\n  getSampleHz() {\n    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;\n  }\n  getAverageCount() {\n    return this.samples > 0 ? this.count / this.samples : 0;\n  }\n  getAverageTime() {\n    return this.samples > 0 ? this.time / this.samples : 0;\n  }\n  getHz() {\n    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;\n  }\n  _checkSampling() {\n    this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0);\n  }\n}\nclass Lo {\n  constructor(t) {\n    this.id = void 0, this.stats = {}, this.id = t.id, this.stats = {}, this._initializeStats(t.stats), Object.seal(this);\n  }\n  get(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"count\";\n    return this._getOrCreate({\n      name: t,\n      type: n\n    });\n  }\n  get size() {\n    return Object.keys(this.stats).length;\n  }\n  reset() {\n    for (const t of Object.values(this.stats))\n      t.reset();\n    return this;\n  }\n  forEach(t) {\n    for (const n of Object.values(this.stats))\n      t(n);\n  }\n  getTable() {\n    const t = {};\n    return this.forEach((n) => {\n      t[n.name] = {\n        time: n.time || 0,\n        count: n.count || 0,\n        average: n.getAverageTime() || 0,\n        hz: n.getHz() || 0\n      };\n    }), t;\n  }\n  _initializeStats() {\n    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((n) => this._getOrCreate(n));\n  }\n  _getOrCreate(t) {\n    const {\n      name: n,\n      type: s\n    } = t;\n    let r = this.stats[n];\n    return r || (t instanceof Jr ? r = t : r = new Jr(n, s), this.stats[n] = r), r;\n  }\n}\nconst gu = \"Queued Requests\", Au = \"Active Requests\", pu = \"Cancelled Requests\", yu = \"Queued Requests Ever\", Bu = \"Active Requests Ever\", Cu = {\n  id: \"request-scheduler\",\n  throttleRequests: !0,\n  maxRequests: 6\n};\nclass Eu {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    this.props = void 0, this.stats = void 0, this.activeRequestCount = 0, this.requestQueue = [], this.requestMap = /* @__PURE__ */ new Map(), this.deferredUpdate = null, this.props = {\n      ...Cu,\n      ...t\n    }, this.stats = new Lo({\n      id: this.props.id\n    }), this.stats.get(gu), this.stats.get(Au), this.stats.get(pu), this.stats.get(yu), this.stats.get(Bu);\n  }\n  scheduleRequest(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => 0;\n    if (!this.props.throttleRequests)\n      return Promise.resolve({\n        done: () => {\n        }\n      });\n    if (this.requestMap.has(t))\n      return this.requestMap.get(t);\n    const s = {\n      handle: t,\n      priority: 0,\n      getPriority: n\n    }, r = new Promise((i) => (s.resolve = i, s));\n    return this.requestQueue.push(s), this.requestMap.set(t, r), this._issueNewRequests(), r;\n  }\n  _issueRequest(t) {\n    const {\n      handle: n,\n      resolve: s\n    } = t;\n    let r = !1;\n    const i = () => {\n      r || (r = !0, this.requestMap.delete(n), this.activeRequestCount--, this._issueNewRequests());\n    };\n    return this.activeRequestCount++, s ? s({\n      done: i\n    }) : Promise.resolve({\n      done: i\n    });\n  }\n  _issueNewRequests() {\n    this.deferredUpdate || (this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0));\n  }\n  _issueNewRequestsAsync() {\n    this.deferredUpdate = null;\n    const t = Math.max(this.props.maxRequests - this.activeRequestCount, 0);\n    if (t !== 0) {\n      this._updateAllRequests();\n      for (let n = 0; n < t; ++n) {\n        const s = this.requestQueue.shift();\n        s && this._issueRequest(s);\n      }\n    }\n  }\n  _updateAllRequests() {\n    const t = this.requestQueue;\n    for (let n = 0; n < t.length; ++n) {\n      const s = t[n];\n      this._updateRequest(s) || (t.splice(n, 1), this.requestMap.delete(s.handle), n--);\n    }\n    t.sort((n, s) => n.priority - s.priority);\n  }\n  _updateRequest(t) {\n    return t.priority = t.getPriority(t.handle), t.priority < 0 ? (t.resolve(null), !1) : !0;\n  }\n}\nlet Tu = \"\";\nconst Vr = {};\nfunction bu(e) {\n  for (const t in Vr)\n    if (e.startsWith(t)) {\n      const n = Vr[t];\n      e = e.replace(t, n);\n    }\n  return !e.startsWith(\"http://\") && !e.startsWith(\"https://\") && (e = `${Tu}${e}`), e;\n}\nfunction _u(e) {\n  return e && typeof e == \"object\" && e.isBuffer;\n}\nfunction Go(e) {\n  if (_u(e))\n    return e;\n  if (e instanceof ArrayBuffer)\n    return e;\n  if (ArrayBuffer.isView(e))\n    return e.byteOffset === 0 && e.byteLength === e.buffer.byteLength ? e.buffer : e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);\n  if (typeof e == \"string\") {\n    const t = e;\n    return new TextEncoder().encode(t).buffer;\n  }\n  if (e && typeof e == \"object\" && e._toArrayBuffer)\n    return e._toArrayBuffer();\n  throw new Error(\"toArrayBuffer\");\n}\nfunction wu() {\n  var e;\n  if (typeof process < \"u\" && typeof process.cwd < \"u\")\n    return process.cwd();\n  const t = (e = window.location) === null || e === void 0 ? void 0 : e.pathname;\n  return (t == null ? void 0 : t.slice(0, t.lastIndexOf(\"/\") + 1)) || \"\";\n}\nfunction Po(e) {\n  const t = e ? e.lastIndexOf(\"/\") : -1;\n  return t >= 0 ? e.substr(t + 1) : \"\";\n}\nfunction rr(e) {\n  const t = e ? e.lastIndexOf(\"/\") : -1;\n  return t >= 0 ? e.substr(0, t) : \"\";\n}\nfunction Ru() {\n  const e = [];\n  for (let r = 0; r < arguments.length; r++)\n    e[r] = r < 0 || arguments.length <= r ? void 0 : arguments[r];\n  let t = \"\", n = !1, s;\n  for (let r = e.length - 1; r >= -1 && !n; r--) {\n    let i;\n    r >= 0 ? i = e[r] : (s === void 0 && (s = wu()), i = s), i.length !== 0 && (t = `${i}/${t}`, n = i.charCodeAt(0) === we);\n  }\n  return t = Mu(t, !n), n ? `/${t}` : t.length > 0 ? t : \".\";\n}\nconst we = 47, ts = 46;\nfunction Mu(e, t) {\n  let n = \"\", s = -1, r = 0, i, o = !1;\n  for (let a = 0; a <= e.length; ++a) {\n    if (a < e.length)\n      i = e.charCodeAt(a);\n    else {\n      if (i === we)\n        break;\n      i = we;\n    }\n    if (i === we) {\n      if (!(s === a - 1 || r === 1))\n        if (s !== a - 1 && r === 2) {\n          if (n.length < 2 || !o || n.charCodeAt(n.length - 1) !== ts || n.charCodeAt(n.length - 2) !== ts) {\n            if (n.length > 2) {\n              const c = n.length - 1;\n              let u = c;\n              for (; u >= 0 && n.charCodeAt(u) !== we; --u)\n                ;\n              if (u !== c) {\n                n = u === -1 ? \"\" : n.slice(0, u), s = a, r = 0, o = !1;\n                continue;\n              }\n            } else if (n.length === 2 || n.length === 1) {\n              n = \"\", s = a, r = 0, o = !1;\n              continue;\n            }\n          }\n          t && (n.length > 0 ? n += \"/..\" : n = \"..\", o = !0);\n        } else {\n          const c = e.slice(s + 1, a);\n          n.length > 0 ? n += `/${c}` : n = c, o = !1;\n        }\n      s = a, r = 0;\n    } else\n      i === ts && r !== -1 ? ++r : r = -1;\n  }\n  return n;\n}\nconst Iu = (e) => typeof e == \"boolean\", Me = (e) => typeof e == \"function\", Ve = (e) => e !== null && typeof e == \"object\", jr = (e) => Ve(e) && e.constructor === {}.constructor, Su = (e) => !!e && typeof e[Symbol.iterator] == \"function\", xu = (e) => e && typeof e[Symbol.asyncIterator] == \"function\", $t = (e) => typeof Response < \"u\" && e instanceof Response || e && e.arrayBuffer && e.text && e.json, Zt = (e) => typeof Blob < \"u\" && e instanceof Blob, Ou = (e) => e && typeof e == \"object\" && e.isBuffer, Fu = (e) => typeof ReadableStream < \"u\" && e instanceof ReadableStream || Ve(e) && Me(e.tee) && Me(e.cancel) && Me(e.getReader), vu = (e) => Ve(e) && Me(e.read) && Me(e.pipe) && Iu(e.readable), No = (e) => Fu(e) || vu(e), Du = /^data:([-\\w.]+\\/[-\\w.+]+)(;|,)/, Lu = /^([-\\w.]+\\/[-\\w.+]+)/;\nfunction Gu(e) {\n  const t = Lu.exec(e);\n  return t ? t[1] : e;\n}\nfunction kr(e) {\n  const t = Du.exec(e);\n  return t ? t[1] : \"\";\n}\nconst Uo = /\\?.*/;\nfunction Pu(e) {\n  const t = e.match(Uo);\n  return t && t[0];\n}\nfunction ir(e) {\n  return e.replace(Uo, \"\");\n}\nfunction Gn(e) {\n  return $t(e) ? e.url : Zt(e) ? e.name || \"\" : typeof e == \"string\" ? e : \"\";\n}\nfunction or(e) {\n  if ($t(e)) {\n    const t = e, n = t.headers.get(\"content-type\") || \"\", s = ir(t.url);\n    return Gu(n) || kr(s);\n  }\n  return Zt(e) ? e.type || \"\" : typeof e == \"string\" ? kr(e) : \"\";\n}\nfunction Nu(e) {\n  return $t(e) ? e.headers[\"content-length\"] || -1 : Zt(e) ? e.size : typeof e == \"string\" ? e.length : e instanceof ArrayBuffer || ArrayBuffer.isView(e) ? e.byteLength : -1;\n}\nasync function Ho(e) {\n  if ($t(e))\n    return e;\n  const t = {}, n = Nu(e);\n  n >= 0 && (t[\"content-length\"] = String(n));\n  const s = Gn(e), r = or(e);\n  r && (t[\"content-type\"] = r);\n  const i = await Ju(e);\n  i && (t[\"x-first-bytes\"] = i), typeof e == \"string\" && (e = new TextEncoder().encode(e));\n  const o = new Response(e, {\n    headers: t\n  });\n  return Object.defineProperty(o, \"url\", {\n    value: s\n  }), o;\n}\nasync function Uu(e) {\n  if (!e.ok) {\n    const t = await Hu(e);\n    throw new Error(t);\n  }\n}\nasync function Hu(e) {\n  let t = `Failed to fetch resource ${e.url} (${e.status}): `;\n  try {\n    const n = e.headers.get(\"Content-Type\");\n    let s = e.statusText;\n    n != null && n.includes(\"application/json\") && (s += ` ${await e.text()}`), t += s, t = t.length > 60 ? `${t.slice(0, 60)}...` : t;\n  } catch {\n  }\n  return t;\n}\nasync function Ju(e) {\n  if (typeof e == \"string\")\n    return `data:,${e.slice(0, 5)}`;\n  if (e instanceof Blob) {\n    const n = e.slice(0, 5);\n    return await new Promise((s) => {\n      const r = new FileReader();\n      r.onload = (i) => {\n        var o;\n        return s(i == null || (o = i.target) === null || o === void 0 ? void 0 : o.result);\n      }, r.readAsDataURL(n);\n    });\n  }\n  if (e instanceof ArrayBuffer) {\n    const n = e.slice(0, 5);\n    return `data:base64,${Vu(n)}`;\n  }\n  return null;\n}\nfunction Vu(e) {\n  let t = \"\";\n  const n = new Uint8Array(e);\n  for (let s = 0; s < n.byteLength; s++)\n    t += String.fromCharCode(n[s]);\n  return btoa(t);\n}\nfunction ju(e) {\n  return !ku(e) && !Ku(e);\n}\nfunction ku(e) {\n  return e.startsWith(\"http:\") || e.startsWith(\"https:\");\n}\nfunction Ku(e) {\n  return e.startsWith(\"data:\");\n}\nasync function Fe(e, t) {\n  if (typeof e == \"string\") {\n    const r = bu(e);\n    if (ju(r)) {\n      var n;\n      if ((n = globalThis.loaders) !== null && n !== void 0 && n.fetchNode) {\n        var s;\n        return (s = globalThis.loaders) === null || s === void 0 ? void 0 : s.fetchNode(r, t);\n      }\n    }\n    return await fetch(r, t);\n  }\n  return await Ho(e);\n}\nfunction zu(e) {\n  if (typeof window < \"u\" && typeof window.process == \"object\" && window.process.type === \"renderer\" || typeof process < \"u\" && typeof process.versions == \"object\" && process.versions.electron)\n    return !0;\n  const t = typeof navigator == \"object\" && typeof navigator.userAgent == \"string\" && navigator.userAgent, n = e || t;\n  return !!(n && n.indexOf(\"Electron\") >= 0);\n}\nfunction je() {\n  return !(typeof process == \"object\" && String(process) === \"[object process]\" && !process.browser) || zu();\n}\nconst Xe = globalThis.window || globalThis.self || globalThis.global, pe = globalThis.process || {}, Jo = typeof __VERSION__ < \"u\" ? __VERSION__ : \"untranspiled source\";\nje();\nfunction Wu(e) {\n  try {\n    const t = window[e], n = \"__storage_test__\";\n    return t.setItem(n, n), t.removeItem(n), t;\n  } catch {\n    return null;\n  }\n}\nclass Xu {\n  constructor(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"sessionStorage\";\n    this.storage = void 0, this.id = void 0, this.config = void 0, this.storage = Wu(s), this.id = t, this.config = n, this._loadConfiguration();\n  }\n  getConfiguration() {\n    return this.config;\n  }\n  setConfiguration(t) {\n    if (Object.assign(this.config, t), this.storage) {\n      const n = JSON.stringify(this.config);\n      this.storage.setItem(this.id, n);\n    }\n  }\n  _loadConfiguration() {\n    let t = {};\n    if (this.storage) {\n      const n = this.storage.getItem(this.id);\n      t = n ? JSON.parse(n) : {};\n    }\n    return Object.assign(this.config, t), this;\n  }\n}\nfunction Qu(e) {\n  let t;\n  return e < 10 ? t = \"\".concat(e.toFixed(2), \"ms\") : e < 100 ? t = \"\".concat(e.toFixed(1), \"ms\") : e < 1e3 ? t = \"\".concat(e.toFixed(0), \"ms\") : t = \"\".concat((e / 1e3).toFixed(2), \"s\"), t;\n}\nfunction qu(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;\n  const n = Math.max(t - e.length, 0);\n  return \"\".concat(\" \".repeat(n)).concat(e);\n}\nfunction es(e, t, n) {\n  let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;\n  const r = e.src.replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\");\n  e.width > s && (n = Math.min(n, s / e.width));\n  const i = e.width * n, o = e.height * n, a = [\"font-size:1px;\", \"padding:\".concat(Math.floor(o / 2), \"px \").concat(Math.floor(i / 2), \"px;\"), \"line-height:\".concat(o, \"px;\"), \"background:url(\".concat(r, \");\"), \"background-size:\".concat(i, \"px \").concat(o, \"px;\"), \"color:transparent;\"].join(\"\");\n  return [\"\".concat(t, \" %c+\"), a];\n}\nlet Tn;\n(function(e) {\n  e[e.BLACK = 30] = \"BLACK\", e[e.RED = 31] = \"RED\", e[e.GREEN = 32] = \"GREEN\", e[e.YELLOW = 33] = \"YELLOW\", e[e.BLUE = 34] = \"BLUE\", e[e.MAGENTA = 35] = \"MAGENTA\", e[e.CYAN = 36] = \"CYAN\", e[e.WHITE = 37] = \"WHITE\", e[e.BRIGHT_BLACK = 90] = \"BRIGHT_BLACK\", e[e.BRIGHT_RED = 91] = \"BRIGHT_RED\", e[e.BRIGHT_GREEN = 92] = \"BRIGHT_GREEN\", e[e.BRIGHT_YELLOW = 93] = \"BRIGHT_YELLOW\", e[e.BRIGHT_BLUE = 94] = \"BRIGHT_BLUE\", e[e.BRIGHT_MAGENTA = 95] = \"BRIGHT_MAGENTA\", e[e.BRIGHT_CYAN = 96] = \"BRIGHT_CYAN\", e[e.BRIGHT_WHITE = 97] = \"BRIGHT_WHITE\";\n})(Tn || (Tn = {}));\nconst Yu = 10;\nfunction Kr(e) {\n  return typeof e != \"string\" ? e : (e = e.toUpperCase(), Tn[e] || Tn.WHITE);\n}\nfunction $u(e, t, n) {\n  if (!je && typeof e == \"string\") {\n    if (t) {\n      const s = Kr(t);\n      e = \"\\x1B[\".concat(s, \"m\").concat(e, \"\\x1B[39m\");\n    }\n    if (n) {\n      const s = Kr(n);\n      e = \"\\x1B[\".concat(s + Yu, \"m\").concat(e, \"\\x1B[49m\");\n    }\n  }\n  return e;\n}\nfunction Zu(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [\"constructor\"];\n  const n = Object.getPrototypeOf(e), s = Object.getOwnPropertyNames(n), r = e;\n  for (const i of s) {\n    const o = r[i];\n    typeof o == \"function\" && (t.find((a) => i === a) || (r[i] = o.bind(e)));\n  }\n}\nfunction bn(e, t) {\n  if (!e)\n    throw new Error(t || \"Assertion failed\");\n}\nfunction se() {\n  let e;\n  if (je() && Xe.performance) {\n    var t, n;\n    e = Xe == null || (t = Xe.performance) === null || t === void 0 || (n = t.now) === null || n === void 0 ? void 0 : n.call(t);\n  } else if (\"hrtime\" in pe) {\n    var s;\n    const r = pe == null || (s = pe.hrtime) === null || s === void 0 ? void 0 : s.call(pe);\n    e = r[0] * 1e3 + r[1] / 1e6;\n  } else\n    e = Date.now();\n  return e;\n}\nconst re = {\n  debug: je() && console.debug || console.log,\n  log: console.log,\n  info: console.info,\n  warn: console.warn,\n  error: console.error\n}, tl = {\n  enabled: !0,\n  level: 0\n};\nfunction yt() {\n}\nconst zr = {}, Wr = {\n  once: !0\n};\nclass Pn {\n  constructor() {\n    let {\n      id: t\n    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {\n      id: \"\"\n    };\n    this.id = void 0, this.VERSION = Jo, this._startTs = se(), this._deltaTs = se(), this._storage = void 0, this.userData = {}, this.LOG_THROTTLE_TIMEOUT = 0, this.id = t, this.userData = {}, this._storage = new Xu(\"__probe-\".concat(this.id, \"__\"), tl), this.timeStamp(\"\".concat(this.id, \" started\")), Zu(this), Object.seal(this);\n  }\n  set level(t) {\n    this.setLevel(t);\n  }\n  get level() {\n    return this.getLevel();\n  }\n  isEnabled() {\n    return this._storage.config.enabled;\n  }\n  getLevel() {\n    return this._storage.config.level;\n  }\n  getTotal() {\n    return Number((se() - this._startTs).toPrecision(10));\n  }\n  getDelta() {\n    return Number((se() - this._deltaTs).toPrecision(10));\n  }\n  set priority(t) {\n    this.level = t;\n  }\n  get priority() {\n    return this.level;\n  }\n  getPriority() {\n    return this.level;\n  }\n  enable() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;\n    return this._storage.setConfiguration({\n      enabled: t\n    }), this;\n  }\n  setLevel(t) {\n    return this._storage.setConfiguration({\n      level: t\n    }), this;\n  }\n  get(t) {\n    return this._storage.config[t];\n  }\n  set(t, n) {\n    this._storage.setConfiguration({\n      [t]: n\n    });\n  }\n  settings() {\n    console.table ? console.table(this._storage.config) : console.log(this._storage.config);\n  }\n  assert(t, n) {\n    bn(t, n);\n  }\n  warn(t) {\n    return this._getLogFunction(0, t, re.warn, arguments, Wr);\n  }\n  error(t) {\n    return this._getLogFunction(0, t, re.error, arguments);\n  }\n  deprecated(t, n) {\n    return this.warn(\"`\".concat(t, \"` is deprecated and will be removed in a later version. Use `\").concat(n, \"` instead\"));\n  }\n  removed(t, n) {\n    return this.error(\"`\".concat(t, \"` has been removed. Use `\").concat(n, \"` instead\"));\n  }\n  probe(t, n) {\n    return this._getLogFunction(t, n, re.log, arguments, {\n      time: !0,\n      once: !0\n    });\n  }\n  log(t, n) {\n    return this._getLogFunction(t, n, re.debug, arguments);\n  }\n  info(t, n) {\n    return this._getLogFunction(t, n, console.info, arguments);\n  }\n  once(t, n) {\n    return this._getLogFunction(t, n, re.debug || re.info, arguments, Wr);\n  }\n  table(t, n, s) {\n    return n ? this._getLogFunction(t, n, console.table || yt, s && [s], {\n      tag: rl(n)\n    }) : yt;\n  }\n  image(t) {\n    let {\n      logLevel: n,\n      priority: s,\n      image: r,\n      message: i = \"\",\n      scale: o = 1\n    } = t;\n    return this._shouldLog(n || s) ? je() ? sl({\n      image: r,\n      message: i,\n      scale: o\n    }) : nl() : yt;\n  }\n  time(t, n) {\n    return this._getLogFunction(t, n, console.time ? console.time : console.info);\n  }\n  timeEnd(t, n) {\n    return this._getLogFunction(t, n, console.timeEnd ? console.timeEnd : console.info);\n  }\n  timeStamp(t, n) {\n    return this._getLogFunction(t, n, console.timeStamp || yt);\n  }\n  group(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {\n      collapsed: !1\n    };\n    const r = Xr({\n      logLevel: t,\n      message: n,\n      opts: s\n    }), {\n      collapsed: i\n    } = s;\n    return r.method = (i ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(r);\n  }\n  groupCollapsed(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return this.group(t, n, Object.assign({}, s, {\n      collapsed: !0\n    }));\n  }\n  groupEnd(t) {\n    return this._getLogFunction(t, \"\", console.groupEnd || yt);\n  }\n  withGroup(t, n, s) {\n    this.group(t, n)();\n    try {\n      s();\n    } finally {\n      this.groupEnd(t)();\n    }\n  }\n  trace() {\n    console.trace && console.trace();\n  }\n  _shouldLog(t) {\n    return this.isEnabled() && this.getLevel() >= Vo(t);\n  }\n  _getLogFunction(t, n, s, r, i) {\n    if (this._shouldLog(t)) {\n      i = Xr({\n        logLevel: t,\n        message: n,\n        args: r,\n        opts: i\n      }), s = s || i.method, bn(s), i.total = this.getTotal(), i.delta = this.getDelta(), this._deltaTs = se();\n      const o = i.tag || i.message;\n      if (i.once && o)\n        if (!zr[o])\n          zr[o] = se();\n        else\n          return yt;\n      return n = el(this.id, i.message, i), s.bind(console, n, ...i.args);\n    }\n    return yt;\n  }\n}\nPn.VERSION = Jo;\nfunction Vo(e) {\n  if (!e)\n    return 0;\n  let t;\n  switch (typeof e) {\n    case \"number\":\n      t = e;\n      break;\n    case \"object\":\n      t = e.logLevel || e.priority || 0;\n      break;\n    default:\n      return 0;\n  }\n  return bn(Number.isFinite(t) && t >= 0), t;\n}\nfunction Xr(e) {\n  const {\n    logLevel: t,\n    message: n\n  } = e;\n  e.logLevel = Vo(t);\n  const s = e.args ? Array.from(e.args) : [];\n  for (; s.length && s.shift() !== n; )\n    ;\n  switch (typeof t) {\n    case \"string\":\n    case \"function\":\n      n !== void 0 && s.unshift(n), e.message = t;\n      break;\n    case \"object\":\n      Object.assign(e, t);\n      break;\n  }\n  typeof e.message == \"function\" && (e.message = e.message());\n  const r = typeof e.message;\n  return bn(r === \"string\" || r === \"object\"), Object.assign(e, {\n    args: s\n  }, e.opts);\n}\nfunction el(e, t, n) {\n  if (typeof t == \"string\") {\n    const s = n.time ? qu(Qu(n.total)) : \"\";\n    t = n.time ? \"\".concat(e, \": \").concat(s, \"  \").concat(t) : \"\".concat(e, \": \").concat(t), t = $u(t, n.color, n.background);\n  }\n  return t;\n}\nfunction nl(e) {\n  return console.warn(\"removed\"), yt;\n}\nfunction sl(e) {\n  let {\n    image: t,\n    message: n = \"\",\n    scale: s = 1\n  } = e;\n  if (typeof t == \"string\") {\n    const i = new Image();\n    return i.onload = () => {\n      const o = es(i, n, s);\n      console.log(...o);\n    }, i.src = t, yt;\n  }\n  const r = t.nodeName || \"\";\n  if (r.toLowerCase() === \"img\")\n    return console.log(...es(t, n, s)), yt;\n  if (r.toLowerCase() === \"canvas\") {\n    const i = new Image();\n    return i.onload = () => console.log(...es(i, n, s)), i.src = t.toDataURL(), yt;\n  }\n  return yt;\n}\nfunction rl(e) {\n  for (const t in e)\n    for (const n in e[t])\n      return n || \"untitled\";\n  return \"empty\";\n}\nconst jo = new Pn({\n  id: \"@probe.gl/log\"\n}), Qr = new Pn({\n  id: \"loaders.gl\"\n});\nclass il {\n  log() {\n    return () => {\n    };\n  }\n  info() {\n    return () => {\n    };\n  }\n  warn() {\n    return () => {\n    };\n  }\n  error() {\n    return () => {\n    };\n  }\n}\nclass ol {\n  constructor() {\n    this.console = void 0, this.console = console;\n  }\n  log() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++)\n      n[s] = arguments[s];\n    return this.console.log.bind(this.console, ...n);\n  }\n  info() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++)\n      n[s] = arguments[s];\n    return this.console.info.bind(this.console, ...n);\n  }\n  warn() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++)\n      n[s] = arguments[s];\n    return this.console.warn.bind(this.console, ...n);\n  }\n  error() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++)\n      n[s] = arguments[s];\n    return this.console.error.bind(this.console, ...n);\n  }\n}\nconst ko = {\n  fetch: null,\n  mimeType: void 0,\n  nothrow: !1,\n  log: new ol(),\n  useLocalLibraries: !1,\n  CDN: \"https://unpkg.com/@loaders.gl\",\n  worker: !0,\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  reuseWorkers: Ln,\n  _nodeWorkers: !1,\n  _workerType: \"\",\n  limit: 0,\n  _limitMB: 0,\n  batchSize: \"auto\",\n  batchDebounceMs: 0,\n  metadata: !1,\n  transforms: []\n}, al = {\n  throws: \"nothrow\",\n  dataType: \"(no longer used)\",\n  uri: \"baseUri\",\n  method: \"fetch.method\",\n  headers: \"fetch.headers\",\n  body: \"fetch.body\",\n  mode: \"fetch.mode\",\n  credentials: \"fetch.credentials\",\n  cache: \"fetch.cache\",\n  redirect: \"fetch.redirect\",\n  referrer: \"fetch.referrer\",\n  referrerPolicy: \"fetch.referrerPolicy\",\n  integrity: \"fetch.integrity\",\n  keepalive: \"fetch.keepalive\",\n  signal: \"fetch.signal\"\n};\nfunction Ko() {\n  globalThis.loaders = globalThis.loaders || {};\n  const {\n    loaders: e\n  } = globalThis;\n  return e._state = e._state || {}, e._state;\n}\nfunction zo() {\n  const e = Ko();\n  return e.globalOptions = e.globalOptions || {\n    ...ko\n  }, e.globalOptions;\n}\nfunction cl(e, t, n, s) {\n  return n = n || [], n = Array.isArray(n) ? n : [n], ul(e, n), hl(t, e, s);\n}\nfunction ul(e, t) {\n  qr(e, null, ko, al, t);\n  for (const n of t) {\n    const s = e && e[n.id] || {}, r = n.options && n.options[n.id] || {}, i = n.deprecatedOptions && n.deprecatedOptions[n.id] || {};\n    qr(s, n.id, r, i, t);\n  }\n}\nfunction qr(e, t, n, s, r) {\n  const i = t || \"Top level\", o = t ? `${t}.` : \"\";\n  for (const a in e) {\n    const c = !t && Ve(e[a]), u = a === \"baseUri\" && !t, l = a === \"workerUrl\" && t;\n    if (!(a in n) && !u && !l) {\n      if (a in s)\n        Qr.warn(`${i} loader option '${o}${a}' no longer supported, use '${s[a]}'`)();\n      else if (!c) {\n        const h = ll(a, r);\n        Qr.warn(`${i} loader option '${o}${a}' not recognized. ${h}`)();\n      }\n    }\n  }\n}\nfunction ll(e, t) {\n  const n = e.toLowerCase();\n  let s = \"\";\n  for (const r of t)\n    for (const i in r.options) {\n      if (e === i)\n        return `Did you mean '${r.id}.${i}'?`;\n      const o = i.toLowerCase();\n      (n.startsWith(o) || o.startsWith(n)) && (s = s || `Did you mean '${r.id}.${i}'?`);\n    }\n  return s;\n}\nfunction hl(e, t, n) {\n  const r = {\n    ...e.options || {}\n  };\n  return fl(r, n), r.log === null && (r.log = new il()), Yr(r, zo()), Yr(r, t), r;\n}\nfunction Yr(e, t) {\n  for (const n in t)\n    if (n in t) {\n      const s = t[n];\n      jr(s) && jr(e[n]) ? e[n] = {\n        ...e[n],\n        ...t[n]\n      } : e[n] = t[n];\n    }\n}\nfunction fl(e, t) {\n  t && !(\"baseUri\" in e) && (e.baseUri = t);\n}\nfunction ar(e) {\n  var t;\n  return e ? (Array.isArray(e) && (e = e[0]), Array.isArray((t = e) === null || t === void 0 ? void 0 : t.extensions)) : !1;\n}\nfunction Wo(e) {\n  var t, n;\n  U(e, \"null loader\"), U(ar(e), \"invalid loader\");\n  let s;\n  return Array.isArray(e) && (s = e[1], e = e[0], e = {\n    ...e,\n    options: {\n      ...e.options,\n      ...s\n    }\n  }), ((t = e) !== null && t !== void 0 && t.parseTextSync || (n = e) !== null && n !== void 0 && n.parseText) && (e.text = !0), e.text || (e.binary = !0), e;\n}\nconst dl = () => {\n  const e = Ko();\n  return e.loaderRegistry = e.loaderRegistry || [], e.loaderRegistry;\n};\nfunction ml() {\n  return dl();\n}\nconst gl = new Pn({\n  id: \"loaders.gl\"\n}), Al = /\\.([^.]+)$/;\nasync function pl(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], n = arguments.length > 2 ? arguments[2] : void 0, s = arguments.length > 3 ? arguments[3] : void 0;\n  if (!Xo(e))\n    return null;\n  let r = $r(e, t, {\n    ...n,\n    nothrow: !0\n  }, s);\n  if (r)\n    return r;\n  if (Zt(e) && (e = await e.slice(0, 10).arrayBuffer(), r = $r(e, t, n, s)), !r && !(n != null && n.nothrow))\n    throw new Error(Qo(e));\n  return r;\n}\nfunction $r(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], n = arguments.length > 2 ? arguments[2] : void 0, s = arguments.length > 3 ? arguments[3] : void 0;\n  if (!Xo(e))\n    return null;\n  if (t && !Array.isArray(t))\n    return Wo(t);\n  let r = [];\n  t && (r = r.concat(t)), n != null && n.ignoreRegisteredLoaders || r.push(...ml()), Bl(r);\n  const i = yl(e, r, n, s);\n  if (!i && !(n != null && n.nothrow))\n    throw new Error(Qo(e));\n  return i;\n}\nfunction yl(e, t, n, s) {\n  const r = Gn(e), i = or(e), o = ir(r) || (s == null ? void 0 : s.url);\n  let a = null, c = \"\";\n  if (n != null && n.mimeType && (a = ns(t, n == null ? void 0 : n.mimeType), c = `match forced by supplied MIME type ${n == null ? void 0 : n.mimeType}`), a = a || Cl(t, o), c = c || (a ? `matched url ${o}` : \"\"), a = a || ns(t, i), c = c || (a ? `matched MIME type ${i}` : \"\"), a = a || Tl(t, e), c = c || (a ? `matched initial data ${qo(e)}` : \"\"), n != null && n.fallbackMimeType && (a = a || ns(t, n == null ? void 0 : n.fallbackMimeType), c = c || (a ? `matched fallback MIME type ${i}` : \"\")), c) {\n    var u;\n    gl.log(1, `selectLoader selected ${(u = a) === null || u === void 0 ? void 0 : u.name}: ${c}.`);\n  }\n  return a;\n}\nfunction Xo(e) {\n  return !(e instanceof Response && e.status === 204);\n}\nfunction Qo(e) {\n  const t = Gn(e), n = or(e);\n  let s = \"No valid loader found (\";\n  s += t ? `${Po(t)}, ` : \"no url provided, \", s += `MIME type: ${n ? `\"${n}\"` : \"not provided\"}, `;\n  const r = e ? qo(e) : \"\";\n  return s += r ? ` first bytes: \"${r}\"` : \"first bytes: not available\", s += \")\", s;\n}\nfunction Bl(e) {\n  for (const t of e)\n    Wo(t);\n}\nfunction Cl(e, t) {\n  const n = t && Al.exec(t), s = n && n[1];\n  return s ? El(e, s) : null;\n}\nfunction El(e, t) {\n  t = t.toLowerCase();\n  for (const n of e)\n    for (const s of n.extensions)\n      if (s.toLowerCase() === t)\n        return n;\n  return null;\n}\nfunction ns(e, t) {\n  for (const n of e)\n    if (n.mimeTypes && n.mimeTypes.includes(t) || t === `application/x.${n.id}`)\n      return n;\n  return null;\n}\nfunction Tl(e, t) {\n  if (!t)\n    return null;\n  for (const n of e)\n    if (typeof t == \"string\") {\n      if (bl(t, n))\n        return n;\n    } else if (ArrayBuffer.isView(t)) {\n      if (Zr(t.buffer, t.byteOffset, n))\n        return n;\n    } else if (t instanceof ArrayBuffer && Zr(t, 0, n))\n      return n;\n  return null;\n}\nfunction bl(e, t) {\n  return t.testText ? t.testText(e) : (Array.isArray(t.tests) ? t.tests : [t.tests]).some((s) => e.startsWith(s));\n}\nfunction Zr(e, t, n) {\n  return (Array.isArray(n.tests) ? n.tests : [n.tests]).some((r) => _l(e, t, n, r));\n}\nfunction _l(e, t, n, s) {\n  if (s instanceof ArrayBuffer)\n    return lu(s, e, s.byteLength);\n  switch (typeof s) {\n    case \"function\":\n      return s(e);\n    case \"string\":\n      const r = Ls(e, t, s.length);\n      return s === r;\n    default:\n      return !1;\n  }\n}\nfunction qo(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;\n  return typeof e == \"string\" ? e.slice(0, t) : ArrayBuffer.isView(e) ? Ls(e.buffer, e.byteOffset, t) : e instanceof ArrayBuffer ? Ls(e, 0, t) : \"\";\n}\nfunction Ls(e, t, n) {\n  if (e.byteLength < t + n)\n    return \"\";\n  const s = new DataView(e);\n  let r = \"\";\n  for (let i = 0; i < n; i++)\n    r += String.fromCharCode(s.getUint8(t + i));\n  return r;\n}\nconst wl = 256 * 1024;\nfunction* Rl(e, t) {\n  const n = (t == null ? void 0 : t.chunkSize) || wl;\n  let s = 0;\n  const r = new TextEncoder();\n  for (; s < e.length; ) {\n    const i = Math.min(e.length - s, n), o = e.slice(s, s + i);\n    s += i, yield r.encode(o);\n  }\n}\nconst Ml = 256 * 1024;\nfunction Il(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  return function* () {\n    const {\n      chunkSize: n = Ml\n    } = t;\n    let s = 0;\n    for (; s < e.byteLength; ) {\n      const r = Math.min(e.byteLength - s, n), i = new ArrayBuffer(r), o = new Uint8Array(e, s, r);\n      new Uint8Array(i).set(o), s += r, yield i;\n    }\n  }();\n}\nconst Sl = 1024 * 1024;\nasync function* xl(e, t) {\n  const n = (t == null ? void 0 : t.chunkSize) || Sl;\n  let s = 0;\n  for (; s < e.size; ) {\n    const r = s + n, i = await e.slice(s, r).arrayBuffer();\n    s = r, yield i;\n  }\n}\nfunction ti(e, t) {\n  return Ln ? Ol(e, t) : Fl(e);\n}\nasync function* Ol(e, t) {\n  const n = e.getReader();\n  let s;\n  try {\n    for (; ; ) {\n      const r = s || n.read();\n      t != null && t._streamReadAhead && (s = n.read());\n      const {\n        done: i,\n        value: o\n      } = await r;\n      if (i)\n        return;\n      yield Go(o);\n    }\n  } catch {\n    n.releaseLock();\n  }\n}\nasync function* Fl(e, t) {\n  for await (const n of e)\n    yield Go(n);\n}\nfunction vl(e, t) {\n  if (typeof e == \"string\")\n    return Rl(e, t);\n  if (e instanceof ArrayBuffer)\n    return Il(e, t);\n  if (Zt(e))\n    return xl(e, t);\n  if (No(e))\n    return ti(e, t);\n  if ($t(e))\n    return ti(e.body, t);\n  throw new Error(\"makeIterator\");\n}\nconst Yo = \"Cannot convert supplied data type\";\nfunction Dl(e, t, n) {\n  if (t.text && typeof e == \"string\")\n    return e;\n  if (Ou(e) && (e = e.buffer), e instanceof ArrayBuffer) {\n    const s = e;\n    return t.text && !t.binary ? new TextDecoder(\"utf8\").decode(s) : s;\n  }\n  if (ArrayBuffer.isView(e)) {\n    if (t.text && !t.binary)\n      return new TextDecoder(\"utf8\").decode(e);\n    let s = e.buffer;\n    const r = e.byteLength || e.length;\n    return (e.byteOffset !== 0 || r !== s.byteLength) && (s = s.slice(e.byteOffset, e.byteOffset + r)), s;\n  }\n  throw new Error(Yo);\n}\nasync function Ll(e, t, n) {\n  const s = e instanceof ArrayBuffer || ArrayBuffer.isView(e);\n  if (typeof e == \"string\" || s)\n    return Dl(e, t);\n  if (Zt(e) && (e = await Ho(e)), $t(e)) {\n    const r = e;\n    return await Uu(r), t.binary ? await r.arrayBuffer() : await r.text();\n  }\n  if (No(e) && (e = vl(e, n)), Su(e) || xu(e))\n    return mu(e);\n  throw new Error(Yo);\n}\nfunction $o(e, t) {\n  const n = zo(), s = e || n;\n  return typeof s.fetch == \"function\" ? s.fetch : Ve(s.fetch) ? (r) => Fe(r, s.fetch) : t != null && t.fetch ? t == null ? void 0 : t.fetch : Fe;\n}\nfunction Gl(e, t, n) {\n  if (n)\n    return n;\n  const s = {\n    fetch: $o(t, e),\n    ...e\n  };\n  if (s.url) {\n    const r = ir(s.url);\n    s.baseUrl = r, s.queryString = Pu(s.url), s.filename = Po(r), s.baseUrl = rr(r);\n  }\n  return Array.isArray(s.loaders) || (s.loaders = null), s;\n}\nfunction Pl(e, t) {\n  if (e && !Array.isArray(e))\n    return e;\n  let n;\n  if (e && (n = Array.isArray(e) ? e : [e]), t && t.loaders) {\n    const s = Array.isArray(t.loaders) ? t.loaders : [t.loaders];\n    n = n ? [...n, ...s] : s;\n  }\n  return n && n.length ? n : void 0;\n}\nasync function _n(e, t, n, s) {\n  t && !Array.isArray(t) && !ar(t) && (s = void 0, n = t, t = void 0), e = await e, n = n || {};\n  const r = Gn(e), o = Pl(t, s), a = await pl(e, o, n);\n  return a ? (n = cl(n, a, o, r), s = Gl({\n    url: r,\n    _parse: _n,\n    loaders: o\n  }, n, s || null), await Nl(a, e, n, s)) : null;\n}\nasync function Nl(e, t, n, s) {\n  if (Yc(e), n = Hc(e.options, n), $t(t)) {\n    const i = t, {\n      ok: o,\n      redirected: a,\n      status: c,\n      statusText: u,\n      type: l,\n      url: h\n    } = i, f = Object.fromEntries(i.headers.entries());\n    s.response = {\n      headers: f,\n      ok: o,\n      redirected: a,\n      status: c,\n      statusText: u,\n      type: l,\n      url: h\n    };\n  }\n  t = await Ll(t, e, n);\n  const r = e;\n  if (r.parseTextSync && typeof t == \"string\")\n    return r.parseTextSync(t, n, s);\n  if (iu(e, n))\n    return await ou(e, t, n, s, _n);\n  if (r.parseText && typeof t == \"string\")\n    return await r.parseText(t, n, s);\n  if (r.parse)\n    return await r.parse(t, n, s);\n  throw Pt(!r.parseSync), new Error(`${e.id} loader - no parser found and worker is disabled`);\n}\nfunction Ul(e) {\n  switch (e.constructor) {\n    case Int8Array:\n      return \"int8\";\n    case Uint8Array:\n    case Uint8ClampedArray:\n      return \"uint8\";\n    case Int16Array:\n      return \"int16\";\n    case Uint16Array:\n      return \"uint16\";\n    case Int32Array:\n      return \"int32\";\n    case Uint32Array:\n      return \"uint32\";\n    case Float32Array:\n      return \"float32\";\n    case Float64Array:\n      return \"float64\";\n    default:\n      return \"null\";\n  }\n}\nfunction Hl(e) {\n  let t = 1 / 0, n = 1 / 0, s = 1 / 0, r = -1 / 0, i = -1 / 0, o = -1 / 0;\n  const a = e.POSITION ? e.POSITION.value : [], c = a && a.length;\n  for (let u = 0; u < c; u += 3) {\n    const l = a[u], h = a[u + 1], f = a[u + 2];\n    t = l < t ? l : t, n = h < n ? h : n, s = f < s ? f : s, r = l > r ? l : r, i = h > i ? h : i, o = f > o ? f : o;\n  }\n  return [[t, n, s], [r, i, o]];\n}\nfunction Jl(e, t, n) {\n  const s = Ul(t.value), r = n || Vl(t);\n  return {\n    name: e,\n    type: {\n      type: \"fixed-size-list\",\n      listSize: t.size,\n      children: [{\n        name: \"value\",\n        type: s\n      }]\n    },\n    nullable: !1,\n    metadata: r\n  };\n}\nfunction Vl(e) {\n  const t = {};\n  return \"byteOffset\" in e && (t.byteOffset = e.byteOffset.toString(10)), \"byteStride\" in e && (t.byteStride = e.byteStride.toString(10)), \"normalized\" in e && (t.normalized = e.normalized.toString()), t;\n}\nasync function fe(e, t, n, s) {\n  let r, i;\n  !Array.isArray(t) && !ar(t) ? (r = [], i = t) : (r = t, i = n);\n  const o = $o(i);\n  let a = e;\n  return typeof e == \"string\" && (a = await o(e)), Zt(e) && (a = await o(e)), Array.isArray(r) ? await _n(a, r, i) : await _n(a, r, i);\n}\nconst jl = 1 / Math.PI * 180, kl = 1 / 180 * Math.PI, Kl = {\n  EPSILON: 1e-12,\n  debug: !1,\n  precision: 4,\n  printTypes: !1,\n  printDegrees: !1,\n  printRowMajor: !0,\n  _cartographicRadians: !1\n};\nglobalThis.mathgl = globalThis.mathgl || {\n  config: {\n    ...Kl\n  }\n};\nconst tt = globalThis.mathgl.config;\nfunction zl(e, {\n  precision: t = tt.precision\n} = {}) {\n  return e = Yl(e), \"\".concat(parseFloat(e.toPrecision(t)));\n}\nfunction qt(e) {\n  return Array.isArray(e) || ArrayBuffer.isView(e) && !(e instanceof DataView);\n}\nfunction Wl(e) {\n  return Ql(e);\n}\nfunction Xl(e) {\n  return _t(e);\n}\nfunction Ql(e, t) {\n  return cr(e, (n) => n * kl, t);\n}\nfunction _t(e, t) {\n  return cr(e, (n) => n * jl, t);\n}\nfunction ql(e, t, n) {\n  return cr(e, (s) => Math.max(t, Math.min(n, s)));\n}\nfunction Jt(e, t, n) {\n  const s = tt.EPSILON;\n  n && (tt.EPSILON = n);\n  try {\n    if (e === t)\n      return !0;\n    if (qt(e) && qt(t)) {\n      if (e.length !== t.length)\n        return !1;\n      for (let r = 0; r < e.length; ++r)\n        if (!Jt(e[r], t[r]))\n          return !1;\n      return !0;\n    }\n    return e && e.equals ? e.equals(t) : t && t.equals ? t.equals(e) : typeof e == \"number\" && typeof t == \"number\" ? Math.abs(e - t) <= tt.EPSILON * Math.max(1, Math.abs(e), Math.abs(t)) : !1;\n  } finally {\n    tt.EPSILON = s;\n  }\n}\nfunction Yl(e) {\n  return Math.round(e / tt.EPSILON) * tt.EPSILON;\n}\nfunction $l(e) {\n  return e.clone ? e.clone() : new Array(e.length);\n}\nfunction cr(e, t, n) {\n  if (qt(e)) {\n    const s = e;\n    n = n || $l(s);\n    for (let r = 0; r < n.length && r < s.length; ++r) {\n      const i = typeof e == \"number\" ? e : e[r];\n      n[r] = t(i, r, n);\n    }\n    return n;\n  }\n  return t(e);\n}\nfunction Zl(e) {\n  function t() {\n    var n = Reflect.construct(e, Array.from(arguments));\n    return Object.setPrototypeOf(n, Object.getPrototypeOf(this)), n;\n  }\n  return t.prototype = Object.create(e.prototype, {\n    constructor: {\n      value: e,\n      enumerable: !1,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e, t;\n}\nclass ur extends Zl(Array) {\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  fromArray(t, n = 0) {\n    for (let s = 0; s < this.ELEMENTS; ++s)\n      this[s] = t[s + n];\n    return this.check();\n  }\n  toArray(t = [], n = 0) {\n    for (let s = 0; s < this.ELEMENTS; ++s)\n      t[n + s] = this[s];\n    return t;\n  }\n  toObject(t) {\n    return t;\n  }\n  from(t) {\n    return Array.isArray(t) ? this.copy(t) : this.fromObject(t);\n  }\n  to(t) {\n    return t === this ? this : qt(t) ? this.toArray(t) : this.toObject(t);\n  }\n  toTarget(t) {\n    return t ? this.to(t) : this;\n  }\n  toFloat32Array() {\n    return new Float32Array(this);\n  }\n  toString() {\n    return this.formatString(tt);\n  }\n  formatString(t) {\n    let n = \"\";\n    for (let s = 0; s < this.ELEMENTS; ++s)\n      n += (s > 0 ? \", \" : \"\") + zl(this[s], t);\n    return \"\".concat(t.printTypes ? this.constructor.name : \"\", \"[\").concat(n, \"]\");\n  }\n  equals(t) {\n    if (!t || this.length !== t.length)\n      return !1;\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      if (!Jt(this[n], t[n]))\n        return !1;\n    return !0;\n  }\n  exactEquals(t) {\n    if (!t || this.length !== t.length)\n      return !1;\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      if (this[n] !== t[n])\n        return !1;\n    return !0;\n  }\n  negate() {\n    for (let t = 0; t < this.ELEMENTS; ++t)\n      this[t] = -this[t];\n    return this.check();\n  }\n  lerp(t, n, s) {\n    if (s === void 0)\n      return this.lerp(this, t, n);\n    for (let r = 0; r < this.ELEMENTS; ++r) {\n      const i = t[r], o = typeof n == \"number\" ? n : n[r];\n      this[r] = i + s * (o - i);\n    }\n    return this.check();\n  }\n  min(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      this[n] = Math.min(t[n], this[n]);\n    return this.check();\n  }\n  max(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      this[n] = Math.max(t[n], this[n]);\n    return this.check();\n  }\n  clamp(t, n) {\n    for (let s = 0; s < this.ELEMENTS; ++s)\n      this[s] = Math.min(Math.max(this[s], t[s]), n[s]);\n    return this.check();\n  }\n  add(...t) {\n    for (const n of t)\n      for (let s = 0; s < this.ELEMENTS; ++s)\n        this[s] += n[s];\n    return this.check();\n  }\n  subtract(...t) {\n    for (const n of t)\n      for (let s = 0; s < this.ELEMENTS; ++s)\n        this[s] -= n[s];\n    return this.check();\n  }\n  scale(t) {\n    if (typeof t == \"number\")\n      for (let n = 0; n < this.ELEMENTS; ++n)\n        this[n] *= t;\n    else\n      for (let n = 0; n < this.ELEMENTS && n < t.length; ++n)\n        this[n] *= t[n];\n    return this.check();\n  }\n  multiplyByScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      this[n] *= t;\n    return this.check();\n  }\n  check() {\n    if (tt.debug && !this.validate())\n      throw new Error(\"math.gl: \".concat(this.constructor.name, \" some fields set to invalid numbers'\"));\n    return this;\n  }\n  validate() {\n    let t = this.length === this.ELEMENTS;\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      t = t && Number.isFinite(this[n]);\n    return t;\n  }\n  sub(t) {\n    return this.subtract(t);\n  }\n  setScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      this[n] = t;\n    return this.check();\n  }\n  addScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      this[n] += t;\n    return this.check();\n  }\n  subScalar(t) {\n    return this.addScalar(-t);\n  }\n  multiplyScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      this[n] *= t;\n    return this.check();\n  }\n  divideScalar(t) {\n    return this.multiplyByScalar(1 / t);\n  }\n  clampScalar(t, n) {\n    for (let s = 0; s < this.ELEMENTS; ++s)\n      this[s] = Math.min(Math.max(this[s], t), n);\n    return this.check();\n  }\n  get elements() {\n    return this;\n  }\n}\nfunction th(e, t) {\n  if (e.length !== t)\n    return !1;\n  for (let n = 0; n < e.length; ++n)\n    if (!Number.isFinite(e[n]))\n      return !1;\n  return !0;\n}\nfunction N(e) {\n  if (!Number.isFinite(e))\n    throw new Error(\"Invalid number \".concat(JSON.stringify(e)));\n  return e;\n}\nfunction Ie(e, t, n = \"\") {\n  if (tt.debug && !th(e, t))\n    throw new Error(\"math.gl: \".concat(n, \" some fields set to invalid numbers'\"));\n  return e;\n}\nfunction j(e, t) {\n  if (!e)\n    throw new Error(\"math.gl assertion \".concat(t));\n}\nclass lr extends ur {\n  get x() {\n    return this[0];\n  }\n  set x(t) {\n    this[0] = N(t);\n  }\n  get y() {\n    return this[1];\n  }\n  set y(t) {\n    this[1] = N(t);\n  }\n  len() {\n    return Math.sqrt(this.lengthSquared());\n  }\n  magnitude() {\n    return this.len();\n  }\n  lengthSquared() {\n    let t = 0;\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      t += this[n] * this[n];\n    return t;\n  }\n  magnitudeSquared() {\n    return this.lengthSquared();\n  }\n  distance(t) {\n    return Math.sqrt(this.distanceSquared(t));\n  }\n  distanceSquared(t) {\n    let n = 0;\n    for (let s = 0; s < this.ELEMENTS; ++s) {\n      const r = this[s] - t[s];\n      n += r * r;\n    }\n    return N(n);\n  }\n  dot(t) {\n    let n = 0;\n    for (let s = 0; s < this.ELEMENTS; ++s)\n      n += this[s] * t[s];\n    return N(n);\n  }\n  normalize() {\n    const t = this.magnitude();\n    if (t !== 0)\n      for (let n = 0; n < this.ELEMENTS; ++n)\n        this[n] /= t;\n    return this.check();\n  }\n  multiply(...t) {\n    for (const n of t)\n      for (let s = 0; s < this.ELEMENTS; ++s)\n        this[s] *= n[s];\n    return this.check();\n  }\n  divide(...t) {\n    for (const n of t)\n      for (let s = 0; s < this.ELEMENTS; ++s)\n        this[s] /= n[s];\n    return this.check();\n  }\n  lengthSq() {\n    return this.lengthSquared();\n  }\n  distanceTo(t) {\n    return this.distance(t);\n  }\n  distanceToSquared(t) {\n    return this.distanceSquared(t);\n  }\n  getComponent(t) {\n    return j(t >= 0 && t < this.ELEMENTS, \"index is out of range\"), N(this[t]);\n  }\n  setComponent(t, n) {\n    return j(t >= 0 && t < this.ELEMENTS, \"index is out of range\"), this[t] = n, this.check();\n  }\n  addVectors(t, n) {\n    return this.copy(t).add(n);\n  }\n  subVectors(t, n) {\n    return this.copy(t).subtract(n);\n  }\n  multiplyVectors(t, n) {\n    return this.copy(t).multiply(n);\n  }\n  addScaledVector(t, n) {\n    return this.add(new this.constructor(t).multiplyScalar(n));\n  }\n}\nconst Se = 1e-6;\nlet Rt = typeof Float32Array < \"u\" ? Float32Array : Array;\nfunction eh() {\n  const e = new Rt(2);\n  return Rt != Float32Array && (e[0] = 0, e[1] = 0), e;\n}\nfunction nh(e, t, n) {\n  const s = t[0], r = t[1];\n  return e[0] = n[0] * s + n[2] * r, e[1] = n[1] * s + n[3] * r, e;\n}\nfunction sh(e, t, n) {\n  const s = t[0], r = t[1];\n  return e[0] = n[0] * s + n[2] * r + n[4], e[1] = n[1] * s + n[3] * r + n[5], e;\n}\nfunction Zo(e, t, n) {\n  const s = t[0], r = t[1];\n  return e[0] = n[0] * s + n[3] * r + n[6], e[1] = n[1] * s + n[4] * r + n[7], e;\n}\nfunction ta(e, t, n) {\n  const s = t[0], r = t[1];\n  return e[0] = n[0] * s + n[4] * r + n[12], e[1] = n[1] * s + n[5] * r + n[13], e;\n}\n(function() {\n  const e = eh();\n  return function(t, n, s, r, i, o) {\n    let a, c;\n    for (n || (n = 2), s || (s = 0), r ? c = Math.min(r * n + s, t.length) : c = t.length, a = s; a < c; a += n)\n      e[0] = t[a], e[1] = t[a + 1], i(e, e, o), t[a] = e[0], t[a + 1] = e[1];\n    return t;\n  };\n})();\nfunction ea(e, t, n) {\n  const s = t[0], r = t[1], i = n[3] * s + n[7] * r || 1;\n  return e[0] = (n[0] * s + n[4] * r) / i, e[1] = (n[1] * s + n[5] * r) / i, e;\n}\nfunction na(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = n[3] * s + n[7] * r + n[11] * i || 1;\n  return e[0] = (n[0] * s + n[4] * r + n[8] * i) / o, e[1] = (n[1] * s + n[5] * r + n[9] * i) / o, e[2] = (n[2] * s + n[6] * r + n[10] * i) / o, e;\n}\nfunction rh(e, t, n) {\n  const s = t[0], r = t[1];\n  return e[0] = n[0] * s + n[2] * r, e[1] = n[1] * s + n[3] * r, e[2] = t[2], e;\n}\nfunction ih(e, t, n) {\n  const s = t[0], r = t[1];\n  return e[0] = n[0] * s + n[2] * r, e[1] = n[1] * s + n[3] * r, e[2] = t[2], e[3] = t[3], e;\n}\nfunction sa(e, t, n) {\n  const s = t[0], r = t[1], i = t[2];\n  return e[0] = n[0] * s + n[3] * r + n[6] * i, e[1] = n[1] * s + n[4] * r + n[7] * i, e[2] = n[2] * s + n[5] * r + n[8] * i, e[3] = t[3], e;\n}\nclass Nn extends lr {\n  constructor(t = 0, n = 0) {\n    super(2), qt(t) && arguments.length === 1 ? this.copy(t) : (tt.debug && (N(t), N(n)), this[0] = t, this[1] = n);\n  }\n  set(t, n) {\n    return this[0] = t, this[1] = n, this.check();\n  }\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this.check();\n  }\n  fromObject(t) {\n    return tt.debug && (N(t.x), N(t.y)), this[0] = t.x, this[1] = t.y, this.check();\n  }\n  toObject(t) {\n    return t.x = this[0], t.y = this[1], t;\n  }\n  get ELEMENTS() {\n    return 2;\n  }\n  horizontalAngle() {\n    return Math.atan2(this.y, this.x);\n  }\n  verticalAngle() {\n    return Math.atan2(this.x, this.y);\n  }\n  transform(t) {\n    return this.transformAsPoint(t);\n  }\n  transformAsPoint(t) {\n    return ta(this, this, t), this.check();\n  }\n  transformAsVector(t) {\n    return ea(this, this, t), this.check();\n  }\n  transformByMatrix3(t) {\n    return Zo(this, this, t), this.check();\n  }\n  transformByMatrix2x3(t) {\n    return sh(this, this, t), this.check();\n  }\n  transformByMatrix2(t) {\n    return nh(this, this, t), this.check();\n  }\n}\nfunction ra() {\n  const e = new Rt(3);\n  return Rt != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e;\n}\nfunction ia(e) {\n  const t = e[0], n = e[1], s = e[2];\n  return Math.sqrt(t * t + n * n + s * s);\n}\nfunction ei(e, t, n) {\n  const s = new Rt(3);\n  return s[0] = e, s[1] = t, s[2] = n, s;\n}\nfunction oh(e, t) {\n  const n = t[0], s = t[1], r = t[2];\n  let i = n * n + s * s + r * r;\n  return i > 0 && (i = 1 / Math.sqrt(i)), e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i, e;\n}\nfunction hr(e, t) {\n  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];\n}\nfunction An(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = n[0], a = n[1], c = n[2];\n  return e[0] = r * c - i * a, e[1] = i * o - s * c, e[2] = s * a - r * o, e;\n}\nfunction fr(e, t, n) {\n  const s = t[0], r = t[1], i = t[2];\n  let o = n[3] * s + n[7] * r + n[11] * i + n[15];\n  return o = o || 1, e[0] = (n[0] * s + n[4] * r + n[8] * i + n[12]) / o, e[1] = (n[1] * s + n[5] * r + n[9] * i + n[13]) / o, e[2] = (n[2] * s + n[6] * r + n[10] * i + n[14]) / o, e;\n}\nfunction oa(e, t, n) {\n  const s = t[0], r = t[1], i = t[2];\n  return e[0] = s * n[0] + r * n[3] + i * n[6], e[1] = s * n[1] + r * n[4] + i * n[7], e[2] = s * n[2] + r * n[5] + i * n[8], e;\n}\nfunction aa(e, t, n) {\n  const s = n[0], r = n[1], i = n[2], o = n[3], a = t[0], c = t[1], u = t[2];\n  let l = r * u - i * c, h = i * a - s * u, f = s * c - r * a, d = r * f - i * h, m = i * l - s * f, g = s * h - r * l;\n  const p = o * 2;\n  return l *= p, h *= p, f *= p, d *= 2, m *= 2, g *= 2, e[0] = a + l + d, e[1] = c + h + m, e[2] = u + f + g, e;\n}\nfunction ah(e, t, n, s) {\n  const r = [], i = [];\n  return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], i[0] = r[0], i[1] = r[1] * Math.cos(s) - r[2] * Math.sin(s), i[2] = r[1] * Math.sin(s) + r[2] * Math.cos(s), e[0] = i[0] + n[0], e[1] = i[1] + n[1], e[2] = i[2] + n[2], e;\n}\nfunction ch(e, t, n, s) {\n  const r = [], i = [];\n  return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], i[0] = r[2] * Math.sin(s) + r[0] * Math.cos(s), i[1] = r[1], i[2] = r[2] * Math.cos(s) - r[0] * Math.sin(s), e[0] = i[0] + n[0], e[1] = i[1] + n[1], e[2] = i[2] + n[2], e;\n}\nfunction uh(e, t, n, s) {\n  const r = [], i = [];\n  return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], i[0] = r[0] * Math.cos(s) - r[1] * Math.sin(s), i[1] = r[0] * Math.sin(s) + r[1] * Math.cos(s), i[2] = r[2], e[0] = i[0] + n[0], e[1] = i[1] + n[1], e[2] = i[2] + n[2], e;\n}\nfunction lh(e, t) {\n  const n = e[0], s = e[1], r = e[2], i = t[0], o = t[1], a = t[2], c = Math.sqrt((n * n + s * s + r * r) * (i * i + o * o + a * a)), u = c && hr(e, t) / c;\n  return Math.acos(Math.min(Math.max(u, -1), 1));\n}\nconst hh = ia;\n(function() {\n  const e = ra();\n  return function(t, n, s, r, i, o) {\n    let a, c;\n    for (n || (n = 3), s || (s = 0), r ? c = Math.min(r * n + s, t.length) : c = t.length, a = s; a < c; a += n)\n      e[0] = t[a], e[1] = t[a + 1], e[2] = t[a + 2], i(e, e, o), t[a] = e[0], t[a + 1] = e[1], t[a + 2] = e[2];\n    return t;\n  };\n})();\nconst ss = [0, 0, 0];\nlet Qe;\nclass A extends lr {\n  static get ZERO() {\n    return Qe || (Qe = new A(0, 0, 0), Object.freeze(Qe)), Qe;\n  }\n  constructor(t = 0, n = 0, s = 0) {\n    super(-0, -0, -0), arguments.length === 1 && qt(t) ? this.copy(t) : (tt.debug && (N(t), N(n), N(s)), this[0] = t, this[1] = n, this[2] = s);\n  }\n  set(t, n, s) {\n    return this[0] = t, this[1] = n, this[2] = s, this.check();\n  }\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this.check();\n  }\n  fromObject(t) {\n    return tt.debug && (N(t.x), N(t.y), N(t.z)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this.check();\n  }\n  toObject(t) {\n    return t.x = this[0], t.y = this[1], t.z = this[2], t;\n  }\n  get ELEMENTS() {\n    return 3;\n  }\n  get z() {\n    return this[2];\n  }\n  set z(t) {\n    this[2] = N(t);\n  }\n  angle(t) {\n    return lh(this, t);\n  }\n  cross(t) {\n    return An(this, this, t), this.check();\n  }\n  rotateX({\n    radians: t,\n    origin: n = ss\n  }) {\n    return ah(this, this, n, t), this.check();\n  }\n  rotateY({\n    radians: t,\n    origin: n = ss\n  }) {\n    return ch(this, this, n, t), this.check();\n  }\n  rotateZ({\n    radians: t,\n    origin: n = ss\n  }) {\n    return uh(this, this, n, t), this.check();\n  }\n  transform(t) {\n    return this.transformAsPoint(t);\n  }\n  transformAsPoint(t) {\n    return fr(this, this, t), this.check();\n  }\n  transformAsVector(t) {\n    return na(this, this, t), this.check();\n  }\n  transformByMatrix3(t) {\n    return oa(this, this, t), this.check();\n  }\n  transformByMatrix2(t) {\n    return rh(this, this, t), this.check();\n  }\n  transformByQuaternion(t) {\n    return aa(this, this, t), this.check();\n  }\n}\nlet qe;\nclass dr extends lr {\n  static get ZERO() {\n    return qe || (qe = new dr(0, 0, 0, 0), Object.freeze(qe)), qe;\n  }\n  constructor(t = 0, n = 0, s = 0, r = 0) {\n    super(-0, -0, -0, -0), qt(t) && arguments.length === 1 ? this.copy(t) : (tt.debug && (N(t), N(n), N(s), N(r)), this[0] = t, this[1] = n, this[2] = s, this[3] = r);\n  }\n  set(t, n, s, r) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this.check();\n  }\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this.check();\n  }\n  fromObject(t) {\n    return tt.debug && (N(t.x), N(t.y), N(t.z), N(t.w)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this[3] = t.w, this;\n  }\n  toObject(t) {\n    return t.x = this[0], t.y = this[1], t.z = this[2], t.w = this[3], t;\n  }\n  get ELEMENTS() {\n    return 4;\n  }\n  get z() {\n    return this[2];\n  }\n  set z(t) {\n    this[2] = N(t);\n  }\n  get w() {\n    return this[3];\n  }\n  set w(t) {\n    this[3] = N(t);\n  }\n  transform(t) {\n    return fr(this, this, t), this.check();\n  }\n  transformByMatrix3(t) {\n    return sa(this, this, t), this.check();\n  }\n  transformByMatrix2(t) {\n    return ih(this, this, t), this.check();\n  }\n  transformByQuaternion(t) {\n    return aa(this, this, t), this.check();\n  }\n  applyMatrix4(t) {\n    return t.transform(this, this), this;\n  }\n}\nclass ca extends ur {\n  toString() {\n    let t = \"[\";\n    if (tt.printRowMajor) {\n      t += \"row-major:\";\n      for (let n = 0; n < this.RANK; ++n)\n        for (let s = 0; s < this.RANK; ++s)\n          t += \" \".concat(this[s * this.RANK + n]);\n    } else {\n      t += \"column-major:\";\n      for (let n = 0; n < this.ELEMENTS; ++n)\n        t += \" \".concat(this[n]);\n    }\n    return t += \"]\", t;\n  }\n  getElementIndex(t, n) {\n    return n * this.RANK + t;\n  }\n  getElement(t, n) {\n    return this[n * this.RANK + t];\n  }\n  setElement(t, n, s) {\n    return this[n * this.RANK + t] = N(s), this;\n  }\n  getColumn(t, n = new Array(this.RANK).fill(-0)) {\n    const s = t * this.RANK;\n    for (let r = 0; r < this.RANK; ++r)\n      n[r] = this[s + r];\n    return n;\n  }\n  setColumn(t, n) {\n    const s = t * this.RANK;\n    for (let r = 0; r < this.RANK; ++r)\n      this[s + r] = n[r];\n    return this;\n  }\n}\nfunction fh() {\n  const e = new Rt(9);\n  return Rt != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[5] = 0, e[6] = 0, e[7] = 0), e[0] = 1, e[4] = 1, e[8] = 1, e;\n}\nfunction dh(e, t) {\n  if (e === t) {\n    const n = t[1], s = t[2], r = t[5];\n    e[1] = t[3], e[2] = t[6], e[3] = n, e[5] = t[7], e[6] = s, e[7] = r;\n  } else\n    e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8];\n  return e;\n}\nfunction mh(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[3], o = t[4], a = t[5], c = t[6], u = t[7], l = t[8], h = l * o - a * u, f = -l * i + a * c, d = u * i - o * c;\n  let m = n * h + s * f + r * d;\n  return m ? (m = 1 / m, e[0] = h * m, e[1] = (-l * s + r * u) * m, e[2] = (a * s - r * o) * m, e[3] = f * m, e[4] = (l * n - r * c) * m, e[5] = (-a * n + r * i) * m, e[6] = d * m, e[7] = (-u * n + s * c) * m, e[8] = (o * n - s * i) * m, e) : null;\n}\nfunction gh(e) {\n  const t = e[0], n = e[1], s = e[2], r = e[3], i = e[4], o = e[5], a = e[6], c = e[7], u = e[8];\n  return t * (u * i - o * c) + n * (-u * r + o * a) + s * (c * r - i * a);\n}\nfunction ni(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = t[4], c = t[5], u = t[6], l = t[7], h = t[8], f = n[0], d = n[1], m = n[2], g = n[3], p = n[4], C = n[5], w = n[6], y = n[7], B = n[8];\n  return e[0] = f * s + d * o + m * u, e[1] = f * r + d * a + m * l, e[2] = f * i + d * c + m * h, e[3] = g * s + p * o + C * u, e[4] = g * r + p * a + C * l, e[5] = g * i + p * c + C * h, e[6] = w * s + y * o + B * u, e[7] = w * r + y * a + B * l, e[8] = w * i + y * c + B * h, e;\n}\nfunction Ah(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = t[4], c = t[5], u = t[6], l = t[7], h = t[8], f = n[0], d = n[1];\n  return e[0] = s, e[1] = r, e[2] = i, e[3] = o, e[4] = a, e[5] = c, e[6] = f * s + d * o + u, e[7] = f * r + d * a + l, e[8] = f * i + d * c + h, e;\n}\nfunction ph(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = t[4], c = t[5], u = t[6], l = t[7], h = t[8], f = Math.sin(n), d = Math.cos(n);\n  return e[0] = d * s + f * o, e[1] = d * r + f * a, e[2] = d * i + f * c, e[3] = d * o - f * s, e[4] = d * a - f * r, e[5] = d * c - f * i, e[6] = u, e[7] = l, e[8] = h, e;\n}\nfunction si(e, t, n) {\n  const s = n[0], r = n[1];\n  return e[0] = s * t[0], e[1] = s * t[1], e[2] = s * t[2], e[3] = r * t[3], e[4] = r * t[4], e[5] = r * t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e;\n}\nfunction yh(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[3], o = n + n, a = s + s, c = r + r, u = n * o, l = s * o, h = s * a, f = r * o, d = r * a, m = r * c, g = i * o, p = i * a, C = i * c;\n  return e[0] = 1 - h - m, e[3] = l - C, e[6] = f + p, e[1] = l + C, e[4] = 1 - u - m, e[7] = d - g, e[2] = f - p, e[5] = d + g, e[8] = 1 - u - h, e;\n}\nvar Gs;\n(function(e) {\n  e[e.COL0ROW0 = 0] = \"COL0ROW0\", e[e.COL0ROW1 = 1] = \"COL0ROW1\", e[e.COL0ROW2 = 2] = \"COL0ROW2\", e[e.COL1ROW0 = 3] = \"COL1ROW0\", e[e.COL1ROW1 = 4] = \"COL1ROW1\", e[e.COL1ROW2 = 5] = \"COL1ROW2\", e[e.COL2ROW0 = 6] = \"COL2ROW0\", e[e.COL2ROW1 = 7] = \"COL2ROW1\", e[e.COL2ROW2 = 8] = \"COL2ROW2\";\n})(Gs || (Gs = {}));\nconst Bh = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);\nclass z extends ca {\n  static get IDENTITY() {\n    return Eh();\n  }\n  static get ZERO() {\n    return Ch();\n  }\n  get ELEMENTS() {\n    return 9;\n  }\n  get RANK() {\n    return 3;\n  }\n  get INDICES() {\n    return Gs;\n  }\n  constructor(t, ...n) {\n    super(-0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(t) ? this.copy(t) : n.length > 0 ? this.copy([t, ...n]) : this.identity();\n  }\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this[4] = t[4], this[5] = t[5], this[6] = t[6], this[7] = t[7], this[8] = t[8], this.check();\n  }\n  identity() {\n    return this.copy(Bh);\n  }\n  fromObject(t) {\n    return this.check();\n  }\n  fromQuaternion(t) {\n    return yh(this, t), this.check();\n  }\n  set(t, n, s, r, i, o, a, c, u) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this[4] = i, this[5] = o, this[6] = a, this[7] = c, this[8] = u, this.check();\n  }\n  setRowMajor(t, n, s, r, i, o, a, c, u) {\n    return this[0] = t, this[1] = r, this[2] = a, this[3] = n, this[4] = i, this[5] = c, this[6] = s, this[7] = o, this[8] = u, this.check();\n  }\n  determinant() {\n    return gh(this);\n  }\n  transpose() {\n    return dh(this, this), this.check();\n  }\n  invert() {\n    return mh(this, this), this.check();\n  }\n  multiplyLeft(t) {\n    return ni(this, t, this), this.check();\n  }\n  multiplyRight(t) {\n    return ni(this, this, t), this.check();\n  }\n  rotate(t) {\n    return ph(this, this, t), this.check();\n  }\n  scale(t) {\n    return Array.isArray(t) ? si(this, this, t) : si(this, this, [t, t]), this.check();\n  }\n  translate(t) {\n    return Ah(this, this, t), this.check();\n  }\n  transform(t, n) {\n    let s;\n    switch (t.length) {\n      case 2:\n        s = Zo(n || [-0, -0], t, this);\n        break;\n      case 3:\n        s = oa(n || [-0, -0, -0], t, this);\n        break;\n      case 4:\n        s = sa(n || [-0, -0, -0, -0], t, this);\n        break;\n      default:\n        throw new Error(\"Illegal vector\");\n    }\n    return Ie(s, t.length), s;\n  }\n  transformVector(t, n) {\n    return this.transform(t, n);\n  }\n  transformVector2(t, n) {\n    return this.transform(t, n);\n  }\n  transformVector3(t, n) {\n    return this.transform(t, n);\n  }\n}\nlet Ye, $e = null;\nfunction Ch() {\n  return Ye || (Ye = new z([0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Ye)), Ye;\n}\nfunction Eh() {\n  return $e || ($e = new z(), Object.freeze($e)), $e;\n}\nfunction Th(e) {\n  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;\n}\nfunction bh(e, t) {\n  if (e === t) {\n    const n = t[1], s = t[2], r = t[3], i = t[6], o = t[7], a = t[11];\n    e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = n, e[6] = t[9], e[7] = t[13], e[8] = s, e[9] = i, e[11] = t[14], e[12] = r, e[13] = o, e[14] = a;\n  } else\n    e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];\n  return e;\n}\nfunction _h(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[3], o = t[4], a = t[5], c = t[6], u = t[7], l = t[8], h = t[9], f = t[10], d = t[11], m = t[12], g = t[13], p = t[14], C = t[15], w = n * a - s * o, y = n * c - r * o, B = n * u - i * o, R = s * c - r * a, E = s * u - i * a, O = r * u - i * c, F = l * g - h * m, x = l * p - f * m, v = l * C - d * m, k = h * p - f * g, X = h * C - d * g, Q = f * C - d * p;\n  let D = w * Q - y * X + B * k + R * v - E * x + O * F;\n  return D ? (D = 1 / D, e[0] = (a * Q - c * X + u * k) * D, e[1] = (r * X - s * Q - i * k) * D, e[2] = (g * O - p * E + C * R) * D, e[3] = (f * E - h * O - d * R) * D, e[4] = (c * v - o * Q - u * x) * D, e[5] = (n * Q - r * v + i * x) * D, e[6] = (p * B - m * O - C * y) * D, e[7] = (l * O - f * B + d * y) * D, e[8] = (o * X - a * v + u * F) * D, e[9] = (s * v - n * X - i * F) * D, e[10] = (m * E - g * B + C * w) * D, e[11] = (h * B - l * E - d * w) * D, e[12] = (a * x - o * k - c * F) * D, e[13] = (n * k - s * x + r * F) * D, e[14] = (g * y - m * R - p * w) * D, e[15] = (l * R - h * y + f * w) * D, e) : null;\n}\nfunction wh(e) {\n  const t = e[0], n = e[1], s = e[2], r = e[3], i = e[4], o = e[5], a = e[6], c = e[7], u = e[8], l = e[9], h = e[10], f = e[11], d = e[12], m = e[13], g = e[14], p = e[15], C = t * o - n * i, w = t * a - s * i, y = n * a - s * o, B = u * m - l * d, R = u * g - h * d, E = l * g - h * m, O = t * E - n * R + s * B, F = i * E - o * R + a * B, x = u * y - l * w + h * C, v = d * y - m * w + g * C;\n  return c * O - r * F + p * x - f * v;\n}\nfunction ri(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = t[4], c = t[5], u = t[6], l = t[7], h = t[8], f = t[9], d = t[10], m = t[11], g = t[12], p = t[13], C = t[14], w = t[15];\n  let y = n[0], B = n[1], R = n[2], E = n[3];\n  return e[0] = y * s + B * a + R * h + E * g, e[1] = y * r + B * c + R * f + E * p, e[2] = y * i + B * u + R * d + E * C, e[3] = y * o + B * l + R * m + E * w, y = n[4], B = n[5], R = n[6], E = n[7], e[4] = y * s + B * a + R * h + E * g, e[5] = y * r + B * c + R * f + E * p, e[6] = y * i + B * u + R * d + E * C, e[7] = y * o + B * l + R * m + E * w, y = n[8], B = n[9], R = n[10], E = n[11], e[8] = y * s + B * a + R * h + E * g, e[9] = y * r + B * c + R * f + E * p, e[10] = y * i + B * u + R * d + E * C, e[11] = y * o + B * l + R * m + E * w, y = n[12], B = n[13], R = n[14], E = n[15], e[12] = y * s + B * a + R * h + E * g, e[13] = y * r + B * c + R * f + E * p, e[14] = y * i + B * u + R * d + E * C, e[15] = y * o + B * l + R * m + E * w, e;\n}\nfunction Rh(e, t, n) {\n  const s = n[0], r = n[1], i = n[2];\n  let o, a, c, u, l, h, f, d, m, g, p, C;\n  return t === e ? (e[12] = t[0] * s + t[4] * r + t[8] * i + t[12], e[13] = t[1] * s + t[5] * r + t[9] * i + t[13], e[14] = t[2] * s + t[6] * r + t[10] * i + t[14], e[15] = t[3] * s + t[7] * r + t[11] * i + t[15]) : (o = t[0], a = t[1], c = t[2], u = t[3], l = t[4], h = t[5], f = t[6], d = t[7], m = t[8], g = t[9], p = t[10], C = t[11], e[0] = o, e[1] = a, e[2] = c, e[3] = u, e[4] = l, e[5] = h, e[6] = f, e[7] = d, e[8] = m, e[9] = g, e[10] = p, e[11] = C, e[12] = o * s + l * r + m * i + t[12], e[13] = a * s + h * r + g * i + t[13], e[14] = c * s + f * r + p * i + t[14], e[15] = u * s + d * r + C * i + t[15]), e;\n}\nfunction Mh(e, t, n) {\n  const s = n[0], r = n[1], i = n[2];\n  return e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s, e[3] = t[3] * s, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * i, e[9] = t[9] * i, e[10] = t[10] * i, e[11] = t[11] * i, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;\n}\nfunction Ih(e, t, n, s) {\n  let r = s[0], i = s[1], o = s[2], a = Math.sqrt(r * r + i * i + o * o), c, u, l, h, f, d, m, g, p, C, w, y, B, R, E, O, F, x, v, k, X, Q, D, at;\n  return a < Se ? null : (a = 1 / a, r *= a, i *= a, o *= a, u = Math.sin(n), c = Math.cos(n), l = 1 - c, h = t[0], f = t[1], d = t[2], m = t[3], g = t[4], p = t[5], C = t[6], w = t[7], y = t[8], B = t[9], R = t[10], E = t[11], O = r * r * l + c, F = i * r * l + o * u, x = o * r * l - i * u, v = r * i * l - o * u, k = i * i * l + c, X = o * i * l + r * u, Q = r * o * l + i * u, D = i * o * l - r * u, at = o * o * l + c, e[0] = h * O + g * F + y * x, e[1] = f * O + p * F + B * x, e[2] = d * O + C * F + R * x, e[3] = m * O + w * F + E * x, e[4] = h * v + g * k + y * X, e[5] = f * v + p * k + B * X, e[6] = d * v + C * k + R * X, e[7] = m * v + w * k + E * X, e[8] = h * Q + g * D + y * at, e[9] = f * Q + p * D + B * at, e[10] = d * Q + C * D + R * at, e[11] = m * Q + w * D + E * at, t !== e && (e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e);\n}\nfunction Sh(e, t, n) {\n  const s = Math.sin(n), r = Math.cos(n), i = t[4], o = t[5], a = t[6], c = t[7], u = t[8], l = t[9], h = t[10], f = t[11];\n  return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = i * r + u * s, e[5] = o * r + l * s, e[6] = a * r + h * s, e[7] = c * r + f * s, e[8] = u * r - i * s, e[9] = l * r - o * s, e[10] = h * r - a * s, e[11] = f * r - c * s, e;\n}\nfunction xh(e, t, n) {\n  const s = Math.sin(n), r = Math.cos(n), i = t[0], o = t[1], a = t[2], c = t[3], u = t[8], l = t[9], h = t[10], f = t[11];\n  return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = i * r - u * s, e[1] = o * r - l * s, e[2] = a * r - h * s, e[3] = c * r - f * s, e[8] = i * s + u * r, e[9] = o * s + l * r, e[10] = a * s + h * r, e[11] = c * s + f * r, e;\n}\nfunction Oh(e, t, n) {\n  const s = Math.sin(n), r = Math.cos(n), i = t[0], o = t[1], a = t[2], c = t[3], u = t[4], l = t[5], h = t[6], f = t[7];\n  return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = i * r + u * s, e[1] = o * r + l * s, e[2] = a * r + h * s, e[3] = c * r + f * s, e[4] = u * r - i * s, e[5] = l * r - o * s, e[6] = h * r - a * s, e[7] = f * r - c * s, e;\n}\nfunction Fh(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[4], o = t[5], a = t[6], c = t[8], u = t[9], l = t[10];\n  return e[0] = Math.sqrt(n * n + s * s + r * r), e[1] = Math.sqrt(i * i + o * o + a * a), e[2] = Math.sqrt(c * c + u * u + l * l), e;\n}\nfunction vh(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[3], o = n + n, a = s + s, c = r + r, u = n * o, l = s * o, h = s * a, f = r * o, d = r * a, m = r * c, g = i * o, p = i * a, C = i * c;\n  return e[0] = 1 - h - m, e[1] = l + C, e[2] = f - p, e[3] = 0, e[4] = l - C, e[5] = 1 - u - m, e[6] = d + g, e[7] = 0, e[8] = f + p, e[9] = d - g, e[10] = 1 - u - h, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;\n}\nfunction Dh(e, t, n, s, r, i, o) {\n  const a = 1 / (n - t), c = 1 / (r - s), u = 1 / (i - o);\n  return e[0] = i * 2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i * 2 * c, e[6] = 0, e[7] = 0, e[8] = (n + t) * a, e[9] = (r + s) * c, e[10] = (o + i) * u, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = o * i * 2 * u, e[15] = 0, e;\n}\nfunction Lh(e, t, n, s, r) {\n  const i = 1 / Math.tan(t / 2);\n  if (e[0] = i / n, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, r != null && r !== 1 / 0) {\n    const o = 1 / (s - r);\n    e[10] = (r + s) * o, e[14] = 2 * r * s * o;\n  } else\n    e[10] = -1, e[14] = -2 * s;\n  return e;\n}\nconst Gh = Lh;\nfunction Ph(e, t, n, s, r, i, o) {\n  const a = 1 / (t - n), c = 1 / (s - r), u = 1 / (i - o);\n  return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * u, e[11] = 0, e[12] = (t + n) * a, e[13] = (r + s) * c, e[14] = (o + i) * u, e[15] = 1, e;\n}\nconst Nh = Ph;\nfunction Uh(e, t, n, s) {\n  let r, i, o, a, c, u, l, h, f, d;\n  const m = t[0], g = t[1], p = t[2], C = s[0], w = s[1], y = s[2], B = n[0], R = n[1], E = n[2];\n  return Math.abs(m - B) < Se && Math.abs(g - R) < Se && Math.abs(p - E) < Se ? Th(e) : (h = m - B, f = g - R, d = p - E, r = 1 / Math.sqrt(h * h + f * f + d * d), h *= r, f *= r, d *= r, i = w * d - y * f, o = y * h - C * d, a = C * f - w * h, r = Math.sqrt(i * i + o * o + a * a), r ? (r = 1 / r, i *= r, o *= r, a *= r) : (i = 0, o = 0, a = 0), c = f * a - d * o, u = d * i - h * a, l = h * o - f * i, r = Math.sqrt(c * c + u * u + l * l), r ? (r = 1 / r, c *= r, u *= r, l *= r) : (c = 0, u = 0, l = 0), e[0] = i, e[1] = c, e[2] = h, e[3] = 0, e[4] = o, e[5] = u, e[6] = f, e[7] = 0, e[8] = a, e[9] = l, e[10] = d, e[11] = 0, e[12] = -(i * m + o * g + a * p), e[13] = -(c * m + u * g + l * p), e[14] = -(h * m + f * g + d * p), e[15] = 1, e);\n}\nfunction Hh() {\n  const e = new Rt(4);\n  return Rt != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0), e;\n}\nfunction Jh(e, t, n) {\n  return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e;\n}\nfunction Vh(e, t, n) {\n  return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e;\n}\nfunction jh(e) {\n  const t = e[0], n = e[1], s = e[2], r = e[3];\n  return Math.sqrt(t * t + n * n + s * s + r * r);\n}\nfunction kh(e) {\n  const t = e[0], n = e[1], s = e[2], r = e[3];\n  return t * t + n * n + s * s + r * r;\n}\nfunction Kh(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[3];\n  let o = n * n + s * s + r * r + i * i;\n  return o > 0 && (o = 1 / Math.sqrt(o)), e[0] = n * o, e[1] = s * o, e[2] = r * o, e[3] = i * o, e;\n}\nfunction zh(e, t) {\n  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];\n}\nfunction Wh(e, t, n, s) {\n  const r = t[0], i = t[1], o = t[2], a = t[3];\n  return e[0] = r + s * (n[0] - r), e[1] = i + s * (n[1] - i), e[2] = o + s * (n[2] - o), e[3] = a + s * (n[3] - a), e;\n}\nfunction Xh(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = t[3];\n  return e[0] = n[0] * s + n[4] * r + n[8] * i + n[12] * o, e[1] = n[1] * s + n[5] * r + n[9] * i + n[13] * o, e[2] = n[2] * s + n[6] * r + n[10] * i + n[14] * o, e[3] = n[3] * s + n[7] * r + n[11] * i + n[15] * o, e;\n}\nfunction Qh(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = n[0], a = n[1], c = n[2], u = n[3], l = u * s + a * i - c * r, h = u * r + c * s - o * i, f = u * i + o * r - a * s, d = -o * s - a * r - c * i;\n  return e[0] = l * u + d * -o + h * -c - f * -a, e[1] = h * u + d * -a + f * -o - l * -c, e[2] = f * u + d * -c + l * -a - h * -o, e[3] = t[3], e;\n}\n(function() {\n  const e = Hh();\n  return function(t, n, s, r, i, o) {\n    let a, c;\n    for (n || (n = 4), s || (s = 0), r ? c = Math.min(r * n + s, t.length) : c = t.length, a = s; a < c; a += n)\n      e[0] = t[a], e[1] = t[a + 1], e[2] = t[a + 2], e[3] = t[a + 3], i(e, e, o), t[a] = e[0], t[a + 1] = e[1], t[a + 2] = e[2], t[a + 3] = e[3];\n    return t;\n  };\n})();\nvar Ps;\n(function(e) {\n  e[e.COL0ROW0 = 0] = \"COL0ROW0\", e[e.COL0ROW1 = 1] = \"COL0ROW1\", e[e.COL0ROW2 = 2] = \"COL0ROW2\", e[e.COL0ROW3 = 3] = \"COL0ROW3\", e[e.COL1ROW0 = 4] = \"COL1ROW0\", e[e.COL1ROW1 = 5] = \"COL1ROW1\", e[e.COL1ROW2 = 6] = \"COL1ROW2\", e[e.COL1ROW3 = 7] = \"COL1ROW3\", e[e.COL2ROW0 = 8] = \"COL2ROW0\", e[e.COL2ROW1 = 9] = \"COL2ROW1\", e[e.COL2ROW2 = 10] = \"COL2ROW2\", e[e.COL2ROW3 = 11] = \"COL2ROW3\", e[e.COL3ROW0 = 12] = \"COL3ROW0\", e[e.COL3ROW1 = 13] = \"COL3ROW1\", e[e.COL3ROW2 = 14] = \"COL3ROW2\", e[e.COL3ROW3 = 15] = \"COL3ROW3\";\n})(Ps || (Ps = {}));\nconst qh = 45 * Math.PI / 180, Yh = 1, rs = 0.1, is = 500, $h = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\nclass V extends ca {\n  static get IDENTITY() {\n    return tf();\n  }\n  static get ZERO() {\n    return Zh();\n  }\n  get ELEMENTS() {\n    return 16;\n  }\n  get RANK() {\n    return 4;\n  }\n  get INDICES() {\n    return Ps;\n  }\n  constructor(t) {\n    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(t) ? this.copy(t) : this.identity();\n  }\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this[4] = t[4], this[5] = t[5], this[6] = t[6], this[7] = t[7], this[8] = t[8], this[9] = t[9], this[10] = t[10], this[11] = t[11], this[12] = t[12], this[13] = t[13], this[14] = t[14], this[15] = t[15], this.check();\n  }\n  set(t, n, s, r, i, o, a, c, u, l, h, f, d, m, g, p) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this[4] = i, this[5] = o, this[6] = a, this[7] = c, this[8] = u, this[9] = l, this[10] = h, this[11] = f, this[12] = d, this[13] = m, this[14] = g, this[15] = p, this.check();\n  }\n  setRowMajor(t, n, s, r, i, o, a, c, u, l, h, f, d, m, g, p) {\n    return this[0] = t, this[1] = i, this[2] = u, this[3] = d, this[4] = n, this[5] = o, this[6] = l, this[7] = m, this[8] = s, this[9] = a, this[10] = h, this[11] = g, this[12] = r, this[13] = c, this[14] = f, this[15] = p, this.check();\n  }\n  toRowMajor(t) {\n    return t[0] = this[0], t[1] = this[4], t[2] = this[8], t[3] = this[12], t[4] = this[1], t[5] = this[5], t[6] = this[9], t[7] = this[13], t[8] = this[2], t[9] = this[6], t[10] = this[10], t[11] = this[14], t[12] = this[3], t[13] = this[7], t[14] = this[11], t[15] = this[15], t;\n  }\n  identity() {\n    return this.copy($h);\n  }\n  fromObject(t) {\n    return this.check();\n  }\n  fromQuaternion(t) {\n    return vh(this, t), this.check();\n  }\n  frustum(t) {\n    const {\n      left: n,\n      right: s,\n      bottom: r,\n      top: i,\n      near: o = rs,\n      far: a = is\n    } = t;\n    return a === 1 / 0 ? ef(this, n, s, r, i, o) : Dh(this, n, s, r, i, o, a), this.check();\n  }\n  lookAt(t) {\n    const {\n      eye: n,\n      center: s = [0, 0, 0],\n      up: r = [0, 1, 0]\n    } = t;\n    return Uh(this, n, s, r), this.check();\n  }\n  ortho(t) {\n    const {\n      left: n,\n      right: s,\n      bottom: r,\n      top: i,\n      near: o = rs,\n      far: a = is\n    } = t;\n    return Nh(this, n, s, r, i, o, a), this.check();\n  }\n  orthographic(t) {\n    const {\n      fovy: n = qh,\n      aspect: s = Yh,\n      focalDistance: r = 1,\n      near: i = rs,\n      far: o = is\n    } = t;\n    ii(n);\n    const a = n / 2, c = r * Math.tan(a), u = c * s;\n    return this.ortho({\n      left: -u,\n      right: u,\n      bottom: -c,\n      top: c,\n      near: i,\n      far: o\n    });\n  }\n  perspective(t) {\n    const {\n      fovy: n = 45 * Math.PI / 180,\n      aspect: s = 1,\n      near: r = 0.1,\n      far: i = 500\n    } = t;\n    return ii(n), Gh(this, n, s, r, i), this.check();\n  }\n  determinant() {\n    return wh(this);\n  }\n  getScale(t = [-0, -0, -0]) {\n    return t[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), t[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), t[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), t;\n  }\n  getTranslation(t = [-0, -0, -0]) {\n    return t[0] = this[12], t[1] = this[13], t[2] = this[14], t;\n  }\n  getRotation(t, n) {\n    t = t || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], n = n || [-0, -0, -0];\n    const s = this.getScale(n), r = 1 / s[0], i = 1 / s[1], o = 1 / s[2];\n    return t[0] = this[0] * r, t[1] = this[1] * i, t[2] = this[2] * o, t[3] = 0, t[4] = this[4] * r, t[5] = this[5] * i, t[6] = this[6] * o, t[7] = 0, t[8] = this[8] * r, t[9] = this[9] * i, t[10] = this[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n  }\n  getRotationMatrix3(t, n) {\n    t = t || [-0, -0, -0, -0, -0, -0, -0, -0, -0], n = n || [-0, -0, -0];\n    const s = this.getScale(n), r = 1 / s[0], i = 1 / s[1], o = 1 / s[2];\n    return t[0] = this[0] * r, t[1] = this[1] * i, t[2] = this[2] * o, t[3] = this[4] * r, t[4] = this[5] * i, t[5] = this[6] * o, t[6] = this[8] * r, t[7] = this[9] * i, t[8] = this[10] * o, t;\n  }\n  transpose() {\n    return bh(this, this), this.check();\n  }\n  invert() {\n    return _h(this, this), this.check();\n  }\n  multiplyLeft(t) {\n    return ri(this, t, this), this.check();\n  }\n  multiplyRight(t) {\n    return ri(this, this, t), this.check();\n  }\n  rotateX(t) {\n    return Sh(this, this, t), this.check();\n  }\n  rotateY(t) {\n    return xh(this, this, t), this.check();\n  }\n  rotateZ(t) {\n    return Oh(this, this, t), this.check();\n  }\n  rotateXYZ(t) {\n    return this.rotateX(t[0]).rotateY(t[1]).rotateZ(t[2]);\n  }\n  rotateAxis(t, n) {\n    return Ih(this, this, t, n), this.check();\n  }\n  scale(t) {\n    return Mh(this, this, Array.isArray(t) ? t : [t, t, t]), this.check();\n  }\n  translate(t) {\n    return Rh(this, this, t), this.check();\n  }\n  transform(t, n) {\n    return t.length === 4 ? (n = Xh(n || [-0, -0, -0, -0], t, this), Ie(n, 4), n) : this.transformAsPoint(t, n);\n  }\n  transformAsPoint(t, n) {\n    const {\n      length: s\n    } = t;\n    let r;\n    switch (s) {\n      case 2:\n        r = ta(n || [-0, -0], t, this);\n        break;\n      case 3:\n        r = fr(n || [-0, -0, -0], t, this);\n        break;\n      default:\n        throw new Error(\"Illegal vector\");\n    }\n    return Ie(r, t.length), r;\n  }\n  transformAsVector(t, n) {\n    let s;\n    switch (t.length) {\n      case 2:\n        s = ea(n || [-0, -0], t, this);\n        break;\n      case 3:\n        s = na(n || [-0, -0, -0], t, this);\n        break;\n      default:\n        throw new Error(\"Illegal vector\");\n    }\n    return Ie(s, t.length), s;\n  }\n  transformPoint(t, n) {\n    return this.transformAsPoint(t, n);\n  }\n  transformVector(t, n) {\n    return this.transformAsPoint(t, n);\n  }\n  transformDirection(t, n) {\n    return this.transformAsVector(t, n);\n  }\n  makeRotationX(t) {\n    return this.identity().rotateX(t);\n  }\n  makeTranslation(t, n, s) {\n    return this.identity().translate([t, n, s]);\n  }\n}\nlet Ze, tn;\nfunction Zh() {\n  return Ze || (Ze = new V([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Ze)), Ze;\n}\nfunction tf() {\n  return tn || (tn = new V(), Object.freeze(tn)), tn;\n}\nfunction ii(e) {\n  if (e > Math.PI * 2)\n    throw Error(\"expected radians\");\n}\nfunction ef(e, t, n, s, r, i) {\n  const o = 2 * i / (n - t), a = 2 * i / (r - s), c = (n + t) / (n - t), u = (r + s) / (r - s), l = -1, h = -1, f = -2 * i;\n  return e[0] = o, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = a, e[6] = 0, e[7] = 0, e[8] = c, e[9] = u, e[10] = l, e[11] = h, e[12] = 0, e[13] = 0, e[14] = f, e[15] = 0, e;\n}\nfunction oi() {\n  const e = new Rt(4);\n  return Rt != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e[3] = 1, e;\n}\nfunction nf(e) {\n  return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;\n}\nfunction ua(e, t, n) {\n  n = n * 0.5;\n  const s = Math.sin(n);\n  return e[0] = s * t[0], e[1] = s * t[1], e[2] = s * t[2], e[3] = Math.cos(n), e;\n}\nfunction ai(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = n[0], c = n[1], u = n[2], l = n[3];\n  return e[0] = s * l + o * a + r * u - i * c, e[1] = r * l + o * c + i * a - s * u, e[2] = i * l + o * u + s * c - r * a, e[3] = o * l - s * a - r * c - i * u, e;\n}\nfunction sf(e, t, n) {\n  n *= 0.5;\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = Math.sin(n), c = Math.cos(n);\n  return e[0] = s * c + o * a, e[1] = r * c + i * a, e[2] = i * c - r * a, e[3] = o * c - s * a, e;\n}\nfunction rf(e, t, n) {\n  n *= 0.5;\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = Math.sin(n), c = Math.cos(n);\n  return e[0] = s * c - i * a, e[1] = r * c + o * a, e[2] = i * c + s * a, e[3] = o * c - r * a, e;\n}\nfunction of(e, t, n) {\n  n *= 0.5;\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = Math.sin(n), c = Math.cos(n);\n  return e[0] = s * c + r * a, e[1] = r * c - s * a, e[2] = i * c + o * a, e[3] = o * c - i * a, e;\n}\nfunction af(e, t) {\n  const n = t[0], s = t[1], r = t[2];\n  return e[0] = n, e[1] = s, e[2] = r, e[3] = Math.sqrt(Math.abs(1 - n * n - s * s - r * r)), e;\n}\nfunction pn(e, t, n, s) {\n  const r = t[0], i = t[1], o = t[2], a = t[3];\n  let c = n[0], u = n[1], l = n[2], h = n[3], f, d, m, g, p;\n  return f = r * c + i * u + o * l + a * h, f < 0 && (f = -f, c = -c, u = -u, l = -l, h = -h), 1 - f > Se ? (d = Math.acos(f), p = Math.sin(d), m = Math.sin((1 - s) * d) / p, g = Math.sin(s * d) / p) : (m = 1 - s, g = s), e[0] = m * r + g * c, e[1] = m * i + g * u, e[2] = m * o + g * l, e[3] = m * a + g * h, e;\n}\nfunction cf(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[3], o = n * n + s * s + r * r + i * i, a = o ? 1 / o : 0;\n  return e[0] = -n * a, e[1] = -s * a, e[2] = -r * a, e[3] = i * a, e;\n}\nfunction uf(e, t) {\n  return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e;\n}\nfunction la(e, t) {\n  const n = t[0] + t[4] + t[8];\n  let s;\n  if (n > 0)\n    s = Math.sqrt(n + 1), e[3] = 0.5 * s, s = 0.5 / s, e[0] = (t[5] - t[7]) * s, e[1] = (t[6] - t[2]) * s, e[2] = (t[1] - t[3]) * s;\n  else {\n    let r = 0;\n    t[4] > t[0] && (r = 1), t[8] > t[r * 3 + r] && (r = 2);\n    const i = (r + 1) % 3, o = (r + 2) % 3;\n    s = Math.sqrt(t[r * 3 + r] - t[i * 3 + i] - t[o * 3 + o] + 1), e[r] = 0.5 * s, s = 0.5 / s, e[3] = (t[i * 3 + o] - t[o * 3 + i]) * s, e[i] = (t[i * 3 + r] + t[r * 3 + i]) * s, e[o] = (t[o * 3 + r] + t[r * 3 + o]) * s;\n  }\n  return e;\n}\nconst lf = Jh, hf = Vh, ff = zh, df = Wh, mf = jh, gf = kh, ha = Kh, Af = function() {\n  const e = ra(), t = ei(1, 0, 0), n = ei(0, 1, 0);\n  return function(s, r, i) {\n    const o = hr(r, i);\n    return o < -0.999999 ? (An(e, t, r), hh(e) < 1e-6 && An(e, n, r), oh(e, e), ua(s, e, Math.PI), s) : o > 0.999999 ? (s[0] = 0, s[1] = 0, s[2] = 0, s[3] = 1, s) : (An(e, r, i), s[0] = e[0], s[1] = e[1], s[2] = e[2], s[3] = 1 + o, ha(s, s));\n  };\n}();\n(function() {\n  const e = oi(), t = oi();\n  return function(n, s, r, i, o, a) {\n    return pn(e, s, o, a), pn(t, r, i, a), pn(n, e, t, 2 * a * (1 - a)), n;\n  };\n})();\n(function() {\n  const e = fh();\n  return function(t, n, s, r) {\n    return e[0] = s[0], e[3] = s[1], e[6] = s[2], e[1] = r[0], e[4] = r[1], e[7] = r[2], e[2] = -n[0], e[5] = -n[1], e[8] = -n[2], ha(t, la(t, e));\n  };\n})();\nconst pf = [0, 0, 0, 1];\nclass wn extends ur {\n  constructor(t = 0, n = 0, s = 0, r = 1) {\n    super(-0, -0, -0, -0), Array.isArray(t) && arguments.length === 1 ? this.copy(t) : this.set(t, n, s, r);\n  }\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this.check();\n  }\n  set(t, n, s, r) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this.check();\n  }\n  fromObject(t) {\n    return this[0] = t.x, this[1] = t.y, this[2] = t.z, this[3] = t.w, this.check();\n  }\n  fromMatrix3(t) {\n    return la(this, t), this.check();\n  }\n  fromAxisRotation(t, n) {\n    return ua(this, t, n), this.check();\n  }\n  identity() {\n    return nf(this), this.check();\n  }\n  setAxisAngle(t, n) {\n    return this.fromAxisRotation(t, n);\n  }\n  get ELEMENTS() {\n    return 4;\n  }\n  get x() {\n    return this[0];\n  }\n  set x(t) {\n    this[0] = N(t);\n  }\n  get y() {\n    return this[1];\n  }\n  set y(t) {\n    this[1] = N(t);\n  }\n  get z() {\n    return this[2];\n  }\n  set z(t) {\n    this[2] = N(t);\n  }\n  get w() {\n    return this[3];\n  }\n  set w(t) {\n    this[3] = N(t);\n  }\n  len() {\n    return mf(this);\n  }\n  lengthSquared() {\n    return gf(this);\n  }\n  dot(t) {\n    return ff(this, t);\n  }\n  rotationTo(t, n) {\n    return Af(this, t, n), this.check();\n  }\n  add(t) {\n    return lf(this, this, t), this.check();\n  }\n  calculateW() {\n    return af(this, this), this.check();\n  }\n  conjugate() {\n    return uf(this, this), this.check();\n  }\n  invert() {\n    return cf(this, this), this.check();\n  }\n  lerp(t, n, s) {\n    return s === void 0 ? this.lerp(this, t, n) : (df(this, t, n, s), this.check());\n  }\n  multiplyRight(t) {\n    return ai(this, this, t), this.check();\n  }\n  multiplyLeft(t) {\n    return ai(this, t, this), this.check();\n  }\n  normalize() {\n    const t = this.len(), n = t > 0 ? 1 / t : 0;\n    return this[0] = this[0] * n, this[1] = this[1] * n, this[2] = this[2] * n, this[3] = this[3] * n, t === 0 && (this[3] = 1), this.check();\n  }\n  rotateX(t) {\n    return sf(this, this, t), this.check();\n  }\n  rotateY(t) {\n    return rf(this, this, t), this.check();\n  }\n  rotateZ(t) {\n    return of(this, this, t), this.check();\n  }\n  scale(t) {\n    return hf(this, this, t), this.check();\n  }\n  slerp(t, n, s) {\n    let r, i, o;\n    switch (arguments.length) {\n      case 1:\n        ({\n          start: r = pf,\n          target: i,\n          ratio: o\n        } = t);\n        break;\n      case 2:\n        r = this, i = t, o = n;\n        break;\n      default:\n        r = t, i = n, o = s;\n    }\n    return pn(this, r, i, o), this.check();\n  }\n  transformVector4(t, n = new dr()) {\n    return Qh(n, t, this), Ie(n, 4);\n  }\n  lengthSq() {\n    return this.lengthSquared();\n  }\n  setFromAxisAngle(t, n) {\n    return this.setAxisAngle(t, n);\n  }\n  premultiply(t) {\n    return this.multiplyLeft(t);\n  }\n  multiply(t) {\n    return this.multiplyRight(t);\n  }\n}\nfunction ve(e) {\n  \"@babel/helpers - typeof\";\n  return ve = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, ve(e);\n}\nfunction yf(e, t) {\n  if (ve(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var s = n.call(e, t || \"default\");\n    if (ve(s) != \"object\")\n      return s;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction Bf(e) {\n  var t = yf(e, \"string\");\n  return ve(t) == \"symbol\" ? t : String(t);\n}\nfunction S(e, t, n) {\n  return t = Bf(t), t in e ? Object.defineProperty(e, t, {\n    value: n,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[t] = n, e;\n}\nconst Cf = 0.1, Ef = 1e-12, fa = 1e-15, Tf = 1e-20, bf = 6378137, _f = 6378137, wf = 6356752314245179e-9;\nfunction Un(e) {\n  return e;\n}\nnew A();\nfunction Rf(e, t = [], n = Un) {\n  return \"longitude\" in e ? (t[0] = n(e.longitude), t[1] = n(e.latitude), t[2] = e.height) : \"x\" in e ? (t[0] = n(e.x), t[1] = n(e.y), t[2] = e.z) : (t[0] = n(e[0]), t[1] = n(e[1]), t[2] = e[2]), t;\n}\nfunction Mf(e, t = []) {\n  return Rf(e, t, tt._cartographicRadians ? Un : Wl);\n}\nfunction If(e, t, n = Un) {\n  return \"longitude\" in t ? (t.longitude = n(e[0]), t.latitude = n(e[1]), t.height = e[2]) : \"x\" in t ? (t.x = n(e[0]), t.y = n(e[1]), t.z = e[2]) : (t[0] = n(e[0]), t[1] = n(e[1]), t[2] = e[2]), t;\n}\nfunction Sf(e, t) {\n  return If(e, t, tt._cartographicRadians ? Un : Xl);\n}\nconst ci = 1e-14, xf = new A(), ui = {\n  up: {\n    south: \"east\",\n    north: \"west\",\n    west: \"south\",\n    east: \"north\"\n  },\n  down: {\n    south: \"west\",\n    north: \"east\",\n    west: \"north\",\n    east: \"south\"\n  },\n  south: {\n    up: \"west\",\n    down: \"east\",\n    west: \"down\",\n    east: \"up\"\n  },\n  north: {\n    up: \"east\",\n    down: \"west\",\n    west: \"up\",\n    east: \"down\"\n  },\n  west: {\n    up: \"north\",\n    down: \"south\",\n    north: \"down\",\n    south: \"up\"\n  },\n  east: {\n    up: \"south\",\n    down: \"north\",\n    north: \"up\",\n    south: \"down\"\n  }\n}, os = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1]\n}, ye = {\n  east: new A(),\n  north: new A(),\n  up: new A(),\n  west: new A(),\n  south: new A(),\n  down: new A()\n}, Of = new A(), Ff = new A(), vf = new A();\nfunction li(e, t, n, s, r, i) {\n  const o = ui[t] && ui[t][n];\n  j(o && (!s || s === o));\n  let a, c, u;\n  const l = xf.copy(r);\n  if (Jt(l.x, 0, ci) && Jt(l.y, 0, ci)) {\n    const f = Math.sign(l.z);\n    a = Of.fromArray(os[t]), t !== \"east\" && t !== \"west\" && a.scale(f), c = Ff.fromArray(os[n]), n !== \"east\" && n !== \"west\" && c.scale(f), u = vf.fromArray(os[s]), s !== \"east\" && s !== \"west\" && u.scale(f);\n  } else {\n    const {\n      up: f,\n      east: d,\n      north: m\n    } = ye;\n    d.set(-l.y, l.x, 0).normalize(), e.geodeticSurfaceNormal(l, f), m.copy(f).cross(d);\n    const {\n      down: g,\n      west: p,\n      south: C\n    } = ye;\n    g.copy(f).scale(-1), p.copy(d).scale(-1), C.copy(m).scale(-1), a = ye[t], c = ye[n], u = ye[s];\n  }\n  return i[0] = a.x, i[1] = a.y, i[2] = a.z, i[3] = 0, i[4] = c.x, i[5] = c.y, i[6] = c.z, i[7] = 0, i[8] = u.x, i[9] = u.y, i[10] = u.z, i[11] = 0, i[12] = l.x, i[13] = l.y, i[14] = l.z, i[15] = 1, i;\n}\nconst ie = new A(), Df = new A(), Lf = new A();\nfunction Gf(e, t, n = []) {\n  const {\n    oneOverRadii: s,\n    oneOverRadiiSquared: r,\n    centerToleranceSquared: i\n  } = t;\n  ie.from(e);\n  const o = ie.x, a = ie.y, c = ie.z, u = s.x, l = s.y, h = s.z, f = o * o * u * u, d = a * a * l * l, m = c * c * h * h, g = f + d + m, p = Math.sqrt(1 / g);\n  if (!Number.isFinite(p))\n    return;\n  const C = Df;\n  if (C.copy(e).scale(p), g < i)\n    return C.to(n);\n  const w = r.x, y = r.y, B = r.z, R = Lf;\n  R.set(C.x * w * 2, C.y * y * 2, C.z * B * 2);\n  let E = (1 - p) * ie.len() / (0.5 * R.len()), O = 0, F, x, v, k;\n  do {\n    E -= O, F = 1 / (1 + E * w), x = 1 / (1 + E * y), v = 1 / (1 + E * B);\n    const X = F * F, Q = x * x, D = v * v, at = X * F, ee = Q * x, ne = D * v;\n    k = f * X + d * Q + m * D - 1;\n    const Nt = -2 * (f * at * w + d * ee * y + m * ne * B);\n    O = k / Nt;\n  } while (Math.abs(k) > Ef);\n  return ie.scale([F, x, v]).to(n);\n}\nconst en = new A(), hi = new A(), Pf = new A(), bt = new A(), Nf = new A(), nn = new A();\nclass J {\n  constructor(t = 0, n = 0, s = 0) {\n    S(this, \"radii\", void 0), S(this, \"radiiSquared\", void 0), S(this, \"radiiToTheFourth\", void 0), S(this, \"oneOverRadii\", void 0), S(this, \"oneOverRadiiSquared\", void 0), S(this, \"minimumRadius\", void 0), S(this, \"maximumRadius\", void 0), S(this, \"centerToleranceSquared\", Cf), S(this, \"squaredXOverSquaredZ\", void 0), j(t >= 0), j(n >= 0), j(s >= 0), this.radii = new A(t, n, s), this.radiiSquared = new A(t * t, n * n, s * s), this.radiiToTheFourth = new A(t * t * t * t, n * n * n * n, s * s * s * s), this.oneOverRadii = new A(t === 0 ? 0 : 1 / t, n === 0 ? 0 : 1 / n, s === 0 ? 0 : 1 / s), this.oneOverRadiiSquared = new A(t === 0 ? 0 : 1 / (t * t), n === 0 ? 0 : 1 / (n * n), s === 0 ? 0 : 1 / (s * s)), this.minimumRadius = Math.min(t, n, s), this.maximumRadius = Math.max(t, n, s), this.radiiSquared.z !== 0 && (this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z), Object.freeze(this);\n  }\n  equals(t) {\n    return this === t || !!(t && this.radii.equals(t.radii));\n  }\n  toString() {\n    return this.radii.toString();\n  }\n  cartographicToCartesian(t, n = [0, 0, 0]) {\n    const s = hi, r = Pf, [, , i] = t;\n    this.geodeticSurfaceNormalCartographic(t, s), r.copy(this.radiiSquared).scale(s);\n    const o = Math.sqrt(s.dot(r));\n    return r.scale(1 / o), s.scale(i), r.add(s), r.to(n);\n  }\n  cartesianToCartographic(t, n = [0, 0, 0]) {\n    nn.from(t);\n    const s = this.scaleToGeodeticSurface(nn, bt);\n    if (!s)\n      return;\n    const r = this.geodeticSurfaceNormal(s, hi), i = Nf;\n    i.copy(nn).subtract(s);\n    const o = Math.atan2(r.y, r.x), a = Math.asin(r.z), c = Math.sign(hr(i, nn)) * ia(i);\n    return Sf([o, a, c], n);\n  }\n  eastNorthUpToFixedFrame(t, n = new V()) {\n    return li(this, \"east\", \"north\", \"up\", t, n);\n  }\n  localFrameToFixedFrame(t, n, s, r, i = new V()) {\n    return li(this, t, n, s, r, i);\n  }\n  geocentricSurfaceNormal(t, n = [0, 0, 0]) {\n    return en.from(t).normalize().to(n);\n  }\n  geodeticSurfaceNormalCartographic(t, n = [0, 0, 0]) {\n    const s = Mf(t), r = s[0], i = s[1], o = Math.cos(i);\n    return en.set(o * Math.cos(r), o * Math.sin(r), Math.sin(i)).normalize(), en.to(n);\n  }\n  geodeticSurfaceNormal(t, n = [0, 0, 0]) {\n    return en.from(t).scale(this.oneOverRadiiSquared).normalize().to(n);\n  }\n  scaleToGeodeticSurface(t, n) {\n    return Gf(t, this, n);\n  }\n  scaleToGeocentricSurface(t, n = [0, 0, 0]) {\n    bt.from(t);\n    const s = bt.x, r = bt.y, i = bt.z, o = this.oneOverRadiiSquared, a = 1 / Math.sqrt(s * s * o.x + r * r * o.y + i * i * o.z);\n    return bt.multiplyScalar(a).to(n);\n  }\n  transformPositionToScaledSpace(t, n = [0, 0, 0]) {\n    return bt.from(t).scale(this.oneOverRadii).to(n);\n  }\n  transformPositionFromScaledSpace(t, n = [0, 0, 0]) {\n    return bt.from(t).scale(this.radii).to(n);\n  }\n  getSurfaceNormalIntersectionWithZAxis(t, n = 0, s = [0, 0, 0]) {\n    j(Jt(this.radii.x, this.radii.y, fa)), j(this.radii.z > 0), bt.from(t);\n    const r = bt.z * (1 - this.squaredXOverSquaredZ);\n    if (!(Math.abs(r) >= this.radii.z - n))\n      return bt.set(0, 0, r).to(s);\n  }\n}\nS(J, \"WGS84\", new J(bf, _f, wf));\nclass Uf {\n  constructor(t, n, s) {\n    this.item = void 0, this.previous = void 0, this.next = void 0, this.item = t, this.previous = n, this.next = s;\n  }\n}\nclass Hf {\n  constructor() {\n    this.head = null, this.tail = null, this._length = 0;\n  }\n  get length() {\n    return this._length;\n  }\n  add(t) {\n    const n = new Uf(t, this.tail, null);\n    return this.tail ? (this.tail.next = n, this.tail = n) : (this.head = n, this.tail = n), ++this._length, n;\n  }\n  remove(t) {\n    t && (t.previous && t.next ? (t.previous.next = t.next, t.next.previous = t.previous) : t.previous ? (t.previous.next = null, this.tail = t.previous) : t.next ? (t.next.previous = null, this.head = t.next) : (this.head = null, this.tail = null), t.next = null, t.previous = null, --this._length);\n  }\n  splice(t, n) {\n    t !== n && (this.remove(n), this._insert(t, n));\n  }\n  _insert(t, n) {\n    const s = t.next;\n    t.next = n, this.tail === t ? this.tail = n : s.previous = n, n.next = s, n.previous = t, ++this._length;\n  }\n}\nclass Jf {\n  constructor() {\n    this._list = void 0, this._sentinel = void 0, this._trimTiles = void 0, this._list = new Hf(), this._sentinel = this._list.add(\"sentinel\"), this._trimTiles = !1;\n  }\n  reset() {\n    this._list.splice(this._list.tail, this._sentinel);\n  }\n  touch(t) {\n    const n = t._cacheNode;\n    n && this._list.splice(this._sentinel, n);\n  }\n  add(t, n, s) {\n    n._cacheNode || (n._cacheNode = this._list.add(n), s && s(t, n));\n  }\n  unloadTile(t, n, s) {\n    const r = n._cacheNode;\n    r && (this._list.remove(r), n._cacheNode = null, s && s(t, n));\n  }\n  unloadTiles(t, n) {\n    const s = this._trimTiles;\n    this._trimTiles = !1;\n    const r = this._list, i = t.maximumMemoryUsage * 1024 * 1024, o = this._sentinel;\n    let a = r.head;\n    for (; a !== o && (t.gpuMemoryUsageInBytes > i || s); ) {\n      const c = a.item;\n      a = a.next, this.unloadTile(t, c, n);\n    }\n  }\n  trim() {\n    this._trimTiles = !0;\n  }\n}\nfunction Vf(e, t) {\n  U(e), U(t);\n  const {\n    rtcCenter: n,\n    gltfUpAxis: s\n  } = t, {\n    computedTransform: r,\n    boundingVolume: {\n      center: i\n    }\n  } = e;\n  let o = new V(r);\n  switch (n && o.translate(n), s) {\n    case \"Z\":\n      break;\n    case \"Y\":\n      const h = new V().rotateX(Math.PI / 2);\n      o = o.multiplyRight(h);\n      break;\n    case \"X\":\n      const f = new V().rotateY(-Math.PI / 2);\n      o = o.multiplyRight(f);\n      break;\n  }\n  t.isQuantized && o.translate(t.quantizedVolumeOffset).scale(t.quantizedVolumeScale);\n  const a = new A(i);\n  t.cartesianModelMatrix = o, t.cartesianOrigin = a;\n  const c = J.WGS84.cartesianToCartographic(a, new A()), l = J.WGS84.eastNorthUpToFixedFrame(a).invert();\n  t.cartographicModelMatrix = l.multiplyRight(o), t.cartographicOrigin = c, t.coordinateSystem || (t.modelMatrix = t.cartographicModelMatrix);\n}\nconst mt = {\n  OUTSIDE: -1,\n  INTERSECTING: 0,\n  INSIDE: 1\n};\nnew A();\nnew A();\nconst Be = new A(), fi = new A();\nclass ke {\n  constructor(t = [0, 0, 0], n = 0) {\n    S(this, \"center\", void 0), S(this, \"radius\", void 0), this.radius = -0, this.center = new A(), this.fromCenterRadius(t, n);\n  }\n  fromCenterRadius(t, n) {\n    return this.center.from(t), this.radius = n, this;\n  }\n  fromCornerPoints(t, n) {\n    return n = Be.from(n), this.center = new A().from(t).add(n).scale(0.5), this.radius = this.center.distance(n), this;\n  }\n  equals(t) {\n    return this === t || !!t && this.center.equals(t.center) && this.radius === t.radius;\n  }\n  clone() {\n    return new ke(this.center, this.radius);\n  }\n  union(t) {\n    const n = this.center, s = this.radius, r = t.center, i = t.radius, o = Be.copy(r).subtract(n), a = o.magnitude();\n    if (s >= a + i)\n      return this.clone();\n    if (i >= a + s)\n      return t.clone();\n    const c = (s + a + i) * 0.5;\n    return fi.copy(o).scale((-s + c) / a).add(n), this.center.copy(fi), this.radius = c, this;\n  }\n  expand(t) {\n    const s = Be.from(t).subtract(this.center).magnitude();\n    return s > this.radius && (this.radius = s), this;\n  }\n  transform(t) {\n    this.center.transform(t);\n    const n = Fh(Be, t);\n    return this.radius = Math.max(n[0], Math.max(n[1], n[2])) * this.radius, this;\n  }\n  distanceSquaredTo(t) {\n    const n = this.distanceTo(t);\n    return n * n;\n  }\n  distanceTo(t) {\n    const s = Be.from(t).subtract(this.center);\n    return Math.max(0, s.len() - this.radius);\n  }\n  intersectPlane(t) {\n    const n = this.center, s = this.radius, i = t.normal.dot(n) + t.distance;\n    return i < -s ? mt.OUTSIDE : i < s ? mt.INTERSECTING : mt.INSIDE;\n  }\n}\nconst jf = new A(), kf = new A(), sn = new A(), rn = new A(), on = new A(), Kf = new A(), zf = new A(), vt = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\nclass Ke {\n  constructor(t = [0, 0, 0], n = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {\n    S(this, \"center\", void 0), S(this, \"halfAxes\", void 0), this.center = new A().from(t), this.halfAxes = new z(n);\n  }\n  get halfSize() {\n    const t = this.halfAxes.getColumn(0), n = this.halfAxes.getColumn(1), s = this.halfAxes.getColumn(2);\n    return [new A(t).len(), new A(n).len(), new A(s).len()];\n  }\n  get quaternion() {\n    const t = this.halfAxes.getColumn(0), n = this.halfAxes.getColumn(1), s = this.halfAxes.getColumn(2), r = new A(t).normalize(), i = new A(n).normalize(), o = new A(s).normalize();\n    return new wn().fromMatrix3(new z([...r, ...i, ...o]));\n  }\n  fromCenterHalfSizeQuaternion(t, n, s) {\n    const r = new wn(s), i = new z().fromQuaternion(r);\n    return i[0] = i[0] * n[0], i[1] = i[1] * n[0], i[2] = i[2] * n[0], i[3] = i[3] * n[1], i[4] = i[4] * n[1], i[5] = i[5] * n[1], i[6] = i[6] * n[2], i[7] = i[7] * n[2], i[8] = i[8] * n[2], this.center = new A().from(t), this.halfAxes = i, this;\n  }\n  clone() {\n    return new Ke(this.center, this.halfAxes);\n  }\n  equals(t) {\n    return this === t || !!t && this.center.equals(t.center) && this.halfAxes.equals(t.halfAxes);\n  }\n  getBoundingSphere(t = new ke()) {\n    const n = this.halfAxes, s = n.getColumn(0, sn), r = n.getColumn(1, rn), i = n.getColumn(2, on), o = jf.copy(s).add(r).add(i);\n    return t.center.copy(this.center), t.radius = o.magnitude(), t;\n  }\n  intersectPlane(t) {\n    const n = this.center, s = t.normal, r = this.halfAxes, i = s.x, o = s.y, a = s.z, c = Math.abs(i * r[vt.COLUMN0ROW0] + o * r[vt.COLUMN0ROW1] + a * r[vt.COLUMN0ROW2]) + Math.abs(i * r[vt.COLUMN1ROW0] + o * r[vt.COLUMN1ROW1] + a * r[vt.COLUMN1ROW2]) + Math.abs(i * r[vt.COLUMN2ROW0] + o * r[vt.COLUMN2ROW1] + a * r[vt.COLUMN2ROW2]), u = s.dot(n) + t.distance;\n    return u <= -c ? mt.OUTSIDE : u >= c ? mt.INSIDE : mt.INTERSECTING;\n  }\n  distanceTo(t) {\n    return Math.sqrt(this.distanceSquaredTo(t));\n  }\n  distanceSquaredTo(t) {\n    const n = kf.from(t).subtract(this.center), s = this.halfAxes, r = s.getColumn(0, sn), i = s.getColumn(1, rn), o = s.getColumn(2, on), a = r.magnitude(), c = i.magnitude(), u = o.magnitude();\n    r.normalize(), i.normalize(), o.normalize();\n    let l = 0, h;\n    return h = Math.abs(n.dot(r)) - a, h > 0 && (l += h * h), h = Math.abs(n.dot(i)) - c, h > 0 && (l += h * h), h = Math.abs(n.dot(o)) - u, h > 0 && (l += h * h), l;\n  }\n  computePlaneDistances(t, n, s = [-0, -0]) {\n    let r = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;\n    const o = this.center, a = this.halfAxes, c = a.getColumn(0, sn), u = a.getColumn(1, rn), l = a.getColumn(2, on), h = Kf.copy(c).add(u).add(l).add(o), f = zf.copy(h).subtract(t);\n    let d = n.dot(f);\n    return r = Math.min(d, r), i = Math.max(d, i), h.copy(o).add(c).add(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), h.copy(o).add(c).subtract(u).add(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), h.copy(o).add(c).subtract(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).add(u).add(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).add(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).subtract(u).add(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).subtract(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), s[0] = r, s[1] = i, s;\n  }\n  transform(t) {\n    this.center.transformAsPoint(t);\n    const n = this.halfAxes.getColumn(0, sn);\n    n.transformAsPoint(t);\n    const s = this.halfAxes.getColumn(1, rn);\n    s.transformAsPoint(t);\n    const r = this.halfAxes.getColumn(2, on);\n    return r.transformAsPoint(t), this.halfAxes = new z([...n, ...s, ...r]), this;\n  }\n  getTransform() {\n    throw new Error(\"not implemented\");\n  }\n}\nconst di = new A(), mi = new A();\nclass et {\n  constructor(t = [0, 0, 1], n = 0) {\n    S(this, \"normal\", void 0), S(this, \"distance\", void 0), this.normal = new A(), this.distance = -0, this.fromNormalDistance(t, n);\n  }\n  fromNormalDistance(t, n) {\n    return j(Number.isFinite(n)), this.normal.from(t).normalize(), this.distance = n, this;\n  }\n  fromPointNormal(t, n) {\n    t = di.from(t), this.normal.from(n).normalize();\n    const s = -this.normal.dot(t);\n    return this.distance = s, this;\n  }\n  fromCoefficients(t, n, s, r) {\n    return this.normal.set(t, n, s), j(Jt(this.normal.len(), 1)), this.distance = r, this;\n  }\n  clone() {\n    return new et(this.normal, this.distance);\n  }\n  equals(t) {\n    return Jt(this.distance, t.distance) && Jt(this.normal, t.normal);\n  }\n  getPointDistance(t) {\n    return this.normal.dot(t) + this.distance;\n  }\n  transform(t) {\n    const n = mi.copy(this.normal).transformAsVector(t).normalize(), s = this.normal.scale(-this.distance).transform(t);\n    return this.fromPointNormal(s, n);\n  }\n  projectPointOntoPlane(t, n = [0, 0, 0]) {\n    const s = di.from(t), r = this.getPointDistance(s), i = mi.copy(this.normal).scale(r);\n    return s.subtract(i).to(n);\n  }\n}\nconst gi = [new A([1, 0, 0]), new A([0, 1, 0]), new A([0, 0, 1])], Ai = new A(), Wf = new A();\nclass ht {\n  constructor(t = []) {\n    S(this, \"planes\", void 0), this.planes = t;\n  }\n  fromBoundingSphere(t) {\n    this.planes.length = 2 * gi.length;\n    const n = t.center, s = t.radius;\n    let r = 0;\n    for (const i of gi) {\n      let o = this.planes[r], a = this.planes[r + 1];\n      o || (o = this.planes[r] = new et()), a || (a = this.planes[r + 1] = new et());\n      const c = Ai.copy(i).scale(-s).add(n);\n      o.fromPointNormal(c, i);\n      const u = Ai.copy(i).scale(s).add(n), l = Wf.copy(i).negate();\n      a.fromPointNormal(u, l), r += 2;\n    }\n    return this;\n  }\n  computeVisibility(t) {\n    let n = mt.INSIDE;\n    for (const s of this.planes)\n      switch (t.intersectPlane(s)) {\n        case mt.OUTSIDE:\n          return mt.OUTSIDE;\n        case mt.INTERSECTING:\n          n = mt.INTERSECTING;\n          break;\n      }\n    return n;\n  }\n  computeVisibilityWithPlaneMask(t, n) {\n    if (j(Number.isFinite(n), \"parentPlaneMask is required.\"), n === ht.MASK_OUTSIDE || n === ht.MASK_INSIDE)\n      return n;\n    let s = ht.MASK_INSIDE;\n    const r = this.planes;\n    for (let i = 0; i < this.planes.length; ++i) {\n      const o = i < 31 ? 1 << i : 0;\n      if (i < 31 && !(n & o))\n        continue;\n      const a = r[i], c = t.intersectPlane(a);\n      if (c === mt.OUTSIDE)\n        return ht.MASK_OUTSIDE;\n      c === mt.INTERSECTING && (s |= o);\n    }\n    return s;\n  }\n}\nS(ht, \"MASK_OUTSIDE\", 4294967295);\nS(ht, \"MASK_INSIDE\", 0);\nS(ht, \"MASK_INDETERMINATE\", 2147483647);\nconst Xf = new A(), Qf = new A(), qf = new A(), Yf = new A(), $f = new A();\nclass Rn {\n  constructor(t = {}) {\n    S(this, \"left\", void 0), S(this, \"_left\", void 0), S(this, \"right\", void 0), S(this, \"_right\", void 0), S(this, \"top\", void 0), S(this, \"_top\", void 0), S(this, \"bottom\", void 0), S(this, \"_bottom\", void 0), S(this, \"near\", void 0), S(this, \"_near\", void 0), S(this, \"far\", void 0), S(this, \"_far\", void 0), S(this, \"_cullingVolume\", new ht([new et(), new et(), new et(), new et(), new et(), new et()])), S(this, \"_perspectiveMatrix\", new V()), S(this, \"_infinitePerspective\", new V());\n    const {\n      near: n = 1,\n      far: s = 5e8\n    } = t;\n    this.left = t.left, this._left = void 0, this.right = t.right, this._right = void 0, this.top = t.top, this._top = void 0, this.bottom = t.bottom, this._bottom = void 0, this.near = n, this._near = n, this.far = s, this._far = s;\n  }\n  clone() {\n    return new Rn({\n      right: this.right,\n      left: this.left,\n      top: this.top,\n      bottom: this.bottom,\n      near: this.near,\n      far: this.far\n    });\n  }\n  equals(t) {\n    return t && t instanceof Rn && this.right === t.right && this.left === t.left && this.top === t.top && this.bottom === t.bottom && this.near === t.near && this.far === t.far;\n  }\n  get projectionMatrix() {\n    return this._update(), this._perspectiveMatrix;\n  }\n  get infiniteProjectionMatrix() {\n    return this._update(), this._infinitePerspective;\n  }\n  computeCullingVolume(t, n, s) {\n    j(t, \"position is required.\"), j(n, \"direction is required.\"), j(s, \"up is required.\");\n    const r = this._cullingVolume.planes;\n    s = Xf.copy(s).normalize();\n    const i = Qf.copy(n).cross(s).normalize(), o = qf.copy(n).multiplyByScalar(this.near).add(t), a = Yf.copy(n).multiplyByScalar(this.far).add(t);\n    let c = $f;\n    return c.copy(i).multiplyByScalar(this.left).add(o).subtract(t).cross(s), r[0].fromPointNormal(t, c), c.copy(i).multiplyByScalar(this.right).add(o).subtract(t).cross(s).negate(), r[1].fromPointNormal(t, c), c.copy(s).multiplyByScalar(this.bottom).add(o).subtract(t).cross(i).negate(), r[2].fromPointNormal(t, c), c.copy(s).multiplyByScalar(this.top).add(o).subtract(t).cross(i), r[3].fromPointNormal(t, c), c = new A().copy(n), r[4].fromPointNormal(o, c), c.negate(), r[5].fromPointNormal(a, c), this._cullingVolume;\n  }\n  getPixelDimensions(t, n, s, r) {\n    this._update(), j(Number.isFinite(t) && Number.isFinite(n)), j(t > 0), j(n > 0), j(s > 0), j(r);\n    const i = 1 / this.near;\n    let o = this.top * i;\n    const a = 2 * s * o / n;\n    o = this.right * i;\n    const c = 2 * s * o / t;\n    return r.x = c, r.y = a, r;\n  }\n  _update() {\n    j(Number.isFinite(this.right) && Number.isFinite(this.left) && Number.isFinite(this.top) && Number.isFinite(this.bottom) && Number.isFinite(this.near) && Number.isFinite(this.far));\n    const {\n      top: t,\n      bottom: n,\n      right: s,\n      left: r,\n      near: i,\n      far: o\n    } = this;\n    (t !== this._top || n !== this._bottom || r !== this._left || s !== this._right || i !== this._near || o !== this._far) && (j(this.near > 0 && this.near < this.far, \"near must be greater than zero and less than far.\"), this._left = r, this._right = s, this._top = t, this._bottom = n, this._near = i, this._far = o, this._perspectiveMatrix = new V().frustum({\n      left: r,\n      right: s,\n      bottom: n,\n      top: t,\n      near: i,\n      far: o\n    }), this._infinitePerspective = new V().frustum({\n      left: r,\n      right: s,\n      bottom: n,\n      top: t,\n      near: i,\n      far: 1 / 0\n    }));\n  }\n}\nconst Zf = (e) => e !== null && typeof e < \"u\";\nclass Mn {\n  constructor(t = {}) {\n    S(this, \"_offCenterFrustum\", new Rn()), S(this, \"fov\", void 0), S(this, \"_fov\", void 0), S(this, \"_fovy\", void 0), S(this, \"_sseDenominator\", void 0), S(this, \"aspectRatio\", void 0), S(this, \"_aspectRatio\", void 0), S(this, \"near\", void 0), S(this, \"_near\", void 0), S(this, \"far\", void 0), S(this, \"_far\", void 0), S(this, \"xOffset\", void 0), S(this, \"_xOffset\", void 0), S(this, \"yOffset\", void 0), S(this, \"_yOffset\", void 0);\n    const {\n      fov: n,\n      aspectRatio: s,\n      near: r = 1,\n      far: i = 5e8,\n      xOffset: o = 0,\n      yOffset: a = 0\n    } = t;\n    this.fov = n, this.aspectRatio = s, this.near = r, this.far = i, this.xOffset = o, this.yOffset = a;\n  }\n  clone() {\n    return new Mn({\n      aspectRatio: this.aspectRatio,\n      fov: this.fov,\n      near: this.near,\n      far: this.far\n    });\n  }\n  equals(t) {\n    return !Zf(t) || !(t instanceof Mn) ? !1 : (this._update(), t._update(), this.fov === t.fov && this.aspectRatio === t.aspectRatio && this.near === t.near && this.far === t.far && this._offCenterFrustum.equals(t._offCenterFrustum));\n  }\n  get projectionMatrix() {\n    return this._update(), this._offCenterFrustum.projectionMatrix;\n  }\n  get infiniteProjectionMatrix() {\n    return this._update(), this._offCenterFrustum.infiniteProjectionMatrix;\n  }\n  get fovy() {\n    return this._update(), this._fovy;\n  }\n  get sseDenominator() {\n    return this._update(), this._sseDenominator;\n  }\n  computeCullingVolume(t, n, s) {\n    return this._update(), this._offCenterFrustum.computeCullingVolume(t, n, s);\n  }\n  getPixelDimensions(t, n, s, r) {\n    return this._update(), this._offCenterFrustum.getPixelDimensions(t, n, s, r || new Nn());\n  }\n  _update() {\n    j(Number.isFinite(this.fov) && Number.isFinite(this.aspectRatio) && Number.isFinite(this.near) && Number.isFinite(this.far));\n    const t = this._offCenterFrustum;\n    (this.fov !== this._fov || this.aspectRatio !== this._aspectRatio || this.near !== this._near || this.far !== this._far || this.xOffset !== this._xOffset || this.yOffset !== this._yOffset) && (j(this.fov >= 0 && this.fov < Math.PI), j(this.aspectRatio > 0), j(this.near >= 0 && this.near < this.far), this._aspectRatio = this.aspectRatio, this._fov = this.fov, this._fovy = this.aspectRatio <= 1 ? this.fov : Math.atan(Math.tan(this.fov * 0.5) / this.aspectRatio) * 2, this._near = this.near, this._far = this.far, this._sseDenominator = 2 * Math.tan(0.5 * this._fovy), this._xOffset = this.xOffset, this._yOffset = this.yOffset, t.top = this.near * Math.tan(0.5 * this._fovy), t.bottom = -t.top, t.right = this.aspectRatio * t.top, t.left = -t.right, t.near = this.near, t.far = this.far, t.right += this.xOffset, t.left += this.xOffset, t.top += this.yOffset, t.bottom += this.yOffset);\n  }\n}\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nconst It = new z(), td = new z(), ed = new z(), an = new z(), pi = new z();\nfunction nd(e, t = {}) {\n  const n = Tf, s = 10;\n  let r = 0, i = 0;\n  const o = td, a = ed;\n  o.identity(), a.copy(e);\n  const c = n * sd(a);\n  for (; i < s && rd(a) > c; )\n    id(a, an), pi.copy(an).transpose(), a.multiplyRight(an), a.multiplyLeft(pi), o.multiplyRight(an), ++r > 2 && (++i, r = 0);\n  return t.unitary = o.toTarget(t.unitary), t.diagonal = a.toTarget(t.diagonal), t;\n}\nfunction sd(e) {\n  let t = 0;\n  for (let n = 0; n < 9; ++n) {\n    const s = e[n];\n    t += s * s;\n  }\n  return Math.sqrt(t);\n}\nconst Ns = [1, 0, 0], Us = [2, 2, 1];\nfunction rd(e) {\n  let t = 0;\n  for (let n = 0; n < 3; ++n) {\n    const s = e[It.getElementIndex(Us[n], Ns[n])];\n    t += 2 * s * s;\n  }\n  return Math.sqrt(t);\n}\nfunction id(e, t) {\n  const n = fa;\n  let s = 0, r = 1;\n  for (let u = 0; u < 3; ++u) {\n    const l = Math.abs(e[It.getElementIndex(Us[u], Ns[u])]);\n    l > s && (r = u, s = l);\n  }\n  const i = Ns[r], o = Us[r];\n  let a = 1, c = 0;\n  if (Math.abs(e[It.getElementIndex(o, i)]) > n) {\n    const u = e[It.getElementIndex(o, o)], l = e[It.getElementIndex(i, i)], h = e[It.getElementIndex(o, i)], f = (u - l) / 2 / h;\n    let d;\n    f < 0 ? d = -1 / (-f + Math.sqrt(1 + f * f)) : d = 1 / (f + Math.sqrt(1 + f * f)), a = 1 / Math.sqrt(1 + d * d), c = d * a;\n  }\n  return z.IDENTITY.to(t), t[It.getElementIndex(i, i)] = t[It.getElementIndex(o, o)] = a, t[It.getElementIndex(o, i)] = c, t[It.getElementIndex(i, o)] = -c, t;\n}\nconst Ut = new A(), od = new A(), ad = new A(), cd = new A(), ud = new A(), ld = new z(), hd = {\n  diagonal: new z(),\n  unitary: new z()\n};\nfunction fd(e, t = new Ke()) {\n  if (!e || e.length === 0)\n    return t.halfAxes = new z([0, 0, 0, 0, 0, 0, 0, 0, 0]), t.center = new A(), t;\n  const n = e.length, s = new A(0, 0, 0);\n  for (const x of e)\n    s.add(x);\n  const r = 1 / n;\n  s.multiplyByScalar(r);\n  let i = 0, o = 0, a = 0, c = 0, u = 0, l = 0;\n  for (const x of e) {\n    const v = Ut.copy(x).subtract(s);\n    i += v.x * v.x, o += v.x * v.y, a += v.x * v.z, c += v.y * v.y, u += v.y * v.z, l += v.z * v.z;\n  }\n  i *= r, o *= r, a *= r, c *= r, u *= r, l *= r;\n  const h = ld;\n  h[0] = i, h[1] = o, h[2] = a, h[3] = o, h[4] = c, h[5] = u, h[6] = a, h[7] = u, h[8] = l;\n  const {\n    unitary: f\n  } = nd(h, hd), d = t.halfAxes.copy(f);\n  let m = d.getColumn(0, ad), g = d.getColumn(1, cd), p = d.getColumn(2, ud), C = -Number.MAX_VALUE, w = -Number.MAX_VALUE, y = -Number.MAX_VALUE, B = Number.MAX_VALUE, R = Number.MAX_VALUE, E = Number.MAX_VALUE;\n  for (const x of e)\n    Ut.copy(x), C = Math.max(Ut.dot(m), C), w = Math.max(Ut.dot(g), w), y = Math.max(Ut.dot(p), y), B = Math.min(Ut.dot(m), B), R = Math.min(Ut.dot(g), R), E = Math.min(Ut.dot(p), E);\n  m = m.multiplyByScalar(0.5 * (B + C)), g = g.multiplyByScalar(0.5 * (R + w)), p = p.multiplyByScalar(0.5 * (E + y)), t.center.copy(m).add(g).add(p);\n  const O = od.set(C - B, w - R, y - E).multiplyByScalar(0.5), F = new z([O[0], 0, 0, 0, O[1], 0, 0, 0, O[2]]);\n  return t.halfAxes.multiplyRight(F), t;\n}\nconst yi = new A(), as = new A(), Hs = new ht([new et(), new et(), new et(), new et(), new et(), new et()]);\nfunction dd(e, t) {\n  const {\n    cameraDirection: n,\n    cameraUp: s,\n    height: r\n  } = e, {\n    metersPerUnit: i\n  } = e.distanceScales, o = yn(e, e.center), a = J.WGS84.eastNorthUpToFixedFrame(o), c = e.unprojectPosition(e.cameraPosition), u = J.WGS84.cartographicToCartesian(c, new A()), l = new A(a.transformAsVector(new A(n).scale(i))).normalize(), h = new A(a.transformAsVector(new A(s).scale(i))).normalize();\n  gd(e);\n  const f = e.constructor, {\n    longitude: d,\n    latitude: m,\n    width: g,\n    bearing: p,\n    zoom: C\n  } = e, w = new f({\n    longitude: d,\n    latitude: m,\n    height: r,\n    width: g,\n    bearing: p,\n    zoom: C,\n    pitch: 0\n  });\n  return {\n    camera: {\n      position: u,\n      direction: l,\n      up: h\n    },\n    viewport: e,\n    topDownViewport: w,\n    height: r,\n    cullingVolume: Hs,\n    frameNumber: t,\n    sseDenominator: 1.15\n  };\n}\nfunction md(e, t, n) {\n  if (n === 0 || e.length <= n)\n    return [e, []];\n  const s = [], {\n    longitude: r,\n    latitude: i\n  } = t.viewport;\n  for (const [u, l] of e.entries()) {\n    const [h, f] = l.header.mbs, d = Math.abs(r - h), m = Math.abs(i - f), g = Math.sqrt(m * m + d * d);\n    s.push([u, g]);\n  }\n  const o = s.sort((u, l) => u[1] - l[1]), a = [];\n  for (let u = 0; u < n; u++)\n    a.push(e[o[u][0]]);\n  const c = [];\n  for (let u = n; u < o.length; u++)\n    c.push(e[o[u][0]]);\n  return [a, c];\n}\nfunction gd(e) {\n  const t = e.getFrustumPlanes(), n = Bi(t.near, e.cameraPosition), s = yn(e, n), r = yn(e, e.cameraPosition, as);\n  let i = 0;\n  Hs.planes[i++].fromPointNormal(s, yi.copy(s).subtract(r));\n  for (const o in t) {\n    if (o === \"near\")\n      continue;\n    const a = t[o], c = Bi(a, n, as), u = yn(e, c, as);\n    Hs.planes[i++].fromPointNormal(u, yi.copy(s).subtract(u));\n  }\n}\nfunction Bi(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new A();\n  const s = e.normal.dot(t);\n  return n.copy(e.normal).scale(e.distance - s).add(t), n;\n}\nfunction yn(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new A();\n  const s = e.unprojectPosition(t);\n  return J.WGS84.cartographicToCartesian(s, n);\n}\nconst Ad = 6378137, pd = 6378137, Js = 6356752314245179e-9, ue = new A();\nfunction yd(e, t) {\n  if (e instanceof Ke) {\n    const {\n      halfAxes: n\n    } = e, s = Cd(n);\n    return Math.log2(Js / (s + t[2]));\n  } else if (e instanceof ke) {\n    const {\n      radius: n\n    } = e;\n    return Math.log2(Js / (n + t[2]));\n  } else if (e.width && e.height) {\n    const {\n      width: n,\n      height: s\n    } = e, r = Math.log2(Ad / n), i = Math.log2(pd / s);\n    return (r + i) / 2;\n  }\n  return 1;\n}\nfunction da(e, t, n) {\n  J.WGS84.cartographicToCartesian([e.xmax, e.ymax, e.zmax], ue);\n  const s = Math.sqrt(Math.pow(ue[0] - n[0], 2) + Math.pow(ue[1] - n[1], 2) + Math.pow(ue[2] - n[2], 2));\n  return Math.log2(Js / (s + t[2]));\n}\nfunction Bd(e, t, n) {\n  const [s, r, i, o] = e;\n  return da({\n    xmin: s,\n    xmax: i,\n    ymin: r,\n    ymax: o,\n    zmin: 0,\n    zmax: 0\n  }, t, n);\n}\nfunction Cd(e) {\n  e.getColumn(0, ue);\n  const t = e.getColumn(1), n = e.getColumn(2);\n  return ue.add(t).add(n).len();\n}\nconst ut = {\n  UNLOADED: 0,\n  LOADING: 1,\n  PROCESSING: 2,\n  READY: 3,\n  EXPIRED: 4,\n  FAILED: 5\n};\nlet Gt = function(e) {\n  return e[e.ADD = 1] = \"ADD\", e[e.REPLACE = 2] = \"REPLACE\", e;\n}({}), zt = function(e) {\n  return e.EMPTY = \"empty\", e.SCENEGRAPH = \"scenegraph\", e.POINTCLOUD = \"pointcloud\", e.MESH = \"mesh\", e;\n}({}), At = function(e) {\n  return e.I3S = \"I3S\", e.TILES3D = \"TILES3D\", e;\n}({}), Hn = function(e) {\n  return e.GEOMETRIC_ERROR = \"geometricError\", e.MAX_SCREEN_THRESHOLD = \"maxScreenThreshold\", e;\n}({});\nconst Ed = {\n  NOT_COMPUTED: -1,\n  USE_OPTIMIZATION: 1,\n  SKIP_OPTIMIZATION: 0\n};\nfunction ma(e) {\n  return e != null;\n}\nconst rt = new A(), Bn = new A(), Td = new A(), bd = new A(), kt = new A(), Ci = new A(), Ei = new A(), Ti = new A();\nfunction cs(e, t, n) {\n  if (U(e, \"3D Tile: boundingVolume must be defined\"), e.box)\n    return ga(e.box, t, n);\n  if (e.region)\n    return Rd(e.region);\n  if (e.sphere)\n    return wd(e.sphere, t, n);\n  throw new Error(\"3D Tile: boundingVolume must contain a sphere, region, or box\");\n}\nfunction _d(e, t) {\n  if (e.box)\n    return Md(t);\n  if (e.region) {\n    const [n, s, r, i, o, a] = e.region;\n    return [[_t(n), _t(s), o], [_t(r), _t(i), a]];\n  }\n  if (e.sphere)\n    return Id(t);\n  throw new Error(\"Unkown boundingVolume type\");\n}\nfunction ga(e, t, n) {\n  const s = new A(e[0], e[1], e[2]);\n  t.transform(s, s);\n  let r = [];\n  if (e.length === 10) {\n    const u = e.slice(3, 6), l = new wn();\n    l.fromArray(e, 6);\n    const h = new A([1, 0, 0]), f = new A([0, 1, 0]), d = new A([0, 0, 1]);\n    h.transformByQuaternion(l), h.scale(u[0]), f.transformByQuaternion(l), f.scale(u[1]), d.transformByQuaternion(l), d.scale(u[2]), r = [...h.toArray(), ...f.toArray(), ...d.toArray()];\n  } else\n    r = [...e.slice(3, 6), ...e.slice(6, 9), ...e.slice(9, 12)];\n  const i = t.transformAsVector(r.slice(0, 3)), o = t.transformAsVector(r.slice(3, 6)), a = t.transformAsVector(r.slice(6, 9)), c = new z([i[0], i[1], i[2], o[0], o[1], o[2], a[0], a[1], a[2]]);\n  return ma(n) ? (n.center = s, n.halfAxes = c, n) : new Ke(s, c);\n}\nfunction wd(e, t, n) {\n  const s = new A(e[0], e[1], e[2]);\n  t.transform(s, s);\n  const r = t.getScale(Bn), i = Math.max(Math.max(r[0], r[1]), r[2]), o = e[3] * i;\n  return ma(n) ? (n.center = s, n.radius = o, n) : new ke(s, o);\n}\nfunction Rd(e) {\n  const [t, n, s, r, i, o] = e, a = J.WGS84.cartographicToCartesian([_t(t), _t(r), i], Td), c = J.WGS84.cartographicToCartesian([_t(s), _t(n), o], bd), u = new A().addVectors(a, c).multiplyByScalar(0.5);\n  return J.WGS84.cartesianToCartographic(u, kt), J.WGS84.cartographicToCartesian([_t(s), kt[1], kt[2]], Ci), J.WGS84.cartographicToCartesian([kt[0], _t(r), kt[2]], Ei), J.WGS84.cartographicToCartesian([kt[0], kt[1], o], Ti), ga([...u, ...Ci.subtract(u), ...Ei.subtract(u), ...Ti.subtract(u)], new V());\n}\nfunction Md(e) {\n  const t = Aa(), {\n    halfAxes: n\n  } = e, s = new A(n.getColumn(0)), r = new A(n.getColumn(1)), i = new A(n.getColumn(2));\n  for (let o = 0; o < 2; o++) {\n    for (let a = 0; a < 2; a++) {\n      for (let c = 0; c < 2; c++)\n        rt.copy(e.center), rt.add(s), rt.add(r), rt.add(i), pa(t, rt), i.negate();\n      r.negate();\n    }\n    s.negate();\n  }\n  return t;\n}\nfunction Id(e) {\n  const t = Aa(), {\n    center: n,\n    radius: s\n  } = e, r = J.WGS84.scaleToGeodeticSurface(n, rt);\n  let i;\n  r ? i = J.WGS84.geodeticSurfaceNormal(r) : i = new A(0, 0, 1);\n  let o = new A(i[2], -i[1], 0);\n  o.len() > 0 ? o.normalize() : o = new A(0, 1, 0);\n  const a = o.clone().cross(i);\n  for (const c of [o, a, i]) {\n    Bn.copy(c).scale(s);\n    for (let u = 0; u < 2; u++)\n      rt.copy(n), rt.add(Bn), pa(t, rt), Bn.negate();\n  }\n  return t;\n}\nfunction Aa() {\n  return [[1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]];\n}\nfunction pa(e, t) {\n  J.WGS84.cartesianToCartographic(t, rt), e[0][0] = Math.min(e[0][0], rt[0]), e[0][1] = Math.min(e[0][1], rt[1]), e[0][2] = Math.min(e[0][2], rt[2]), e[1][0] = Math.max(e[1][0], rt[0]), e[1][1] = Math.max(e[1][1], rt[1]), e[1][2] = Math.max(e[1][2], rt[2]);\n}\nnew A();\nnew A();\nnew V();\nnew A();\nnew A();\nnew A();\nfunction Sd(e, t) {\n  const n = e * t;\n  return 1 - Math.exp(-(n * n));\n}\nfunction xd(e, t) {\n  if (e.dynamicScreenSpaceError && e.dynamicScreenSpaceErrorComputedDensity) {\n    const n = e.dynamicScreenSpaceErrorComputedDensity, s = e.dynamicScreenSpaceErrorFactor;\n    return Sd(t, n) * s;\n  }\n  return 0;\n}\nfunction Od(e, t, n) {\n  const s = e.tileset, r = e.parent && e.parent.lodMetricValue || e.lodMetricValue, i = n ? r : e.lodMetricValue;\n  if (i === 0)\n    return 0;\n  const o = Math.max(e._distanceToCamera, 1e-7), {\n    height: a,\n    sseDenominator: c\n  } = t, {\n    viewDistanceScale: u\n  } = s.options;\n  let l = i * a * (u || 1) / (o * c);\n  return l -= xd(s, o), l;\n}\nconst us = new A(), bi = new A(), Ht = new A(), _i = new A(), Fd = new A(), ls = new V(), wi = new V();\nfunction vd(e, t) {\n  if (e.lodMetricValue === 0 || isNaN(e.lodMetricValue))\n    return \"DIG\";\n  const n = 2 * ya(e, t);\n  return n < 2 ? \"OUT\" : !e.header.children || n <= e.lodMetricValue ? \"DRAW\" : e.header.children ? \"DIG\" : \"OUT\";\n}\nfunction ya(e, t) {\n  const {\n    topDownViewport: n\n  } = t, s = e.header.mbs[1], r = e.header.mbs[0], i = e.header.mbs[2], o = e.header.mbs[3], a = [...e.boundingVolume.center], c = n.unprojectPosition(n.cameraPosition);\n  J.WGS84.cartographicToCartesian(c, us), bi.copy(us).subtract(a).normalize(), J.WGS84.eastNorthUpToFixedFrame(a, ls), wi.copy(ls).invert(), Ht.copy(us).transform(wi);\n  const u = Math.sqrt(Ht[0] * Ht[0] + Ht[1] * Ht[1]), l = u * u / Ht[2];\n  _i.copy([Ht[0], Ht[1], l]);\n  const f = _i.transform(ls).subtract(a).normalize(), m = bi.cross(f).normalize().scale(o).add(a), g = J.WGS84.cartesianToCartographic(m), p = n.project([r, s, i]), C = n.project(g);\n  return Fd.copy(p).subtract(C).magnitude();\n}\nfunction Dd(e) {\n  return {\n    assetGltfUpAxis: e.asset && e.asset.gltfUpAxis || \"Y\"\n  };\n}\nclass Ri {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n    this._map = /* @__PURE__ */ new Map(), this._array = void 0, this._length = void 0, this._array = new Array(t), this._length = t;\n  }\n  get length() {\n    return this._length;\n  }\n  set length(t) {\n    this._length = t, t > this._array.length && (this._array.length = t);\n  }\n  get values() {\n    return this._array;\n  }\n  get(t) {\n    return U(t < this._array.length), this._array[t];\n  }\n  set(t, n) {\n    U(t >= 0), t >= this.length && (this.length = t + 1), this._map.has(this._array[t]) && this._map.delete(this._array[t]), this._array[t] = n, this._map.set(n, t);\n  }\n  delete(t) {\n    const n = this._map.get(t);\n    n >= 0 && (this._array.splice(n, 1), this._map.delete(t), this.length--);\n  }\n  peek() {\n    return this._array[this._length - 1];\n  }\n  push(t) {\n    if (!this._map.has(t)) {\n      const n = this.length++;\n      this._array[n] = t, this._map.set(t, n);\n    }\n  }\n  pop() {\n    const t = this._array[--this.length];\n    return this._map.delete(t), t;\n  }\n  reserve(t) {\n    U(t >= 0), t > this._array.length && (this._array.length = t);\n  }\n  resize(t) {\n    U(t >= 0), this.length = t;\n  }\n  trim(t) {\n    t == null && (t = this.length), this._array.length = t;\n  }\n  reset() {\n    this._array = [], this._map = /* @__PURE__ */ new Map(), this._length = 0;\n  }\n  find(t) {\n    return this._map.has(t);\n  }\n}\nconst Ld = {\n  loadSiblings: !1,\n  skipLevelOfDetail: !1,\n  updateTransforms: !0,\n  onTraversalEnd: () => {\n  },\n  viewportTraversersMap: {},\n  basePath: \"\"\n};\nclass Jn {\n  traversalFinished(t) {\n    return !0;\n  }\n  constructor(t) {\n    this.options = void 0, this.root = null, this.selectedTiles = {}, this.requestedTiles = {}, this.emptyTiles = {}, this.lastUpdate = (/* @__PURE__ */ new Date()).getTime(), this.updateDebounceTime = 1e3, this._traversalStack = new Ri(), this._emptyTraversalStack = new Ri(), this._frameNumber = null, this.options = {\n      ...Ld,\n      ...t\n    };\n  }\n  traverse(t, n, s) {\n    this.root = t, this.options = {\n      ...this.options,\n      ...s\n    }, this.reset(), this.updateTile(t, n), this._frameNumber = n.frameNumber, this.executeTraversal(t, n);\n  }\n  reset() {\n    this.requestedTiles = {}, this.selectedTiles = {}, this.emptyTiles = {}, this._traversalStack.reset(), this._emptyTraversalStack.reset();\n  }\n  executeTraversal(t, n) {\n    const s = this._traversalStack;\n    for (t._selectionDepth = 1, s.push(t); s.length > 0; ) {\n      const i = s.pop();\n      let o = !1;\n      this.canTraverse(i, n) && (this.updateChildTiles(i, n), o = this.updateAndPushChildren(i, n, s, i.hasRenderContent ? i._selectionDepth + 1 : i._selectionDepth));\n      const a = i.parent, c = !!(!a || a._shouldRefine), u = !o;\n      i.hasRenderContent ? i.refine === Gt.ADD ? (this.loadTile(i, n), this.selectTile(i, n)) : i.refine === Gt.REPLACE && (this.loadTile(i, n), u && this.selectTile(i, n)) : (this.emptyTiles[i.id] = i, this.loadTile(i, n), u && this.selectTile(i, n)), this.touchTile(i, n), i._shouldRefine = o && c;\n    }\n    const r = (/* @__PURE__ */ new Date()).getTime();\n    (this.traversalFinished(n) || r - this.lastUpdate > this.updateDebounceTime) && (this.lastUpdate = r, this.options.onTraversalEnd(n));\n  }\n  updateChildTiles(t, n) {\n    const s = t.children;\n    for (const r of s)\n      this.updateTile(r, n);\n  }\n  updateAndPushChildren(t, n, s, r) {\n    const {\n      loadSiblings: i,\n      skipLevelOfDetail: o\n    } = this.options, a = t.children;\n    a.sort(this.compareDistanceToCamera.bind(this));\n    const c = t.refine === Gt.REPLACE && t.hasRenderContent && !o;\n    let u = !1, l = !0;\n    for (const h of a)\n      if (h._selectionDepth = r, h.isVisibleAndInRequestVolume ? (s.find(h) && s.delete(h), s.push(h), u = !0) : (c || i) && (this.loadTile(h, n), this.touchTile(h, n)), c) {\n        let f;\n        if (h._inRequestVolume ? h.hasRenderContent ? f = h.contentAvailable : f = this.executeEmptyTraversal(h, n) : f = !1, l = l && f, !l)\n          return !1;\n      }\n    return u || (l = !1), l;\n  }\n  updateTile(t, n) {\n    this.updateTileVisibility(t, n);\n  }\n  selectTile(t, n) {\n    this.shouldSelectTile(t) && (t._selectedFrame = n.frameNumber, this.selectedTiles[t.id] = t);\n  }\n  loadTile(t, n) {\n    this.shouldLoadTile(t) && (t._requestedFrame = n.frameNumber, t._priority = t._getPriority(), this.requestedTiles[t.id] = t);\n  }\n  touchTile(t, n) {\n    t.tileset._cache.touch(t), t._touchedFrame = n.frameNumber;\n  }\n  canTraverse(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;\n    return t.hasChildren ? t.hasTilesetContent ? !t.contentExpired : !r && !t.isVisibleAndInRequestVolume ? !1 : this.shouldRefine(t, n, s) : !1;\n  }\n  shouldLoadTile(t) {\n    return t.hasUnloadedContent || t.contentExpired;\n  }\n  shouldSelectTile(t) {\n    return t.contentAvailable && !this.options.skipLevelOfDetail;\n  }\n  shouldRefine(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, r = t._screenSpaceError;\n    return s && (r = t.getScreenSpaceError(n, !0)), r > t.tileset.memoryAdjustedScreenSpaceError;\n  }\n  updateTileVisibility(t, n) {\n    const s = [];\n    if (this.options.viewportTraversersMap)\n      for (const r in this.options.viewportTraversersMap)\n        this.options.viewportTraversersMap[r] === n.viewport.id && s.push(r);\n    else\n      s.push(n.viewport.id);\n    t.updateVisibility(n, s);\n  }\n  compareDistanceToCamera(t, n) {\n    return t._distanceToCamera - n._distanceToCamera;\n  }\n  anyChildrenVisible(t, n) {\n    let s = !1;\n    for (const r of t.children)\n      r.updateVisibility(n), s = s || r.isVisibleAndInRequestVolume;\n    return s;\n  }\n  executeEmptyTraversal(t, n) {\n    let s = !0;\n    const r = this._emptyTraversalStack;\n    for (r.push(t); r.length > 0; ) {\n      const i = r.pop(), o = !i.hasRenderContent && this.canTraverse(i, n, !1, !1), a = !i.hasRenderContent && i.children.length === 0;\n      if (!o && !i.contentAvailable && !a && (s = !1), this.updateTile(i, n), i.isVisibleAndInRequestVolume || (this.loadTile(i, n), this.touchTile(i, n)), o) {\n        const c = i.children;\n        for (const u of c)\n          r.push(u);\n      }\n    }\n    return s;\n  }\n}\nconst Mi = new A();\nfunction Gd(e) {\n  return e != null;\n}\nclass Vs {\n  constructor(t, n, s) {\n    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"\";\n    this.tileset = void 0, this.header = void 0, this.id = void 0, this.url = void 0, this.parent = void 0, this.refine = void 0, this.type = void 0, this.contentUrl = void 0, this.lodMetricType = \"geometricError\", this.lodMetricValue = 0, this.boundingVolume = null, this.content = null, this.contentState = ut.UNLOADED, this.gpuMemoryUsageInBytes = 0, this.children = [], this.depth = 0, this.viewportIds = [], this.transform = new V(), this.extensions = null, this.implicitTiling = null, this.userData = {}, this.computedTransform = void 0, this.hasEmptyContent = !1, this.hasTilesetContent = !1, this.traverser = new Jn({}), this._cacheNode = null, this._frameNumber = null, this._expireDate = null, this._expiredContent = null, this._boundingBox = void 0, this._distanceToCamera = 0, this._screenSpaceError = 0, this._visibilityPlaneMask = void 0, this._visible = void 0, this._contentBoundingVolume = void 0, this._viewerRequestVolume = void 0, this._initialTransform = new V(), this._priority = 0, this._selectedFrame = 0, this._requestedFrame = 0, this._selectionDepth = 0, this._touchedFrame = 0, this._centerZDepth = 0, this._shouldRefine = !1, this._stackLength = 0, this._visitedFrame = 0, this._inRequestVolume = !1, this._lodJudge = null, this.header = n, this.tileset = t, this.id = r || n.id, this.url = n.url, this.parent = s, this.refine = this._getRefine(n.refine), this.type = n.type, this.contentUrl = n.contentUrl, this._initializeLodMetric(n), this._initializeTransforms(n), this._initializeBoundingVolumes(n), this._initializeContent(n), this._initializeRenderingState(n), Object.seal(this);\n  }\n  destroy() {\n    this.header = null;\n  }\n  isDestroyed() {\n    return this.header === null;\n  }\n  get selected() {\n    return this._selectedFrame === this.tileset._frameNumber;\n  }\n  get isVisible() {\n    return this._visible;\n  }\n  get isVisibleAndInRequestVolume() {\n    return this._visible && this._inRequestVolume;\n  }\n  get hasRenderContent() {\n    return !this.hasEmptyContent && !this.hasTilesetContent;\n  }\n  get hasChildren() {\n    return this.children.length > 0 || this.header.children && this.header.children.length > 0;\n  }\n  get contentReady() {\n    return this.contentState === ut.READY || this.hasEmptyContent;\n  }\n  get contentAvailable() {\n    return !!(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);\n  }\n  get hasUnloadedContent() {\n    return this.hasRenderContent && this.contentUnloaded;\n  }\n  get contentUnloaded() {\n    return this.contentState === ut.UNLOADED;\n  }\n  get contentExpired() {\n    return this.contentState === ut.EXPIRED;\n  }\n  get contentFailed() {\n    return this.contentState === ut.FAILED;\n  }\n  get distanceToCamera() {\n    return this._distanceToCamera;\n  }\n  get screenSpaceError() {\n    return this._screenSpaceError;\n  }\n  get boundingBox() {\n    return this._boundingBox || (this._boundingBox = _d(this.header.boundingVolume, this.boundingVolume)), this._boundingBox;\n  }\n  getScreenSpaceError(t, n) {\n    switch (this.tileset.type) {\n      case At.I3S:\n        return ya(this, t);\n      case At.TILES3D:\n        return Od(this, t, n);\n      default:\n        throw new Error(\"Unsupported tileset type\");\n    }\n  }\n  unselect() {\n    this._selectedFrame = 0;\n  }\n  _getGpuMemoryUsageInBytes() {\n    return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;\n  }\n  _getPriority() {\n    const t = this.tileset._traverser, {\n      skipLevelOfDetail: n\n    } = t.options, s = this.refine === Gt.ADD || n;\n    if (s && !this.isVisible && this._visible !== void 0 || this.tileset._frameNumber - this._touchedFrame >= 1 || this.contentState === ut.UNLOADED)\n      return -1;\n    const r = this.parent, o = r && (!s || this._screenSpaceError === 0 || r.hasTilesetContent) ? r._screenSpaceError : this._screenSpaceError, a = t.root ? t.root._screenSpaceError : 0;\n    return Math.max(a - o, 0);\n  }\n  async loadContent() {\n    if (this.hasEmptyContent)\n      return !1;\n    if (this.content)\n      return !0;\n    this.contentExpired && (this._expireDate = null), this.contentState = ut.LOADING;\n    const n = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));\n    if (!n)\n      return this.contentState = ut.UNLOADED, !1;\n    try {\n      const s = this.tileset.getTileUrl(this.contentUrl), r = this.tileset.loader, i = {\n        ...this.tileset.loadOptions,\n        [r.id]: {\n          ...this.tileset.loadOptions[r.id],\n          isTileset: this.type === \"json\",\n          ...this._getLoaderSpecificOptions(r.id)\n        }\n      };\n      return this.content = await fe(s, r, i), this.tileset.options.contentLoader && await this.tileset.options.contentLoader(this), this._isTileset() && this.tileset._initializeTileHeaders(this.content, this), this.contentState = ut.READY, this._onContentLoaded(), !0;\n    } catch (s) {\n      throw this.contentState = ut.FAILED, s;\n    } finally {\n      n.done();\n    }\n  }\n  unloadContent() {\n    return this.content && this.content.destroy && this.content.destroy(), this.content = null, this.header.content && this.header.content.destroy && this.header.content.destroy(), this.header.content = null, this.contentState = ut.UNLOADED, !0;\n  }\n  updateVisibility(t, n) {\n    if (this._frameNumber === t.frameNumber)\n      return;\n    const s = this.parent, r = s ? s._visibilityPlaneMask : ht.MASK_INDETERMINATE;\n    if (this.tileset._traverser.options.updateTransforms) {\n      const i = s ? s.computedTransform : this.tileset.modelMatrix;\n      this._updateTransform(i);\n    }\n    this._distanceToCamera = this.distanceToTile(t), this._screenSpaceError = this.getScreenSpaceError(t, !1), this._visibilityPlaneMask = this.visibility(t, r), this._visible = this._visibilityPlaneMask !== ht.MASK_OUTSIDE, this._inRequestVolume = this.insideViewerRequestVolume(t), this._frameNumber = t.frameNumber, this.viewportIds = n;\n  }\n  visibility(t, n) {\n    const {\n      cullingVolume: s\n    } = t, {\n      boundingVolume: r\n    } = this;\n    return s.computeVisibilityWithPlaneMask(r, n);\n  }\n  contentVisibility() {\n    return !0;\n  }\n  distanceToTile(t) {\n    const n = this.boundingVolume;\n    return Math.sqrt(Math.max(n.distanceSquaredTo(t.camera.position), 0));\n  }\n  cameraSpaceZDepth(t) {\n    let {\n      camera: n\n    } = t;\n    const s = this.boundingVolume;\n    return Mi.subVectors(s.center, n.position), n.direction.dot(Mi);\n  }\n  insideViewerRequestVolume(t) {\n    const n = this._viewerRequestVolume;\n    return !n || n.distanceSquaredTo(t.camera.position) <= 0;\n  }\n  updateExpiration() {\n    if (Gd(this._expireDate) && this.contentReady && !this.hasEmptyContent) {\n      const t = Date.now();\n      Date.lessThan(this._expireDate, t) && (this.contentState = ut.EXPIRED, this._expiredContent = this.content);\n    }\n  }\n  get extras() {\n    return this.header.extras;\n  }\n  _initializeLodMetric(t) {\n    \"lodMetricType\" in t ? this.lodMetricType = t.lodMetricType : (this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType, console.warn(\"3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType\")), \"lodMetricValue\" in t ? this.lodMetricValue = t.lodMetricValue : (this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue, console.warn(\"3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue\"));\n  }\n  _initializeTransforms(t) {\n    this.transform = t.transform ? new V(t.transform) : new V();\n    const n = this.parent, s = this.tileset, r = n && n.computedTransform ? n.computedTransform.clone() : s.modelMatrix.clone();\n    this.computedTransform = new V(r).multiplyRight(this.transform);\n    const i = n && n._initialTransform ? n._initialTransform.clone() : new V();\n    this._initialTransform = new V(i).multiplyRight(this.transform);\n  }\n  _initializeBoundingVolumes(t) {\n    this._contentBoundingVolume = null, this._viewerRequestVolume = null, this._updateBoundingVolume(t);\n  }\n  _initializeContent(t) {\n    this.content = {\n      _tileset: this.tileset,\n      _tile: this\n    }, this.hasEmptyContent = !0, this.contentState = ut.UNLOADED, this.hasTilesetContent = !1, t.contentUrl && (this.content = null, this.hasEmptyContent = !1);\n  }\n  _initializeRenderingState(t) {\n    this.depth = t.level || (this.parent ? this.parent.depth + 1 : 0), this._shouldRefine = !1, this._distanceToCamera = 0, this._centerZDepth = 0, this._screenSpaceError = 0, this._visibilityPlaneMask = ht.MASK_INDETERMINATE, this._visible = void 0, this._inRequestVolume = !1, this._stackLength = 0, this._selectionDepth = 0, this._frameNumber = 0, this._touchedFrame = 0, this._visitedFrame = 0, this._selectedFrame = 0, this._requestedFrame = 0, this._priority = 0;\n  }\n  _getRefine(t) {\n    return t || this.parent && this.parent.refine || Gt.REPLACE;\n  }\n  _isTileset() {\n    return this.contentUrl.indexOf(\".json\") !== -1;\n  }\n  _onContentLoaded() {\n    switch (this.content && this.content.type) {\n      case \"vctr\":\n      case \"geom\":\n        this.tileset._traverser.disableSkipLevelOfDetail = !0;\n        break;\n    }\n    this._isTileset() ? this.hasTilesetContent = !0 : this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();\n  }\n  _updateBoundingVolume(t) {\n    this.boundingVolume = cs(t.boundingVolume, this.computedTransform, this.boundingVolume);\n    const n = t.content;\n    n && (n.boundingVolume && (this._contentBoundingVolume = cs(n.boundingVolume, this.computedTransform, this._contentBoundingVolume)), t.viewerRequestVolume && (this._viewerRequestVolume = cs(t.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume)));\n  }\n  _updateTransform() {\n    const n = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new V()).clone().multiplyRight(this.transform);\n    n.equals(this.computedTransform) || (this.computedTransform = n, this._updateBoundingVolume(this.header));\n  }\n  _getLoaderSpecificOptions(t) {\n    switch (t) {\n      case \"i3s\":\n        return {\n          ...this.tileset.options.i3s,\n          _tileOptions: {\n            attributeUrls: this.header.attributeUrls,\n            textureUrl: this.header.textureUrl,\n            textureFormat: this.header.textureFormat,\n            textureLoaderOptions: this.header.textureLoaderOptions,\n            materialDefinition: this.header.materialDefinition,\n            isDracoGeometry: this.header.isDracoGeometry,\n            mbs: this.header.mbs\n          },\n          _tilesetOptions: {\n            store: this.tileset.tileset.store,\n            attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,\n            fields: this.tileset.tileset.fields\n          },\n          isTileHeader: !1\n        };\n      case \"3d-tiles\":\n      case \"cesium-ion\":\n      default:\n        return Dd(this.tileset.tileset);\n    }\n  }\n}\nclass Pd extends Jn {\n  compareDistanceToCamera(t, n) {\n    return n._distanceToCamera === 0 && t._distanceToCamera === 0 ? n._centerZDepth - t._centerZDepth : n._distanceToCamera - t._distanceToCamera;\n  }\n  updateTileVisibility(t, n) {\n    if (super.updateTileVisibility(t, n), !t.isVisibleAndInRequestVolume)\n      return;\n    const s = t.children.length > 0;\n    if (t.hasTilesetContent && s) {\n      const o = t.children[0];\n      this.updateTileVisibility(o, n), t._visible = o._visible;\n      return;\n    }\n    if (this.meetsScreenSpaceErrorEarly(t, n)) {\n      t._visible = !1;\n      return;\n    }\n    const r = t.refine === Gt.REPLACE, i = t._optimChildrenWithinParent === Ed.USE_OPTIMIZATION;\n    if (r && i && s && !this.anyChildrenVisible(t, n)) {\n      t._visible = !1;\n      return;\n    }\n  }\n  meetsScreenSpaceErrorEarly(t, n) {\n    const {\n      parent: s\n    } = t;\n    return !s || s.hasTilesetContent || s.refine !== Gt.ADD ? !1 : !this.shouldRefine(t, n, !0);\n  }\n}\nclass Nd {\n  constructor() {\n    this.frameNumberMap = /* @__PURE__ */ new Map();\n  }\n  register(t, n) {\n    const s = this.frameNumberMap.get(t) || /* @__PURE__ */ new Map(), r = s.get(n) || 0;\n    s.set(n, r + 1), this.frameNumberMap.set(t, s);\n  }\n  deregister(t, n) {\n    const s = this.frameNumberMap.get(t);\n    if (!s)\n      return;\n    const r = s.get(n) || 1;\n    s.set(n, r - 1);\n  }\n  isZero(t, n) {\n    var s;\n    return (((s = this.frameNumberMap.get(t)) === null || s === void 0 ? void 0 : s.get(n)) || 0) === 0;\n  }\n}\nconst hs = {\n  REQUESTED: \"REQUESTED\",\n  COMPLETED: \"COMPLETED\",\n  ERROR: \"ERROR\"\n};\nclass Ud {\n  constructor() {\n    this._statusMap = void 0, this.pendingTilesRegister = new Nd(), this._statusMap = {};\n  }\n  add(t, n, s, r) {\n    if (!this._statusMap[n]) {\n      const {\n        frameNumber: i,\n        viewport: {\n          id: o\n        }\n      } = r;\n      this._statusMap[n] = {\n        request: t,\n        callback: s,\n        key: n,\n        frameState: r,\n        status: hs.REQUESTED\n      }, this.pendingTilesRegister.register(o, i), t().then((a) => {\n        this._statusMap[n].status = hs.COMPLETED;\n        const {\n          frameNumber: c,\n          viewport: {\n            id: u\n          }\n        } = this._statusMap[n].frameState;\n        this.pendingTilesRegister.deregister(u, c), this._statusMap[n].callback(a, r);\n      }).catch((a) => {\n        this._statusMap[n].status = hs.ERROR;\n        const {\n          frameNumber: c,\n          viewport: {\n            id: u\n          }\n        } = this._statusMap[n].frameState;\n        this.pendingTilesRegister.deregister(u, c), s(a);\n      });\n    }\n  }\n  update(t, n) {\n    if (this._statusMap[t]) {\n      const {\n        frameNumber: s,\n        viewport: {\n          id: r\n        }\n      } = this._statusMap[t].frameState;\n      this.pendingTilesRegister.deregister(r, s);\n      const {\n        frameNumber: i,\n        viewport: {\n          id: o\n        }\n      } = n;\n      this.pendingTilesRegister.register(o, i), this._statusMap[t].frameState = n;\n    }\n  }\n  find(t) {\n    return this._statusMap[t];\n  }\n  hasPendingTiles(t, n) {\n    return !this.pendingTilesRegister.isZero(t, n);\n  }\n}\nclass Hd extends Jn {\n  constructor(t) {\n    super(t), this._tileManager = void 0, this._tileManager = new Ud();\n  }\n  traversalFinished(t) {\n    return !this._tileManager.hasPendingTiles(t.viewport.id, this._frameNumber || 0);\n  }\n  shouldRefine(t, n) {\n    return t._lodJudge = vd(t, n), t._lodJudge === \"DIG\";\n  }\n  updateChildTiles(t, n) {\n    const s = t.header.children || [], r = t.children, i = t.tileset;\n    for (const o of s) {\n      const a = `${o.id}-${n.viewport.id}`, c = r && r.find((u) => u.id === a);\n      if (c)\n        c && this.updateTile(c, n);\n      else {\n        let u = () => this._loadTile(o.id, i);\n        this._tileManager.find(a) ? this._tileManager.update(a, n) : (i.tileset.nodePages && (u = () => i.tileset.nodePagesTile.formTileFromNodePages(o.id)), this._tileManager.add(u, a, (h) => this._onTileLoad(h, t, a), n));\n      }\n    }\n    return !1;\n  }\n  async _loadTile(t, n) {\n    const {\n      loader: s\n    } = n, r = n.getTileUrl(`${n.url}/nodes/${t}`), i = {\n      ...n.loadOptions,\n      i3s: {\n        ...n.loadOptions.i3s,\n        isTileHeader: !0\n      }\n    };\n    return await fe(r, s, i);\n  }\n  _onTileLoad(t, n, s) {\n    const r = new Vs(n.tileset, t, n, s);\n    n.children.push(r);\n    const i = this._tileManager.find(r.id).frameState;\n    this.updateTile(r, i), this._frameNumber === i.frameNumber && (this.traversalFinished(i) || (/* @__PURE__ */ new Date()).getTime() - this.lastUpdate > this.updateDebounceTime) && this.executeTraversal(r, i);\n  }\n}\nconst Jd = {\n  description: \"\",\n  ellipsoid: J.WGS84,\n  modelMatrix: new V(),\n  throttleRequests: !0,\n  maxRequests: 64,\n  maximumMemoryUsage: 32,\n  memoryCacheOverflow: 1,\n  maximumTilesSelected: 0,\n  debounceTime: 0,\n  onTileLoad: () => {\n  },\n  onTileUnload: () => {\n  },\n  onTileError: () => {\n  },\n  onTraversalComplete: (e) => e,\n  contentLoader: void 0,\n  viewDistanceScale: 1,\n  maximumScreenSpaceError: 8,\n  memoryAdjustedScreenSpaceError: !1,\n  loadTiles: !0,\n  updateTransforms: !0,\n  viewportTraversersMap: null,\n  loadOptions: {\n    fetch: {}\n  },\n  attributions: [],\n  basePath: \"\",\n  i3s: {}\n}, cn = \"Tiles In Tileset(s)\", fs = \"Tiles In Memory\", Ii = \"Tiles In View\", Si = \"Tiles To Render\", xi = \"Tiles Loaded\", ds = \"Tiles Loading\", Oi = \"Tiles Unloaded\", Fi = \"Failed Tile Loads\", vi = \"Points/Vertices\", ms = \"Tile Memory Use\", Di = \"Maximum Screen Space Error\";\nclass Vd {\n  constructor(t, n) {\n    this.options = void 0, this.loadOptions = void 0, this.type = void 0, this.tileset = void 0, this.loader = void 0, this.url = void 0, this.basePath = void 0, this.modelMatrix = void 0, this.ellipsoid = void 0, this.lodMetricType = void 0, this.lodMetricValue = void 0, this.refine = void 0, this.root = null, this.roots = {}, this.asset = {}, this.description = \"\", this.properties = void 0, this.extras = null, this.attributions = {}, this.credits = {}, this.stats = void 0, this.contentFormats = {\n      draco: !1,\n      meshopt: !1,\n      dds: !1,\n      ktx2: !1\n    }, this.cartographicCenter = null, this.cartesianCenter = null, this.zoom = 1, this.boundingVolume = null, this.dynamicScreenSpaceErrorComputedDensity = 0, this.maximumMemoryUsage = 32, this.gpuMemoryUsageInBytes = 0, this.memoryAdjustedScreenSpaceError = 0, this._cacheBytes = 0, this._cacheOverflowBytes = 0, this._frameNumber = 0, this._queryParams = {}, this._extensionsUsed = [], this._tiles = {}, this._pendingCount = 0, this.selectedTiles = [], this.traverseCounter = 0, this.geometricError = 0, this.lastUpdatedVieports = null, this._requestedTiles = [], this._emptyTiles = [], this.frameStateData = {}, this._traverser = void 0, this._cache = new Jf(), this._requestScheduler = void 0, this.updatePromise = null, this.tilesetInitializationPromise = void 0, this.options = {\n      ...Jd,\n      ...n\n    }, this.tileset = t, this.loader = t.loader, this.type = t.type, this.url = t.url, this.basePath = t.basePath || rr(this.url), this.modelMatrix = this.options.modelMatrix, this.ellipsoid = this.options.ellipsoid, this.lodMetricType = t.lodMetricType, this.lodMetricValue = t.lodMetricValue, this.refine = t.root.refine, this.loadOptions = this.options.loadOptions || {}, this._traverser = this._initializeTraverser(), this._requestScheduler = new Eu({\n      throttleRequests: this.options.throttleRequests,\n      maxRequests: this.options.maxRequests\n    }), this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError, this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024, this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024, this.stats = new Lo({\n      id: this.url\n    }), this._initializeStats(), this.tilesetInitializationPromise = this._initializeTileSet(t);\n  }\n  destroy() {\n    this._destroy();\n  }\n  isLoaded() {\n    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;\n  }\n  get tiles() {\n    return Object.values(this._tiles);\n  }\n  get frameNumber() {\n    return this._frameNumber;\n  }\n  get queryParams() {\n    return new URLSearchParams(this._queryParams).toString();\n  }\n  setProps(t) {\n    this.options = {\n      ...this.options,\n      ...t\n    };\n  }\n  getTileUrl(t) {\n    if (t.startsWith(\"data:\"))\n      return t;\n    let s = t;\n    return this.queryParams.length && (s = `${t}${t.includes(\"?\") ? \"&\" : \"?\"}${this.queryParams}`), s;\n  }\n  hasExtension(t) {\n    return this._extensionsUsed.indexOf(t) > -1;\n  }\n  update() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n    this.tilesetInitializationPromise.then(() => {\n      !t && this.lastUpdatedVieports ? t = this.lastUpdatedVieports : this.lastUpdatedVieports = t, t && this.doUpdate(t);\n    });\n  }\n  async selectTiles() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n    return await this.tilesetInitializationPromise, t && (this.lastUpdatedVieports = t), this.updatePromise || (this.updatePromise = new Promise((n) => {\n      setTimeout(() => {\n        this.lastUpdatedVieports && this.doUpdate(this.lastUpdatedVieports), n(this._frameNumber), this.updatePromise = null;\n      }, this.options.debounceTime);\n    })), this.updatePromise;\n  }\n  adjustScreenSpaceError() {\n    this.gpuMemoryUsageInBytes < this._cacheBytes ? this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError) : this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes && (this.memoryAdjustedScreenSpaceError *= 1.02);\n  }\n  doUpdate(t) {\n    if (\"loadTiles\" in this.options && !this.options.loadTiles || this.traverseCounter > 0)\n      return;\n    const n = t instanceof Array ? t : [t];\n    this._cache.reset(), this._frameNumber++, this.traverseCounter = n.length;\n    const s = [];\n    for (const r of n) {\n      const i = r.id;\n      this._needTraverse(i) ? s.push(i) : this.traverseCounter--;\n    }\n    for (const r of n) {\n      const i = r.id;\n      if (this.roots[i] || (this.roots[i] = this._initializeTileHeaders(this.tileset, null)), !s.includes(i))\n        continue;\n      const o = dd(r, this._frameNumber);\n      this._traverser.traverse(this.roots[i], o, this.options);\n    }\n  }\n  _needTraverse(t) {\n    let n = t;\n    return this.options.viewportTraversersMap && (n = this.options.viewportTraversersMap[t]), n === t;\n  }\n  _onTraversalEnd(t) {\n    const n = t.viewport.id;\n    this.frameStateData[n] || (this.frameStateData[n] = {\n      selectedTiles: [],\n      _requestedTiles: [],\n      _emptyTiles: []\n    });\n    const s = this.frameStateData[n], r = Object.values(this._traverser.selectedTiles), [i, o] = md(r, t, this.options.maximumTilesSelected);\n    s.selectedTiles = i;\n    for (const a of o)\n      a.unselect();\n    s._requestedTiles = Object.values(this._traverser.requestedTiles), s._emptyTiles = Object.values(this._traverser.emptyTiles), this.traverseCounter--, !(this.traverseCounter > 0) && this._updateTiles();\n  }\n  _updateTiles() {\n    this.selectedTiles = [], this._requestedTiles = [], this._emptyTiles = [];\n    for (const t in this.frameStateData) {\n      const n = this.frameStateData[t];\n      this.selectedTiles = this.selectedTiles.concat(n.selectedTiles), this._requestedTiles = this._requestedTiles.concat(n._requestedTiles), this._emptyTiles = this._emptyTiles.concat(n._emptyTiles);\n    }\n    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);\n    for (const t of this.selectedTiles)\n      this._tiles[t.id] = t;\n    this._loadTiles(), this._unloadTiles(), this._updateStats();\n  }\n  _tilesChanged(t, n) {\n    if (t.length !== n.length)\n      return !0;\n    const s = new Set(t.map((o) => o.id)), r = new Set(n.map((o) => o.id));\n    let i = t.filter((o) => !r.has(o.id)).length > 0;\n    return i = i || n.filter((o) => !s.has(o.id)).length > 0, i;\n  }\n  _loadTiles() {\n    for (const t of this._requestedTiles)\n      t.contentUnloaded && this._loadTile(t);\n  }\n  _unloadTiles() {\n    this._cache.unloadTiles(this, (t, n) => t._unloadTile(n));\n  }\n  _updateStats() {\n    let t = 0, n = 0;\n    for (const s of this.selectedTiles)\n      s.contentAvailable && s.content && (t++, s.content.pointCount ? n += s.content.pointCount : n += s.content.vertexCount);\n    this.stats.get(Ii).count = this.selectedTiles.length, this.stats.get(Si).count = t, this.stats.get(vi).count = n, this.stats.get(Di).count = this.memoryAdjustedScreenSpaceError;\n  }\n  async _initializeTileSet(t) {\n    this.type === At.I3S && (this.calculateViewPropsI3S(), t.root = await t.root), this.root = this._initializeTileHeaders(t, null), this.type === At.TILES3D && (this._initializeTiles3DTileset(t), this.calculateViewPropsTiles3D()), this.type === At.I3S && this._initializeI3STileset();\n  }\n  calculateViewPropsI3S() {\n    var t;\n    const n = this.tileset.fullExtent;\n    if (n) {\n      const {\n        xmin: r,\n        xmax: i,\n        ymin: o,\n        ymax: a,\n        zmin: c,\n        zmax: u\n      } = n;\n      this.cartographicCenter = new A(r + (i - r) / 2, o + (a - o) / 2, c + (u - c) / 2), this.cartesianCenter = new A(), J.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = da(n, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n    const s = (t = this.tileset.store) === null || t === void 0 ? void 0 : t.extent;\n    if (s) {\n      const [r, i, o, a] = s;\n      this.cartographicCenter = new A(r + (o - r) / 2, i + (a - i) / 2, 0), this.cartesianCenter = new A(), J.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = Bd(s, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n    console.warn(\"Extent is not defined in the tileset header\"), this.cartographicCenter = new A(), this.zoom = 1;\n  }\n  calculateViewPropsTiles3D() {\n    const t = this.root, {\n      center: n\n    } = t.boundingVolume;\n    if (!n) {\n      console.warn(\"center was not pre-calculated for the root tile\"), this.cartographicCenter = new A(), this.zoom = 1;\n      return;\n    }\n    n[0] !== 0 || n[1] !== 0 || n[2] !== 0 ? (this.cartographicCenter = new A(), J.WGS84.cartesianToCartographic(n, this.cartographicCenter)) : this.cartographicCenter = new A(0, 0, -J.WGS84.radii[0]), this.cartesianCenter = n, this.zoom = yd(t.boundingVolume, this.cartographicCenter);\n  }\n  _initializeStats() {\n    this.stats.get(cn), this.stats.get(ds), this.stats.get(fs), this.stats.get(Ii), this.stats.get(Si), this.stats.get(xi), this.stats.get(Oi), this.stats.get(Fi), this.stats.get(vi), this.stats.get(ms, \"memory\"), this.stats.get(Di);\n  }\n  _initializeTileHeaders(t, n) {\n    const s = new Vs(this, t.root, n);\n    if (n && (n.children.push(s), s.depth = n.depth + 1), this.type === At.TILES3D) {\n      const i = [];\n      for (i.push(s); i.length > 0; ) {\n        const o = i.pop();\n        this.stats.get(cn).incrementCount();\n        const a = o.header.children || [];\n        for (const c of a) {\n          var r;\n          const u = new Vs(this, c, o);\n          if ((r = u.contentUrl) !== null && r !== void 0 && r.includes(\"?session=\")) {\n            const h = new URL(u.contentUrl).searchParams.get(\"session\");\n            h && (this._queryParams.session = h);\n          }\n          o.children.push(u), u.depth = o.depth + 1, i.push(u);\n        }\n      }\n    }\n    return s;\n  }\n  _initializeTraverser() {\n    let t;\n    switch (this.type) {\n      case At.TILES3D:\n        t = Pd;\n        break;\n      case At.I3S:\n        t = Hd;\n        break;\n      default:\n        t = Jn;\n    }\n    return new t({\n      basePath: this.basePath,\n      onTraversalEnd: this._onTraversalEnd.bind(this)\n    });\n  }\n  _destroyTileHeaders(t) {\n    this._destroySubtree(t);\n  }\n  async _loadTile(t) {\n    let n;\n    try {\n      this._onStartTileLoading(), n = await t.loadContent();\n    } catch (s) {\n      this._onTileLoadError(t, s instanceof Error ? s : new Error(\"load failed\"));\n    } finally {\n      this._onEndTileLoading(), this._onTileLoad(t, n);\n    }\n  }\n  _onTileLoadError(t, n) {\n    this.stats.get(Fi).incrementCount();\n    const s = n.message || n.toString(), r = t.url;\n    console.error(`A 3D tile failed to load: ${t.url} ${s}`), this.options.onTileError(t, s, r);\n  }\n  _onTileLoad(t, n) {\n    if (n) {\n      if (this.type === At.I3S) {\n        var s, r;\n        const i = ((s = this.tileset) === null || s === void 0 || (r = s.nodePagesTile) === null || r === void 0 ? void 0 : r.nodesInNodePages) || 0;\n        this.stats.get(cn).reset(), this.stats.get(cn).addCount(i);\n      }\n      t && t.content && Vf(t, t.content), this.updateContentTypes(t), this._addTileToCache(t), this.options.onTileLoad(t);\n    }\n  }\n  updateContentTypes(t) {\n    if (this.type === At.I3S)\n      switch (t.header.isDracoGeometry && (this.contentFormats.draco = !0), t.header.textureFormat) {\n        case \"dds\":\n          this.contentFormats.dds = !0;\n          break;\n        case \"ktx2\":\n          this.contentFormats.ktx2 = !0;\n          break;\n      }\n    else if (this.type === At.TILES3D) {\n      var n;\n      const {\n        extensionsRemoved: s = []\n      } = ((n = t.content) === null || n === void 0 ? void 0 : n.gltf) || {};\n      s.includes(\"KHR_draco_mesh_compression\") && (this.contentFormats.draco = !0), s.includes(\"EXT_meshopt_compression\") && (this.contentFormats.meshopt = !0), s.includes(\"KHR_texture_basisu\") && (this.contentFormats.ktx2 = !0);\n    }\n  }\n  _onStartTileLoading() {\n    this._pendingCount++, this.stats.get(ds).incrementCount();\n  }\n  _onEndTileLoading() {\n    this._pendingCount--, this.stats.get(ds).decrementCount();\n  }\n  _addTileToCache(t) {\n    this._cache.add(this, t, (n) => n._updateCacheStats(t));\n  }\n  _updateCacheStats(t) {\n    this.stats.get(xi).incrementCount(), this.stats.get(fs).incrementCount(), this.gpuMemoryUsageInBytes += t.gpuMemoryUsageInBytes || 0, this.stats.get(ms).count = this.gpuMemoryUsageInBytes, this.options.memoryAdjustedScreenSpaceError && this.adjustScreenSpaceError();\n  }\n  _unloadTile(t) {\n    this.gpuMemoryUsageInBytes -= t.gpuMemoryUsageInBytes || 0, this.stats.get(fs).decrementCount(), this.stats.get(Oi).incrementCount(), this.stats.get(ms).count = this.gpuMemoryUsageInBytes, this.options.onTileUnload(t), t.unloadContent();\n  }\n  _destroy() {\n    const t = [];\n    for (this.root && t.push(this.root); t.length > 0; ) {\n      const n = t.pop();\n      for (const s of n.children)\n        t.push(s);\n      this._destroyTile(n);\n    }\n    this.root = null;\n  }\n  _destroySubtree(t) {\n    const n = t, s = [];\n    for (s.push(n); s.length > 0; ) {\n      t = s.pop();\n      for (const r of t.children)\n        s.push(r);\n      t !== n && this._destroyTile(t);\n    }\n    n.children = [];\n  }\n  _destroyTile(t) {\n    this._cache.unloadTile(this, t), this._unloadTile(t), t.destroy();\n  }\n  _initializeTiles3DTileset(t) {\n    if (t.queryString) {\n      const n = new URLSearchParams(t.queryString), s = Object.fromEntries(n.entries());\n      this._queryParams = {\n        ...this._queryParams,\n        ...s\n      };\n    }\n    if (this.asset = t.asset, !this.asset)\n      throw new Error(\"Tileset must have an asset property.\");\n    if (this.asset.version !== \"0.0\" && this.asset.version !== \"1.0\" && this.asset.version !== \"1.1\")\n      throw new Error(\"The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.\");\n    \"tilesetVersion\" in this.asset && (this._queryParams.v = this.asset.tilesetVersion), this.credits = {\n      attributions: this.options.attributions || []\n    }, this.description = this.options.description || \"\", this.properties = t.properties, this.geometricError = t.geometricError, this._extensionsUsed = t.extensionsUsed || [], this.extras = t.extras;\n  }\n  _initializeI3STileset() {\n    this.loadOptions.i3s && \"token\" in this.loadOptions.i3s && (this._queryParams.token = this.loadOptions.i3s.token);\n  }\n}\nconst Ba = \"4.1.1\", Ce = {\n  COMPOSITE: \"cmpt\",\n  POINT_CLOUD: \"pnts\",\n  BATCHED_3D_MODEL: \"b3dm\",\n  INSTANCED_3D_MODEL: \"i3dm\",\n  GEOMETRY: \"geom\",\n  VECTOR: \"vect\",\n  GLTF: \"glTF\"\n};\nfunction Ca(e, t, n) {\n  U(e instanceof ArrayBuffer);\n  const s = new TextDecoder(\"utf8\"), r = new Uint8Array(e, t, n);\n  return s.decode(r);\n}\nfunction jd(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n  const n = new DataView(e);\n  return `${String.fromCharCode(n.getUint8(t + 0))}${String.fromCharCode(n.getUint8(t + 1))}${String.fromCharCode(n.getUint8(t + 2))}${String.fromCharCode(n.getUint8(t + 3))}`;\n}\nconst kd = \"4.1.1\", Kd = {\n  name: \"Draco\",\n  id: \"draco\",\n  module: \"draco\",\n  version: kd,\n  worker: !0,\n  extensions: [\"drc\"],\n  mimeTypes: [\"application/octet-stream\"],\n  binary: !0,\n  tests: [\"DRACO\"],\n  options: {\n    draco: {\n      decoderType: typeof WebAssembly == \"object\" ? \"wasm\" : \"js\",\n      libraryPath: \"libs/\",\n      extraAttributes: {},\n      attributeNameEntry: void 0\n    }\n  }\n};\nfunction zd(e, t, n) {\n  const s = Ea(t.metadata), r = [], i = Wd(t.attributes);\n  for (const o in e) {\n    const a = e[o], c = Li(o, a, i[o]);\n    r.push(c);\n  }\n  if (n) {\n    const o = Li(\"indices\", n);\n    r.push(o);\n  }\n  return {\n    fields: r,\n    metadata: s\n  };\n}\nfunction Wd(e) {\n  const t = {};\n  for (const n in e) {\n    const s = e[n];\n    t[s.name || \"undefined\"] = s;\n  }\n  return t;\n}\nfunction Li(e, t, n) {\n  const s = n ? Ea(n.metadata) : void 0;\n  return Jl(e, t, s);\n}\nfunction Ea(e) {\n  Object.entries(e);\n  const t = {};\n  for (const n in e)\n    t[`${n}.string`] = JSON.stringify(e[n]);\n  return t;\n}\nconst Gi = {\n  POSITION: \"POSITION\",\n  NORMAL: \"NORMAL\",\n  COLOR: \"COLOR_0\",\n  TEX_COORD: \"TEXCOORD_0\"\n}, Xd = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n}, Qd = 4;\nclass qd {\n  constructor(t) {\n    this.draco = void 0, this.decoder = void 0, this.metadataQuerier = void 0, this.draco = t, this.decoder = new this.draco.Decoder(), this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n  destroy() {\n    this.draco.destroy(this.decoder), this.draco.destroy(this.metadataQuerier);\n  }\n  parseSync(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const s = new this.draco.DecoderBuffer();\n    s.Init(new Int8Array(t), t.byteLength), this._disableAttributeTransforms(n);\n    const r = this.decoder.GetEncodedGeometryType(s), i = r === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();\n    try {\n      let o;\n      switch (r) {\n        case this.draco.TRIANGULAR_MESH:\n          o = this.decoder.DecodeBufferToMesh(s, i);\n          break;\n        case this.draco.POINT_CLOUD:\n          o = this.decoder.DecodeBufferToPointCloud(s, i);\n          break;\n        default:\n          throw new Error(\"DRACO: Unknown geometry type.\");\n      }\n      if (!o.ok() || !i.ptr) {\n        const f = `DRACO decompression failed: ${o.error_msg()}`;\n        throw new Error(f);\n      }\n      const a = this._getDracoLoaderData(i, r, n), c = this._getMeshData(i, a, n), u = Hl(c.attributes), l = zd(c.attributes, a, c.indices);\n      return {\n        loader: \"draco\",\n        loaderData: a,\n        header: {\n          vertexCount: i.num_points(),\n          boundingBox: u\n        },\n        ...c,\n        schema: l\n      };\n    } finally {\n      this.draco.destroy(s), i && this.draco.destroy(i);\n    }\n  }\n  _getDracoLoaderData(t, n, s) {\n    const r = this._getTopLevelMetadata(t), i = this._getDracoAttributes(t, s);\n    return {\n      geometry_type: n,\n      num_attributes: t.num_attributes(),\n      num_points: t.num_points(),\n      num_faces: t instanceof this.draco.Mesh ? t.num_faces() : 0,\n      metadata: r,\n      attributes: i\n    };\n  }\n  _getDracoAttributes(t, n) {\n    const s = {};\n    for (let r = 0; r < t.num_attributes(); r++) {\n      const i = this.decoder.GetAttribute(t, r), o = this._getAttributeMetadata(t, r);\n      s[i.unique_id()] = {\n        unique_id: i.unique_id(),\n        attribute_type: i.attribute_type(),\n        data_type: i.data_type(),\n        num_components: i.num_components(),\n        byte_offset: i.byte_offset(),\n        byte_stride: i.byte_stride(),\n        normalized: i.normalized(),\n        attribute_index: r,\n        metadata: o\n      };\n      const a = this._getQuantizationTransform(i, n);\n      a && (s[i.unique_id()].quantization_transform = a);\n      const c = this._getOctahedronTransform(i, n);\n      c && (s[i.unique_id()].octahedron_transform = c);\n    }\n    return s;\n  }\n  _getMeshData(t, n, s) {\n    const r = this._getMeshAttributes(n, t, s);\n    if (!r.POSITION)\n      throw new Error(\"DRACO: No position attribute found.\");\n    if (t instanceof this.draco.Mesh)\n      switch (s.topology) {\n        case \"triangle-strip\":\n          return {\n            topology: \"triangle-strip\",\n            mode: 4,\n            attributes: r,\n            indices: {\n              value: this._getTriangleStripIndices(t),\n              size: 1\n            }\n          };\n        case \"triangle-list\":\n        default:\n          return {\n            topology: \"triangle-list\",\n            mode: 5,\n            attributes: r,\n            indices: {\n              value: this._getTriangleListIndices(t),\n              size: 1\n            }\n          };\n      }\n    return {\n      topology: \"point-list\",\n      mode: 0,\n      attributes: r\n    };\n  }\n  _getMeshAttributes(t, n, s) {\n    const r = {};\n    for (const i of Object.values(t.attributes)) {\n      const o = this._deduceAttributeName(i, s);\n      i.name = o;\n      const {\n        value: a,\n        size: c\n      } = this._getAttributeValues(n, i);\n      r[o] = {\n        value: a,\n        size: c,\n        byteOffset: i.byte_offset,\n        byteStride: i.byte_stride,\n        normalized: i.normalized\n      };\n    }\n    return r;\n  }\n  _getTriangleListIndices(t) {\n    const s = t.num_faces() * 3, r = s * Qd, i = this.draco._malloc(r);\n    try {\n      return this.decoder.GetTrianglesUInt32Array(t, r, i), new Uint32Array(this.draco.HEAPF32.buffer, i, s).slice();\n    } finally {\n      this.draco._free(i);\n    }\n  }\n  _getTriangleStripIndices(t) {\n    const n = new this.draco.DracoInt32Array();\n    try {\n      return this.decoder.GetTriangleStripsFromMesh(t, n), Zd(n);\n    } finally {\n      this.draco.destroy(n);\n    }\n  }\n  _getAttributeValues(t, n) {\n    const s = Xd[n.data_type], r = n.num_components, o = t.num_points() * r, a = o * s.BYTES_PER_ELEMENT, c = Yd(this.draco, s);\n    let u;\n    const l = this.draco._malloc(a);\n    try {\n      const h = this.decoder.GetAttribute(t, n.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(t, h, c, a, l), u = new s(this.draco.HEAPF32.buffer, l, o).slice();\n    } finally {\n      this.draco._free(l);\n    }\n    return {\n      value: u,\n      size: r\n    };\n  }\n  _deduceAttributeName(t, n) {\n    const s = t.unique_id;\n    for (const [o, a] of Object.entries(n.extraAttributes || {}))\n      if (a === s)\n        return o;\n    const r = t.attribute_type;\n    for (const o in Gi)\n      if (this.draco[o] === r)\n        return Gi[o];\n    const i = n.attributeNameEntry || \"name\";\n    return t.metadata[i] ? t.metadata[i].string : `CUSTOM_ATTRIBUTE_${s}`;\n  }\n  _getTopLevelMetadata(t) {\n    const n = this.decoder.GetMetadata(t);\n    return this._getDracoMetadata(n);\n  }\n  _getAttributeMetadata(t, n) {\n    const s = this.decoder.GetAttributeMetadata(t, n);\n    return this._getDracoMetadata(s);\n  }\n  _getDracoMetadata(t) {\n    if (!t || !t.ptr)\n      return {};\n    const n = {}, s = this.metadataQuerier.NumEntries(t);\n    for (let r = 0; r < s; r++) {\n      const i = this.metadataQuerier.GetEntryName(t, r);\n      n[i] = this._getDracoMetadataField(t, i);\n    }\n    return n;\n  }\n  _getDracoMetadataField(t, n) {\n    const s = new this.draco.DracoInt32Array();\n    try {\n      this.metadataQuerier.GetIntEntryArray(t, n, s);\n      const r = $d(s);\n      return {\n        int: this.metadataQuerier.GetIntEntry(t, n),\n        string: this.metadataQuerier.GetStringEntry(t, n),\n        double: this.metadataQuerier.GetDoubleEntry(t, n),\n        intArray: r\n      };\n    } finally {\n      this.draco.destroy(s);\n    }\n  }\n  _disableAttributeTransforms(t) {\n    const {\n      quantizedAttributes: n = [],\n      octahedronAttributes: s = []\n    } = t, r = [...n, ...s];\n    for (const i of r)\n      this.decoder.SkipAttributeTransform(this.draco[i]);\n  }\n  _getQuantizationTransform(t, n) {\n    const {\n      quantizedAttributes: s = []\n    } = n, r = t.attribute_type();\n    if (s.map((o) => this.decoder[o]).includes(r)) {\n      const o = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (o.InitFromAttribute(t))\n          return {\n            quantization_bits: o.quantization_bits(),\n            range: o.range(),\n            min_values: new Float32Array([1, 2, 3]).map((a) => o.min_value(a))\n          };\n      } finally {\n        this.draco.destroy(o);\n      }\n    }\n    return null;\n  }\n  _getOctahedronTransform(t, n) {\n    const {\n      octahedronAttributes: s = []\n    } = n, r = t.attribute_type();\n    if (s.map((o) => this.decoder[o]).includes(r)) {\n      const o = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (o.InitFromAttribute(t))\n          return {\n            quantization_bits: o.quantization_bits()\n          };\n      } finally {\n        this.draco.destroy(o);\n      }\n    }\n    return null;\n  }\n}\nfunction Yd(e, t) {\n  switch (t) {\n    case Float32Array:\n      return e.DT_FLOAT32;\n    case Int8Array:\n      return e.DT_INT8;\n    case Int16Array:\n      return e.DT_INT16;\n    case Int32Array:\n      return e.DT_INT32;\n    case Uint8Array:\n      return e.DT_UINT8;\n    case Uint16Array:\n      return e.DT_UINT16;\n    case Uint32Array:\n      return e.DT_UINT32;\n    default:\n      return e.DT_INVALID;\n  }\n}\nfunction $d(e) {\n  const t = e.size(), n = new Int32Array(t);\n  for (let s = 0; s < t; s++)\n    n[s] = e.GetValue(s);\n  return n;\n}\nfunction Zd(e) {\n  const t = e.size(), n = new Int32Array(t);\n  for (let s = 0; s < t; s++)\n    n[s] = e.GetValue(s);\n  return n;\n}\nconst tm = \"1.5.6\", em = \"1.4.1\", gs = `https://www.gstatic.com/draco/versioned/decoders/${tm}`, lt = {\n  DECODER: \"draco_wasm_wrapper.js\",\n  DECODER_WASM: \"draco_decoder.wasm\",\n  FALLBACK_DECODER: \"draco_decoder.js\",\n  ENCODER: \"draco_encoder.js\"\n}, As = {\n  [lt.DECODER]: `${gs}/${lt.DECODER}`,\n  [lt.DECODER_WASM]: `${gs}/${lt.DECODER_WASM}`,\n  [lt.FALLBACK_DECODER]: `${gs}/${lt.FALLBACK_DECODER}`,\n  [lt.ENCODER]: `https://raw.githubusercontent.com/google/draco/${em}/javascript/${lt.ENCODER}`\n};\nlet Ee;\nasync function nm(e) {\n  const t = e.modules || {};\n  return t.draco3d ? Ee = Ee || t.draco3d.createDecoderModule({}).then((n) => ({\n    draco: n\n  })) : Ee = Ee || sm(e), await Ee;\n}\nasync function sm(e) {\n  let t, n;\n  switch (e.draco && e.draco.decoderType) {\n    case \"js\":\n      t = await Xt(As[lt.FALLBACK_DECODER], \"draco\", e, lt.FALLBACK_DECODER);\n      break;\n    case \"wasm\":\n    default:\n      [t, n] = await Promise.all([await Xt(As[lt.DECODER], \"draco\", e, lt.DECODER), await Xt(As[lt.DECODER_WASM], \"draco\", e, lt.DECODER_WASM)]);\n  }\n  return t = t || globalThis.DracoDecoderModule, await rm(t, n);\n}\nfunction rm(e, t) {\n  const n = {};\n  return t && (n.wasmBinary = t), new Promise((s) => {\n    e({\n      ...n,\n      onModuleLoaded: (r) => s({\n        draco: r\n      })\n    });\n  });\n}\nconst Ta = {\n  ...Kd,\n  parse: im\n};\nasync function im(e, t) {\n  const {\n    draco: n\n  } = await nm(t), s = new qd(n);\n  try {\n    return s.parseSync(e, t == null ? void 0 : t.draco);\n  } finally {\n    s.destroy();\n  }\n}\nconst om = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6\n}, Y = {\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  DOUBLE: 5130\n}, G = {\n  ...om,\n  ...Y\n}, ps = {\n  [Y.DOUBLE]: Float64Array,\n  [Y.FLOAT]: Float32Array,\n  [Y.UNSIGNED_SHORT]: Uint16Array,\n  [Y.UNSIGNED_INT]: Uint32Array,\n  [Y.UNSIGNED_BYTE]: Uint8Array,\n  [Y.BYTE]: Int8Array,\n  [Y.SHORT]: Int16Array,\n  [Y.INT]: Int32Array\n}, am = {\n  DOUBLE: Y.DOUBLE,\n  FLOAT: Y.FLOAT,\n  UNSIGNED_SHORT: Y.UNSIGNED_SHORT,\n  UNSIGNED_INT: Y.UNSIGNED_INT,\n  UNSIGNED_BYTE: Y.UNSIGNED_BYTE,\n  BYTE: Y.BYTE,\n  SHORT: Y.SHORT,\n  INT: Y.INT\n}, ys = \"Failed to convert GL type\";\nclass Ot {\n  static fromTypedArray(t) {\n    t = ArrayBuffer.isView(t) ? t.constructor : t;\n    for (const n in ps)\n      if (ps[n] === t)\n        return n;\n    throw new Error(ys);\n  }\n  static fromName(t) {\n    const n = am[t];\n    if (!n)\n      throw new Error(ys);\n    return n;\n  }\n  static getArrayType(t) {\n    switch (t) {\n      case Y.UNSIGNED_SHORT_5_6_5:\n      case Y.UNSIGNED_SHORT_4_4_4_4:\n      case Y.UNSIGNED_SHORT_5_5_5_1:\n        return Uint16Array;\n      default:\n        const n = ps[t];\n        if (!n)\n          throw new Error(ys);\n        return n;\n    }\n  }\n  static getByteSize(t) {\n    return Ot.getArrayType(t).BYTES_PER_ELEMENT;\n  }\n  static validate(t) {\n    return !!Ot.getArrayType(t);\n  }\n  static createTypedArray(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r = arguments.length > 3 ? arguments[3] : void 0;\n    r === void 0 && (r = (n.byteLength - s) / Ot.getByteSize(t));\n    const i = Ot.getArrayType(t);\n    return new i(n, s, r);\n  }\n}\nfunction cm(e, t) {\n  if (!e)\n    throw new Error(`math.gl assertion failed. ${t}`);\n}\nfunction um(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];\n  const n = e >> 11 & 31, s = e >> 5 & 63, r = e & 31;\n  return t[0] = n << 3, t[1] = s << 2, t[2] = r << 3, t;\n}\nnew Nn();\nnew A();\nnew Nn();\nnew Nn();\nfunction Pi(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 255;\n  return ql(e, 0, t) / t * 2 - 1;\n}\nfunction Ni(e) {\n  return e < 0 ? -1 : 1;\n}\nfunction lm(e, t, n, s) {\n  if (cm(s), e < 0 || e > n || t < 0 || t > n)\n    throw new Error(`x and y must be unsigned normalized integers between 0 and ${n}`);\n  if (s.x = Pi(e, n), s.y = Pi(t, n), s.z = 1 - (Math.abs(s.x) + Math.abs(s.y)), s.z < 0) {\n    const r = s.x;\n    s.x = (1 - Math.abs(s.y)) * Ni(r), s.y = (1 - Math.abs(r)) * Ni(s.y);\n  }\n  return s.normalize();\n}\nfunction hm(e, t, n) {\n  return lm(e, t, 255, n);\n}\nclass mr {\n  constructor(t, n) {\n    this.json = void 0, this.buffer = void 0, this.featuresLength = 0, this._cachedTypedArrays = {}, this.json = t, this.buffer = n;\n  }\n  getExtension(t) {\n    return this.json.extensions && this.json.extensions[t];\n  }\n  hasProperty(t) {\n    return !!this.json[t];\n  }\n  getGlobalProperty(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : G.UNSIGNED_INT, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n    const r = this.json[t];\n    return r && Number.isFinite(r.byteOffset) ? this._getTypedArrayFromBinary(t, n, s, 1, r.byteOffset) : r;\n  }\n  getPropertyArray(t, n, s) {\n    const r = this.json[t];\n    return r && Number.isFinite(r.byteOffset) ? (\"componentType\" in r && (n = Ot.fromName(r.componentType)), this._getTypedArrayFromBinary(t, n, s, this.featuresLength, r.byteOffset)) : this._getTypedArrayFromArray(t, n, r);\n  }\n  getProperty(t, n, s, r, i) {\n    const o = this.json[t];\n    if (!o)\n      return o;\n    const a = this.getPropertyArray(t, n, s);\n    if (s === 1)\n      return a[r];\n    for (let c = 0; c < s; ++c)\n      i[c] = a[s * r + c];\n    return i;\n  }\n  _getTypedArrayFromBinary(t, n, s, r, i) {\n    const o = this._cachedTypedArrays;\n    let a = o[t];\n    return a || (a = Ot.createTypedArray(n, this.buffer.buffer, this.buffer.byteOffset + i, r * s), o[t] = a), a;\n  }\n  _getTypedArrayFromArray(t, n, s) {\n    const r = this._cachedTypedArrays;\n    let i = r[t];\n    return i || (i = Ot.createTypedArray(n, s), r[t] = i), i;\n  }\n}\nconst fm = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n}, dm = {\n  SCALAR: (e, t) => e[t],\n  VEC2: (e, t) => [e[2 * t + 0], e[2 * t + 1]],\n  VEC3: (e, t) => [e[3 * t + 0], e[3 * t + 1], e[3 * t + 2]],\n  VEC4: (e, t) => [e[4 * t + 0], e[4 * t + 1], e[4 * t + 2], e[4 * t + 3]],\n  MAT2: (e, t) => [e[4 * t + 0], e[4 * t + 1], e[4 * t + 2], e[4 * t + 3]],\n  MAT3: (e, t) => [e[9 * t + 0], e[9 * t + 1], e[9 * t + 2], e[9 * t + 3], e[9 * t + 4], e[9 * t + 5], e[9 * t + 6], e[9 * t + 7], e[9 * t + 8]],\n  MAT4: (e, t) => [e[16 * t + 0], e[16 * t + 1], e[16 * t + 2], e[16 * t + 3], e[16 * t + 4], e[16 * t + 5], e[16 * t + 6], e[16 * t + 7], e[16 * t + 8], e[16 * t + 9], e[16 * t + 10], e[16 * t + 11], e[16 * t + 12], e[16 * t + 13], e[16 * t + 14], e[16 * t + 15]]\n}, mm = {\n  SCALAR: (e, t, n) => {\n    t[n] = e;\n  },\n  VEC2: (e, t, n) => {\n    t[2 * n + 0] = e[0], t[2 * n + 1] = e[1];\n  },\n  VEC3: (e, t, n) => {\n    t[3 * n + 0] = e[0], t[3 * n + 1] = e[1], t[3 * n + 2] = e[2];\n  },\n  VEC4: (e, t, n) => {\n    t[4 * n + 0] = e[0], t[4 * n + 1] = e[1], t[4 * n + 2] = e[2], t[4 * n + 3] = e[3];\n  },\n  MAT2: (e, t, n) => {\n    t[4 * n + 0] = e[0], t[4 * n + 1] = e[1], t[4 * n + 2] = e[2], t[4 * n + 3] = e[3];\n  },\n  MAT3: (e, t, n) => {\n    t[9 * n + 0] = e[0], t[9 * n + 1] = e[1], t[9 * n + 2] = e[2], t[9 * n + 3] = e[3], t[9 * n + 4] = e[4], t[9 * n + 5] = e[5], t[9 * n + 6] = e[6], t[9 * n + 7] = e[7], t[9 * n + 8] = e[8], t[9 * n + 9] = e[9];\n  },\n  MAT4: (e, t, n) => {\n    t[16 * n + 0] = e[0], t[16 * n + 1] = e[1], t[16 * n + 2] = e[2], t[16 * n + 3] = e[3], t[16 * n + 4] = e[4], t[16 * n + 5] = e[5], t[16 * n + 6] = e[6], t[16 * n + 7] = e[7], t[16 * n + 8] = e[8], t[16 * n + 9] = e[9], t[16 * n + 10] = e[10], t[16 * n + 11] = e[11], t[16 * n + 12] = e[12], t[16 * n + 13] = e[13], t[16 * n + 14] = e[14], t[16 * n + 15] = e[15];\n  }\n};\nfunction gm(e, t, n, s) {\n  const {\n    componentType: r\n  } = e;\n  U(e.componentType);\n  const i = typeof r == \"string\" ? Ot.fromName(r) : r, o = fm[e.type], a = dm[e.type], c = mm[e.type];\n  return n += e.byteOffset, {\n    values: Ot.createTypedArray(i, t, n, o * s),\n    type: i,\n    size: o,\n    unpacker: a,\n    packer: c\n  };\n}\nconst St = (e) => e !== void 0;\nfunction Am(e, t, n) {\n  if (!t)\n    return null;\n  let s = e.getExtension(\"3DTILES_batch_table_hierarchy\");\n  const r = t.HIERARCHY;\n  return r && (console.warn(\"3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.\"), t.extensions = t.extensions || {}, t.extensions[\"3DTILES_batch_table_hierarchy\"] = r, s = r), s ? pm(s, n) : null;\n}\nfunction pm(e, t) {\n  let n, s, r;\n  const i = e.instancesLength, o = e.classes;\n  let a = e.classIds, c = e.parentCounts, u = e.parentIds, l = i;\n  St(a.byteOffset) && (a.componentType = defaultValue(a.componentType, GL.UNSIGNED_SHORT), a.type = AttributeType.SCALAR, r = getBinaryAccessor(a), a = r.createArrayBufferView(t.buffer, t.byteOffset + a.byteOffset, i));\n  let h;\n  if (St(c))\n    for (St(c.byteOffset) && (c.componentType = defaultValue(c.componentType, GL.UNSIGNED_SHORT), c.type = AttributeType.SCALAR, r = getBinaryAccessor(c), c = r.createArrayBufferView(t.buffer, t.byteOffset + c.byteOffset, i)), h = new Uint16Array(i), l = 0, n = 0; n < i; ++n)\n      h[n] = l, l += c[n];\n  St(u) && St(u.byteOffset) && (u.componentType = defaultValue(u.componentType, GL.UNSIGNED_SHORT), u.type = AttributeType.SCALAR, r = getBinaryAccessor(u), u = r.createArrayBufferView(t.buffer, t.byteOffset + u.byteOffset, l));\n  const f = o.length;\n  for (n = 0; n < f; ++n) {\n    const p = o[n].length, C = o[n].instances, w = getBinaryProperties(p, C, t);\n    o[n].instances = combine(w, C);\n  }\n  const d = new Array(f).fill(0), m = new Uint16Array(i);\n  for (n = 0; n < i; ++n)\n    s = a[n], m[n] = d[s], ++d[s];\n  const g = {\n    classes: o,\n    classIds: a,\n    classIndexes: m,\n    parentCounts: c,\n    parentIndexes: h,\n    parentIds: u\n  };\n  return Cm(g), g;\n}\nfunction Te(e, t, n) {\n  if (!e)\n    return;\n  const s = e.parentCounts;\n  return e.parentIds ? n(e, t) : s > 0 ? ym(e, t, n) : Bm(e, t, n);\n}\nfunction ym(e, t, n) {\n  const s = e.classIds, r = e.parentCounts, i = e.parentIds, o = e.parentIndexes, a = s.length, c = scratchVisited;\n  c.length = Math.max(c.length, a);\n  const u = ++marker, l = scratchStack;\n  for (l.length = 0, l.push(t); l.length > 0; ) {\n    if (t = l.pop(), c[t] === u)\n      continue;\n    c[t] = u;\n    const h = n(e, t);\n    if (St(h))\n      return h;\n    const f = r[t], d = o[t];\n    for (let m = 0; m < f; ++m) {\n      const g = i[d + m];\n      g !== t && l.push(g);\n    }\n  }\n  return null;\n}\nfunction Bm(e, t, n) {\n  let s = !0;\n  for (; s; ) {\n    const r = n(e, t);\n    if (St(r))\n      return r;\n    const i = e.parentIds[t];\n    s = i !== t, t = i;\n  }\n  throw new Error(\"traverseHierarchySingleParent\");\n}\nfunction Cm(e) {\n  const n = e.classIds.length;\n  for (let s = 0; s < n; ++s)\n    ba(e, s, stack);\n}\nfunction ba(e, t, n) {\n  const s = e.parentCounts, r = e.parentIds, i = e.parentIndexes, a = e.classIds.length;\n  if (!St(r))\n    return;\n  assert(t < a, `Parent index ${t} exceeds the total number of instances: ${a}`), assert(n.indexOf(t) === -1, \"Circular dependency detected in the batch table hierarchy.\"), n.push(t);\n  const c = St(s) ? s[t] : 1, u = St(s) ? i[t] : t;\n  for (let l = 0; l < c; ++l) {\n    const h = r[u + l];\n    h !== t && ba(e, h, n);\n  }\n  n.pop(t);\n}\nfunction ct(e) {\n  return e != null;\n}\nconst un = (e, t) => e, Em = {\n  HIERARCHY: !0,\n  extensions: !0,\n  extras: !0\n};\nclass _a {\n  constructor(t, n, s) {\n    var r;\n    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    this.json = void 0, this.binary = void 0, this.featureCount = void 0, this._extensions = void 0, this._properties = void 0, this._binaryProperties = void 0, this._hierarchy = void 0, U(s >= 0), this.json = t || {}, this.binary = n, this.featureCount = s, this._extensions = ((r = this.json) === null || r === void 0 ? void 0 : r.extensions) || {}, this._properties = {};\n    for (const o in this.json)\n      Em[o] || (this._properties[o] = this.json[o]);\n    this._binaryProperties = this._initializeBinaryProperties(), i[\"3DTILES_batch_table_hierarchy\"] && (this._hierarchy = Am(this, this.json, this.binary));\n  }\n  getExtension(t) {\n    return this.json && this.json.extensions && this.json.extensions[t];\n  }\n  memorySizeInBytes() {\n    return 0;\n  }\n  isClass(t, n) {\n    if (this._checkBatchId(t), U(typeof n == \"string\", n), this._hierarchy) {\n      const s = Te(this._hierarchy, t, (r, i) => {\n        const o = r.classIds[i];\n        return r.classes[o].name === n;\n      });\n      return ct(s);\n    }\n    return !1;\n  }\n  isExactClass(t, n) {\n    return U(typeof n == \"string\", n), this.getExactClassName(t) === n;\n  }\n  getExactClassName(t) {\n    if (this._checkBatchId(t), this._hierarchy) {\n      const n = this._hierarchy.classIds[t];\n      return this._hierarchy.classes[n].name;\n    }\n  }\n  hasProperty(t, n) {\n    return this._checkBatchId(t), U(typeof n == \"string\", n), ct(this._properties[n]) || this._hasPropertyInHierarchy(t, n);\n  }\n  getPropertyNames(t, n) {\n    this._checkBatchId(t), n = ct(n) ? n : [], n.length = 0;\n    const s = Object.keys(this._properties);\n    return n.push(...s), this._hierarchy && this._getPropertyNamesInHierarchy(t, n), n;\n  }\n  getProperty(t, n) {\n    if (this._checkBatchId(t), U(typeof n == \"string\", n), this._binaryProperties) {\n      const r = this._binaryProperties[n];\n      if (ct(r))\n        return this._getBinaryProperty(r, t);\n    }\n    const s = this._properties[n];\n    if (ct(s))\n      return un(s[t]);\n    if (this._hierarchy) {\n      const r = this._getHierarchyProperty(t, n);\n      if (ct(r))\n        return r;\n    }\n  }\n  setProperty(t, n, s) {\n    const r = this.featureCount;\n    if (this._checkBatchId(t), U(typeof n == \"string\", n), this._binaryProperties) {\n      const o = this._binaryProperties[n];\n      if (o) {\n        this._setBinaryProperty(o, t, s);\n        return;\n      }\n    }\n    if (this._hierarchy && this._setHierarchyProperty(this, t, n, s))\n      return;\n    let i = this._properties[n];\n    ct(i) || (this._properties[n] = new Array(r), i = this._properties[n]), i[t] = un(s);\n  }\n  _checkBatchId(t) {\n    if (!(t >= 0 && t < this.featureCount))\n      throw new Error(\"batchId not in range [0, featureCount - 1].\");\n  }\n  _getBinaryProperty(t, n) {\n    return t.unpack(t.typedArray, n);\n  }\n  _setBinaryProperty(t, n, s) {\n    t.pack(s, t.typedArray, n);\n  }\n  _initializeBinaryProperties() {\n    let t = null;\n    for (const n in this._properties) {\n      const s = this._properties[n], r = this._initializeBinaryProperty(n, s);\n      r && (t = t || {}, t[n] = r);\n    }\n    return t;\n  }\n  _initializeBinaryProperty(t, n) {\n    if (\"byteOffset\" in n) {\n      const s = n;\n      U(this.binary, `Property ${t} requires a batch table binary.`), U(s.type, `Property ${t} requires a type.`);\n      const r = gm(s, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);\n      return {\n        typedArray: r.values,\n        componentCount: r.size,\n        unpack: r.unpacker,\n        pack: r.packer\n      };\n    }\n    return null;\n  }\n  _hasPropertyInHierarchy(t, n) {\n    if (!this._hierarchy)\n      return !1;\n    const s = Te(this._hierarchy, t, (r, i) => {\n      const o = r.classIds[i], a = r.classes[o].instances;\n      return ct(a[n]);\n    });\n    return ct(s);\n  }\n  _getPropertyNamesInHierarchy(t, n) {\n    Te(this._hierarchy, t, (s, r) => {\n      const i = s.classIds[r], o = s.classes[i].instances;\n      for (const a in o)\n        o.hasOwnProperty(a) && n.indexOf(a) === -1 && n.push(a);\n    });\n  }\n  _getHierarchyProperty(t, n) {\n    return Te(this._hierarchy, t, (s, r) => {\n      const i = s.classIds[r], o = s.classes[i], a = s.classIndexes[r], c = o.instances[n];\n      return ct(c) ? ct(c.typedArray) ? this._getBinaryProperty(c, a) : un(c[a]) : null;\n    });\n  }\n  _setHierarchyProperty(t, n, s, r) {\n    const i = Te(this._hierarchy, n, (o, a) => {\n      const c = o.classIds[a], u = o.classes[c], l = o.classIndexes[a], h = u.instances[s];\n      return ct(h) ? (U(a === n, `Inherited property \"${s}\" is read-only.`), ct(h.typedArray) ? this._setBinaryProperty(h, l, r) : h[l] = un(r), !0) : !1;\n    });\n    return ct(i);\n  }\n}\nconst Bs = 4;\nfunction Vn(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  const s = new DataView(t);\n  if (e.magic = s.getUint32(n, !0), n += Bs, e.version = s.getUint32(n, !0), n += Bs, e.byteLength = s.getUint32(n, !0), n += Bs, e.version !== 1)\n    throw new Error(`3D Tile Version ${e.version} not supported`);\n  return n;\n}\nconst oe = 4, Ui = \"b3dm tile in legacy format.\";\nfunction gr(e, t, n) {\n  const s = new DataView(t);\n  let r;\n  e.header = e.header || {};\n  let i = s.getUint32(n, !0);\n  n += oe;\n  let o = s.getUint32(n, !0);\n  n += oe;\n  let a = s.getUint32(n, !0);\n  n += oe;\n  let c = s.getUint32(n, !0);\n  return n += oe, a >= 570425344 ? (n -= oe * 2, r = i, a = o, c = 0, i = 0, o = 0, console.warn(Ui)) : c >= 570425344 && (n -= oe, r = a, a = i, c = o, i = 0, o = 0, console.warn(Ui)), e.header.featureTableJsonByteLength = i, e.header.featureTableBinaryByteLength = o, e.header.batchTableJsonByteLength = a, e.header.batchTableBinaryByteLength = c, e.header.batchLength = r, n;\n}\nfunction Ar(e, t, n, s) {\n  return n = Tm(e, t, n), n = bm(e, t, n), n;\n}\nfunction Tm(e, t, n, s) {\n  const {\n    featureTableJsonByteLength: r,\n    featureTableBinaryByteLength: i,\n    batchLength: o\n  } = e.header || {};\n  if (e.featureTableJson = {\n    BATCH_LENGTH: o || 0\n  }, r && r > 0) {\n    const a = Ca(t, n, r);\n    e.featureTableJson = JSON.parse(a);\n  }\n  return n += r || 0, e.featureTableBinary = new Uint8Array(t, n, i), n += i || 0, n;\n}\nfunction bm(e, t, n, s) {\n  const {\n    batchTableJsonByteLength: r,\n    batchTableBinaryByteLength: i\n  } = e.header || {};\n  if (r && r > 0) {\n    const o = Ca(t, n, r);\n    e.batchTableJson = JSON.parse(o), n += r, i && i > 0 && (e.batchTableBinary = new Uint8Array(t, n, i), e.batchTableBinary = new Uint8Array(e.batchTableBinary), n += i);\n  }\n  return n;\n}\nfunction wa(e, t, n) {\n  if (!t && (!e || !e.batchIds || !n))\n    return null;\n  const {\n    batchIds: s,\n    isRGB565: r,\n    pointCount: i = 0\n  } = e;\n  if (s && n) {\n    const o = new Uint8ClampedArray(i * 3);\n    for (let a = 0; a < i; a++) {\n      const c = s[a], l = n.getProperty(c, \"dimensions\").map((h) => h * 255);\n      o[a * 3] = l[0], o[a * 3 + 1] = l[1], o[a * 3 + 2] = l[2];\n    }\n    return {\n      type: G.UNSIGNED_BYTE,\n      value: o,\n      size: 3,\n      normalized: !0\n    };\n  }\n  if (t && r) {\n    const o = new Uint8ClampedArray(i * 3);\n    for (let a = 0; a < i; a++) {\n      const c = um(t[a]);\n      o[a * 3] = c[0], o[a * 3 + 1] = c[1], o[a * 3 + 2] = c[2];\n    }\n    return {\n      type: G.UNSIGNED_BYTE,\n      value: o,\n      size: 3,\n      normalized: !0\n    };\n  }\n  return t && t.length === i * 3 ? {\n    type: G.UNSIGNED_BYTE,\n    value: t,\n    size: 3,\n    normalized: !0\n  } : {\n    type: G.UNSIGNED_BYTE,\n    value: t || new Uint8ClampedArray(),\n    size: 4,\n    normalized: !0\n  };\n}\nconst Hi = new A();\nfunction _m(e, t) {\n  if (!t)\n    return null;\n  if (e.isOctEncoded16P) {\n    const n = new Float32Array((e.pointsLength || 0) * 3);\n    for (let s = 0; s < (e.pointsLength || 0); s++)\n      hm(t[s * 2], t[s * 2 + 1], Hi), Hi.toArray(n, s * 3);\n    return {\n      type: G.FLOAT,\n      size: 2,\n      value: n\n    };\n  }\n  return {\n    type: G.FLOAT,\n    size: 2,\n    value: t\n  };\n}\nfunction wm(e, t, n) {\n  return e.isQuantized ? n[\"3d-tiles\"] && n[\"3d-tiles\"].decodeQuantizedPositions ? (e.isQuantized = !1, Rm(e, t)) : {\n    type: G.UNSIGNED_SHORT,\n    value: t,\n    size: 3,\n    normalized: !0\n  } : t;\n}\nfunction Rm(e, t) {\n  const n = new A(), s = new Float32Array(e.pointCount * 3);\n  for (let r = 0; r < e.pointCount; r++)\n    n.set(t[r * 3], t[r * 3 + 1], t[r * 3 + 2]).scale(1 / e.quantizedRange).multiply(e.quantizedVolumeScale).add(e.quantizedVolumeOffset).toArray(s, r * 3);\n  return s;\n}\nasync function Mm(e, t, n, s, r) {\n  n = Vn(e, t, n), n = gr(e, t, n), n = Ar(e, t, n), Im(e);\n  const {\n    featureTable: i,\n    batchTable: o\n  } = Sm(e);\n  return await Dm(e, i, o, s, r), xm(e, i, s), Om(e, i, o), Fm(e, i), n;\n}\nfunction Im(e) {\n  e.attributes = {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, e.isQuantized = !1, e.isTranslucent = !1, e.isRGB565 = !1, e.isOctEncoded16P = !1;\n}\nfunction Sm(e) {\n  const t = new mr(e.featureTableJson, e.featureTableBinary), n = t.getGlobalProperty(\"POINTS_LENGTH\");\n  if (!Number.isFinite(n))\n    throw new Error(\"POINTS_LENGTH must be defined\");\n  t.featuresLength = n, e.featuresLength = n, e.pointsLength = n, e.pointCount = n, e.rtcCenter = t.getGlobalProperty(\"RTC_CENTER\", G.FLOAT, 3);\n  const s = vm(e, t);\n  return {\n    featureTable: t,\n    batchTable: s\n  };\n}\nfunction xm(e, t, n) {\n  if (e.attributes = e.attributes || {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, !e.attributes.positions) {\n    if (t.hasProperty(\"POSITION\"))\n      e.attributes.positions = t.getPropertyArray(\"POSITION\", G.FLOAT, 3);\n    else if (t.hasProperty(\"POSITION_QUANTIZED\")) {\n      const s = t.getPropertyArray(\"POSITION_QUANTIZED\", G.UNSIGNED_SHORT, 3);\n      if (e.isQuantized = !0, e.quantizedRange = 65535, e.quantizedVolumeScale = t.getGlobalProperty(\"QUANTIZED_VOLUME_SCALE\", G.FLOAT, 3), !e.quantizedVolumeScale)\n        throw new Error(\"QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\");\n      if (e.quantizedVolumeOffset = t.getGlobalProperty(\"QUANTIZED_VOLUME_OFFSET\", G.FLOAT, 3), !e.quantizedVolumeOffset)\n        throw new Error(\"QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\");\n      e.attributes.positions = wm(e, s, n);\n    }\n  }\n  if (!e.attributes.positions)\n    throw new Error(\"Either POSITION or POSITION_QUANTIZED must be defined.\");\n}\nfunction Om(e, t, n) {\n  if (e.attributes = e.attributes || {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, !e.attributes.colors) {\n    let s = null;\n    t.hasProperty(\"RGBA\") ? (s = t.getPropertyArray(\"RGBA\", G.UNSIGNED_BYTE, 4), e.isTranslucent = !0) : t.hasProperty(\"RGB\") ? s = t.getPropertyArray(\"RGB\", G.UNSIGNED_BYTE, 3) : t.hasProperty(\"RGB565\") && (s = t.getPropertyArray(\"RGB565\", G.UNSIGNED_SHORT, 1), e.isRGB565 = !0), e.attributes.colors = wa(e, s, n);\n  }\n  t.hasProperty(\"CONSTANT_RGBA\") && (e.constantRGBA = t.getGlobalProperty(\"CONSTANT_RGBA\", G.UNSIGNED_BYTE, 4));\n}\nfunction Fm(e, t) {\n  if (e.attributes = e.attributes || {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, !e.attributes.normals) {\n    let n = null;\n    t.hasProperty(\"NORMAL\") ? n = t.getPropertyArray(\"NORMAL\", G.FLOAT, 3) : t.hasProperty(\"NORMAL_OCT16P\") && (n = t.getPropertyArray(\"NORMAL_OCT16P\", G.UNSIGNED_BYTE, 2), e.isOctEncoded16P = !0), e.attributes.normals = _m(e, n);\n  }\n}\nfunction vm(e, t) {\n  let n = null;\n  if (!e.batchIds && t.hasProperty(\"BATCH_ID\") && (e.batchIds = t.getPropertyArray(\"BATCH_ID\", G.UNSIGNED_SHORT, 1), e.batchIds)) {\n    const s = t.getGlobalProperty(\"BATCH_LENGTH\");\n    if (!s)\n      throw new Error(\"Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.\");\n    const {\n      batchTableJson: r,\n      batchTableBinary: i\n    } = e;\n    n = new _a(r, i, s);\n  }\n  return n;\n}\nasync function Dm(e, t, n, s, r) {\n  let i, o, a;\n  const c = e.batchTableJson && e.batchTableJson.extensions && e.batchTableJson.extensions[\"3DTILES_draco_point_compression\"];\n  c && (a = c.properties);\n  const u = t.getExtension(\"3DTILES_draco_point_compression\");\n  if (u) {\n    o = u.properties;\n    const h = u.byteOffset, f = u.byteLength;\n    if (!o || !Number.isFinite(h) || !f)\n      throw new Error(\"Draco properties, byteOffset, and byteLength must be defined\");\n    i = (e.featureTableBinary || []).slice(h, h + f), e.hasPositions = Number.isFinite(o.POSITION), e.hasColors = Number.isFinite(o.RGB) || Number.isFinite(o.RGBA), e.hasNormals = Number.isFinite(o.NORMAL), e.hasBatchIds = Number.isFinite(o.BATCH_ID), e.isTranslucent = Number.isFinite(o.RGBA);\n  }\n  if (!i)\n    return !0;\n  const l = {\n    buffer: i,\n    properties: {\n      ...o,\n      ...a\n    },\n    featureTableProperties: o,\n    batchTableProperties: a,\n    dequantizeInShader: !1\n  };\n  return await Lm(e, l, s, r);\n}\nasync function Lm(e, t, n, s) {\n  if (!s)\n    return;\n  const r = {\n    ...n,\n    draco: {\n      ...n == null ? void 0 : n.draco,\n      extraAttributes: t.batchTableProperties || {}\n    }\n  };\n  delete r[\"3d-tiles\"];\n  const i = await He(t.buffer, Ta, r, s), o = i.attributes.POSITION && i.attributes.POSITION.value, a = i.attributes.COLOR_0 && i.attributes.COLOR_0.value, c = i.attributes.NORMAL && i.attributes.NORMAL.value, u = i.attributes.BATCH_ID && i.attributes.BATCH_ID.value, l = o && i.attributes.POSITION.value.quantization, h = c && i.attributes.NORMAL.value.quantization;\n  if (l) {\n    const d = i.POSITION.data.quantization, m = d.range;\n    e.quantizedVolumeScale = new A(m, m, m), e.quantizedVolumeOffset = new A(d.minValues), e.quantizedRange = (1 << d.quantizationBits) - 1, e.isQuantizedDraco = !0;\n  }\n  h && (e.octEncodedRange = (1 << i.NORMAL.data.quantization.quantizationBits) - 1, e.isOctEncodedDraco = !0);\n  const f = {};\n  if (t.batchTableProperties)\n    for (const d of Object.keys(t.batchTableProperties))\n      i.attributes[d] && i.attributes[d].value && (f[d.toLowerCase()] = i.attributes[d].value);\n  e.attributes = {\n    positions: o,\n    colors: wa(e, a, void 0),\n    normals: c,\n    batchIds: u,\n    ...f\n  };\n}\nconst Gm = \"4.1.1\";\nvar Cs;\nconst Pm = (Cs = globalThis.loaders) === null || Cs === void 0 ? void 0 : Cs.parseImageNode, js = typeof Image < \"u\", ks = typeof ImageBitmap < \"u\", Nm = !!Pm, Ks = Ln ? !0 : Nm;\nfunction Um(e) {\n  switch (e) {\n    case \"auto\":\n      return ks || js || Ks;\n    case \"imagebitmap\":\n      return ks;\n    case \"image\":\n      return js;\n    case \"data\":\n      return Ks;\n    default:\n      throw new Error(`@loaders.gl/images: image ${e} not supported in this environment`);\n  }\n}\nfunction Hm() {\n  if (ks)\n    return \"imagebitmap\";\n  if (js)\n    return \"image\";\n  if (Ks)\n    return \"data\";\n  throw new Error(\"Install '@loaders.gl/polyfills' to parse images under Node.js\");\n}\nfunction Jm(e) {\n  const t = Vm(e);\n  if (!t)\n    throw new Error(\"Not an image\");\n  return t;\n}\nfunction Ra(e) {\n  switch (Jm(e)) {\n    case \"data\":\n      return e;\n    case \"image\":\n    case \"imagebitmap\":\n      const t = document.createElement(\"canvas\"), n = t.getContext(\"2d\");\n      if (!n)\n        throw new Error(\"getImageData\");\n      return t.width = e.width, t.height = e.height, n.drawImage(e, 0, 0), n.getImageData(0, 0, e.width, e.height);\n    default:\n      throw new Error(\"getImageData\");\n  }\n}\nfunction Vm(e) {\n  return typeof ImageBitmap < \"u\" && e instanceof ImageBitmap ? \"imagebitmap\" : typeof Image < \"u\" && e instanceof Image ? \"image\" : e && typeof e == \"object\" && e.data && e.width && e.height ? \"data\" : null;\n}\nconst jm = /^data:image\\/svg\\+xml/, km = /\\.svg((\\?|#).*)?$/;\nfunction pr(e) {\n  return e && (jm.test(e) || km.test(e));\n}\nfunction Km(e, t) {\n  if (pr(t)) {\n    let s = new TextDecoder().decode(e);\n    try {\n      typeof unescape == \"function\" && typeof encodeURIComponent == \"function\" && (s = unescape(encodeURIComponent(s)));\n    } catch (i) {\n      throw new Error(i.message);\n    }\n    return `data:image/svg+xml;base64,${btoa(s)}`;\n  }\n  return Ma(e, t);\n}\nfunction Ma(e, t) {\n  if (pr(t))\n    throw new Error(\"SVG cannot be parsed directly to imagebitmap\");\n  return new Blob([new Uint8Array(e)]);\n}\nasync function Ia(e, t, n) {\n  const s = Km(e, n), r = self.URL || self.webkitURL, i = typeof s != \"string\" && r.createObjectURL(s);\n  try {\n    return await zm(i || s, t);\n  } finally {\n    i && r.revokeObjectURL(i);\n  }\n}\nasync function zm(e, t) {\n  const n = new Image();\n  return n.src = e, t.image && t.image.decode && n.decode ? (await n.decode(), n) : await new Promise((s, r) => {\n    try {\n      n.onload = () => s(n), n.onerror = (i) => {\n        const o = i instanceof Error ? i.message : \"error\";\n        r(new Error(o));\n      };\n    } catch (i) {\n      r(i);\n    }\n  });\n}\nconst Wm = {};\nlet Ji = !0;\nasync function Xm(e, t, n) {\n  let s;\n  pr(n) ? s = await Ia(e, t, n) : s = Ma(e, n);\n  const r = t && t.imagebitmap;\n  return await Qm(s, r);\n}\nasync function Qm(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n  if ((qm(t) || !Ji) && (t = null), t)\n    try {\n      return await createImageBitmap(e, t);\n    } catch (n) {\n      console.warn(n), Ji = !1;\n    }\n  return await createImageBitmap(e);\n}\nfunction qm(e) {\n  for (const t in e || Wm)\n    return !1;\n  return !0;\n}\nfunction Ym(e) {\n  return !eg(e, \"ftyp\", 4) || !(e[8] & 96) ? null : $m(e);\n}\nfunction $m(e) {\n  switch (Zm(e, 8, 12).replace(\"\\0\", \" \").trim()) {\n    case \"avif\":\n    case \"avis\":\n      return {\n        extension: \"avif\",\n        mimeType: \"image/avif\"\n      };\n    default:\n      return null;\n  }\n}\nfunction Zm(e, t, n) {\n  return String.fromCharCode(...e.slice(t, n));\n}\nfunction tg(e) {\n  return [...e].map((t) => t.charCodeAt(0));\n}\nfunction eg(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  const s = tg(t);\n  for (let r = 0; r < s.length; ++r)\n    if (s[r] !== e[r + n])\n      return !1;\n  return !0;\n}\nconst xt = !1, xe = !0;\nfunction yr(e) {\n  const t = ze(e);\n  return sg(t) || og(t) || rg(t) || ig(t) || ng(t);\n}\nfunction ng(e) {\n  const t = new Uint8Array(e instanceof DataView ? e.buffer : e), n = Ym(t);\n  return n ? {\n    mimeType: n.mimeType,\n    width: 0,\n    height: 0\n  } : null;\n}\nfunction sg(e) {\n  const t = ze(e);\n  return t.byteLength >= 24 && t.getUint32(0, xt) === 2303741511 ? {\n    mimeType: \"image/png\",\n    width: t.getUint32(16, xt),\n    height: t.getUint32(20, xt)\n  } : null;\n}\nfunction rg(e) {\n  const t = ze(e);\n  return t.byteLength >= 10 && t.getUint32(0, xt) === 1195984440 ? {\n    mimeType: \"image/gif\",\n    width: t.getUint16(6, xe),\n    height: t.getUint16(8, xe)\n  } : null;\n}\nfunction ig(e) {\n  const t = ze(e);\n  return t.byteLength >= 14 && t.getUint16(0, xt) === 16973 && t.getUint32(2, xe) === t.byteLength ? {\n    mimeType: \"image/bmp\",\n    width: t.getUint32(18, xe),\n    height: t.getUint32(22, xe)\n  } : null;\n}\nfunction og(e) {\n  const t = ze(e);\n  if (!(t.byteLength >= 3 && t.getUint16(0, xt) === 65496 && t.getUint8(2) === 255))\n    return null;\n  const {\n    tableMarkers: s,\n    sofMarkers: r\n  } = ag();\n  let i = 2;\n  for (; i + 9 < t.byteLength; ) {\n    const o = t.getUint16(i, xt);\n    if (r.has(o))\n      return {\n        mimeType: \"image/jpeg\",\n        height: t.getUint16(i + 5, xt),\n        width: t.getUint16(i + 7, xt)\n      };\n    if (!s.has(o))\n      return null;\n    i += 2, i += t.getUint16(i, xt);\n  }\n  return null;\n}\nfunction ag() {\n  const e = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);\n  for (let n = 65504; n < 65520; ++n)\n    e.add(n);\n  return {\n    tableMarkers: e,\n    sofMarkers: /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502])\n  };\n}\nfunction ze(e) {\n  if (e instanceof DataView)\n    return e;\n  if (ArrayBuffer.isView(e))\n    return new DataView(e.buffer);\n  if (e instanceof ArrayBuffer)\n    return new DataView(e);\n  throw new Error(\"toDataView\");\n}\nasync function cg(e, t) {\n  var n;\n  const {\n    mimeType: s\n  } = yr(e) || {}, r = (n = globalThis.loaders) === null || n === void 0 ? void 0 : n.parseImageNode;\n  return U(r), await r(e, s);\n}\nasync function ug(e, t, n) {\n  t = t || {};\n  const r = (t.image || {}).type || \"auto\", {\n    url: i\n  } = n || {}, o = lg(r);\n  let a;\n  switch (o) {\n    case \"imagebitmap\":\n      a = await Xm(e, t, i);\n      break;\n    case \"image\":\n      a = await Ia(e, t, i);\n      break;\n    case \"data\":\n      a = await cg(e);\n      break;\n    default:\n      U(!1);\n  }\n  return r === \"data\" && (a = Ra(a)), a;\n}\nfunction lg(e) {\n  switch (e) {\n    case \"auto\":\n    case \"data\":\n      return Hm();\n    default:\n      return Um(e), e;\n  }\n}\nconst hg = [\"png\", \"jpg\", \"jpeg\", \"gif\", \"webp\", \"bmp\", \"ico\", \"svg\", \"avif\"], fg = [\"image/png\", \"image/jpeg\", \"image/gif\", \"image/webp\", \"image/avif\", \"image/bmp\", \"image/vnd.microsoft.icon\", \"image/svg+xml\"], dg = {\n  image: {\n    type: \"auto\",\n    decode: !0\n  }\n}, mg = {\n  id: \"image\",\n  module: \"images\",\n  name: \"Images\",\n  version: Gm,\n  mimeTypes: fg,\n  extensions: hg,\n  parse: ug,\n  tests: [(e) => !!yr(new DataView(e))],\n  options: dg\n}, Es = {};\nfunction gg(e) {\n  if (Es[e] === void 0) {\n    const t = Ln ? pg(e) : Ag(e);\n    Es[e] = t;\n  }\n  return Es[e];\n}\nfunction Ag(e) {\n  var t, n;\n  const s = [\"image/png\", \"image/jpeg\", \"image/gif\"], r = ((t = globalThis.loaders) === null || t === void 0 ? void 0 : t.imageFormatsNode) || s;\n  return !!((n = globalThis.loaders) === null || n === void 0 ? void 0 : n.parseImageNode) && r.includes(e);\n}\nfunction pg(e) {\n  switch (e) {\n    case \"image/avif\":\n    case \"image/webp\":\n      return yg(e);\n    default:\n      return !0;\n  }\n}\nfunction yg(e) {\n  try {\n    return document.createElement(\"canvas\").toDataURL(e).indexOf(`data:${e}`) === 0;\n  } catch {\n    return !1;\n  }\n}\nfunction gt(e, t) {\n  if (!e)\n    throw new Error(t || \"assert failed: gltf\");\n}\nconst Sa = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n}, xa = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n}, Bg = 1.33, Vi = [\"SCALAR\", \"VEC2\", \"VEC3\", \"VEC4\"], Cg = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]], Eg = new Map(Cg), Tg = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n}, bg = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n}, _g = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nfunction Oa(e) {\n  return Vi[e - 1] || Vi[0];\n}\nfunction Br(e) {\n  const t = Eg.get(e.constructor);\n  if (!t)\n    throw new Error(\"Illegal typed array\");\n  return t;\n}\nfunction Cr(e, t) {\n  const n = _g[e.componentType], s = Tg[e.type], r = bg[e.componentType], i = e.count * s, o = e.count * s * r;\n  gt(o >= 0 && o <= t.byteLength);\n  const a = xa[e.componentType], c = Sa[e.type];\n  return {\n    ArrayType: n,\n    length: i,\n    byteLength: o,\n    componentByteSize: a,\n    numberOfComponentsInElement: c\n  };\n}\nfunction Fa(e) {\n  let {\n    images: t,\n    bufferViews: n\n  } = e;\n  t = t || [], n = n || [];\n  const s = t.map((o) => o.bufferView);\n  n = n.filter((o) => !s.includes(o));\n  const r = n.reduce((o, a) => o + a.byteLength, 0), i = t.reduce((o, a) => {\n    const {\n      width: c,\n      height: u\n    } = a.image;\n    return o + c * u;\n  }, 0);\n  return r + Math.ceil(4 * i * Bg);\n}\nfunction wg(e, t, n) {\n  const s = e.bufferViews[n];\n  gt(s);\n  const r = s.buffer, i = t[r];\n  gt(i);\n  const o = (s.byteOffset || 0) + i.byteOffset;\n  return new Uint8Array(i.arrayBuffer, o, s.byteLength);\n}\nfunction Rg(e, t, n) {\n  var s, r;\n  const i = typeof n == \"number\" ? (s = e.accessors) === null || s === void 0 ? void 0 : s[n] : n;\n  if (!i)\n    throw new Error(`No gltf accessor ${JSON.stringify(n)}`);\n  const o = (r = e.bufferViews) === null || r === void 0 ? void 0 : r[i.bufferView || 0];\n  if (!o)\n    throw new Error(`No gltf buffer view for accessor ${o}`);\n  const {\n    arrayBuffer: a,\n    byteOffset: c\n  } = t[o.buffer], u = (c || 0) + (i.byteOffset || 0) + (o.byteOffset || 0), {\n    ArrayType: l,\n    length: h,\n    componentByteSize: f,\n    numberOfComponentsInElement: d\n  } = Cr(i, o), m = f * d, g = o.byteStride || m;\n  if (typeof o.byteStride > \"u\" || o.byteStride === m)\n    return new l(a, u, h);\n  const p = new l(h);\n  for (let C = 0; C < i.count; C++) {\n    const w = new l(a, u + C * g, d);\n    p.set(w, C * d);\n  }\n  return p;\n}\nfunction Mg() {\n  return {\n    asset: {\n      version: \"2.0\",\n      generator: \"loaders.gl\"\n    },\n    buffers: [],\n    extensions: {},\n    extensionsRequired: [],\n    extensionsUsed: []\n  };\n}\nclass it {\n  constructor(t) {\n    this.gltf = void 0, this.sourceBuffers = void 0, this.byteLength = void 0, this.gltf = {\n      json: (t == null ? void 0 : t.json) || Mg(),\n      buffers: (t == null ? void 0 : t.buffers) || [],\n      images: (t == null ? void 0 : t.images) || []\n    }, this.sourceBuffers = [], this.byteLength = 0, this.gltf.buffers && this.gltf.buffers[0] && (this.byteLength = this.gltf.buffers[0].byteLength, this.sourceBuffers = [this.gltf.buffers[0]]);\n  }\n  get json() {\n    return this.gltf.json;\n  }\n  getApplicationData(t) {\n    return this.json[t];\n  }\n  getExtraData(t) {\n    return (this.json.extras || {})[t];\n  }\n  hasExtension(t) {\n    const n = this.getUsedExtensions().find((r) => r === t), s = this.getRequiredExtensions().find((r) => r === t);\n    return typeof n == \"string\" || typeof s == \"string\";\n  }\n  getExtension(t) {\n    const n = this.getUsedExtensions().find((r) => r === t), s = this.json.extensions || {};\n    return n ? s[t] : null;\n  }\n  getRequiredExtension(t) {\n    return this.getRequiredExtensions().find((s) => s === t) ? this.getExtension(t) : null;\n  }\n  getRequiredExtensions() {\n    return this.json.extensionsRequired || [];\n  }\n  getUsedExtensions() {\n    return this.json.extensionsUsed || [];\n  }\n  getRemovedExtensions() {\n    return this.json.extensionsRemoved || [];\n  }\n  getObjectExtension(t, n) {\n    return (t.extensions || {})[n];\n  }\n  getScene(t) {\n    return this.getObject(\"scenes\", t);\n  }\n  getNode(t) {\n    return this.getObject(\"nodes\", t);\n  }\n  getSkin(t) {\n    return this.getObject(\"skins\", t);\n  }\n  getMesh(t) {\n    return this.getObject(\"meshes\", t);\n  }\n  getMaterial(t) {\n    return this.getObject(\"materials\", t);\n  }\n  getAccessor(t) {\n    return this.getObject(\"accessors\", t);\n  }\n  getTexture(t) {\n    return this.getObject(\"textures\", t);\n  }\n  getSampler(t) {\n    return this.getObject(\"samplers\", t);\n  }\n  getImage(t) {\n    return this.getObject(\"images\", t);\n  }\n  getBufferView(t) {\n    return this.getObject(\"bufferViews\", t);\n  }\n  getBuffer(t) {\n    return this.getObject(\"buffers\", t);\n  }\n  getObject(t, n) {\n    if (typeof n == \"object\")\n      return n;\n    const s = this.json[t] && this.json[t][n];\n    if (!s)\n      throw new Error(`glTF file error: Could not find ${t}[${n}]`);\n    return s;\n  }\n  getTypedArrayForBufferView(t) {\n    t = this.getBufferView(t);\n    const n = t.buffer, s = this.gltf.buffers[n];\n    gt(s);\n    const r = (t.byteOffset || 0) + s.byteOffset;\n    return new Uint8Array(s.arrayBuffer, r, t.byteLength);\n  }\n  getTypedArrayForAccessor(t) {\n    const n = this.getAccessor(t);\n    return Rg(this.gltf.json, this.gltf.buffers, n);\n  }\n  getTypedArrayForImageData(t) {\n    t = this.getAccessor(t);\n    const n = this.getBufferView(t.bufferView), r = this.getBuffer(n.buffer).data, i = n.byteOffset || 0;\n    return new Uint8Array(r, i, n.byteLength);\n  }\n  addApplicationData(t, n) {\n    return this.json[t] = n, this;\n  }\n  addExtraData(t, n) {\n    return this.json.extras = this.json.extras || {}, this.json.extras[t] = n, this;\n  }\n  addObjectExtension(t, n, s) {\n    return t.extensions = t.extensions || {}, t.extensions[n] = s, this.registerUsedExtension(n), this;\n  }\n  setObjectExtension(t, n, s) {\n    const r = t.extensions || {};\n    r[n] = s;\n  }\n  removeObjectExtension(t, n) {\n    const s = (t == null ? void 0 : t.extensions) || {};\n    if (s[n]) {\n      this.json.extensionsRemoved = this.json.extensionsRemoved || [];\n      const r = this.json.extensionsRemoved;\n      r.includes(n) || r.push(n);\n    }\n    delete s[n];\n  }\n  addExtension(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return gt(n), this.json.extensions = this.json.extensions || {}, this.json.extensions[t] = n, this.registerUsedExtension(t), n;\n  }\n  addRequiredExtension(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return gt(n), this.addExtension(t, n), this.registerRequiredExtension(t), n;\n  }\n  registerUsedExtension(t) {\n    this.json.extensionsUsed = this.json.extensionsUsed || [], this.json.extensionsUsed.find((n) => n === t) || this.json.extensionsUsed.push(t);\n  }\n  registerRequiredExtension(t) {\n    this.registerUsedExtension(t), this.json.extensionsRequired = this.json.extensionsRequired || [], this.json.extensionsRequired.find((n) => n === t) || this.json.extensionsRequired.push(t);\n  }\n  removeExtension(t) {\n    var n;\n    if ((n = this.json.extensions) !== null && n !== void 0 && n[t]) {\n      this.json.extensionsRemoved = this.json.extensionsRemoved || [];\n      const s = this.json.extensionsRemoved;\n      s.includes(t) || s.push(t);\n    }\n    this.json.extensions && delete this.json.extensions[t], this.json.extensionsRequired && this._removeStringFromArray(this.json.extensionsRequired, t), this.json.extensionsUsed && this._removeStringFromArray(this.json.extensionsUsed, t);\n  }\n  setDefaultScene(t) {\n    this.json.scene = t;\n  }\n  addScene(t) {\n    const {\n      nodeIndices: n\n    } = t;\n    return this.json.scenes = this.json.scenes || [], this.json.scenes.push({\n      nodes: n\n    }), this.json.scenes.length - 1;\n  }\n  addNode(t) {\n    const {\n      meshIndex: n,\n      matrix: s\n    } = t;\n    this.json.nodes = this.json.nodes || [];\n    const r = {\n      mesh: n\n    };\n    return s && (r.matrix = s), this.json.nodes.push(r), this.json.nodes.length - 1;\n  }\n  addMesh(t) {\n    const {\n      attributes: n,\n      indices: s,\n      material: r,\n      mode: i = 4\n    } = t, a = {\n      primitives: [{\n        attributes: this._addAttributes(n),\n        mode: i\n      }]\n    };\n    if (s) {\n      const c = this._addIndices(s);\n      a.primitives[0].indices = c;\n    }\n    return Number.isFinite(r) && (a.primitives[0].material = r), this.json.meshes = this.json.meshes || [], this.json.meshes.push(a), this.json.meshes.length - 1;\n  }\n  addPointCloud(t) {\n    const s = {\n      primitives: [{\n        attributes: this._addAttributes(t),\n        mode: 0\n      }]\n    };\n    return this.json.meshes = this.json.meshes || [], this.json.meshes.push(s), this.json.meshes.length - 1;\n  }\n  addImage(t, n) {\n    const s = yr(t), r = n || (s == null ? void 0 : s.mimeType), o = {\n      bufferView: this.addBufferView(t),\n      mimeType: r\n    };\n    return this.json.images = this.json.images || [], this.json.images.push(o), this.json.images.length - 1;\n  }\n  addBufferView(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.byteLength;\n    const r = t.byteLength;\n    gt(Number.isFinite(r)), this.sourceBuffers = this.sourceBuffers || [], this.sourceBuffers.push(t);\n    const i = {\n      buffer: n,\n      byteOffset: s,\n      byteLength: r\n    };\n    return this.byteLength += Je(r, 4), this.json.bufferViews = this.json.bufferViews || [], this.json.bufferViews.push(i), this.json.bufferViews.length - 1;\n  }\n  addAccessor(t, n) {\n    const s = {\n      bufferView: t,\n      type: Oa(n.size),\n      componentType: n.componentType,\n      count: n.count,\n      max: n.max,\n      min: n.min\n    };\n    return this.json.accessors = this.json.accessors || [], this.json.accessors.push(s), this.json.accessors.length - 1;\n  }\n  addBinaryBuffer(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n      size: 3\n    };\n    const s = this.addBufferView(t);\n    let r = {\n      min: n.min,\n      max: n.max\n    };\n    (!r.min || !r.max) && (r = this._getAccessorMinMax(t, n.size));\n    const i = {\n      size: n.size,\n      componentType: Br(t),\n      count: Math.round(t.length / n.size),\n      min: r.min,\n      max: r.max\n    };\n    return this.addAccessor(s, Object.assign(i, n));\n  }\n  addTexture(t) {\n    const {\n      imageIndex: n\n    } = t, s = {\n      source: n\n    };\n    return this.json.textures = this.json.textures || [], this.json.textures.push(s), this.json.textures.length - 1;\n  }\n  addMaterial(t) {\n    return this.json.materials = this.json.materials || [], this.json.materials.push(t), this.json.materials.length - 1;\n  }\n  createBinaryChunk() {\n    var t, n;\n    this.gltf.buffers = [];\n    const s = this.byteLength, r = new ArrayBuffer(s), i = new Uint8Array(r);\n    let o = 0;\n    for (const a of this.sourceBuffers || [])\n      o = du(a, i, o);\n    (t = this.json) !== null && t !== void 0 && (n = t.buffers) !== null && n !== void 0 && n[0] ? this.json.buffers[0].byteLength = s : this.json.buffers = [{\n      byteLength: s\n    }], this.gltf.binary = r, this.sourceBuffers = [r];\n  }\n  _removeStringFromArray(t, n) {\n    let s = !0;\n    for (; s; ) {\n      const r = t.indexOf(n);\n      r > -1 ? t.splice(r, 1) : s = !1;\n    }\n  }\n  _addAttributes() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const n = {};\n    for (const s in t) {\n      const r = t[s], i = this._getGltfAttributeName(s), o = this.addBinaryBuffer(r.value, r);\n      n[i] = o;\n    }\n    return n;\n  }\n  _addIndices(t) {\n    return this.addBinaryBuffer(t, {\n      size: 1\n    });\n  }\n  _getGltfAttributeName(t) {\n    switch (t.toLowerCase()) {\n      case \"position\":\n      case \"positions\":\n      case \"vertices\":\n        return \"POSITION\";\n      case \"normal\":\n      case \"normals\":\n        return \"NORMAL\";\n      case \"color\":\n      case \"colors\":\n        return \"COLOR_0\";\n      case \"texcoord\":\n      case \"texcoords\":\n        return \"TEXCOORD_0\";\n      default:\n        return t;\n    }\n  }\n  _getAccessorMinMax(t, n) {\n    const s = {\n      min: null,\n      max: null\n    };\n    if (t.length < n)\n      return s;\n    s.min = [], s.max = [];\n    const r = t.subarray(0, n);\n    for (const i of r)\n      s.min.push(i), s.max.push(i);\n    for (let i = n; i < t.length; i += n)\n      for (let o = 0; o < n; o++)\n        s.min[0 + o] = Math.min(s.min[0 + o], t[i + o]), s.max[0 + o] = Math.max(s.max[0 + o], t[i + o]);\n    return s;\n  }\n}\nfunction ji(e) {\n  return (e % 1 + 1) % 1;\n}\nconst va = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16,\n  BOOLEAN: 1,\n  STRING: 1,\n  ENUM: 1\n}, Ig = {\n  INT8: Int8Array,\n  UINT8: Uint8Array,\n  INT16: Int16Array,\n  UINT16: Uint16Array,\n  INT32: Int32Array,\n  UINT32: Uint32Array,\n  INT64: BigInt64Array,\n  UINT64: BigUint64Array,\n  FLOAT32: Float32Array,\n  FLOAT64: Float64Array\n}, Da = {\n  INT8: 1,\n  UINT8: 1,\n  INT16: 2,\n  UINT16: 2,\n  INT32: 4,\n  UINT32: 4,\n  INT64: 8,\n  UINT64: 8,\n  FLOAT32: 4,\n  FLOAT64: 8\n};\nfunction Er(e, t) {\n  return Da[t] * va[e];\n}\nfunction jn(e, t, n, s) {\n  if (n !== \"UINT8\" && n !== \"UINT16\" && n !== \"UINT32\" && n !== \"UINT64\")\n    return null;\n  const r = e.getTypedArrayForBufferView(t), i = kn(r, \"SCALAR\", n, s + 1);\n  return i instanceof BigInt64Array || i instanceof BigUint64Array ? null : i;\n}\nfunction kn(e, t, n) {\n  let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n  const r = va[t], i = Ig[n], o = Da[n], a = s * r, c = a * o;\n  let u = e.buffer, l = e.byteOffset;\n  return l % o !== 0 && (u = new Uint8Array(u).slice(l, l + c).buffer, l = 0), new i(u, l, a);\n}\nfunction Tr(e, t, n) {\n  var s, r;\n  const i = `TEXCOORD_${t.texCoord || 0}`, o = n.attributes[i], a = e.getTypedArrayForAccessor(o), c = e.gltf.json, u = t.index, l = (s = c.textures) === null || s === void 0 || (r = s[u]) === null || r === void 0 ? void 0 : r.source;\n  if (typeof l < \"u\") {\n    var h, f, d;\n    const m = (h = c.images) === null || h === void 0 || (f = h[l]) === null || f === void 0 ? void 0 : f.mimeType, g = (d = e.gltf.images) === null || d === void 0 ? void 0 : d[l];\n    if (g && typeof g.width < \"u\") {\n      const p = [];\n      for (let C = 0; C < a.length; C += 2) {\n        const w = Sg(g, m, a, C, t.channels);\n        p.push(w);\n      }\n      return p;\n    }\n  }\n  return [];\n}\nfunction La(e, t, n, s, r) {\n  if (!(n != null && n.length))\n    return;\n  const i = [];\n  for (const l of n) {\n    let h = s.findIndex((f) => f === l);\n    h === -1 && (h = s.push(l) - 1), i.push(h);\n  }\n  const o = new Uint32Array(i), a = e.gltf.buffers.push({\n    arrayBuffer: o.buffer,\n    byteOffset: o.byteOffset,\n    byteLength: o.byteLength\n  }) - 1, c = e.addBufferView(o, a, 0), u = e.addAccessor(c, {\n    size: 1,\n    componentType: Br(o),\n    count: o.length\n  });\n  r.attributes[t] = u;\n}\nfunction Sg(e, t, n, s) {\n  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [0];\n  const i = {\n    r: {\n      offset: 0,\n      shift: 0\n    },\n    g: {\n      offset: 1,\n      shift: 8\n    },\n    b: {\n      offset: 2,\n      shift: 16\n    },\n    a: {\n      offset: 3,\n      shift: 24\n    }\n  }, o = n[s], a = n[s + 1];\n  let c = 1;\n  t && (t.indexOf(\"image/jpeg\") !== -1 || t.indexOf(\"image/png\") !== -1) && (c = 4);\n  const u = xg(o, a, e, c);\n  let l = 0;\n  for (const h of r) {\n    const f = typeof h == \"number\" ? Object.values(i)[h] : i[h], d = u + f.offset, m = Ra(e);\n    if (m.data.length <= d)\n      throw new Error(`${m.data.length} <= ${d}`);\n    const g = m.data[d];\n    l |= g << f.shift;\n  }\n  return l;\n}\nfunction xg(e, t, n) {\n  let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n  const r = n.width, i = ji(e) * (r - 1), o = Math.round(i), a = n.height, c = ji(t) * (a - 1), u = Math.round(c), l = n.components ? n.components : s;\n  return (u * r + o) * l;\n}\nfunction Ga(e, t, n, s, r) {\n  const i = [];\n  for (let o = 0; o < t; o++) {\n    const a = n[o], c = n[o + 1] - n[o];\n    if (c + a > s)\n      break;\n    const u = a / r, l = c / r;\n    i.push(e.slice(u, u + l));\n  }\n  return i;\n}\nfunction Pa(e, t, n) {\n  const s = [];\n  for (let r = 0; r < t; r++) {\n    const i = r * n;\n    s.push(e.slice(i, i + n));\n  }\n  return s;\n}\nfunction Na(e, t, n, s) {\n  if (n)\n    throw new Error(\"Not implemented - arrayOffsets for strings is specified\");\n  if (s) {\n    const r = [], i = new TextDecoder(\"utf8\");\n    let o = 0;\n    for (let a = 0; a < e; a++) {\n      const c = s[a + 1] - s[a];\n      if (c + o <= t.length) {\n        const u = t.subarray(o, c + o), l = i.decode(u);\n        r.push(l), o += c;\n      }\n    }\n    return r;\n  }\n  return [];\n}\nconst Ua = \"EXT_mesh_features\", Og = Ua;\nasync function Fg(e, t) {\n  const n = new it(e);\n  vg(n, t);\n}\nfunction vg(e, t) {\n  const n = e.gltf.json;\n  if (n.meshes)\n    for (const s of n.meshes)\n      for (const r of s.primitives)\n        Dg(e, r, t);\n}\nfunction Dg(e, t, n) {\n  var s, r;\n  if (!(n != null && (s = n.gltf) !== null && s !== void 0 && s.loadBuffers))\n    return;\n  const i = (r = t.extensions) === null || r === void 0 ? void 0 : r[Ua], o = i == null ? void 0 : i.featureIds;\n  if (o)\n    for (const c of o) {\n      var a;\n      let u;\n      if (typeof c.attribute < \"u\") {\n        const l = `_FEATURE_ID_${c.attribute}`, h = t.attributes[l];\n        u = e.getTypedArrayForAccessor(h);\n      } else\n        typeof c.texture < \"u\" && n !== null && n !== void 0 && (a = n.gltf) !== null && a !== void 0 && a.loadImages ? u = Tr(e, c.texture, t) : u = [];\n      c.data = u;\n    }\n}\nconst Lg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: Fg,\n  name: Og\n}, Symbol.toStringTag, { value: \"Module\" })), br = \"EXT_structural_metadata\", Gg = br;\nasync function Pg(e, t) {\n  const n = new it(e);\n  Ng(n, t);\n}\nfunction Ng(e, t) {\n  var n, s;\n  if (!((n = t.gltf) !== null && n !== void 0 && n.loadBuffers))\n    return;\n  const r = e.getExtension(br);\n  r && ((s = t.gltf) !== null && s !== void 0 && s.loadImages && Ug(e, r), Hg(e, r));\n}\nfunction Ug(e, t) {\n  const n = t.propertyTextures, s = e.gltf.json;\n  if (n && s.meshes)\n    for (const r of s.meshes)\n      for (const i of r.primitives)\n        Vg(e, n, i, t);\n}\nfunction Hg(e, t) {\n  const n = t.schema;\n  if (!n)\n    return;\n  const s = n.classes, r = t.propertyTables;\n  if (s && r)\n    for (const i in s) {\n      const o = Jg(r, i);\n      o && kg(e, n, o);\n    }\n}\nfunction Jg(e, t) {\n  for (const n of e)\n    if (n.class === t)\n      return n;\n  return null;\n}\nfunction Vg(e, t, n, s) {\n  var r;\n  if (!t)\n    return;\n  const i = (r = n.extensions) === null || r === void 0 ? void 0 : r[br], o = i == null ? void 0 : i.propertyTextures;\n  if (o)\n    for (const a of o) {\n      const c = t[a];\n      jg(e, c, n, s);\n    }\n}\nfunction jg(e, t, n, s) {\n  if (!t.properties)\n    return;\n  s.dataAttributeNames || (s.dataAttributeNames = []);\n  const r = t.class;\n  for (const o in t.properties) {\n    var i;\n    const a = `${r}_${o}`, c = (i = t.properties) === null || i === void 0 ? void 0 : i[o];\n    if (!c)\n      continue;\n    c.data || (c.data = []);\n    const u = c.data, l = Tr(e, c, n);\n    l !== null && (La(e, a, l, u, n), c.data = u, s.dataAttributeNames.push(a));\n  }\n}\nfunction kg(e, t, n) {\n  var s;\n  const r = (s = t.classes) === null || s === void 0 ? void 0 : s[n.class];\n  if (!r)\n    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${n.class}`);\n  const i = n.count;\n  for (const a in r.properties) {\n    var o;\n    const c = r.properties[a], u = (o = n.properties) === null || o === void 0 ? void 0 : o[a];\n    if (u) {\n      const l = Kg(e, t, c, i, u);\n      u.data = l;\n    }\n  }\n}\nfunction Kg(e, t, n, s, r) {\n  let i = [];\n  const o = r.values, a = e.getTypedArrayForBufferView(o), c = zg(e, n, r, s), u = Wg(e, r, s);\n  switch (n.type) {\n    case \"SCALAR\":\n    case \"VEC2\":\n    case \"VEC3\":\n    case \"VEC4\":\n    case \"MAT2\":\n    case \"MAT3\":\n    case \"MAT4\": {\n      i = Xg(n, s, a, c);\n      break;\n    }\n    case \"BOOLEAN\":\n      throw new Error(`Not implemented - classProperty.type=${n.type}`);\n    case \"STRING\": {\n      i = Na(s, a, c, u);\n      break;\n    }\n    case \"ENUM\": {\n      i = Qg(t, n, s, a, c);\n      break;\n    }\n    default:\n      throw new Error(`Unknown classProperty type ${n.type}`);\n  }\n  return i;\n}\nfunction zg(e, t, n, s) {\n  return t.array && typeof t.count > \"u\" && typeof n.arrayOffsets < \"u\" ? jn(e, n.arrayOffsets, n.arrayOffsetType || \"UINT32\", s) : null;\n}\nfunction Wg(e, t, n) {\n  return typeof t.stringOffsets < \"u\" ? jn(e, t.stringOffsets, t.stringOffsetType || \"UINT32\", n) : null;\n}\nfunction Xg(e, t, n, s) {\n  const r = e.array, i = e.count, o = Er(e.type, e.componentType), a = n.byteLength / o;\n  let c;\n  return e.componentType ? c = kn(n, e.type, e.componentType, a) : c = n, r ? s ? Ga(c, t, s, n.length, o) : i ? Pa(c, t, i) : [] : c;\n}\nfunction Qg(e, t, n, s, r) {\n  var i;\n  const o = t.enumType;\n  if (!o)\n    throw new Error(\"Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM\");\n  const a = (i = e.enums) === null || i === void 0 ? void 0 : i[o];\n  if (!a)\n    throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${o}`);\n  const c = a.valueType || \"UINT16\", u = Er(t.type, c), l = s.byteLength / u;\n  let h = kn(s, t.type, c, l);\n  if (h || (h = s), t.array) {\n    if (r)\n      return qg({\n        valuesData: h,\n        numberOfElements: n,\n        arrayOffsets: r,\n        valuesDataBytesLength: s.length,\n        elementSize: u,\n        enumEntry: a\n      });\n    const f = t.count;\n    return f ? Yg(h, n, f, a) : [];\n  }\n  return _r(h, 0, n, a);\n}\nfunction qg(e) {\n  const {\n    valuesData: t,\n    numberOfElements: n,\n    arrayOffsets: s,\n    valuesDataBytesLength: r,\n    elementSize: i,\n    enumEntry: o\n  } = e, a = [];\n  for (let c = 0; c < n; c++) {\n    const u = s[c], l = s[c + 1] - s[c];\n    if (l + u > r)\n      break;\n    const h = u / i, f = l / i, d = _r(t, h, f, o);\n    a.push(d);\n  }\n  return a;\n}\nfunction Yg(e, t, n, s) {\n  const r = [];\n  for (let i = 0; i < t; i++) {\n    const o = n * i, a = _r(e, o, n, s);\n    r.push(a);\n  }\n  return r;\n}\nfunction _r(e, t, n, s) {\n  const r = [];\n  for (let i = 0; i < n; i++)\n    if (e instanceof BigInt64Array || e instanceof BigUint64Array)\n      r.push(\"\");\n    else {\n      const o = e[t + i], a = $g(s, o);\n      a ? r.push(a.name) : r.push(\"\");\n    }\n  return r;\n}\nfunction $g(e, t) {\n  for (const n of e.values)\n    if (n.value === t)\n      return n;\n  return null;\n}\nconst Zg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: Pg,\n  name: Gg\n}, Symbol.toStringTag, { value: \"Module\" })), Ha = \"EXT_feature_metadata\", t0 = Ha;\nasync function e0(e, t) {\n  const n = new it(e);\n  n0(n, t);\n}\nfunction n0(e, t) {\n  var n, s;\n  if (!((n = t.gltf) !== null && n !== void 0 && n.loadBuffers))\n    return;\n  const r = e.getExtension(Ha);\n  r && ((s = t.gltf) !== null && s !== void 0 && s.loadImages && s0(e, r), r0(e, r));\n}\nfunction s0(e, t) {\n  const n = t.schema;\n  if (!n)\n    return;\n  const s = n.classes, {\n    featureTextures: r\n  } = t;\n  if (s && r)\n    for (const i in s) {\n      const o = s[i], a = o0(r, i);\n      a && c0(e, a, o);\n    }\n}\nfunction r0(e, t) {\n  const n = t.schema;\n  if (!n)\n    return;\n  const s = n.classes, r = t.featureTables;\n  if (s && r)\n    for (const i in s) {\n      const o = i0(r, i);\n      o && a0(e, n, o);\n    }\n}\nfunction i0(e, t) {\n  for (const n in e) {\n    const s = e[n];\n    if (s.class === t)\n      return s;\n  }\n  return null;\n}\nfunction o0(e, t) {\n  for (const n in e) {\n    const s = e[n];\n    if (s.class === t)\n      return s;\n  }\n  return null;\n}\nfunction a0(e, t, n) {\n  var s;\n  if (!n.class)\n    return;\n  const r = (s = t.classes) === null || s === void 0 ? void 0 : s[n.class];\n  if (!r)\n    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${n.class}`);\n  const i = n.count;\n  for (const a in r.properties) {\n    var o;\n    const c = r.properties[a], u = (o = n.properties) === null || o === void 0 ? void 0 : o[a];\n    if (u) {\n      const l = u0(e, t, c, i, u);\n      u.data = l;\n    }\n  }\n}\nfunction c0(e, t, n) {\n  const s = t.class;\n  for (const i in n.properties) {\n    var r;\n    const o = t == null || (r = t.properties) === null || r === void 0 ? void 0 : r[i];\n    if (o) {\n      const a = m0(e, o, s);\n      o.data = a;\n    }\n  }\n}\nfunction u0(e, t, n, s, r) {\n  let i = [];\n  const o = r.bufferView, a = e.getTypedArrayForBufferView(o), c = l0(e, n, r, s), u = h0(e, n, r, s);\n  return n.type === \"STRING\" || n.componentType === \"STRING\" ? i = Na(s, a, c, u) : f0(n) && (i = d0(n, s, a, c)), i;\n}\nfunction l0(e, t, n, s) {\n  return t.type === \"ARRAY\" && typeof t.componentCount > \"u\" && typeof n.arrayOffsetBufferView < \"u\" ? jn(e, n.arrayOffsetBufferView, n.offsetType || \"UINT32\", s) : null;\n}\nfunction h0(e, t, n, s) {\n  return typeof n.stringOffsetBufferView < \"u\" ? jn(e, n.stringOffsetBufferView, n.offsetType || \"UINT32\", s) : null;\n}\nfunction f0(e) {\n  const t = [\"UINT8\", \"INT16\", \"UINT16\", \"INT32\", \"UINT32\", \"INT64\", \"UINT64\", \"FLOAT32\", \"FLOAT64\"];\n  return t.includes(e.type) || typeof e.componentType < \"u\" && t.includes(e.componentType);\n}\nfunction d0(e, t, n, s) {\n  const r = e.type === \"ARRAY\", i = e.componentCount, o = \"SCALAR\", a = e.componentType || e.type, c = Er(o, a), u = n.byteLength / c, l = kn(n, o, a, u);\n  return r ? s ? Ga(l, t, s, n.length, c) : i ? Pa(l, t, i) : [] : l;\n}\nfunction m0(e, t, n) {\n  const s = e.gltf.json;\n  if (!s.meshes)\n    return [];\n  const r = [];\n  for (const i of s.meshes)\n    for (const o of i.primitives)\n      g0(e, n, t, r, o);\n  return r;\n}\nfunction g0(e, t, n, s, r) {\n  const i = {\n    channels: n.channels,\n    ...n.texture\n  }, o = Tr(e, i, r);\n  o && La(e, t, o, s, r);\n}\nconst A0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: e0,\n  name: t0\n}, Symbol.toStringTag, { value: \"Module\" })), p0 = \"4.1.1\", y0 = \"4.1.1\", In = {\n  TRANSCODER: \"basis_transcoder.js\",\n  TRANSCODER_WASM: \"basis_transcoder.wasm\",\n  ENCODER: \"basis_encoder.js\",\n  ENCODER_WASM: \"basis_encoder.wasm\"\n};\nlet Ts;\nasync function ki(e) {\n  const t = e.modules || {};\n  return t.basis ? t.basis : (Ts = Ts || B0(e), await Ts);\n}\nasync function B0(e) {\n  let t = null, n = null;\n  return [t, n] = await Promise.all([await Xt(In.TRANSCODER, \"textures\", e), await Xt(In.TRANSCODER_WASM, \"textures\", e)]), t = t || globalThis.BASIS, await C0(t, n);\n}\nfunction C0(e, t) {\n  const n = {};\n  return t && (n.wasmBinary = t), new Promise((s) => {\n    e(n).then((r) => {\n      const {\n        BasisFile: i,\n        initializeBasis: o\n      } = r;\n      o(), s({\n        BasisFile: i\n      });\n    });\n  });\n}\nlet bs;\nasync function Ki(e) {\n  const t = e.modules || {};\n  return t.basisEncoder ? t.basisEncoder : (bs = bs || E0(e), await bs);\n}\nasync function E0(e) {\n  let t = null, n = null;\n  return [t, n] = await Promise.all([await Xt(In.ENCODER, \"textures\", e), await Xt(In.ENCODER_WASM, \"textures\", e)]), t = t || globalThis.BASIS, await T0(t, n);\n}\nfunction T0(e, t) {\n  const n = {};\n  return t && (n.wasmBinary = t), new Promise((s) => {\n    e(n).then((r) => {\n      const {\n        BasisFile: i,\n        KTX2File: o,\n        initializeBasis: a,\n        BasisEncoder: c\n      } = r;\n      a(), s({\n        BasisFile: i,\n        KTX2File: o,\n        BasisEncoder: c\n      });\n    });\n  });\n}\nconst ae = {\n  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,\n  COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,\n  COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,\n  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,\n  COMPRESSED_R11_EAC: 37488,\n  COMPRESSED_SIGNED_R11_EAC: 37489,\n  COMPRESSED_RG11_EAC: 37490,\n  COMPRESSED_SIGNED_RG11_EAC: 37491,\n  COMPRESSED_RGB8_ETC2: 37492,\n  COMPRESSED_RGBA8_ETC2_EAC: 37493,\n  COMPRESSED_SRGB8_ETC2: 37494,\n  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,\n  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,\n  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,\n  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,\n  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,\n  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,\n  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,\n  COMPRESSED_RGB_ETC1_WEBGL: 36196,\n  COMPRESSED_RGB_ATC_WEBGL: 35986,\n  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,\n  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,\n  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,\n  COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,\n  COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,\n  COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,\n  COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,\n  COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,\n  COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,\n  COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,\n  COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,\n  COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,\n  COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,\n  COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,\n  COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,\n  COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,\n  COMPRESSED_RED_RGTC1_EXT: 36283,\n  COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,\n  COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,\n  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,\n  COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919\n}, b0 = [\"\", \"WEBKIT_\", \"MOZ_\"], zi = {\n  WEBGL_compressed_texture_s3tc: \"dxt\",\n  WEBGL_compressed_texture_s3tc_srgb: \"dxt-srgb\",\n  WEBGL_compressed_texture_etc1: \"etc1\",\n  WEBGL_compressed_texture_etc: \"etc2\",\n  WEBGL_compressed_texture_pvrtc: \"pvrtc\",\n  WEBGL_compressed_texture_atc: \"atc\",\n  WEBGL_compressed_texture_astc: \"astc\",\n  EXT_texture_compression_rgtc: \"rgtc\"\n};\nlet ln = null;\nfunction _0(e) {\n  if (!ln) {\n    e = e || w0() || void 0, ln = /* @__PURE__ */ new Set();\n    for (const t of b0)\n      for (const n in zi)\n        if (e && e.getExtension(`${t}${n}`)) {\n          const s = zi[n];\n          ln.add(s);\n        }\n  }\n  return ln;\n}\nfunction w0() {\n  try {\n    return document.createElement(\"canvas\").getContext(\"webgl\");\n  } catch {\n    return null;\n  }\n}\nvar Wi, Xi, Qi, qi, Yi, $i, Zi, to;\n(function(e) {\n  e[e.NONE = 0] = \"NONE\", e[e.BASISLZ = 1] = \"BASISLZ\", e[e.ZSTD = 2] = \"ZSTD\", e[e.ZLIB = 3] = \"ZLIB\";\n})(Wi || (Wi = {})), function(e) {\n  e[e.BASICFORMAT = 0] = \"BASICFORMAT\";\n}(Xi || (Xi = {})), function(e) {\n  e[e.UNSPECIFIED = 0] = \"UNSPECIFIED\", e[e.ETC1S = 163] = \"ETC1S\", e[e.UASTC = 166] = \"UASTC\";\n}(Qi || (Qi = {})), function(e) {\n  e[e.UNSPECIFIED = 0] = \"UNSPECIFIED\", e[e.SRGB = 1] = \"SRGB\";\n}(qi || (qi = {})), function(e) {\n  e[e.UNSPECIFIED = 0] = \"UNSPECIFIED\", e[e.LINEAR = 1] = \"LINEAR\", e[e.SRGB = 2] = \"SRGB\", e[e.ITU = 3] = \"ITU\", e[e.NTSC = 4] = \"NTSC\", e[e.SLOG = 5] = \"SLOG\", e[e.SLOG2 = 6] = \"SLOG2\";\n}(Yi || (Yi = {})), function(e) {\n  e[e.ALPHA_STRAIGHT = 0] = \"ALPHA_STRAIGHT\", e[e.ALPHA_PREMULTIPLIED = 1] = \"ALPHA_PREMULTIPLIED\";\n}($i || ($i = {})), function(e) {\n  e[e.RGB = 0] = \"RGB\", e[e.RRR = 3] = \"RRR\", e[e.GGG = 4] = \"GGG\", e[e.AAA = 15] = \"AAA\";\n}(Zi || (Zi = {})), function(e) {\n  e[e.RGB = 0] = \"RGB\", e[e.RGBA = 3] = \"RGBA\", e[e.RRR = 4] = \"RRR\", e[e.RRRG = 5] = \"RRRG\";\n}(to || (to = {}));\nconst dt = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];\nfunction R0(e) {\n  const t = new Uint8Array(e);\n  return !(t.byteLength < dt.length || t[0] !== dt[0] || t[1] !== dt[1] || t[2] !== dt[2] || t[3] !== dt[3] || t[4] !== dt[4] || t[5] !== dt[5] || t[6] !== dt[6] || t[7] !== dt[7] || t[8] !== dt[8] || t[9] !== dt[9] || t[10] !== dt[10] || t[11] !== dt[11]);\n}\nconst M0 = {\n  etc1: {\n    basisFormat: 0,\n    compressed: !0,\n    format: ae.COMPRESSED_RGB_ETC1_WEBGL\n  },\n  etc2: {\n    basisFormat: 1,\n    compressed: !0\n  },\n  bc1: {\n    basisFormat: 2,\n    compressed: !0,\n    format: ae.COMPRESSED_RGB_S3TC_DXT1_EXT\n  },\n  bc3: {\n    basisFormat: 3,\n    compressed: !0,\n    format: ae.COMPRESSED_RGBA_S3TC_DXT5_EXT\n  },\n  bc4: {\n    basisFormat: 4,\n    compressed: !0\n  },\n  bc5: {\n    basisFormat: 5,\n    compressed: !0\n  },\n  \"bc7-m6-opaque-only\": {\n    basisFormat: 6,\n    compressed: !0\n  },\n  \"bc7-m5\": {\n    basisFormat: 7,\n    compressed: !0\n  },\n  \"pvrtc1-4-rgb\": {\n    basisFormat: 8,\n    compressed: !0,\n    format: ae.COMPRESSED_RGB_PVRTC_4BPPV1_IMG\n  },\n  \"pvrtc1-4-rgba\": {\n    basisFormat: 9,\n    compressed: !0,\n    format: ae.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\n  },\n  \"astc-4x4\": {\n    basisFormat: 10,\n    compressed: !0,\n    format: ae.COMPRESSED_RGBA_ASTC_4X4_KHR\n  },\n  \"atc-rgb\": {\n    basisFormat: 11,\n    compressed: !0\n  },\n  \"atc-rgba-interpolated-alpha\": {\n    basisFormat: 12,\n    compressed: !0\n  },\n  rgba32: {\n    basisFormat: 13,\n    compressed: !1\n  },\n  rgb565: {\n    basisFormat: 14,\n    compressed: !1\n  },\n  bgr565: {\n    basisFormat: 15,\n    compressed: !1\n  },\n  rgba4444: {\n    basisFormat: 16,\n    compressed: !1\n  }\n};\nasync function I0(e, t) {\n  if (t.basis.containerFormat === \"auto\") {\n    if (R0(e)) {\n      const s = await Ki(t);\n      return eo(s.KTX2File, e, t);\n    }\n    const {\n      BasisFile: n\n    } = await ki(t);\n    return _s(n, e, t);\n  }\n  switch (t.basis.module) {\n    case \"encoder\":\n      const n = await Ki(t);\n      switch (t.basis.containerFormat) {\n        case \"ktx2\":\n          return eo(n.KTX2File, e, t);\n        case \"basis\":\n        default:\n          return _s(n.BasisFile, e, t);\n      }\n    case \"transcoder\":\n    default:\n      const {\n        BasisFile: s\n      } = await ki(t);\n      return _s(s, e, t);\n  }\n}\nfunction _s(e, t, n) {\n  const s = new e(new Uint8Array(t));\n  try {\n    if (!s.startTranscoding())\n      throw new Error(\"Failed to start basis transcoding\");\n    const r = s.getNumImages(), i = [];\n    for (let o = 0; o < r; o++) {\n      const a = s.getNumLevels(o), c = [];\n      for (let u = 0; u < a; u++)\n        c.push(S0(s, o, u, n));\n      i.push(c);\n    }\n    return i;\n  } finally {\n    s.close(), s.delete();\n  }\n}\nfunction S0(e, t, n, s) {\n  const r = e.getImageWidth(t, n), i = e.getImageHeight(t, n), o = e.getHasAlpha(), {\n    compressed: a,\n    format: c,\n    basisFormat: u\n  } = Ja(s, o), l = e.getImageTranscodedSizeInBytes(t, n, u), h = new Uint8Array(l);\n  if (!e.transcodeImage(h, t, n, u, 0, 0))\n    throw new Error(\"failed to start Basis transcoding\");\n  return {\n    width: r,\n    height: i,\n    data: h,\n    compressed: a,\n    format: c,\n    hasAlpha: o\n  };\n}\nfunction eo(e, t, n) {\n  const s = new e(new Uint8Array(t));\n  try {\n    if (!s.startTranscoding())\n      throw new Error(\"failed to start KTX2 transcoding\");\n    const r = s.getLevels(), i = [];\n    for (let o = 0; o < r; o++) {\n      i.push(x0(s, o, n));\n      break;\n    }\n    return [i];\n  } finally {\n    s.close(), s.delete();\n  }\n}\nfunction x0(e, t, n) {\n  const {\n    alphaFlag: s,\n    height: r,\n    width: i\n  } = e.getImageLevelInfo(t, 0, 0), {\n    compressed: o,\n    format: a,\n    basisFormat: c\n  } = Ja(n, s), u = e.getImageTranscodedSizeInBytes(t, 0, 0, c), l = new Uint8Array(u);\n  if (!e.transcodeImage(l, t, 0, 0, c, 0, -1, -1))\n    throw new Error(\"Failed to transcode KTX2 image\");\n  return {\n    width: i,\n    height: r,\n    data: l,\n    compressed: o,\n    levelSize: u,\n    hasAlpha: s,\n    format: a\n  };\n}\nfunction Ja(e, t) {\n  let n = e && e.basis && e.basis.format;\n  return n === \"auto\" && (n = Va()), typeof n == \"object\" && (n = t ? n.alpha : n.noAlpha), n = n.toLowerCase(), M0[n];\n}\nfunction Va() {\n  const e = _0();\n  return e.has(\"astc\") ? \"astc-4x4\" : e.has(\"dxt\") ? {\n    alpha: \"bc3\",\n    noAlpha: \"bc1\"\n  } : e.has(\"pvrtc\") ? {\n    alpha: \"pvrtc1-4-rgba\",\n    noAlpha: \"pvrtc1-4-rgb\"\n  } : e.has(\"etc1\") ? \"etc1\" : e.has(\"etc2\") ? \"etc2\" : \"rgb565\";\n}\nconst O0 = {\n  name: \"Basis\",\n  id: \"basis\",\n  module: \"textures\",\n  version: y0,\n  worker: !0,\n  extensions: [\"basis\", \"ktx2\"],\n  mimeTypes: [\"application/octet-stream\", \"image/ktx2\"],\n  tests: [\"sB\"],\n  binary: !0,\n  options: {\n    basis: {\n      format: \"auto\",\n      libraryPath: \"libs/\",\n      containerFormat: \"auto\",\n      module: \"transcoder\"\n    }\n  }\n}, F0 = {\n  ...O0,\n  parse: I0\n}, de = !0, no = 1735152710, wr = 12, Sn = 8, v0 = 1313821514, D0 = 5130562, L0 = 0, G0 = 0, P0 = 1;\nfunction N0(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n  return `${String.fromCharCode(e.getUint8(t + 0))}${String.fromCharCode(e.getUint8(t + 1))}${String.fromCharCode(e.getUint8(t + 2))}${String.fromCharCode(e.getUint8(t + 3))}`;\n}\nfunction U0(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n  const s = new DataView(e), {\n    magic: r = no\n  } = n, i = s.getUint32(t, !1);\n  return i === r || i === no;\n}\nfunction H0(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  const s = new DataView(t), r = N0(s, n + 0), i = s.getUint32(n + 4, de), o = s.getUint32(n + 8, de);\n  switch (Object.assign(e, {\n    header: {\n      byteOffset: n,\n      byteLength: o,\n      hasBinChunk: !1\n    },\n    type: r,\n    version: i,\n    json: {},\n    binChunks: []\n  }), n += wr, e.version) {\n    case 1:\n      return J0(e, s, n);\n    case 2:\n      return V0(e, s, n, {});\n    default:\n      throw new Error(`Invalid GLB version ${e.version}. Only supports version 1 and 2.`);\n  }\n}\nfunction J0(e, t, n) {\n  U(e.header.byteLength > wr + Sn);\n  const s = t.getUint32(n + 0, de), r = t.getUint32(n + 4, de);\n  return n += Sn, U(r === L0), zs(e, t, n, s), n += s, n += Ws(e, t, n, e.header.byteLength), n;\n}\nfunction V0(e, t, n, s) {\n  return U(e.header.byteLength > wr + Sn), j0(e, t, n, s), n + e.header.byteLength;\n}\nfunction j0(e, t, n, s) {\n  for (; n + 8 <= e.header.byteLength; ) {\n    const r = t.getUint32(n + 0, de), i = t.getUint32(n + 4, de);\n    switch (n += Sn, i) {\n      case v0:\n        zs(e, t, n, r);\n        break;\n      case D0:\n        Ws(e, t, n, r);\n        break;\n      case G0:\n        s.strict || zs(e, t, n, r);\n        break;\n      case P0:\n        s.strict || Ws(e, t, n, r);\n        break;\n    }\n    n += Je(r, 4);\n  }\n  return n;\n}\nfunction zs(e, t, n, s) {\n  const r = new Uint8Array(t.buffer, n, s), o = new TextDecoder(\"utf8\").decode(r);\n  return e.json = JSON.parse(o), Je(s, 4);\n}\nfunction Ws(e, t, n, s) {\n  return e.header.hasBinChunk = !0, e.binChunks.push({\n    byteOffset: n,\n    byteLength: s,\n    arrayBuffer: t.buffer\n  }), Je(s, 4);\n}\nfunction ja(e, t) {\n  if (e.startsWith(\"data:\") || e.startsWith(\"http:\") || e.startsWith(\"https:\"))\n    return e;\n  const s = t.baseUri || t.uri;\n  if (!s)\n    throw new Error(`'baseUri' must be provided to resolve relative url ${e}`);\n  return s.substr(0, s.lastIndexOf(\"/\") + 1) + e;\n}\nconst k0 = \"B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB\", K0 = \"B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB\", z0 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), W0 = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]), X0 = {\n  0: \"\",\n  1: \"meshopt_decodeFilterOct\",\n  2: \"meshopt_decodeFilterQuat\",\n  3: \"meshopt_decodeFilterExp\",\n  NONE: \"\",\n  OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n  QUATERNION: \"meshopt_decodeFilterQuat\",\n  EXPONENTIAL: \"meshopt_decodeFilterExp\"\n}, Q0 = {\n  0: \"meshopt_decodeVertexBuffer\",\n  1: \"meshopt_decodeIndexBuffer\",\n  2: \"meshopt_decodeIndexSequence\",\n  ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n  TRIANGLES: \"meshopt_decodeIndexBuffer\",\n  INDICES: \"meshopt_decodeIndexSequence\"\n};\nasync function q0(e, t, n, s, r) {\n  let i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"NONE\";\n  const o = await Y0();\n  tA(o, o.exports[Q0[r]], e, t, n, s, o.exports[X0[i || \"NONE\"]]);\n}\nlet ws;\nasync function Y0() {\n  return ws || (ws = $0()), ws;\n}\nasync function $0() {\n  let e = k0;\n  WebAssembly.validate(z0) && (e = K0, console.log(\"Warning: meshopt_decoder is using experimental SIMD support\"));\n  const t = await WebAssembly.instantiate(Z0(e), {});\n  return await t.instance.exports.__wasm_call_ctors(), t.instance;\n}\nfunction Z0(e) {\n  const t = new Uint8Array(e.length);\n  for (let s = 0; s < e.length; ++s) {\n    const r = e.charCodeAt(s);\n    t[s] = r > 96 ? r - 71 : r > 64 ? r - 65 : r > 47 ? r + 4 : r > 46 ? 63 : 62;\n  }\n  let n = 0;\n  for (let s = 0; s < e.length; ++s)\n    t[n++] = t[s] < 60 ? W0[t[s]] : (t[s] - 60) * 64 + t[++s];\n  return t.buffer.slice(0, n);\n}\nfunction tA(e, t, n, s, r, i, o) {\n  const a = e.exports.sbrk, c = s + 3 & -4, u = a(c * r), l = a(i.length), h = new Uint8Array(e.exports.memory.buffer);\n  h.set(i, l);\n  const f = t(u, s, r, l, i.length);\n  if (f === 0 && o && o(u, c, r), n.set(h.subarray(u, u + s * r)), a(u - a(0)), f !== 0)\n    throw new Error(`Malformed buffer data: ${f}`);\n}\nconst xn = \"EXT_meshopt_compression\", eA = xn;\nasync function nA(e, t) {\n  var n, s;\n  const r = new it(e);\n  if (!(t != null && (n = t.gltf) !== null && n !== void 0 && n.decompressMeshes) || !((s = t.gltf) !== null && s !== void 0 && s.loadBuffers))\n    return;\n  const i = [];\n  for (const o of e.json.bufferViews || [])\n    i.push(sA(r, o));\n  await Promise.all(i), r.removeExtension(xn);\n}\nasync function sA(e, t) {\n  const n = e.getObjectExtension(t, xn);\n  if (n) {\n    const {\n      byteOffset: s = 0,\n      byteLength: r = 0,\n      byteStride: i,\n      count: o,\n      mode: a,\n      filter: c = \"NONE\",\n      buffer: u\n    } = n, l = e.gltf.buffers[u], h = new Uint8Array(l.arrayBuffer, l.byteOffset + s, r), f = new Uint8Array(e.gltf.buffers[t.buffer].arrayBuffer, t.byteOffset, t.byteLength);\n    await q0(f, o, i, h, a, c), e.removeObjectExtension(t, xn);\n  }\n}\nconst rA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: nA,\n  name: eA\n}, Symbol.toStringTag, { value: \"Module\" })), ce = \"EXT_texture_webp\", iA = ce;\nfunction oA(e, t) {\n  const n = new it(e);\n  if (!gg(\"image/webp\")) {\n    if (n.getRequiredExtensions().includes(ce))\n      throw new Error(`gltf: Required extension ${ce} not supported by browser`);\n    return;\n  }\n  const {\n    json: s\n  } = n;\n  for (const r of s.textures || []) {\n    const i = n.getObjectExtension(r, ce);\n    i && (r.source = i.source), n.removeObjectExtension(r, ce);\n  }\n  n.removeExtension(ce);\n}\nconst aA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  name: iA,\n  preprocess: oA\n}, Symbol.toStringTag, { value: \"Module\" })), Cn = \"KHR_texture_basisu\", cA = Cn;\nfunction uA(e, t) {\n  const n = new it(e), {\n    json: s\n  } = n;\n  for (const r of s.textures || []) {\n    const i = n.getObjectExtension(r, Cn);\n    i && (r.source = i.source, n.removeObjectExtension(r, Cn));\n  }\n  n.removeExtension(Cn);\n}\nconst lA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  name: cA,\n  preprocess: uA\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction hA(e) {\n  const t = {};\n  for (const n in e) {\n    const s = e[n];\n    if (n !== \"indices\") {\n      const r = ka(s);\n      t[n] = r;\n    }\n  }\n  return t;\n}\nfunction ka(e) {\n  const {\n    buffer: t,\n    size: n,\n    count: s\n  } = fA(e);\n  return {\n    value: t,\n    size: n,\n    byteOffset: 0,\n    count: s,\n    type: Oa(n),\n    componentType: Br(t)\n  };\n}\nfunction fA(e) {\n  let t = e, n = 1, s = 0;\n  return e && e.value && (t = e.value, n = e.size || 1), t && (ArrayBuffer.isView(t) || (t = dA(t, Float32Array)), s = t.length / n), {\n    buffer: t,\n    size: n,\n    count: s\n  };\n}\nfunction dA(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n  return e ? Array.isArray(e) ? new t(e) : n && !(e instanceof t) ? new t(e) : e : null;\n}\nconst Vt = \"KHR_draco_mesh_compression\", mA = Vt;\nfunction gA(e, t, n) {\n  const s = new it(e);\n  for (const r of Ka(s))\n    s.getObjectExtension(r, Vt);\n}\nasync function AA(e, t, n) {\n  var s;\n  if (!(t != null && (s = t.gltf) !== null && s !== void 0 && s.decompressMeshes))\n    return;\n  const r = new it(e), i = [];\n  for (const o of Ka(r))\n    r.getObjectExtension(o, Vt) && i.push(yA(r, o, t, n));\n  await Promise.all(i), r.removeExtension(Vt);\n}\nfunction pA(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  const n = new it(e);\n  for (const s of n.json.meshes || [])\n    BA(s, t), n.addRequiredExtension(Vt);\n}\nasync function yA(e, t, n, s) {\n  const r = e.getObjectExtension(t, Vt);\n  if (!r)\n    return;\n  const i = e.getTypedArrayForBufferView(r.bufferView), o = sr(i.buffer, i.byteOffset), a = {\n    ...n\n  };\n  delete a[\"3d-tiles\"];\n  const c = await He(o, Ta, a, s), u = hA(c.attributes);\n  for (const [l, h] of Object.entries(u))\n    if (l in t.attributes) {\n      const f = t.attributes[l], d = e.getAccessor(f);\n      d != null && d.min && d !== null && d !== void 0 && d.max && (h.min = d.min, h.max = d.max);\n    }\n  t.attributes = u, c.indices && (t.indices = ka(c.indices)), e.removeObjectExtension(t, Vt), CA(t);\n}\nfunction BA(e, t) {\n  var n;\n  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 4, r = arguments.length > 3 ? arguments[3] : void 0, i = arguments.length > 4 ? arguments[4] : void 0;\n  if (!r.DracoWriter)\n    throw new Error(\"options.gltf.DracoWriter not provided\");\n  const o = r.DracoWriter.encodeSync({\n    attributes: e\n  }), a = i == null || (n = i.parseSync) === null || n === void 0 ? void 0 : n.call(i, {\n    attributes: e\n  }), c = r._addFauxAttributes(a.attributes), u = r.addBufferView(o);\n  return {\n    primitives: [{\n      attributes: c,\n      mode: s,\n      extensions: {\n        [Vt]: {\n          bufferView: u,\n          attributes: c\n        }\n      }\n    }]\n  };\n}\nfunction CA(e) {\n  if (!e.attributes && Object.keys(e.attributes).length > 0)\n    throw new Error(\"glTF: Empty primitive detected: Draco decompression failure?\");\n}\nfunction* Ka(e) {\n  for (const t of e.json.meshes || [])\n    for (const n of t.primitives)\n      yield n;\n}\nconst EA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: AA,\n  encode: pA,\n  name: mA,\n  preprocess: gA\n}, Symbol.toStringTag, { value: \"Module\" })), Rr = \"KHR_texture_transform\", TA = Rr, hn = new A(), bA = new z(), _A = new z();\nasync function wA(e, t) {\n  var n;\n  if (!new it(e).hasExtension(Rr) || !((n = t.gltf) !== null && n !== void 0 && n.loadBuffers))\n    return;\n  const i = e.json.materials || [];\n  for (let o = 0; o < i.length; o++)\n    RA(o, e);\n}\nfunction RA(e, t) {\n  var n, s, r;\n  const i = [], o = (n = t.json.materials) === null || n === void 0 ? void 0 : n[e], a = o == null || (s = o.pbrMetallicRoughness) === null || s === void 0 ? void 0 : s.baseColorTexture;\n  a && be(t, e, a, i);\n  const c = o == null ? void 0 : o.emissiveTexture;\n  c && be(t, e, c, i);\n  const u = o == null ? void 0 : o.normalTexture;\n  u && be(t, e, u, i);\n  const l = o == null ? void 0 : o.occlusionTexture;\n  l && be(t, e, l, i);\n  const h = o == null || (r = o.pbrMetallicRoughness) === null || r === void 0 ? void 0 : r.metallicRoughnessTexture;\n  h && be(t, e, h, i);\n}\nfunction be(e, t, n, s) {\n  const r = MA(n, s);\n  if (!r)\n    return;\n  const i = e.json.meshes || [];\n  for (const o of i)\n    for (const a of o.primitives) {\n      const c = a.material;\n      Number.isFinite(c) && t === c && IA(e, a, r);\n    }\n}\nfunction MA(e, t) {\n  var n;\n  const s = (n = e.extensions) === null || n === void 0 ? void 0 : n[Rr], {\n    texCoord: r = 0\n  } = e, {\n    texCoord: i = r\n  } = s;\n  if (!(t.findIndex((a) => {\n    let [c, u] = a;\n    return c === r && u === i;\n  }) !== -1)) {\n    const a = OA(s);\n    return r !== i && (e.texCoord = i), t.push([r, i]), {\n      originalTexCoord: r,\n      texCoord: i,\n      matrix: a\n    };\n  }\n  return null;\n}\nfunction IA(e, t, n) {\n  const {\n    originalTexCoord: s,\n    texCoord: r,\n    matrix: i\n  } = n, o = t.attributes[`TEXCOORD_${s}`];\n  if (Number.isFinite(o)) {\n    var a;\n    const u = (a = e.json.accessors) === null || a === void 0 ? void 0 : a[o];\n    if (u && u.bufferView) {\n      var c;\n      const l = (c = e.json.bufferViews) === null || c === void 0 ? void 0 : c[u.bufferView];\n      if (l) {\n        const {\n          arrayBuffer: h,\n          byteOffset: f\n        } = e.buffers[l.buffer], d = (f || 0) + (u.byteOffset || 0) + (l.byteOffset || 0), {\n          ArrayType: m,\n          length: g\n        } = Cr(u, l), p = xa[u.componentType], C = Sa[u.type], w = l.byteStride || p * C, y = new Float32Array(g);\n        for (let B = 0; B < u.count; B++) {\n          const R = new m(h, d + B * w, 2);\n          hn.set(R[0], R[1], 1), hn.transformByMatrix3(i), y.set([hn[0], hn[1]], B * C);\n        }\n        s === r ? SA(u, l, e.buffers, y) : xA(r, u, t, e, y);\n      }\n    }\n  }\n}\nfunction SA(e, t, n, s) {\n  e.componentType = 5126, n.push({\n    arrayBuffer: s.buffer,\n    byteOffset: 0,\n    byteLength: s.buffer.byteLength\n  }), t.buffer = n.length - 1, t.byteLength = s.buffer.byteLength, t.byteOffset = 0, delete t.byteStride;\n}\nfunction xA(e, t, n, s, r) {\n  s.buffers.push({\n    arrayBuffer: r.buffer,\n    byteOffset: 0,\n    byteLength: r.buffer.byteLength\n  });\n  const i = s.json.bufferViews;\n  if (!i)\n    return;\n  i.push({\n    buffer: s.buffers.length - 1,\n    byteLength: r.buffer.byteLength,\n    byteOffset: 0\n  });\n  const o = s.json.accessors;\n  o && (o.push({\n    bufferView: (i == null ? void 0 : i.length) - 1,\n    byteOffset: 0,\n    componentType: 5126,\n    count: t.count,\n    type: \"VEC2\"\n  }), n.attributes[`TEXCOORD_${e}`] = o.length - 1);\n}\nfunction OA(e) {\n  const {\n    offset: t = [0, 0],\n    rotation: n = 0,\n    scale: s = [1, 1]\n  } = e, r = new z().set(1, 0, 0, 0, 1, 0, t[0], t[1], 1), i = bA.set(Math.cos(n), Math.sin(n), 0, -Math.sin(n), Math.cos(n), 0, 0, 0, 1), o = _A.set(s[0], 0, 0, 0, s[1], 0, 0, 0, 1);\n  return r.multiplyRight(i).multiplyRight(o);\n}\nconst FA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: wA,\n  name: TA\n}, Symbol.toStringTag, { value: \"Module\" })), Wt = \"KHR_lights_punctual\", vA = Wt;\nasync function DA(e) {\n  const t = new it(e), {\n    json: n\n  } = t, s = t.getExtension(Wt);\n  s && (t.json.lights = s.lights, t.removeExtension(Wt));\n  for (const r of n.nodes || []) {\n    const i = t.getObjectExtension(r, Wt);\n    i && (r.light = i.light), t.removeObjectExtension(r, Wt);\n  }\n}\nasync function LA(e) {\n  const t = new it(e), {\n    json: n\n  } = t;\n  if (n.lights) {\n    const s = t.addExtension(Wt);\n    gt(!s.lights), s.lights = n.lights, delete n.lights;\n  }\n  if (t.json.lights) {\n    for (const s of t.json.lights) {\n      const r = s.node;\n      t.addObjectExtension(r, Wt, s);\n    }\n    delete t.json.lights;\n  }\n}\nconst GA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: DA,\n  encode: LA,\n  name: vA\n}, Symbol.toStringTag, { value: \"Module\" })), De = \"KHR_materials_unlit\", PA = De;\nasync function NA(e) {\n  const t = new it(e), {\n    json: n\n  } = t;\n  for (const s of n.materials || [])\n    s.extensions && s.extensions.KHR_materials_unlit && (s.unlit = !0), t.removeObjectExtension(s, De);\n  t.removeExtension(De);\n}\nfunction UA(e) {\n  const t = new it(e), {\n    json: n\n  } = t;\n  if (t.materials)\n    for (const s of n.materials || [])\n      s.unlit && (delete s.unlit, t.addObjectExtension(s, De, {}), t.addExtension(De));\n}\nconst HA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: NA,\n  encode: UA,\n  name: PA\n}, Symbol.toStringTag, { value: \"Module\" })), Re = \"KHR_techniques_webgl\", JA = Re;\nasync function VA(e) {\n  const t = new it(e), {\n    json: n\n  } = t, s = t.getExtension(Re);\n  if (s) {\n    const r = kA(s, t);\n    for (const i of n.materials || []) {\n      const o = t.getObjectExtension(i, Re);\n      o && (i.technique = Object.assign({}, o, r[o.technique]), i.technique.values = KA(i.technique, t)), t.removeObjectExtension(i, Re);\n    }\n    t.removeExtension(Re);\n  }\n}\nasync function jA(e, t) {\n}\nfunction kA(e, t) {\n  const {\n    programs: n = [],\n    shaders: s = [],\n    techniques: r = []\n  } = e, i = new TextDecoder();\n  return s.forEach((o) => {\n    if (Number.isFinite(o.bufferView))\n      o.code = i.decode(t.getTypedArrayForBufferView(o.bufferView));\n    else\n      throw new Error(\"KHR_techniques_webgl: no shader code\");\n  }), n.forEach((o) => {\n    o.fragmentShader = s[o.fragmentShader], o.vertexShader = s[o.vertexShader];\n  }), r.forEach((o) => {\n    o.program = n[o.program];\n  }), r;\n}\nfunction KA(e, t) {\n  const n = Object.assign({}, e.values);\n  return Object.keys(e.uniforms || {}).forEach((s) => {\n    e.uniforms[s].value && !(s in n) && (n[s] = e.uniforms[s].value);\n  }), Object.keys(n).forEach((s) => {\n    typeof n[s] == \"object\" && n[s].index !== void 0 && (n[s].texture = t.getTexture(n[s].index));\n  }), n;\n}\nconst zA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: VA,\n  encode: jA,\n  name: JA\n}, Symbol.toStringTag, { value: \"Module\" })), za = [Zg, Lg, rA, aA, lA, EA, GA, HA, zA, FA, A0];\nfunction WA(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = za.filter((i) => Wa(i.name, t));\n  for (const i of s) {\n    var r;\n    (r = i.preprocess) === null || r === void 0 || r.call(i, e, t, n);\n  }\n}\nasync function XA(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = za.filter((i) => Wa(i.name, t));\n  for (const i of s) {\n    var r;\n    await ((r = i.decode) === null || r === void 0 ? void 0 : r.call(i, e, t, n));\n  }\n}\nfunction Wa(e, t) {\n  var n;\n  const s = (t == null || (n = t.gltf) === null || n === void 0 ? void 0 : n.excludeExtensions) || {};\n  return !(e in s && !s[e]);\n}\nconst Rs = \"KHR_binary_glTF\";\nfunction QA(e) {\n  const t = new it(e), {\n    json: n\n  } = t;\n  for (const s of n.images || []) {\n    const r = t.getObjectExtension(s, Rs);\n    r && Object.assign(s, r), t.removeObjectExtension(s, Rs);\n  }\n  n.buffers && n.buffers[0] && delete n.buffers[0].uri, t.removeExtension(Rs);\n}\nconst so = {\n  accessors: \"accessor\",\n  animations: \"animation\",\n  buffers: \"buffer\",\n  bufferViews: \"bufferView\",\n  images: \"image\",\n  materials: \"material\",\n  meshes: \"mesh\",\n  nodes: \"node\",\n  samplers: \"sampler\",\n  scenes: \"scene\",\n  skins: \"skin\",\n  textures: \"texture\"\n}, qA = {\n  accessor: \"accessors\",\n  animations: \"animation\",\n  buffer: \"buffers\",\n  bufferView: \"bufferViews\",\n  image: \"images\",\n  material: \"materials\",\n  mesh: \"meshes\",\n  node: \"nodes\",\n  sampler: \"samplers\",\n  scene: \"scenes\",\n  skin: \"skins\",\n  texture: \"textures\"\n};\nclass YA {\n  constructor() {\n    this.idToIndexMap = {\n      animations: {},\n      accessors: {},\n      buffers: {},\n      bufferViews: {},\n      images: {},\n      materials: {},\n      meshes: {},\n      nodes: {},\n      samplers: {},\n      scenes: {},\n      skins: {},\n      textures: {}\n    }, this.json = void 0;\n  }\n  normalize(t, n) {\n    this.json = t.json;\n    const s = t.json;\n    switch (s.asset && s.asset.version) {\n      case \"2.0\":\n        return;\n      case void 0:\n      case \"1.0\":\n        break;\n      default:\n        console.warn(`glTF: Unknown version ${s.asset.version}`);\n        return;\n    }\n    if (!n.normalize)\n      throw new Error(\"glTF v1 is not supported.\");\n    console.warn(\"Converting glTF v1 to glTF v2 format. This is experimental and may fail.\"), this._addAsset(s), this._convertTopLevelObjectsToArrays(s), QA(t), this._convertObjectIdsToArrayIndices(s), this._updateObjects(s), this._updateMaterial(s);\n  }\n  _addAsset(t) {\n    t.asset = t.asset || {}, t.asset.version = \"2.0\", t.asset.generator = t.asset.generator || \"Normalized to glTF 2.0 by loaders.gl\";\n  }\n  _convertTopLevelObjectsToArrays(t) {\n    for (const n in so)\n      this._convertTopLevelObjectToArray(t, n);\n  }\n  _convertTopLevelObjectToArray(t, n) {\n    const s = t[n];\n    if (!(!s || Array.isArray(s))) {\n      t[n] = [];\n      for (const r in s) {\n        const i = s[r];\n        i.id = i.id || r;\n        const o = t[n].length;\n        t[n].push(i), this.idToIndexMap[n][r] = o;\n      }\n    }\n  }\n  _convertObjectIdsToArrayIndices(t) {\n    for (const n in so)\n      this._convertIdsToIndices(t, n);\n    \"scene\" in t && (t.scene = this._convertIdToIndex(t.scene, \"scene\"));\n    for (const n of t.textures)\n      this._convertTextureIds(n);\n    for (const n of t.meshes)\n      this._convertMeshIds(n);\n    for (const n of t.nodes)\n      this._convertNodeIds(n);\n    for (const n of t.scenes)\n      this._convertSceneIds(n);\n  }\n  _convertTextureIds(t) {\n    t.source && (t.source = this._convertIdToIndex(t.source, \"image\"));\n  }\n  _convertMeshIds(t) {\n    for (const n of t.primitives) {\n      const {\n        attributes: s,\n        indices: r,\n        material: i\n      } = n;\n      for (const o in s)\n        s[o] = this._convertIdToIndex(s[o], \"accessor\");\n      r && (n.indices = this._convertIdToIndex(r, \"accessor\")), i && (n.material = this._convertIdToIndex(i, \"material\"));\n    }\n  }\n  _convertNodeIds(t) {\n    t.children && (t.children = t.children.map((n) => this._convertIdToIndex(n, \"node\"))), t.meshes && (t.meshes = t.meshes.map((n) => this._convertIdToIndex(n, \"mesh\")));\n  }\n  _convertSceneIds(t) {\n    t.nodes && (t.nodes = t.nodes.map((n) => this._convertIdToIndex(n, \"node\")));\n  }\n  _convertIdsToIndices(t, n) {\n    t[n] || (console.warn(`gltf v1: json doesn't contain attribute ${n}`), t[n] = []);\n    for (const s of t[n])\n      for (const r in s) {\n        const i = s[r], o = this._convertIdToIndex(i, r);\n        s[r] = o;\n      }\n  }\n  _convertIdToIndex(t, n) {\n    const s = qA[n];\n    if (s in this.idToIndexMap) {\n      const r = this.idToIndexMap[s][t];\n      if (!Number.isFinite(r))\n        throw new Error(`gltf v1: failed to resolve ${n} with id ${t}`);\n      return r;\n    }\n    return t;\n  }\n  _updateObjects(t) {\n    for (const n of this.json.buffers)\n      delete n.type;\n  }\n  _updateMaterial(t) {\n    for (const i of t.materials) {\n      var n, s, r;\n      i.pbrMetallicRoughness = {\n        baseColorFactor: [1, 1, 1, 1],\n        metallicFactor: 1,\n        roughnessFactor: 1\n      };\n      const o = ((n = i.values) === null || n === void 0 ? void 0 : n.tex) || ((s = i.values) === null || s === void 0 ? void 0 : s.texture2d_0) || ((r = i.values) === null || r === void 0 ? void 0 : r.diffuseTex), a = t.textures.findIndex((c) => c.id === o);\n      a !== -1 && (i.pbrMetallicRoughness.baseColorTexture = {\n        index: a\n      });\n    }\n  }\n}\nfunction $A(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  return new YA().normalize(e, t);\n}\nasync function ZA(e, t) {\n  var n, s, r;\n  let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, o = arguments.length > 3 ? arguments[3] : void 0, a = arguments.length > 4 ? arguments[4] : void 0;\n  return tp(e, t, i, o), $A(e, {\n    normalize: o == null || (n = o.gltf) === null || n === void 0 ? void 0 : n.normalize\n  }), WA(e, o, a), o != null && (s = o.gltf) !== null && s !== void 0 && s.loadBuffers && e.json.buffers && await ep(e, o, a), o != null && (r = o.gltf) !== null && r !== void 0 && r.loadImages && await np(e, o, a), await XA(e, o, a), e;\n}\nfunction tp(e, t, n, s) {\n  if (s.uri && (e.baseUri = s.uri), t instanceof ArrayBuffer && !U0(t, n, s) && (t = new TextDecoder().decode(t)), typeof t == \"string\")\n    e.json = uu(t);\n  else if (t instanceof ArrayBuffer) {\n    const o = {};\n    n = H0(o, t, n, s.glb), gt(o.type === \"glTF\", `Invalid GLB magic string ${o.type}`), e._glb = o, e.json = o.json;\n  } else\n    gt(!1, \"GLTF: must be ArrayBuffer or string\");\n  const r = e.json.buffers || [];\n  if (e.buffers = new Array(r.length).fill(null), e._glb && e._glb.header.hasBinChunk) {\n    const {\n      binChunks: o\n    } = e._glb;\n    e.buffers[0] = {\n      arrayBuffer: o[0].arrayBuffer,\n      byteOffset: o[0].byteOffset,\n      byteLength: o[0].byteLength\n    };\n  }\n  const i = e.json.images || [];\n  e.images = new Array(i.length).fill({});\n}\nasync function ep(e, t, n) {\n  const s = e.json.buffers || [];\n  for (let o = 0; o < s.length; ++o) {\n    const a = s[o];\n    if (a.uri) {\n      var r, i;\n      const {\n        fetch: c\n      } = n;\n      gt(c);\n      const u = ja(a.uri, t), l = await (n == null || (r = n.fetch) === null || r === void 0 ? void 0 : r.call(n, u)), h = await (l == null || (i = l.arrayBuffer) === null || i === void 0 ? void 0 : i.call(l));\n      e.buffers[o] = {\n        arrayBuffer: h,\n        byteOffset: 0,\n        byteLength: h.byteLength\n      }, delete a.uri;\n    } else\n      e.buffers[o] === null && (e.buffers[o] = {\n        arrayBuffer: new ArrayBuffer(a.byteLength),\n        byteOffset: 0,\n        byteLength: a.byteLength\n      });\n  }\n}\nasync function np(e, t, n) {\n  const s = sp(e), r = e.json.images || [], i = [];\n  for (const o of s)\n    i.push(rp(e, r[o], o, t, n));\n  return await Promise.all(i);\n}\nfunction sp(e) {\n  const t = /* @__PURE__ */ new Set(), n = e.json.textures || [];\n  for (const s of n)\n    s.source !== void 0 && t.add(s.source);\n  return Array.from(t).sort();\n}\nasync function rp(e, t, n, s, r) {\n  let i;\n  if (t.uri && !t.hasOwnProperty(\"bufferView\")) {\n    const a = ja(t.uri, s), {\n      fetch: c\n    } = r;\n    i = await (await c(a)).arrayBuffer(), t.bufferView = {\n      data: i\n    };\n  }\n  if (Number.isFinite(t.bufferView)) {\n    const a = wg(e.json, e.buffers, t.bufferView);\n    i = sr(a.buffer, a.byteOffset, a.byteLength);\n  }\n  gt(i, \"glTF image has no data\");\n  let o = await He(i, [mg, F0], {\n    ...s,\n    mimeType: t.mimeType,\n    basis: s.basis || {\n      format: Va()\n    }\n  }, r);\n  o && o[0] && (o = {\n    compressed: !0,\n    mipmaps: !1,\n    width: o[0].width,\n    height: o[0].height,\n    data: o[0]\n  }), e.images = e.images || [], e.images[n] = o;\n}\nconst On = {\n  name: \"glTF\",\n  id: \"gltf\",\n  module: \"gltf\",\n  version: p0,\n  extensions: [\"gltf\", \"glb\"],\n  mimeTypes: [\"model/gltf+json\", \"model/gltf-binary\"],\n  text: !0,\n  binary: !0,\n  tests: [\"glTF\"],\n  parse: ip,\n  options: {\n    gltf: {\n      normalize: !0,\n      loadBuffers: !0,\n      loadImages: !0,\n      decompressMeshes: !0\n    },\n    log: console\n  }\n};\nasync function ip(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;\n  t = {\n    ...On.options,\n    ...t\n  }, t.gltf = {\n    ...On.options.gltf,\n    ...t.gltf\n  };\n  const {\n    byteOffset: s = 0\n  } = t;\n  return await ZA({}, e, s, t, n);\n}\nconst op = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n}, ap = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n}, pt = {\n  TEXTURE_MAG_FILTER: 10240,\n  TEXTURE_MIN_FILTER: 10241,\n  TEXTURE_WRAP_S: 10242,\n  TEXTURE_WRAP_T: 10243,\n  REPEAT: 10497,\n  LINEAR: 9729,\n  NEAREST_MIPMAP_LINEAR: 9986\n}, cp = {\n  magFilter: pt.TEXTURE_MAG_FILTER,\n  minFilter: pt.TEXTURE_MIN_FILTER,\n  wrapS: pt.TEXTURE_WRAP_S,\n  wrapT: pt.TEXTURE_WRAP_T\n}, up = {\n  [pt.TEXTURE_MAG_FILTER]: pt.LINEAR,\n  [pt.TEXTURE_MIN_FILTER]: pt.NEAREST_MIPMAP_LINEAR,\n  [pt.TEXTURE_WRAP_S]: pt.REPEAT,\n  [pt.TEXTURE_WRAP_T]: pt.REPEAT\n};\nfunction lp() {\n  return {\n    id: \"default-sampler\",\n    parameters: up\n  };\n}\nfunction hp(e) {\n  return ap[e];\n}\nfunction fp(e) {\n  return op[e];\n}\nclass dp {\n  constructor() {\n    this.baseUri = \"\", this.jsonUnprocessed = void 0, this.json = void 0, this.buffers = [], this.images = [];\n  }\n  postProcess(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const {\n      json: s,\n      buffers: r = [],\n      images: i = []\n    } = t, {\n      baseUri: o = \"\"\n    } = t;\n    return gt(s), this.baseUri = o, this.buffers = r, this.images = i, this.jsonUnprocessed = s, this.json = this._resolveTree(t.json, n), this.json;\n  }\n  _resolveTree(t) {\n    const n = {\n      ...t\n    };\n    return this.json = n, t.bufferViews && (n.bufferViews = t.bufferViews.map((s, r) => this._resolveBufferView(s, r))), t.images && (n.images = t.images.map((s, r) => this._resolveImage(s, r))), t.samplers && (n.samplers = t.samplers.map((s, r) => this._resolveSampler(s, r))), t.textures && (n.textures = t.textures.map((s, r) => this._resolveTexture(s, r))), t.accessors && (n.accessors = t.accessors.map((s, r) => this._resolveAccessor(s, r))), t.materials && (n.materials = t.materials.map((s, r) => this._resolveMaterial(s, r))), t.meshes && (n.meshes = t.meshes.map((s, r) => this._resolveMesh(s, r))), t.nodes && (n.nodes = t.nodes.map((s, r) => this._resolveNode(s, r)), n.nodes = n.nodes.map((s, r) => this._resolveNodeChildren(s))), t.skins && (n.skins = t.skins.map((s, r) => this._resolveSkin(s, r))), t.scenes && (n.scenes = t.scenes.map((s, r) => this._resolveScene(s, r))), typeof this.json.scene == \"number\" && n.scenes && (n.scene = n.scenes[this.json.scene]), n;\n  }\n  getScene(t) {\n    return this._get(this.json.scenes, t);\n  }\n  getNode(t) {\n    return this._get(this.json.nodes, t);\n  }\n  getSkin(t) {\n    return this._get(this.json.skins, t);\n  }\n  getMesh(t) {\n    return this._get(this.json.meshes, t);\n  }\n  getMaterial(t) {\n    return this._get(this.json.materials, t);\n  }\n  getAccessor(t) {\n    return this._get(this.json.accessors, t);\n  }\n  getCamera(t) {\n    return this._get(this.json.cameras, t);\n  }\n  getTexture(t) {\n    return this._get(this.json.textures, t);\n  }\n  getSampler(t) {\n    return this._get(this.json.samplers, t);\n  }\n  getImage(t) {\n    return this._get(this.json.images, t);\n  }\n  getBufferView(t) {\n    return this._get(this.json.bufferViews, t);\n  }\n  getBuffer(t) {\n    return this._get(this.json.buffers, t);\n  }\n  _get(t, n) {\n    if (typeof n == \"object\")\n      return n;\n    const s = t && t[n];\n    return s || console.warn(`glTF file error: Could not find ${t}[${n}]`), s;\n  }\n  _resolveScene(t, n) {\n    return {\n      ...t,\n      id: t.id || `scene-${n}`,\n      nodes: (t.nodes || []).map((s) => this.getNode(s))\n    };\n  }\n  _resolveNode(t, n) {\n    const s = {\n      ...t,\n      id: (t == null ? void 0 : t.id) || `node-${n}`\n    };\n    return t.mesh !== void 0 && (s.mesh = this.getMesh(t.mesh)), t.camera !== void 0 && (s.camera = this.getCamera(t.camera)), t.skin !== void 0 && (s.skin = this.getSkin(t.skin)), t.meshes !== void 0 && t.meshes.length && (s.mesh = t.meshes.reduce((r, i) => {\n      const o = this.getMesh(i);\n      return r.id = o.id, r.primitives = r.primitives.concat(o.primitives), r;\n    }, {\n      primitives: []\n    })), s;\n  }\n  _resolveNodeChildren(t) {\n    return t.children && (t.children = t.children.map((n) => this.getNode(n))), t;\n  }\n  _resolveSkin(t, n) {\n    const s = typeof t.inverseBindMatrices == \"number\" ? this.getAccessor(t.inverseBindMatrices) : void 0;\n    return {\n      ...t,\n      id: t.id || `skin-${n}`,\n      inverseBindMatrices: s\n    };\n  }\n  _resolveMesh(t, n) {\n    const s = {\n      ...t,\n      id: t.id || `mesh-${n}`,\n      primitives: []\n    };\n    return t.primitives && (s.primitives = t.primitives.map((r) => {\n      const i = {\n        ...r,\n        attributes: {},\n        indices: void 0,\n        material: void 0\n      }, o = r.attributes;\n      for (const a in o)\n        i.attributes[a] = this.getAccessor(o[a]);\n      return r.indices !== void 0 && (i.indices = this.getAccessor(r.indices)), r.material !== void 0 && (i.material = this.getMaterial(r.material)), i;\n    })), s;\n  }\n  _resolveMaterial(t, n) {\n    const s = {\n      ...t,\n      id: t.id || `material-${n}`\n    };\n    if (s.normalTexture && (s.normalTexture = {\n      ...s.normalTexture\n    }, s.normalTexture.texture = this.getTexture(s.normalTexture.index)), s.occlusionTexture && (s.occlusionTexture = {\n      ...s.occlusionTexture\n    }, s.occlusionTexture.texture = this.getTexture(s.occlusionTexture.index)), s.emissiveTexture && (s.emissiveTexture = {\n      ...s.emissiveTexture\n    }, s.emissiveTexture.texture = this.getTexture(s.emissiveTexture.index)), s.emissiveFactor || (s.emissiveFactor = s.emissiveTexture ? [1, 1, 1] : [0, 0, 0]), s.pbrMetallicRoughness) {\n      s.pbrMetallicRoughness = {\n        ...s.pbrMetallicRoughness\n      };\n      const r = s.pbrMetallicRoughness;\n      r.baseColorTexture && (r.baseColorTexture = {\n        ...r.baseColorTexture\n      }, r.baseColorTexture.texture = this.getTexture(r.baseColorTexture.index)), r.metallicRoughnessTexture && (r.metallicRoughnessTexture = {\n        ...r.metallicRoughnessTexture\n      }, r.metallicRoughnessTexture.texture = this.getTexture(r.metallicRoughnessTexture.index));\n    }\n    return s;\n  }\n  _resolveAccessor(t, n) {\n    const s = hp(t.componentType), r = fp(t.type), i = s * r, o = {\n      ...t,\n      id: t.id || `accessor-${n}`,\n      bytesPerComponent: s,\n      components: r,\n      bytesPerElement: i,\n      value: void 0,\n      bufferView: void 0,\n      sparse: void 0\n    };\n    if (t.bufferView !== void 0 && (o.bufferView = this.getBufferView(t.bufferView)), o.bufferView) {\n      const a = o.bufferView.buffer, {\n        ArrayType: c,\n        byteLength: u\n      } = Cr(o, o.bufferView), l = (o.bufferView.byteOffset || 0) + (o.byteOffset || 0) + a.byteOffset;\n      let h = a.arrayBuffer.slice(l, l + u);\n      o.bufferView.byteStride && (h = this._getValueFromInterleavedBuffer(a, l, o.bufferView.byteStride, o.bytesPerElement, o.count)), o.value = new c(h);\n    }\n    return o;\n  }\n  _getValueFromInterleavedBuffer(t, n, s, r, i) {\n    const o = new Uint8Array(i * r);\n    for (let a = 0; a < i; a++) {\n      const c = n + a * s;\n      o.set(new Uint8Array(t.arrayBuffer.slice(c, c + r)), a * r);\n    }\n    return o.buffer;\n  }\n  _resolveTexture(t, n) {\n    return {\n      ...t,\n      id: t.id || `texture-${n}`,\n      sampler: typeof t.sampler == \"number\" ? this.getSampler(t.sampler) : lp(),\n      source: typeof t.source == \"number\" ? this.getImage(t.source) : void 0\n    };\n  }\n  _resolveSampler(t, n) {\n    const s = {\n      id: t.id || `sampler-${n}`,\n      ...t,\n      parameters: {}\n    };\n    for (const r in s) {\n      const i = this._enumSamplerParameter(r);\n      i !== void 0 && (s.parameters[i] = s[r]);\n    }\n    return s;\n  }\n  _enumSamplerParameter(t) {\n    return cp[t];\n  }\n  _resolveImage(t, n) {\n    const s = {\n      ...t,\n      id: t.id || `image-${n}`,\n      image: null,\n      bufferView: t.bufferView !== void 0 ? this.getBufferView(t.bufferView) : void 0\n    }, r = this.images[n];\n    return r && (s.image = r), s;\n  }\n  _resolveBufferView(t, n) {\n    const s = t.buffer, r = this.buffers[s].arrayBuffer;\n    let i = this.buffers[s].byteOffset || 0;\n    return t.byteOffset && (i += t.byteOffset), {\n      id: `bufferView-${n}`,\n      ...t,\n      buffer: this.buffers[s],\n      data: new Uint8Array(r, i, t.byteLength)\n    };\n  }\n  _resolveCamera(t, n) {\n    const s = {\n      ...t,\n      id: t.id || `camera-${n}`\n    };\n    return s.perspective, s.orthographic, s;\n  }\n}\nfunction Xa(e, t) {\n  return new dp().postProcess(e, t);\n}\nconst Xs = {\n  URI: 0,\n  EMBEDDED: 1\n};\nfunction Qa(e, t, n, s) {\n  e.rotateYtoZ = !0;\n  const r = (e.byteOffset || 0) + (e.byteLength || 0) - n;\n  if (r === 0)\n    throw new Error(\"glTF byte length must be greater than 0.\");\n  return e.gltfUpAxis = s != null && s[\"3d-tiles\"] && s[\"3d-tiles\"].assetGltfUpAxis ? s[\"3d-tiles\"].assetGltfUpAxis : \"Y\", e.gltfArrayBuffer = sr(t, n, r), e.gltfByteOffset = 0, e.gltfByteLength = r, n % 4 === 0 || console.warn(`${e.type}: embedded glb is not aligned to a 4-byte boundary.`), (e.byteOffset || 0) + (e.byteLength || 0);\n}\nasync function qa(e, t, n, s) {\n  const r = (n == null ? void 0 : n[\"3d-tiles\"]) || {};\n  if (mp(e, t), r.loadGLTF) {\n    if (!s)\n      return;\n    if (e.gltfUrl) {\n      const {\n        fetch: i\n      } = s, o = await i(e.gltfUrl, n);\n      e.gltfArrayBuffer = await o.arrayBuffer(), e.gltfByteOffset = 0;\n    }\n    if (e.gltfArrayBuffer) {\n      const i = await He(e.gltfArrayBuffer, On, n, s);\n      e.gltf = Xa(i), e.gpuMemoryUsageInBytes = Fa(e.gltf), delete e.gltfArrayBuffer, delete e.gltfByteOffset, delete e.gltfByteLength;\n    }\n  }\n}\nfunction mp(e, t, n) {\n  switch (t) {\n    case Xs.URI:\n      if (e.gltfArrayBuffer) {\n        const s = new Uint8Array(e.gltfArrayBuffer, e.gltfByteOffset), i = new TextDecoder().decode(s);\n        e.gltfUrl = i.replace(/[\\s\\0]+$/, \"\");\n      }\n      delete e.gltfArrayBuffer, delete e.gltfByteOffset, delete e.gltfByteLength;\n      break;\n    case Xs.EMBEDDED:\n      break;\n    default:\n      throw new Error(\"b3dm: Illegal glTF format field\");\n  }\n}\nasync function gp(e, t, n, s, r) {\n  var i;\n  n = Ap(e, t, n, s), await qa(e, Xs.EMBEDDED, s, r);\n  const o = e == null || (i = e.gltf) === null || i === void 0 ? void 0 : i.extensions;\n  return o && o.CESIUM_RTC && (e.rtcCenter = o.CESIUM_RTC.center), n;\n}\nfunction Ap(e, t, n, s, r) {\n  n = Vn(e, t, n), n = gr(e, t, n), n = Ar(e, t, n), n = Qa(e, t, n, s);\n  const i = new mr(e.featureTableJson, e.featureTableBinary);\n  return e.rtcCenter = i.getGlobalProperty(\"RTC_CENTER\", G.FLOAT, 3), n;\n}\nasync function pp(e, t, n, s, r) {\n  return n = yp(e, t, n, s), await qa(e, e.gltfFormat || 0, s, r), n;\n}\nfunction yp(e, t, n, s, r) {\n  var i;\n  if (n = Vn(e, t, n), e.version !== 1)\n    throw new Error(`Instanced 3D Model version ${e.version} is not supported`);\n  n = gr(e, t, n);\n  const o = new DataView(t);\n  if (e.gltfFormat = o.getUint32(n, !0), n += 4, n = Ar(e, t, n), n = Qa(e, t, n, s), !(e != null && (i = e.header) !== null && i !== void 0 && i.featureTableJsonByteLength) || e.header.featureTableJsonByteLength === 0)\n    throw new Error(\"i3dm parser: featureTableJsonByteLength is zero.\");\n  const a = new mr(e.featureTableJson, e.featureTableBinary), c = a.getGlobalProperty(\"INSTANCES_LENGTH\");\n  if (a.featuresLength = c, !Number.isFinite(c))\n    throw new Error(\"i3dm parser: INSTANCES_LENGTH must be defined\");\n  e.eastNorthUp = a.getGlobalProperty(\"EAST_NORTH_UP\"), e.rtcCenter = a.getGlobalProperty(\"RTC_CENTER\", G.FLOAT, 3);\n  const u = new _a(e.batchTableJson, e.batchTableBinary, c);\n  return Bp(e, a, u, c), n;\n}\nfunction Bp(e, t, n, s) {\n  const r = new Array(s), i = new A();\n  new A(), new A(), new A();\n  const o = new z(), a = new wn(), c = new A(), u = {}, l = new V(), h = [], f = [], d = [], m = [];\n  for (let g = 0; g < s; g++) {\n    let p;\n    if (t.hasProperty(\"POSITION\"))\n      p = t.getProperty(\"POSITION\", G.FLOAT, 3, g, i);\n    else if (t.hasProperty(\"POSITION_QUANTIZED\")) {\n      p = t.getProperty(\"POSITION_QUANTIZED\", G.UNSIGNED_SHORT, 3, g, i);\n      const E = t.getGlobalProperty(\"QUANTIZED_VOLUME_OFFSET\", G.FLOAT, 3);\n      if (!E)\n        throw new Error(\"i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\");\n      const O = t.getGlobalProperty(\"QUANTIZED_VOLUME_SCALE\", G.FLOAT, 3);\n      if (!O)\n        throw new Error(\"i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\");\n      const F = 65535;\n      for (let x = 0; x < 3; x++)\n        p[x] = p[x] / F * O[x] + E[x];\n    }\n    if (!p)\n      throw new Error(\"i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.\");\n    if (i.copy(p), u.translation = i, e.normalUp = t.getProperty(\"NORMAL_UP\", G.FLOAT, 3, g, h), e.normalRight = t.getProperty(\"NORMAL_RIGHT\", G.FLOAT, 3, g, f), e.normalUp) {\n      if (!e.normalRight)\n        throw new Error(\"i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.\");\n      e.hasCustomOrientation = !0;\n    } else {\n      if (e.octNormalUp = t.getProperty(\"NORMAL_UP_OCT32P\", G.UNSIGNED_SHORT, 2, g, h), e.octNormalRight = t.getProperty(\"NORMAL_RIGHT_OCT32P\", G.UNSIGNED_SHORT, 2, g, f), e.octNormalUp)\n        throw e.octNormalRight ? new Error(\"i3dm: oct-encoded orientation not implemented\") : new Error(\"i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P\");\n      e.eastNorthUp ? (J.WGS84.eastNorthUpToFixedFrame(i, l), l.getRotationMatrix3(o)) : o.identity();\n    }\n    a.fromMatrix3(o), u.rotation = a, c.set(1, 1, 1);\n    const C = t.getProperty(\"SCALE\", G.FLOAT, 1, g, d);\n    Number.isFinite(C) && c.multiplyByScalar(C);\n    const w = t.getProperty(\"SCALE_NON_UNIFORM\", G.FLOAT, 3, g, h);\n    w && c.scale(w), u.scale = c;\n    let y = t.getProperty(\"BATCH_ID\", G.UNSIGNED_SHORT, 1, g, m);\n    y === void 0 && (y = g);\n    const B = new V().fromQuaternion(u.rotation);\n    l.identity(), l.translate(u.translation), l.multiplyRight(B), l.scale(u.scale);\n    const R = l.clone();\n    r[g] = {\n      modelMatrix: R,\n      batchId: y\n    };\n  }\n  e.instances = r;\n}\nasync function Cp(e, t, n, s, r, i) {\n  n = Vn(e, t, n);\n  const o = new DataView(t);\n  for (e.tilesLength = o.getUint32(n, !0), n += 4, e.tiles = []; e.tiles.length < e.tilesLength && (e.byteLength || 0) - n > 12; ) {\n    const a = {\n      shape: \"tile3d\"\n    };\n    e.tiles.push(a), n = await i(t, n, s, r, a);\n  }\n  return n;\n}\nasync function Ep(e, t, n, s) {\n  var r, i;\n  if (e.rotateYtoZ = !0, e.gltfUpAxis = n != null && (r = n[\"3d-tiles\"]) !== null && r !== void 0 && r.assetGltfUpAxis ? n[\"3d-tiles\"].assetGltfUpAxis : \"Y\", n != null && (i = n[\"3d-tiles\"]) !== null && i !== void 0 && i.loadGLTF) {\n    if (!s)\n      return t.byteLength;\n    const o = await He(t, On, n, s);\n    e.gltf = Xa(o), e.gpuMemoryUsageInBytes = Fa(e.gltf);\n  } else\n    e.gltfArrayBuffer = t;\n  return t.byteLength;\n}\nasync function Ya(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 ? arguments[2] : void 0, s = arguments.length > 3 ? arguments[3] : void 0, r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {\n    shape: \"tile3d\"\n  };\n  switch (r.byteOffset = t, r.type = jd(e, t), r.type) {\n    case Ce.COMPOSITE:\n      return await Cp(r, e, t, n, s, Ya);\n    case Ce.BATCHED_3D_MODEL:\n      return await gp(r, e, t, n, s);\n    case Ce.GLTF:\n      return await Ep(r, e, n, s);\n    case Ce.INSTANCED_3D_MODEL:\n      return await pp(r, e, t, n, s);\n    case Ce.POINT_CLOUD:\n      return await Mm(r, e, t, n, s);\n    default:\n      throw new Error(`3DTileLoader: unknown type ${r.type}`);\n  }\n}\nconst Tp = 1952609651, bp = 1;\nasync function _p(e, t, n) {\n  if (new Uint32Array(e.slice(0, 4))[0] !== Tp)\n    throw new Error(\"Wrong subtree file magic number\");\n  if (new Uint32Array(e.slice(4, 8))[0] !== bp)\n    throw new Error(\"Wrong subtree file verson, must be 1\");\n  const i = ro(e.slice(8, 16)), o = new Uint8Array(e, 24, i), c = new TextDecoder(\"utf8\").decode(o), u = JSON.parse(c), l = ro(e.slice(16, 24));\n  let h = new ArrayBuffer(0);\n  if (l && (h = e.slice(24 + i)), await fn(u, u.tileAvailability, h, n), Array.isArray(u.contentAvailability))\n    for (const f of u.contentAvailability)\n      await fn(u, f, h, n);\n  else\n    await fn(u, u.contentAvailability, h, n);\n  return await fn(u, u.childSubtreeAvailability, h, n), u;\n}\nasync function fn(e, t, n, s) {\n  const r = Number.isFinite(t.bitstream) ? t.bitstream : t.bufferView;\n  if (typeof r != \"number\")\n    return;\n  const i = e.bufferViews[r], o = e.buffers[i.buffer];\n  if (!(s != null && s.baseUrl))\n    throw new Error(\"Url is not provided\");\n  if (!s.fetch)\n    throw new Error(\"fetch is not provided\");\n  if (o.uri) {\n    const c = `${(s == null ? void 0 : s.baseUrl) || \"\"}/${o.uri}`, l = await (await s.fetch(c)).arrayBuffer();\n    t.explicitBitstream = new Uint8Array(l, i.byteOffset, i.byteLength);\n    return;\n  }\n  const a = e.buffers.slice(0, i.buffer).reduce((c, u) => c + u.byteLength, 0);\n  t.explicitBitstream = new Uint8Array(n.slice(a, a + o.byteLength), i.byteOffset, i.byteLength);\n}\nfunction ro(e) {\n  const t = new DataView(e), n = t.getUint32(0, !0), s = t.getUint32(4, !0);\n  return n + 2 ** 32 * s;\n}\nconst $a = {\n  id: \"3d-tiles-subtree\",\n  name: \"3D Tiles Subtree\",\n  module: \"3d-tiles\",\n  version: Ba,\n  extensions: [\"subtree\"],\n  mimeTypes: [\"application/octet-stream\"],\n  tests: [\"subtree\"],\n  parse: _p,\n  options: {}\n};\n/**\n * @license\n * Copyright 2009 The Closure Library Authors\n * Copyright 2020 Daniel Wirtz / The long.js Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nvar Bt = null;\ntry {\n  Bt = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n    0,\n    97,\n    115,\n    109,\n    1,\n    0,\n    0,\n    0,\n    1,\n    13,\n    2,\n    96,\n    0,\n    1,\n    127,\n    96,\n    4,\n    127,\n    127,\n    127,\n    127,\n    1,\n    127,\n    3,\n    7,\n    6,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    6,\n    6,\n    1,\n    127,\n    1,\n    65,\n    0,\n    11,\n    7,\n    50,\n    6,\n    3,\n    109,\n    117,\n    108,\n    0,\n    1,\n    5,\n    100,\n    105,\n    118,\n    95,\n    115,\n    0,\n    2,\n    5,\n    100,\n    105,\n    118,\n    95,\n    117,\n    0,\n    3,\n    5,\n    114,\n    101,\n    109,\n    95,\n    115,\n    0,\n    4,\n    5,\n    114,\n    101,\n    109,\n    95,\n    117,\n    0,\n    5,\n    8,\n    103,\n    101,\n    116,\n    95,\n    104,\n    105,\n    103,\n    104,\n    0,\n    0,\n    10,\n    191,\n    1,\n    6,\n    4,\n    0,\n    35,\n    0,\n    11,\n    36,\n    1,\n    1,\n    126,\n    32,\n    0,\n    173,\n    32,\n    1,\n    173,\n    66,\n    32,\n    134,\n    132,\n    32,\n    2,\n    173,\n    32,\n    3,\n    173,\n    66,\n    32,\n    134,\n    132,\n    126,\n    34,\n    4,\n    66,\n    32,\n    135,\n    167,\n    36,\n    0,\n    32,\n    4,\n    167,\n    11,\n    36,\n    1,\n    1,\n    126,\n    32,\n    0,\n    173,\n    32,\n    1,\n    173,\n    66,\n    32,\n    134,\n    132,\n    32,\n    2,\n    173,\n    32,\n    3,\n    173,\n    66,\n    32,\n    134,\n    132,\n    127,\n    34,\n    4,\n    66,\n    32,\n    135,\n    167,\n    36,\n    0,\n    32,\n    4,\n    167,\n    11,\n    36,\n    1,\n    1,\n    126,\n    32,\n    0,\n    173,\n    32,\n    1,\n    173,\n    66,\n    32,\n    134,\n    132,\n    32,\n    2,\n    173,\n    32,\n    3,\n    173,\n    66,\n    32,\n    134,\n    132,\n    128,\n    34,\n    4,\n    66,\n    32,\n    135,\n    167,\n    36,\n    0,\n    32,\n    4,\n    167,\n    11,\n    36,\n    1,\n    1,\n    126,\n    32,\n    0,\n    173,\n    32,\n    1,\n    173,\n    66,\n    32,\n    134,\n    132,\n    32,\n    2,\n    173,\n    32,\n    3,\n    173,\n    66,\n    32,\n    134,\n    132,\n    129,\n    34,\n    4,\n    66,\n    32,\n    135,\n    167,\n    36,\n    0,\n    32,\n    4,\n    167,\n    11,\n    36,\n    1,\n    1,\n    126,\n    32,\n    0,\n    173,\n    32,\n    1,\n    173,\n    66,\n    32,\n    134,\n    132,\n    32,\n    2,\n    173,\n    32,\n    3,\n    173,\n    66,\n    32,\n    134,\n    132,\n    130,\n    34,\n    4,\n    66,\n    32,\n    135,\n    167,\n    36,\n    0,\n    32,\n    4,\n    167,\n    11\n  ])), {}).exports;\n} catch {\n}\nfunction H(e, t, n) {\n  this.low = e | 0, this.high = t | 0, this.unsigned = !!n;\n}\nH.prototype.__isLong__;\nObject.defineProperty(H.prototype, \"__isLong__\", { value: !0 });\nfunction ot(e) {\n  return (e && e.__isLong__) === !0;\n}\nfunction io(e) {\n  var t = Math.clz32(e & -e);\n  return e ? 31 - t : t;\n}\nH.isLong = ot;\nvar oo = {}, ao = {};\nfunction te(e, t) {\n  var n, s, r;\n  return t ? (e >>>= 0, (r = 0 <= e && e < 256) && (s = ao[e], s) ? s : (n = P(e, 0, !0), r && (ao[e] = n), n)) : (e |= 0, (r = -128 <= e && e < 128) && (s = oo[e], s) ? s : (n = P(e, e < 0 ? -1 : 0, !1), r && (oo[e] = n), n));\n}\nH.fromInt = te;\nfunction Ct(e, t) {\n  if (isNaN(e))\n    return t ? Lt : wt;\n  if (t) {\n    if (e < 0)\n      return Lt;\n    if (e >= Za)\n      return nc;\n  } else {\n    if (e <= -uo)\n      return ft;\n    if (e + 1 >= uo)\n      return ec;\n  }\n  return e < 0 ? Ct(-e, t).neg() : P(e % me | 0, e / me | 0, t);\n}\nH.fromNumber = Ct;\nfunction P(e, t, n) {\n  return new H(e, t, n);\n}\nH.fromBits = P;\nvar Fn = Math.pow;\nfunction Mr(e, t, n) {\n  if (e.length === 0)\n    throw Error(\"empty string\");\n  if (typeof t == \"number\" ? (n = t, t = !1) : t = !!t, e === \"NaN\" || e === \"Infinity\" || e === \"+Infinity\" || e === \"-Infinity\")\n    return t ? Lt : wt;\n  if (n = n || 10, n < 2 || 36 < n)\n    throw RangeError(\"radix\");\n  var s;\n  if ((s = e.indexOf(\"-\")) > 0)\n    throw Error(\"interior hyphen\");\n  if (s === 0)\n    return Mr(e.substring(1), t, n).neg();\n  for (var r = Ct(Fn(n, 8)), i = wt, o = 0; o < e.length; o += 8) {\n    var a = Math.min(8, e.length - o), c = parseInt(e.substring(o, o + a), n);\n    if (a < 8) {\n      var u = Ct(Fn(n, a));\n      i = i.mul(u).add(Ct(c));\n    } else\n      i = i.mul(r), i = i.add(Ct(c));\n  }\n  return i.unsigned = t, i;\n}\nH.fromString = Mr;\nfunction Mt(e, t) {\n  return typeof e == \"number\" ? Ct(e, t) : typeof e == \"string\" ? Mr(e, t) : P(e.low, e.high, typeof t == \"boolean\" ? t : e.unsigned);\n}\nH.fromValue = Mt;\nvar co = 65536, wp = 1 << 24, me = co * co, Za = me * me, uo = Za / 2, lo = te(wp), wt = te(0);\nH.ZERO = wt;\nvar Lt = te(0, !0);\nH.UZERO = Lt;\nvar le = te(1);\nH.ONE = le;\nvar tc = te(1, !0);\nH.UONE = tc;\nvar Qs = te(-1);\nH.NEG_ONE = Qs;\nvar ec = P(-1, 2147483647, !1);\nH.MAX_VALUE = ec;\nvar nc = P(-1, -1, !0);\nH.MAX_UNSIGNED_VALUE = nc;\nvar ft = P(0, -2147483648, !1);\nH.MIN_VALUE = ft;\nvar b = H.prototype;\nb.toInt = function() {\n  return this.unsigned ? this.low >>> 0 : this.low;\n};\nb.toNumber = function() {\n  return this.unsigned ? (this.high >>> 0) * me + (this.low >>> 0) : this.high * me + (this.low >>> 0);\n};\nb.toString = function(t) {\n  if (t = t || 10, t < 2 || 36 < t)\n    throw RangeError(\"radix\");\n  if (this.isZero())\n    return \"0\";\n  if (this.isNegative())\n    if (this.eq(ft)) {\n      var n = Ct(t), s = this.div(n), r = s.mul(n).sub(this);\n      return s.toString(t) + r.toInt().toString(t);\n    } else\n      return \"-\" + this.neg().toString(t);\n  for (var i = Ct(Fn(t, 6), this.unsigned), o = this, a = \"\"; ; ) {\n    var c = o.div(i), u = o.sub(c.mul(i)).toInt() >>> 0, l = u.toString(t);\n    if (o = c, o.isZero())\n      return l + a;\n    for (; l.length < 6; )\n      l = \"0\" + l;\n    a = \"\" + l + a;\n  }\n};\nb.getHighBits = function() {\n  return this.high;\n};\nb.getHighBitsUnsigned = function() {\n  return this.high >>> 0;\n};\nb.getLowBits = function() {\n  return this.low;\n};\nb.getLowBitsUnsigned = function() {\n  return this.low >>> 0;\n};\nb.getNumBitsAbs = function() {\n  if (this.isNegative())\n    return this.eq(ft) ? 64 : this.neg().getNumBitsAbs();\n  for (var t = this.high != 0 ? this.high : this.low, n = 31; n > 0 && !(t & 1 << n); n--)\n    ;\n  return this.high != 0 ? n + 33 : n + 1;\n};\nb.isZero = function() {\n  return this.high === 0 && this.low === 0;\n};\nb.eqz = b.isZero;\nb.isNegative = function() {\n  return !this.unsigned && this.high < 0;\n};\nb.isPositive = function() {\n  return this.unsigned || this.high >= 0;\n};\nb.isOdd = function() {\n  return (this.low & 1) === 1;\n};\nb.isEven = function() {\n  return (this.low & 1) === 0;\n};\nb.equals = function(t) {\n  return ot(t) || (t = Mt(t)), this.unsigned !== t.unsigned && this.high >>> 31 === 1 && t.high >>> 31 === 1 ? !1 : this.high === t.high && this.low === t.low;\n};\nb.eq = b.equals;\nb.notEquals = function(t) {\n  return !this.eq(\n    /* validates */\n    t\n  );\n};\nb.neq = b.notEquals;\nb.ne = b.notEquals;\nb.lessThan = function(t) {\n  return this.comp(\n    /* validates */\n    t\n  ) < 0;\n};\nb.lt = b.lessThan;\nb.lessThanOrEqual = function(t) {\n  return this.comp(\n    /* validates */\n    t\n  ) <= 0;\n};\nb.lte = b.lessThanOrEqual;\nb.le = b.lessThanOrEqual;\nb.greaterThan = function(t) {\n  return this.comp(\n    /* validates */\n    t\n  ) > 0;\n};\nb.gt = b.greaterThan;\nb.greaterThanOrEqual = function(t) {\n  return this.comp(\n    /* validates */\n    t\n  ) >= 0;\n};\nb.gte = b.greaterThanOrEqual;\nb.ge = b.greaterThanOrEqual;\nb.compare = function(t) {\n  if (ot(t) || (t = Mt(t)), this.eq(t))\n    return 0;\n  var n = this.isNegative(), s = t.isNegative();\n  return n && !s ? -1 : !n && s ? 1 : this.unsigned ? t.high >>> 0 > this.high >>> 0 || t.high === this.high && t.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t).isNegative() ? -1 : 1;\n};\nb.comp = b.compare;\nb.negate = function() {\n  return !this.unsigned && this.eq(ft) ? ft : this.not().add(le);\n};\nb.neg = b.negate;\nb.add = function(t) {\n  ot(t) || (t = Mt(t));\n  var n = this.high >>> 16, s = this.high & 65535, r = this.low >>> 16, i = this.low & 65535, o = t.high >>> 16, a = t.high & 65535, c = t.low >>> 16, u = t.low & 65535, l = 0, h = 0, f = 0, d = 0;\n  return d += i + u, f += d >>> 16, d &= 65535, f += r + c, h += f >>> 16, f &= 65535, h += s + a, l += h >>> 16, h &= 65535, l += n + o, l &= 65535, P(f << 16 | d, l << 16 | h, this.unsigned);\n};\nb.subtract = function(t) {\n  return ot(t) || (t = Mt(t)), this.add(t.neg());\n};\nb.sub = b.subtract;\nb.multiply = function(t) {\n  if (this.isZero())\n    return this;\n  if (ot(t) || (t = Mt(t)), Bt) {\n    var n = Bt.mul(\n      this.low,\n      this.high,\n      t.low,\n      t.high\n    );\n    return P(n, Bt.get_high(), this.unsigned);\n  }\n  if (t.isZero())\n    return this.unsigned ? Lt : wt;\n  if (this.eq(ft))\n    return t.isOdd() ? ft : wt;\n  if (t.eq(ft))\n    return this.isOdd() ? ft : wt;\n  if (this.isNegative())\n    return t.isNegative() ? this.neg().mul(t.neg()) : this.neg().mul(t).neg();\n  if (t.isNegative())\n    return this.mul(t.neg()).neg();\n  if (this.lt(lo) && t.lt(lo))\n    return Ct(this.toNumber() * t.toNumber(), this.unsigned);\n  var s = this.high >>> 16, r = this.high & 65535, i = this.low >>> 16, o = this.low & 65535, a = t.high >>> 16, c = t.high & 65535, u = t.low >>> 16, l = t.low & 65535, h = 0, f = 0, d = 0, m = 0;\n  return m += o * l, d += m >>> 16, m &= 65535, d += i * l, f += d >>> 16, d &= 65535, d += o * u, f += d >>> 16, d &= 65535, f += r * l, h += f >>> 16, f &= 65535, f += i * u, h += f >>> 16, f &= 65535, f += o * c, h += f >>> 16, f &= 65535, h += s * l + r * u + i * c + o * a, h &= 65535, P(d << 16 | m, h << 16 | f, this.unsigned);\n};\nb.mul = b.multiply;\nb.divide = function(t) {\n  if (ot(t) || (t = Mt(t)), t.isZero())\n    throw Error(\"division by zero\");\n  if (Bt) {\n    if (!this.unsigned && this.high === -2147483648 && t.low === -1 && t.high === -1)\n      return this;\n    var n = (this.unsigned ? Bt.div_u : Bt.div_s)(\n      this.low,\n      this.high,\n      t.low,\n      t.high\n    );\n    return P(n, Bt.get_high(), this.unsigned);\n  }\n  if (this.isZero())\n    return this.unsigned ? Lt : wt;\n  var s, r, i;\n  if (this.unsigned) {\n    if (t.unsigned || (t = t.toUnsigned()), t.gt(this))\n      return Lt;\n    if (t.gt(this.shru(1)))\n      return tc;\n    i = Lt;\n  } else {\n    if (this.eq(ft)) {\n      if (t.eq(le) || t.eq(Qs))\n        return ft;\n      if (t.eq(ft))\n        return le;\n      var o = this.shr(1);\n      return s = o.div(t).shl(1), s.eq(wt) ? t.isNegative() ? le : Qs : (r = this.sub(t.mul(s)), i = s.add(r.div(t)), i);\n    } else if (t.eq(ft))\n      return this.unsigned ? Lt : wt;\n    if (this.isNegative())\n      return t.isNegative() ? this.neg().div(t.neg()) : this.neg().div(t).neg();\n    if (t.isNegative())\n      return this.div(t.neg()).neg();\n    i = wt;\n  }\n  for (r = this; r.gte(t); ) {\n    s = Math.max(1, Math.floor(r.toNumber() / t.toNumber()));\n    for (var a = Math.ceil(Math.log(s) / Math.LN2), c = a <= 48 ? 1 : Fn(2, a - 48), u = Ct(s), l = u.mul(t); l.isNegative() || l.gt(r); )\n      s -= c, u = Ct(s, this.unsigned), l = u.mul(t);\n    u.isZero() && (u = le), i = i.add(u), r = r.sub(l);\n  }\n  return i;\n};\nb.div = b.divide;\nb.modulo = function(t) {\n  if (ot(t) || (t = Mt(t)), Bt) {\n    var n = (this.unsigned ? Bt.rem_u : Bt.rem_s)(\n      this.low,\n      this.high,\n      t.low,\n      t.high\n    );\n    return P(n, Bt.get_high(), this.unsigned);\n  }\n  return this.sub(this.div(t).mul(t));\n};\nb.mod = b.modulo;\nb.rem = b.modulo;\nb.not = function() {\n  return P(~this.low, ~this.high, this.unsigned);\n};\nb.countLeadingZeros = function() {\n  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n};\nb.clz = b.countLeadingZeros;\nb.countTrailingZeros = function() {\n  return this.low ? io(this.low) : io(this.high) + 32;\n};\nb.ctz = b.countTrailingZeros;\nb.and = function(t) {\n  return ot(t) || (t = Mt(t)), P(this.low & t.low, this.high & t.high, this.unsigned);\n};\nb.or = function(t) {\n  return ot(t) || (t = Mt(t)), P(this.low | t.low, this.high | t.high, this.unsigned);\n};\nb.xor = function(t) {\n  return ot(t) || (t = Mt(t)), P(this.low ^ t.low, this.high ^ t.high, this.unsigned);\n};\nb.shiftLeft = function(t) {\n  return ot(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? P(this.low << t, this.high << t | this.low >>> 32 - t, this.unsigned) : P(0, this.low << t - 32, this.unsigned);\n};\nb.shl = b.shiftLeft;\nb.shiftRight = function(t) {\n  return ot(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? P(this.low >>> t | this.high << 32 - t, this.high >> t, this.unsigned) : P(this.high >> t - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n};\nb.shr = b.shiftRight;\nb.shiftRightUnsigned = function(t) {\n  return ot(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? P(this.low >>> t | this.high << 32 - t, this.high >>> t, this.unsigned) : t === 32 ? P(this.high, 0, this.unsigned) : P(this.high >>> t - 32, 0, this.unsigned);\n};\nb.shru = b.shiftRightUnsigned;\nb.shr_u = b.shiftRightUnsigned;\nb.rotateLeft = function(t) {\n  var n;\n  return ot(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t === 32 ? P(this.high, this.low, this.unsigned) : t < 32 ? (n = 32 - t, P(this.low << t | this.high >>> n, this.high << t | this.low >>> n, this.unsigned)) : (t -= 32, n = 32 - t, P(this.high << t | this.low >>> n, this.low << t | this.high >>> n, this.unsigned));\n};\nb.rotl = b.rotateLeft;\nb.rotateRight = function(t) {\n  var n;\n  return ot(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t === 32 ? P(this.high, this.low, this.unsigned) : t < 32 ? (n = 32 - t, P(this.high << n | this.low >>> t, this.low << n | this.high >>> t, this.unsigned)) : (t -= 32, n = 32 - t, P(this.low << n | this.high >>> t, this.high << n | this.low >>> t, this.unsigned));\n};\nb.rotr = b.rotateRight;\nb.toSigned = function() {\n  return this.unsigned ? P(this.low, this.high, !1) : this;\n};\nb.toUnsigned = function() {\n  return this.unsigned ? this : P(this.low, this.high, !0);\n};\nb.toBytes = function(t) {\n  return t ? this.toBytesLE() : this.toBytesBE();\n};\nb.toBytesLE = function() {\n  var t = this.high, n = this.low;\n  return [\n    n & 255,\n    n >>> 8 & 255,\n    n >>> 16 & 255,\n    n >>> 24,\n    t & 255,\n    t >>> 8 & 255,\n    t >>> 16 & 255,\n    t >>> 24\n  ];\n};\nb.toBytesBE = function() {\n  var t = this.high, n = this.low;\n  return [\n    t >>> 24,\n    t >>> 16 & 255,\n    t >>> 8 & 255,\n    t & 255,\n    n >>> 24,\n    n >>> 16 & 255,\n    n >>> 8 & 255,\n    n & 255\n  ];\n};\nH.fromBytes = function(t, n, s) {\n  return s ? H.fromBytesLE(t, n) : H.fromBytesBE(t, n);\n};\nH.fromBytesLE = function(t, n) {\n  return new H(\n    t[0] | t[1] << 8 | t[2] << 16 | t[3] << 24,\n    t[4] | t[5] << 8 | t[6] << 16 | t[7] << 24,\n    n\n  );\n};\nH.fromBytesBE = function(t, n) {\n  return new H(\n    t[4] << 24 | t[5] << 16 | t[6] << 8 | t[7],\n    t[0] << 24 | t[1] << 16 | t[2] << 8 | t[3],\n    n\n  );\n};\nconst Rp = 16;\nfunction sc(e) {\n  e === \"X\" && (e = \"\");\n  const t = e.padEnd(Rp, \"0\");\n  return H.fromString(t, !0, 16);\n}\nfunction Mp(e) {\n  if (e.isZero())\n    return \"X\";\n  let t = e.countTrailingZeros();\n  const n = t % 4;\n  t = (t - n) / 4;\n  const s = t;\n  t *= 4;\n  const i = e.shiftRightUnsigned(t).toString(16).replace(/0+$/, \"\");\n  return Array(17 - s - i.length).join(\"0\") + i;\n}\nfunction Ip(e, t) {\n  const n = Sp(e).shiftRightUnsigned(2);\n  return e.add(H.fromNumber(2 * t + 1 - 4).multiply(n));\n}\nfunction Sp(e) {\n  return e.and(e.not().add(1));\n}\nconst xp = 3, Op = 30, Fp = 2 * Op + 1, ho = 180 / Math.PI;\nfunction vp(e) {\n  if (e.length === 0)\n    throw new Error(`Invalid Hilbert quad key ${e}`);\n  const t = e.split(\"/\"), n = parseInt(t[0], 10), s = t[1], r = s.length;\n  let i = 0;\n  const o = [0, 0];\n  for (let a = r - 1; a >= 0; a--) {\n    i = r - a;\n    const c = s[a];\n    let u = 0, l = 0;\n    c === \"1\" ? l = 1 : c === \"2\" ? (u = 1, l = 1) : c === \"3\" && (u = 1);\n    const h = Math.pow(2, i - 1);\n    Lp(h, o, u, l), o[0] += h * u, o[1] += h * l;\n  }\n  if (n % 2 === 1) {\n    const a = o[0];\n    o[0] = o[1], o[1] = a;\n  }\n  return {\n    face: n,\n    ij: o,\n    level: i\n  };\n}\nfunction Dp(e) {\n  if (e.isZero())\n    return \"\";\n  let t = e.toString(2);\n  for (; t.length < xp + Fp; )\n    t = \"0\" + t;\n  const n = t.lastIndexOf(\"1\"), s = t.substring(0, 3), r = t.substring(3, n), i = r.length / 2, o = H.fromString(s, !0, 2).toString(10);\n  let a = \"\";\n  if (i !== 0)\n    for (a = H.fromString(r, !0, 2).toString(4); a.length < i; )\n      a = \"0\" + a;\n  return `${o}/${a}`;\n}\nfunction rc(e, t, n) {\n  const s = 1 << t;\n  return [(e[0] + n[0]) / s, (e[1] + n[1]) / s];\n}\nfunction fo(e) {\n  return e >= 0.5 ? 1 / 3 * (4 * e * e - 1) : 1 / 3 * (1 - 4 * (1 - e) * (1 - e));\n}\nfunction ic(e) {\n  return [fo(e[0]), fo(e[1])];\n}\nfunction oc(e, t) {\n  let [n, s] = t;\n  switch (e) {\n    case 0:\n      return [1, n, s];\n    case 1:\n      return [-n, 1, s];\n    case 2:\n      return [-n, -s, 1];\n    case 3:\n      return [-1, -s, -n];\n    case 4:\n      return [s, -1, -n];\n    case 5:\n      return [s, n, -1];\n    default:\n      throw new Error(\"Invalid face\");\n  }\n}\nfunction ac(e) {\n  let [t, n, s] = e;\n  const r = Math.atan2(s, Math.sqrt(t * t + n * n));\n  return [Math.atan2(n, t) * ho, r * ho];\n}\nfunction Lp(e, t, n, s) {\n  if (s === 0) {\n    n === 1 && (t[0] = e - 1 - t[0], t[1] = e - 1 - t[1]);\n    const r = t[0];\n    t[0] = t[1], t[1] = r;\n  }\n}\nfunction Gp(e) {\n  const t = rc(e.ij, e.level, [0.5, 0.5]), n = ic(t), s = oc(e.face, n);\n  return ac(s);\n}\nconst Pp = 100;\nfunction mo(e) {\n  const {\n    face: t,\n    ij: n,\n    level: s\n  } = e, r = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]], i = Math.max(1, Math.ceil(Pp * Math.pow(2, -s))), o = new Float64Array(4 * i * 2 + 2);\n  let a = 0, c = 0;\n  for (let u = 0; u < 4; u++) {\n    const l = r[u].slice(0), h = r[u + 1], f = (h[0] - l[0]) / i, d = (h[1] - l[1]) / i;\n    for (let m = 0; m < i; m++) {\n      l[0] += f, l[1] += d;\n      const g = rc(n, s, l), p = ic(g), C = oc(t, p), w = ac(C);\n      Math.abs(w[1]) > 89.999 && (w[0] = c);\n      const y = w[0] - c;\n      w[0] += y > 180 ? -360 : y < -180 ? 360 : 0, o[a++] = w[0], o[a++] = w[1], c = w[0];\n    }\n  }\n  return o[a++] = o[0], o[a++] = o[1], o;\n}\nfunction Ir(e) {\n  const t = Np(e);\n  return vp(t);\n}\nfunction Np(e) {\n  if (e.indexOf(\"/\") > 0)\n    return e;\n  const t = sc(e);\n  return Dp(t);\n}\nfunction Up(e) {\n  const t = Ir(e);\n  return Gp(t);\n}\nfunction Hp(e) {\n  let t;\n  if (e.face === 2 || e.face === 5) {\n    let n = null, s = 0;\n    for (let r = 0; r < 4; r++) {\n      const i = `${e.face}/${r}`, o = Ir(i), a = mo(o);\n      (typeof n > \"u\" || n === null) && (n = new Float64Array(4 * a.length)), n.set(a, s), s += a.length;\n    }\n    t = go(n);\n  } else {\n    const n = mo(e);\n    t = go(n);\n  }\n  return t;\n}\nfunction go(e) {\n  if (e.length % 2 !== 0)\n    throw new Error(\"Invalid corners\");\n  const t = [], n = [];\n  for (let s = 0; s < e.length; s += 2)\n    t.push(e[s]), n.push(e[s + 1]);\n  return t.sort((s, r) => s - r), n.sort((s, r) => s - r), {\n    west: t[0],\n    east: t[t.length - 1],\n    north: n[n.length - 1],\n    south: n[0]\n  };\n}\nfunction Jp(e, t) {\n  const n = (t == null ? void 0 : t.minimumHeight) || 0, s = (t == null ? void 0 : t.maximumHeight) || 0, r = Ir(e), i = Hp(r), o = i.west, a = i.south, c = i.east, u = i.north, l = [];\n  return l.push(new A(o, u, n)), l.push(new A(c, u, n)), l.push(new A(c, a, n)), l.push(new A(o, a, n)), l.push(new A(o, u, s)), l.push(new A(c, u, s)), l.push(new A(c, a, s)), l.push(new A(o, a, s)), l;\n}\nfunction cc(e) {\n  const t = e.token, n = {\n    minimumHeight: e.minimumHeight,\n    maximumHeight: e.maximumHeight\n  }, s = Jp(t, n), r = Up(t), i = r[0], o = r[1], a = J.WGS84.cartographicToCartesian([i, o, n.maximumHeight]), c = new A(a[0], a[1], a[2]);\n  s.push(c);\n  const u = fd(s);\n  return [...u.center, ...u.halfAxes];\n}\nconst Vp = 4, jp = 8, kp = {\n  QUADTREE: Vp,\n  OCTREE: jp\n};\nfunction Kp(e, t, n) {\n  if (e != null && e.box) {\n    const s = sc(e.s2VolumeInfo.token), r = Ip(s, t), i = Mp(r), o = {\n      ...e.s2VolumeInfo\n    };\n    switch (o.token = i, n) {\n      case \"OCTREE\":\n        const u = e.s2VolumeInfo, l = u.maximumHeight - u.minimumHeight, h = l / 2, f = u.minimumHeight + l / 2;\n        u.minimumHeight = f - h, u.maximumHeight = f + h;\n        break;\n    }\n    return {\n      box: cc(o),\n      s2VolumeInfo: o\n    };\n  }\n}\nasync function uc(e) {\n  const {\n    implicitOptions: t,\n    parentData: n = {\n      mortonIndex: 0,\n      x: 0,\n      y: 0,\n      z: 0\n    },\n    childIndex: s = 0,\n    s2VolumeBox: r,\n    loaderOptions: i\n  } = e;\n  let {\n    subtree: o,\n    level: a = 0,\n    globalData: c = {\n      level: 0,\n      mortonIndex: 0,\n      x: 0,\n      y: 0,\n      z: 0\n    }\n  } = e;\n  const {\n    subdivisionScheme: u,\n    subtreeLevels: l,\n    maximumLevel: h,\n    contentUrlTemplate: f,\n    subtreesUriTemplate: d,\n    basePath: m\n  } = t, g = {\n    children: [],\n    lodMetricValue: 0,\n    contentUrl: \"\"\n  };\n  if (!h)\n    return jo.once(`Missing 'maximumLevel' or 'availableLevels' property. The subtree ${f} won't be loaded...`), g;\n  const p = a + c.level;\n  if (p > h)\n    return g;\n  const C = kp[u], w = Math.log2(C), y = s & 1, B = s >> 1 & 1, R = s >> 2 & 1, E = (C ** a - 1) / (C - 1);\n  let O = Kt(n.mortonIndex, s, w), F = E + O, x = Kt(n.x, y, 1), v = Kt(n.y, B, 1), k = Kt(n.z, R, 1), X = !1;\n  a >= l && (X = Ms(o.childSubtreeAvailability, O));\n  const Q = Kt(c.x, x, a), D = Kt(c.y, v, a), at = Kt(c.z, k, a);\n  if (X) {\n    const nt = `${m}/${d}`, Ft = qs(nt, p, Q, D, at);\n    o = await fe(Ft, $a, i), c = {\n      mortonIndex: O,\n      x,\n      y: v,\n      z: k,\n      level: a\n    }, O = 0, F = 0, x = 0, v = 0, k = 0, a = 0;\n  }\n  if (!Ms(o.tileAvailability, F))\n    return g;\n  Ms(o.contentAvailability, F) && (g.contentUrl = qs(f, p, Q, D, at));\n  const ge = a + 1, Nt = {\n    mortonIndex: O,\n    x,\n    y: v,\n    z: k\n  };\n  for (let nt = 0; nt < C; nt++) {\n    const Ft = Kp(r, nt, u), jt = await uc({\n      subtree: o,\n      implicitOptions: t,\n      loaderOptions: i,\n      parentData: Nt,\n      childIndex: nt,\n      level: ge,\n      globalData: {\n        ...c\n      },\n      s2VolumeBox: Ft\n    });\n    if (jt.contentUrl || jt.children.length) {\n      const Ae = p + 1, zn = zp(jt, Ae, {\n        childTileX: x,\n        childTileY: v,\n        childTileZ: k\n      }, t, r);\n      g.children.push(zn);\n    }\n  }\n  return g;\n}\nfunction Ms(e, t) {\n  let n;\n  return Array.isArray(e) ? (n = e[0], e.length > 1 && jo.once('Not supported extension \"3DTILES_multiple_contents\" has been detected')) : n = e, \"constant\" in n ? !!n.constant : n.explicitBitstream ? Qp(t, n.explicitBitstream) : !1;\n}\nfunction zp(e, t, n, s, r) {\n  const {\n    basePath: i,\n    refine: o,\n    getRefine: a,\n    lodMetricType: c,\n    getTileType: u,\n    rootLodMetricValue: l,\n    rootBoundingVolume: h\n  } = s, f = e.contentUrl && e.contentUrl.replace(`${i}/`, \"\"), d = l / 2 ** t, m = r != null && r.box ? {\n    box: r.box\n  } : h, g = Wp(t, m, n);\n  return {\n    children: e.children,\n    contentUrl: e.contentUrl,\n    content: {\n      uri: f\n    },\n    id: e.contentUrl,\n    refine: a(o),\n    type: u(e),\n    lodMetricType: c,\n    lodMetricValue: d,\n    geometricError: d,\n    transform: e.transform,\n    boundingVolume: g\n  };\n}\nfunction Wp(e, t, n) {\n  if (t.region) {\n    const {\n      childTileX: s,\n      childTileY: r,\n      childTileZ: i\n    } = n, [o, a, c, u, l, h] = t.region, f = 2 ** e, d = (c - o) / f, m = (u - a) / f, g = (h - l) / f, [p, C] = [o + d * s, o + d * (s + 1)], [w, y] = [a + m * r, a + m * (r + 1)], [B, R] = [l + g * i, l + g * (i + 1)];\n    return {\n      region: [p, w, C, y, B, R]\n    };\n  }\n  if (t.box)\n    return t;\n  throw new Error(`Unsupported bounding volume type ${t}`);\n}\nfunction Kt(e, t, n) {\n  return (e << n) + t;\n}\nfunction qs(e, t, n, s, r) {\n  const i = Xp({\n    level: t,\n    x: n,\n    y: s,\n    z: r\n  });\n  return e.replace(/{level}|{x}|{y}|{z}/gi, (o) => i[o]);\n}\nfunction Xp(e) {\n  const t = {};\n  for (const n in e)\n    t[`{${n}}`] = e[n];\n  return t;\n}\nfunction Qp(e, t) {\n  const n = Math.floor(e / 8), s = e % 8;\n  return (t[n] >> s & 1) === 1;\n}\nfunction Sr(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n  if (!t)\n    return zt.EMPTY;\n  const s = t.split(\"?\")[0].split(\".\").pop();\n  switch (s) {\n    case \"pnts\":\n      return zt.POINTCLOUD;\n    case \"i3dm\":\n    case \"b3dm\":\n    case \"glb\":\n    case \"gltf\":\n      return zt.SCENEGRAPH;\n    default:\n      return s || zt.EMPTY;\n  }\n}\nfunction xr(e) {\n  switch (e) {\n    case \"REPLACE\":\n    case \"replace\":\n      return Gt.REPLACE;\n    case \"ADD\":\n    case \"add\":\n      return Gt.ADD;\n    default:\n      return e;\n  }\n}\nfunction Ys(e, t) {\n  if (/^[a-z][0-9a-z+.-]*:/i.test(t)) {\n    const s = new URL(e, `${t}/`);\n    return decodeURI(s.toString());\n  } else if (e.startsWith(\"/\"))\n    return e;\n  return Ru(t, e);\n}\nfunction Ao(e, t) {\n  if (!e)\n    return null;\n  let n;\n  if (e.content) {\n    var s;\n    const i = e.content.uri || ((s = e.content) === null || s === void 0 ? void 0 : s.url);\n    typeof i < \"u\" && (n = Ys(i, t));\n  }\n  return {\n    ...e,\n    id: n,\n    contentUrl: n,\n    lodMetricType: Hn.GEOMETRIC_ERROR,\n    lodMetricValue: e.geometricError,\n    transformMatrix: e.transform,\n    type: Sr(e, n),\n    refine: xr(e.refine)\n  };\n}\nasync function qp(e, t, n) {\n  let s = null;\n  const r = yo(e.root);\n  r && e.root ? s = await po(e.root, e, t, r, n) : s = Ao(e.root, t);\n  const i = [];\n  for (i.push(s); i.length > 0; ) {\n    const o = i.pop() || {}, a = o.children || [], c = [];\n    for (const u of a) {\n      const l = yo(u);\n      let h;\n      l ? h = await po(u, e, t, l, n) : h = Ao(u, t), h && (c.push(h), i.push(h));\n    }\n    o.children = c;\n  }\n  return s;\n}\nasync function po(e, t, n, s, r) {\n  var i, o, a;\n  const {\n    subdivisionScheme: c,\n    maximumLevel: u,\n    availableLevels: l,\n    subtreeLevels: h,\n    subtrees: {\n      uri: f\n    }\n  } = s, d = qs(f, 0, 0, 0, 0), m = Ys(d, n), g = await fe(m, $a, r), p = (i = e.content) === null || i === void 0 ? void 0 : i.uri, C = p ? Ys(p, n) : \"\", w = t == null || (o = t.root) === null || o === void 0 ? void 0 : o.refine, y = e.geometricError, B = (a = e.boundingVolume.extensions) === null || a === void 0 ? void 0 : a[\"3DTILES_bounding_volume_S2\"];\n  if (B) {\n    const F = {\n      box: cc(B),\n      s2VolumeInfo: B\n    };\n    e.boundingVolume = F;\n  }\n  const R = e.boundingVolume, E = {\n    contentUrlTemplate: C,\n    subtreesUriTemplate: f,\n    subdivisionScheme: c,\n    subtreeLevels: h,\n    maximumLevel: Number.isFinite(l) ? l - 1 : u,\n    refine: w,\n    basePath: n,\n    lodMetricType: Hn.GEOMETRIC_ERROR,\n    rootLodMetricValue: y,\n    rootBoundingVolume: R,\n    getTileType: Sr,\n    getRefine: xr\n  };\n  return await Yp(e, n, g, E, r);\n}\nasync function Yp(e, t, n, s, r) {\n  if (!e)\n    return null;\n  const {\n    children: i,\n    contentUrl: o\n  } = await uc({\n    subtree: n,\n    implicitOptions: s,\n    loaderOptions: r\n  });\n  let a, c = null;\n  return o && (a = o, c = {\n    uri: o.replace(`${t}/`, \"\")\n  }), {\n    ...e,\n    id: a,\n    contentUrl: a,\n    lodMetricType: Hn.GEOMETRIC_ERROR,\n    lodMetricValue: e.geometricError,\n    transformMatrix: e.transform,\n    type: Sr(e, a),\n    refine: xr(e.refine),\n    content: c || e.content,\n    children: i\n  };\n}\nfunction yo(e) {\n  var t;\n  return (e == null || (t = e.extensions) === null || t === void 0 ? void 0 : t[\"3DTILES_implicit_tiling\"]) || (e == null ? void 0 : e.implicitTiling);\n}\nconst Oe = {\n  id: \"3d-tiles\",\n  name: \"3D Tiles\",\n  module: \"3d-tiles\",\n  version: Ba,\n  extensions: [\"cmpt\", \"pnts\", \"b3dm\", \"i3dm\"],\n  mimeTypes: [\"application/octet-stream\"],\n  tests: [\"cmpt\", \"pnts\", \"b3dm\", \"i3dm\"],\n  parse: $p,\n  options: {\n    \"3d-tiles\": {\n      loadGLTF: !0,\n      decodeQuantizedPositions: !1,\n      isTileset: \"auto\",\n      assetGltfUpAxis: null\n    }\n  }\n};\nasync function $p(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = t[\"3d-tiles\"] || {};\n  let r;\n  return s.isTileset === \"auto\" ? r = (n == null ? void 0 : n.url) && n.url.indexOf(\".json\") !== -1 : r = s.isTileset, r ? Zp(e, t, n) : ty(e, t, n);\n}\nasync function Zp(e, t, n) {\n  var s;\n  const r = JSON.parse(new TextDecoder().decode(e)), i = (n == null ? void 0 : n.url) || \"\", o = ey(i), a = await qp(r, o, t || {});\n  return {\n    ...r,\n    shape: \"tileset3d\",\n    loader: Oe,\n    url: i,\n    queryString: (n == null ? void 0 : n.queryString) || \"\",\n    basePath: o,\n    root: a || r.root,\n    type: At.TILES3D,\n    lodMetricType: Hn.GEOMETRIC_ERROR,\n    lodMetricValue: ((s = r.root) === null || s === void 0 ? void 0 : s.geometricError) || 0\n  };\n}\nasync function ty(e, t, n) {\n  const s = {\n    content: {\n      shape: \"tile3d\",\n      featureIds: null\n    }\n  };\n  return await Ya(e, 0, t, n, s.content), s.content;\n}\nfunction ey(e) {\n  return rr(e);\n}\nconst lc = \"https://api.cesium.com/v1/assets\";\nasync function ny(e, t) {\n  if (!t) {\n    const i = await sy(e);\n    for (const o of i.items)\n      o.type === \"3DTILES\" && (t = o.id);\n  }\n  const n = await ry(e, t), {\n    type: s,\n    url: r\n  } = n;\n  return U(s === \"3DTILES\" && r), n.headers = {\n    Authorization: `Bearer ${n.accessToken}`\n  }, n;\n}\nasync function sy(e) {\n  U(e);\n  const t = lc, n = {\n    Authorization: `Bearer ${e}`\n  }, s = await Fe(t, {\n    headers: n\n  });\n  if (!s.ok)\n    throw new Error(s.statusText);\n  return await s.json();\n}\nasync function ry(e, t) {\n  U(e, t);\n  const n = {\n    Authorization: `Bearer ${e}`\n  }, s = `${lc}/${t}`;\n  let r = await Fe(`${s}`, {\n    headers: n\n  });\n  if (!r.ok)\n    throw new Error(r.statusText);\n  let i = await r.json();\n  if (r = await Fe(`${s}/endpoint`, {\n    headers: n\n  }), !r.ok)\n    throw new Error(r.statusText);\n  const o = await r.json();\n  return i = {\n    ...i,\n    ...o\n  }, i;\n}\nasync function iy(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  t = t[\"cesium-ion\"] || {};\n  const {\n    accessToken: n\n  } = t;\n  let s = t.assetId;\n  if (!Number.isFinite(s)) {\n    const r = e.match(/\\/([0-9]+)\\/tileset.json/);\n    s = r && r[1];\n  }\n  return ny(n, s);\n}\nconst hc = {\n  ...Oe,\n  id: \"cesium-ion\",\n  name: \"Cesium Ion\",\n  preload: iy,\n  parse: async (e, t, n) => (t = {\n    ...t\n  }, t[\"3d-tiles\"] = t[\"cesium-ion\"], t.loader = hc, Oe.parse(e, t, n)),\n  options: {\n    \"cesium-ion\": {\n      ...Oe.options[\"3d-tiles\"],\n      accessToken: null\n    }\n  }\n}, Bo = 100;\nclass oy {\n  constructor(t, n) {\n    if (this.schema = void 0, this.options = void 0, this.shape = void 0, this.length = 0, this.rows = null, this.cursor = 0, this._headers = [], this.options = n, this.schema = t, !Array.isArray(t)) {\n      this._headers = [];\n      for (const s in t)\n        this._headers[t[s].index] = t[s].name;\n    }\n  }\n  rowCount() {\n    return this.length;\n  }\n  addArrayRow(t, n) {\n    Number.isFinite(n) && (this.cursor = n), this.shape = \"array-row-table\", this.rows = this.rows || new Array(Bo), this.rows[this.length] = t, this.length++;\n  }\n  addObjectRow(t, n) {\n    Number.isFinite(n) && (this.cursor = n), this.shape = \"object-row-table\", this.rows = this.rows || new Array(Bo), this.rows[this.length] = t, this.length++;\n  }\n  getBatch() {\n    let t = this.rows;\n    return t ? (t = t.slice(0, this.length), this.rows = null, {\n      shape: this.shape || \"array-row-table\",\n      batchType: \"data\",\n      data: t,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    }) : null;\n  }\n}\nfunction ay(e, t) {\n  if (!e)\n    throw new Error(\"null row\");\n  const n = {};\n  if (t)\n    for (let s = 0; s < t.length; s++)\n      n[t[s]] = e[s];\n  else\n    for (let s = 0; s < e.length; s++) {\n      const r = `column-${s}`;\n      n[r] = e[s];\n    }\n  return n;\n}\nfunction cy(e, t) {\n  if (!e)\n    throw new Error(\"null row\");\n  if (t) {\n    const n = new Array(t.length);\n    for (let s = 0; s < t.length; s++)\n      n[s] = e[t[s]];\n    return n;\n  }\n  return Object.values(e);\n}\nfunction uy(e) {\n  const t = [];\n  for (let n = 0; n < e.length; n++) {\n    const s = `column-${n}`;\n    t.push(s);\n  }\n  return t;\n}\nfunction ly(e) {\n  return Object.keys(e);\n}\nconst Co = 100;\nclass hy {\n  constructor(t, n) {\n    if (this.schema = void 0, this.options = void 0, this.length = 0, this.objectRows = null, this.arrayRows = null, this.cursor = 0, this._headers = null, this.options = n, this.schema = t, t) {\n      this._headers = [];\n      for (const s in t)\n        this._headers[t[s].index] = t[s].name;\n    }\n  }\n  rowCount() {\n    return this.length;\n  }\n  addArrayRow(t, n) {\n    switch (Number.isFinite(n) && (this.cursor = n), this._headers || (this._headers = uy(t)), this.options.shape) {\n      case \"object-row-table\":\n        const s = ay(t, this._headers);\n        this.addObjectRow(s, n);\n        break;\n      case \"array-row-table\":\n        this.arrayRows = this.arrayRows || new Array(Co), this.arrayRows[this.length] = t, this.length++;\n        break;\n    }\n  }\n  addObjectRow(t, n) {\n    switch (Number.isFinite(n) && (this.cursor = n), this._headers || (this._headers = ly(t)), this.options.shape) {\n      case \"array-row-table\":\n        const s = cy(t, this._headers);\n        this.addArrayRow(s, n);\n        break;\n      case \"object-row-table\":\n        this.objectRows = this.objectRows || new Array(Co), this.objectRows[this.length] = t, this.length++;\n        break;\n    }\n  }\n  getBatch() {\n    let t = this.arrayRows || this.objectRows;\n    return t ? (t = t.slice(0, this.length), this.arrayRows = null, this.objectRows = null, {\n      shape: this.options.shape,\n      batchType: \"data\",\n      data: t,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    }) : null;\n  }\n}\nconst fy = 100;\nclass dy {\n  constructor(t, n) {\n    this.schema = void 0, this.length = 0, this.allocated = 0, this.columns = {}, this.schema = t, this._reallocateColumns();\n  }\n  rowCount() {\n    return this.length;\n  }\n  addArrayRow(t) {\n    this._reallocateColumns();\n    let n = 0;\n    for (const s in this.columns)\n      this.columns[s][this.length] = t[n++];\n    this.length++;\n  }\n  addObjectRow(t) {\n    this._reallocateColumns();\n    for (const n in t)\n      this.columns[n][this.length] = t[n];\n    this.length++;\n  }\n  getBatch() {\n    this._pruneColumns();\n    const t = Array.isArray(this.schema) ? this.columns : {};\n    if (!Array.isArray(this.schema))\n      for (const s in this.schema) {\n        const r = this.schema[s];\n        t[r.name] = this.columns[r.index];\n      }\n    return this.columns = {}, {\n      shape: \"columnar-table\",\n      batchType: \"data\",\n      data: t,\n      schema: this.schema,\n      length: this.length\n    };\n  }\n  _reallocateColumns() {\n    if (!(this.length < this.allocated)) {\n      this.allocated = this.allocated > 0 ? this.allocated *= 2 : fy, this.columns = {};\n      for (const t in this.schema) {\n        const n = this.schema[t], s = n.type || Float32Array, r = this.columns[n.index];\n        if (r && ArrayBuffer.isView(r)) {\n          const i = new s(this.allocated);\n          i.set(r), this.columns[n.index] = i;\n        } else\n          r ? (r.length = this.allocated, this.columns[n.index] = r) : this.columns[n.index] = new s(this.allocated);\n      }\n    }\n  }\n  _pruneColumns() {\n    for (const [t, n] of Object.entries(this.columns))\n      this.columns[t] = n.slice(0, this.length);\n  }\n}\nconst my = {\n  shape: void 0,\n  batchSize: \"auto\",\n  batchDebounceMs: 0,\n  limit: 0,\n  _limitMB: 0\n}, gy = \"TableBatchBuilder\";\nclass Le {\n  constructor(t, n) {\n    this.schema = void 0, this.options = void 0, this.aggregator = null, this.batchCount = 0, this.bytesUsed = 0, this.isChunkComplete = !1, this.lastBatchEmittedMs = Date.now(), this.totalLength = 0, this.totalBytes = 0, this.rowBytes = 0, this.schema = t, this.options = {\n      ...my,\n      ...n\n    };\n  }\n  limitReached() {\n    var t, n;\n    return !!(!((t = this.options) === null || t === void 0) && t.limit && this.totalLength >= this.options.limit || !((n = this.options) === null || n === void 0) && n._limitMB && this.totalBytes / 1e6 >= this.options._limitMB);\n  }\n  addRow(t) {\n    this.limitReached() || (this.totalLength++, this.rowBytes = this.rowBytes || this._estimateRowMB(t), this.totalBytes += this.rowBytes, Array.isArray(t) ? this.addArrayRow(t) : this.addObjectRow(t));\n  }\n  addArrayRow(t) {\n    if (!this.aggregator) {\n      const n = this._getTableBatchType();\n      this.aggregator = new n(this.schema, this.options);\n    }\n    this.aggregator.addArrayRow(t);\n  }\n  addObjectRow(t) {\n    if (!this.aggregator) {\n      const n = this._getTableBatchType();\n      this.aggregator = new n(this.schema, this.options);\n    }\n    this.aggregator.addObjectRow(t);\n  }\n  chunkComplete(t) {\n    t instanceof ArrayBuffer && (this.bytesUsed += t.byteLength), typeof t == \"string\" && (this.bytesUsed += t.length), this.isChunkComplete = !0;\n  }\n  getFullBatch(t) {\n    return this._isFull() ? this._getBatch(t) : null;\n  }\n  getFinalBatch(t) {\n    return this._getBatch(t);\n  }\n  _estimateRowMB(t) {\n    return Array.isArray(t) ? t.length * 8 : Object.keys(t).length * 8;\n  }\n  _isFull() {\n    if (!this.aggregator || this.aggregator.rowCount() === 0)\n      return !1;\n    if (this.options.batchSize === \"auto\") {\n      if (!this.isChunkComplete)\n        return !1;\n    } else if (this.options.batchSize > this.aggregator.rowCount())\n      return !1;\n    return this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs ? !1 : (this.isChunkComplete = !1, this.lastBatchEmittedMs = Date.now(), !0);\n  }\n  _getBatch(t) {\n    if (!this.aggregator)\n      return null;\n    t != null && t.bytesUsed && (this.bytesUsed = t.bytesUsed);\n    const n = this.aggregator.getBatch();\n    return n.count = this.batchCount, n.bytesUsed = this.bytesUsed, Object.assign(n, t), this.batchCount++, this.aggregator = null, n;\n  }\n  _getTableBatchType() {\n    switch (this.options.shape) {\n      case \"array-row-table\":\n      case \"object-row-table\":\n        return hy;\n      case \"columnar-table\":\n        return dy;\n      case \"arrow-table\":\n        if (!Le.ArrowBatch)\n          throw new Error(gy);\n        return Le.ArrowBatch;\n      default:\n        return oy;\n    }\n  }\n}\nLe.ArrowBatch = void 0;\nfunction Ay(e) {\n  try {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return async function* () {\n      const n = new TextDecoder(void 0, t);\n      for await (const s of e)\n        yield typeof s == \"string\" ? s : n.decode(s, {\n          stream: !0\n        });\n    }();\n  } catch (t) {\n    return Promise.reject(t);\n  }\n}\nconst $s = Number.MAX_SAFE_INTEGER;\nvar M = function(e) {\n  return e[e.BEGIN = 0] = \"BEGIN\", e[e.VALUE = 1] = \"VALUE\", e[e.OPEN_OBJECT = 2] = \"OPEN_OBJECT\", e[e.CLOSE_OBJECT = 3] = \"CLOSE_OBJECT\", e[e.OPEN_ARRAY = 4] = \"OPEN_ARRAY\", e[e.CLOSE_ARRAY = 5] = \"CLOSE_ARRAY\", e[e.TEXT_ESCAPE = 6] = \"TEXT_ESCAPE\", e[e.STRING = 7] = \"STRING\", e[e.BACKSLASH = 8] = \"BACKSLASH\", e[e.END = 9] = \"END\", e[e.OPEN_KEY = 10] = \"OPEN_KEY\", e[e.CLOSE_KEY = 11] = \"CLOSE_KEY\", e[e.TRUE = 12] = \"TRUE\", e[e.TRUE2 = 13] = \"TRUE2\", e[e.TRUE3 = 14] = \"TRUE3\", e[e.FALSE = 15] = \"FALSE\", e[e.FALSE2 = 16] = \"FALSE2\", e[e.FALSE3 = 17] = \"FALSE3\", e[e.FALSE4 = 18] = \"FALSE4\", e[e.NULL = 19] = \"NULL\", e[e.NULL2 = 20] = \"NULL2\", e[e.NULL3 = 21] = \"NULL3\", e[e.NUMBER_DECIMAL_POINT = 22] = \"NUMBER_DECIMAL_POINT\", e[e.NUMBER_DIGIT = 23] = \"NUMBER_DIGIT\", e;\n}(M || {});\nconst I = {\n  tab: 9,\n  lineFeed: 10,\n  carriageReturn: 13,\n  space: 32,\n  doubleQuote: 34,\n  plus: 43,\n  comma: 44,\n  minus: 45,\n  period: 46,\n  _0: 48,\n  _9: 57,\n  colon: 58,\n  E: 69,\n  openBracket: 91,\n  backslash: 92,\n  closeBracket: 93,\n  a: 97,\n  b: 98,\n  e: 101,\n  f: 102,\n  l: 108,\n  n: 110,\n  r: 114,\n  s: 115,\n  t: 116,\n  u: 117,\n  openBrace: 123,\n  closeBrace: 125\n}, Eo = /[\\\\\"\\n]/g, To = {\n  onready: () => {\n  },\n  onopenobject: () => {\n  },\n  onkey: () => {\n  },\n  oncloseobject: () => {\n  },\n  onopenarray: () => {\n  },\n  onclosearray: () => {\n  },\n  onvalue: () => {\n  },\n  onerror: () => {\n  },\n  onend: () => {\n  },\n  onchunkparsed: () => {\n  }\n};\nclass py {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    this.options = To, this.bufferCheckPosition = $s, this.q = \"\", this.c = \"\", this.p = \"\", this.closed = !1, this.closedRoot = !1, this.sawRoot = !1, this.error = null, this.state = M.BEGIN, this.stack = [], this.position = 0, this.column = 0, this.line = 1, this.slashed = !1, this.unicodeI = 0, this.unicodeS = null, this.depth = 0, this.textNode = void 0, this.numberNode = void 0, this.options = {\n      ...To,\n      ...t\n    }, this.textNode = void 0, this.numberNode = \"\", this.emit(\"onready\");\n  }\n  end() {\n    return (this.state !== M.VALUE || this.depth !== 0) && this._error(\"Unexpected end\"), this._closeValue(), this.c = \"\", this.closed = !0, this.emit(\"onend\"), this;\n  }\n  resume() {\n    return this.error = null, this;\n  }\n  close() {\n    return this.write(null);\n  }\n  emit(t, n) {\n    var s, r;\n    (s = (r = this.options)[t]) === null || s === void 0 || s.call(r, n, this);\n  }\n  emitNode(t, n) {\n    this._closeValue(), this.emit(t, n);\n  }\n  write(t) {\n    if (this.error)\n      throw this.error;\n    if (this.closed)\n      return this._error(\"Cannot write after close. Assign an onready handler.\");\n    if (t === null)\n      return this.end();\n    let n = 0, s = t.charCodeAt(0), r = this.p;\n    for (; s && (r = s, this.c = s = t.charCodeAt(n++), r !== s ? this.p = r : r = this.p, !!s); )\n      switch (this.position++, s === I.lineFeed ? (this.line++, this.column = 0) : this.column++, this.state) {\n        case M.BEGIN:\n          s === I.openBrace ? this.state = M.OPEN_OBJECT : s === I.openBracket ? this.state = M.OPEN_ARRAY : _e(s) || this._error(\"Non-whitespace before {[.\");\n          continue;\n        case M.OPEN_KEY:\n        case M.OPEN_OBJECT:\n          if (_e(s))\n            continue;\n          if (this.state === M.OPEN_KEY)\n            this.stack.push(M.CLOSE_KEY);\n          else if (s === I.closeBrace) {\n            this.emit(\"onopenobject\"), this.depth++, this.emit(\"oncloseobject\"), this.depth--, this.state = this.stack.pop() || M.VALUE;\n            continue;\n          } else\n            this.stack.push(M.CLOSE_OBJECT);\n          s === I.doubleQuote ? this.state = M.STRING : this._error('Malformed object key should start with \"');\n          continue;\n        case M.CLOSE_KEY:\n        case M.CLOSE_OBJECT:\n          if (_e(s))\n            continue;\n          s === I.colon ? (this.state === M.CLOSE_OBJECT ? (this.stack.push(M.CLOSE_OBJECT), this._closeValue(\"onopenobject\"), this.depth++) : this._closeValue(\"onkey\"), this.state = M.VALUE) : s === I.closeBrace ? (this.emitNode(\"oncloseobject\"), this.depth--, this.state = this.stack.pop() || M.VALUE) : s === I.comma ? (this.state === M.CLOSE_OBJECT && this.stack.push(M.CLOSE_OBJECT), this._closeValue(), this.state = M.OPEN_KEY) : this._error(\"Bad object\");\n          continue;\n        case M.OPEN_ARRAY:\n        case M.VALUE:\n          if (_e(s))\n            continue;\n          if (this.state === M.OPEN_ARRAY)\n            if (this.emit(\"onopenarray\"), this.depth++, this.state = M.VALUE, s === I.closeBracket) {\n              this.emit(\"onclosearray\"), this.depth--, this.state = this.stack.pop() || M.VALUE;\n              continue;\n            } else\n              this.stack.push(M.CLOSE_ARRAY);\n          s === I.doubleQuote ? this.state = M.STRING : s === I.openBrace ? this.state = M.OPEN_OBJECT : s === I.openBracket ? this.state = M.OPEN_ARRAY : s === I.t ? this.state = M.TRUE : s === I.f ? this.state = M.FALSE : s === I.n ? this.state = M.NULL : s === I.minus ? this.numberNode += \"-\" : I._0 <= s && s <= I._9 ? (this.numberNode += String.fromCharCode(s), this.state = M.NUMBER_DIGIT) : this._error(\"Bad value\");\n          continue;\n        case M.CLOSE_ARRAY:\n          if (s === I.comma)\n            this.stack.push(M.CLOSE_ARRAY), this._closeValue(\"onvalue\"), this.state = M.VALUE;\n          else if (s === I.closeBracket)\n            this.emitNode(\"onclosearray\"), this.depth--, this.state = this.stack.pop() || M.VALUE;\n          else {\n            if (_e(s))\n              continue;\n            this._error(\"Bad array\");\n          }\n          continue;\n        case M.STRING:\n          this.textNode === void 0 && (this.textNode = \"\");\n          let i = n - 1, o = this.slashed, a = this.unicodeI;\n          t:\n            for (; ; ) {\n              for (; a > 0; )\n                if (this.unicodeS += String.fromCharCode(s), s = t.charCodeAt(n++), this.position++, a === 4 ? (this.textNode += String.fromCharCode(parseInt(this.unicodeS, 16)), a = 0, i = n - 1) : a++, !s)\n                  break t;\n              if (s === I.doubleQuote && !o) {\n                this.state = this.stack.pop() || M.VALUE, this.textNode += t.substring(i, n - 1), this.position += n - 1 - i;\n                break;\n              }\n              if (s === I.backslash && !o && (o = !0, this.textNode += t.substring(i, n - 1), this.position += n - 1 - i, s = t.charCodeAt(n++), this.position++, !s))\n                break;\n              if (o) {\n                if (o = !1, s === I.n ? this.textNode += `\n` : s === I.r ? this.textNode += \"\\r\" : s === I.t ? this.textNode += \"\t\" : s === I.f ? this.textNode += \"\\f\" : s === I.b ? this.textNode += \"\\b\" : s === I.u ? (a = 1, this.unicodeS = \"\") : this.textNode += String.fromCharCode(s), s = t.charCodeAt(n++), this.position++, i = n - 1, s)\n                  continue;\n                break;\n              }\n              Eo.lastIndex = n;\n              const c = Eo.exec(t);\n              if (c === null) {\n                n = t.length + 1, this.textNode += t.substring(i, n - 1), this.position += n - 1 - i;\n                break;\n              }\n              if (n = c.index + 1, s = t.charCodeAt(c.index), !s) {\n                this.textNode += t.substring(i, n - 1), this.position += n - 1 - i;\n                break;\n              }\n            }\n          this.slashed = o, this.unicodeI = a;\n          continue;\n        case M.TRUE:\n          s === I.r ? this.state = M.TRUE2 : this._error(`Invalid true started with t${s}`);\n          continue;\n        case M.TRUE2:\n          s === I.u ? this.state = M.TRUE3 : this._error(`Invalid true started with tr${s}`);\n          continue;\n        case M.TRUE3:\n          s === I.e ? (this.emit(\"onvalue\", !0), this.state = this.stack.pop() || M.VALUE) : this._error(`Invalid true started with tru${s}`);\n          continue;\n        case M.FALSE:\n          s === I.a ? this.state = M.FALSE2 : this._error(`Invalid false started with f${s}`);\n          continue;\n        case M.FALSE2:\n          s === I.l ? this.state = M.FALSE3 : this._error(`Invalid false started with fa${s}`);\n          continue;\n        case M.FALSE3:\n          s === I.s ? this.state = M.FALSE4 : this._error(`Invalid false started with fal${s}`);\n          continue;\n        case M.FALSE4:\n          s === I.e ? (this.emit(\"onvalue\", !1), this.state = this.stack.pop() || M.VALUE) : this._error(`Invalid false started with fals${s}`);\n          continue;\n        case M.NULL:\n          s === I.u ? this.state = M.NULL2 : this._error(`Invalid null started with n${s}`);\n          continue;\n        case M.NULL2:\n          s === I.l ? this.state = M.NULL3 : this._error(`Invalid null started with nu${s}`);\n          continue;\n        case M.NULL3:\n          s === I.l ? (this.emit(\"onvalue\", null), this.state = this.stack.pop() || M.VALUE) : this._error(`Invalid null started with nul${s}`);\n          continue;\n        case M.NUMBER_DECIMAL_POINT:\n          s === I.period ? (this.numberNode += \".\", this.state = M.NUMBER_DIGIT) : this._error(\"Leading zero not followed by .\");\n          continue;\n        case M.NUMBER_DIGIT:\n          I._0 <= s && s <= I._9 ? this.numberNode += String.fromCharCode(s) : s === I.period ? (this.numberNode.indexOf(\".\") !== -1 && this._error(\"Invalid number has two dots\"), this.numberNode += \".\") : s === I.e || s === I.E ? ((this.numberNode.indexOf(\"e\") !== -1 || this.numberNode.indexOf(\"E\") !== -1) && this._error(\"Invalid number has two exponential\"), this.numberNode += \"e\") : s === I.plus || s === I.minus ? (r === I.e || r === I.E || this._error(\"Invalid symbol in number\"), this.numberNode += String.fromCharCode(s)) : (this._closeNumber(), n--, this.state = this.stack.pop() || M.VALUE);\n          continue;\n        default:\n          this._error(`Unknown state: ${this.state}`);\n      }\n    return this.position >= this.bufferCheckPosition && yy(this), this.emit(\"onchunkparsed\"), this;\n  }\n  _closeValue() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"onvalue\";\n    this.textNode !== void 0 && this.emit(t, this.textNode), this.textNode = void 0;\n  }\n  _closeNumber() {\n    this.numberNode && this.emit(\"onvalue\", parseFloat(this.numberNode)), this.numberNode = \"\";\n  }\n  _error() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n    this._closeValue(), t += `\nLine: ${this.line}\nColumn: ${this.column}\nChar: ${this.c}`;\n    const n = new Error(t);\n    this.error = n, this.emit(\"onerror\", n);\n  }\n}\nfunction _e(e) {\n  return e === I.carriageReturn || e === I.lineFeed || e === I.space || e === I.tab;\n}\nfunction yy(e) {\n  const t = Math.max($s, 10);\n  let n = 0;\n  for (const s of [\"textNode\", \"numberNode\"]) {\n    const r = e[s] === void 0 ? 0 : e[s].length;\n    if (r > t)\n      switch (s) {\n        case \"text\":\n          break;\n        default:\n          e._error(`Max buffer length exceeded: ${s}`);\n      }\n    n = Math.max(n, r);\n  }\n  e.bufferCheckPosition = $s - n + e.position;\n}\nclass Qt {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n    if (this.path = void 0, this.path = [\"$\"], t instanceof Qt) {\n      this.path = [...t.path];\n      return;\n    }\n    if (Array.isArray(t)) {\n      this.path.push(...t);\n      return;\n    }\n    if (typeof t == \"string\" && (this.path = t.split(\".\"), this.path[0] !== \"$\"))\n      throw new Error(\"JSONPaths must start with $\");\n  }\n  clone() {\n    return new Qt(this);\n  }\n  toString() {\n    return this.path.join(\".\");\n  }\n  push(t) {\n    this.path.push(t);\n  }\n  pop() {\n    return this.path.pop();\n  }\n  set(t) {\n    this.path[this.path.length - 1] = t;\n  }\n  equals(t) {\n    if (!this || !t || this.path.length !== t.path.length)\n      return !1;\n    for (let n = 0; n < this.path.length; ++n)\n      if (this.path[n] !== t.path[n])\n        return !1;\n    return !0;\n  }\n  setFieldAtPath(t, n) {\n    const s = [...this.path];\n    s.shift();\n    const r = s.pop();\n    for (const i of s)\n      t = t[i];\n    t[r] = n;\n  }\n  getFieldAtPath(t) {\n    const n = [...this.path];\n    n.shift();\n    const s = n.pop();\n    for (const r of n)\n      t = t[r];\n    return t[s];\n  }\n}\nclass By {\n  constructor(t) {\n    this.parser = void 0, this.result = void 0, this.previousStates = [], this.currentState = Object.freeze({\n      container: [],\n      key: null\n    }), this.jsonpath = new Qt(), this.reset(), this.parser = new py({\n      onready: () => {\n        this.jsonpath = new Qt(), this.previousStates.length = 0, this.currentState.container.length = 0;\n      },\n      onopenobject: (n) => {\n        this._openObject({}), typeof n < \"u\" && this.parser.emit(\"onkey\", n);\n      },\n      onkey: (n) => {\n        this.jsonpath.set(n), this.currentState.key = n;\n      },\n      oncloseobject: () => {\n        this._closeObject();\n      },\n      onopenarray: () => {\n        this._openArray();\n      },\n      onclosearray: () => {\n        this._closeArray();\n      },\n      onvalue: (n) => {\n        this._pushOrSet(n);\n      },\n      onerror: (n) => {\n        throw n;\n      },\n      onend: () => {\n        this.result = this.currentState.container.pop();\n      },\n      ...t\n    });\n  }\n  reset() {\n    this.result = void 0, this.previousStates = [], this.currentState = Object.freeze({\n      container: [],\n      key: null\n    }), this.jsonpath = new Qt();\n  }\n  write(t) {\n    this.parser.write(t);\n  }\n  close() {\n    this.parser.close();\n  }\n  _pushOrSet(t) {\n    const {\n      container: n,\n      key: s\n    } = this.currentState;\n    s !== null ? (n[s] = t, this.currentState.key = null) : n.push(t);\n  }\n  _openArray() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    this.jsonpath.push(null), this._pushOrSet(t), this.previousStates.push(this.currentState), this.currentState = {\n      container: t,\n      isArray: !0,\n      key: null\n    };\n  }\n  _closeArray() {\n    this.jsonpath.pop(), this.currentState = this.previousStates.pop();\n  }\n  _openObject() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    this.jsonpath.push(null), this._pushOrSet(t), this.previousStates.push(this.currentState), this.currentState = {\n      container: t,\n      isArray: !1,\n      key: null\n    };\n  }\n  _closeObject() {\n    this.jsonpath.pop(), this.currentState = this.previousStates.pop();\n  }\n}\nclass Cy extends By {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    super({\n      onopenarray: () => {\n        if (!this.streamingArray && this._matchJSONPath()) {\n          this.streamingJsonPath = this.getJsonPath().clone(), this.streamingArray = [], this._openArray(this.streamingArray);\n          return;\n        }\n        this._openArray();\n      },\n      onopenobject: (s) => {\n        this.topLevelObject ? this._openObject({}) : (this.topLevelObject = {}, this._openObject(this.topLevelObject)), typeof s < \"u\" && this.parser.emit(\"onkey\", s);\n      }\n    }), this.jsonPaths = void 0, this.streamingJsonPath = null, this.streamingArray = null, this.topLevelObject = null;\n    const n = t.jsonpaths || [];\n    this.jsonPaths = n.map((s) => new Qt(s));\n  }\n  write(t) {\n    super.write(t);\n    let n = [];\n    return this.streamingArray && (n = [...this.streamingArray], this.streamingArray.length = 0), n;\n  }\n  getPartialResult() {\n    return this.topLevelObject;\n  }\n  getStreamingJsonPath() {\n    return this.streamingJsonPath;\n  }\n  getStreamingJsonPathAsString() {\n    return this.streamingJsonPath && this.streamingJsonPath.toString();\n  }\n  getJsonPath() {\n    return this.jsonpath;\n  }\n  _matchJSONPath() {\n    const t = this.getJsonPath();\n    if (this.jsonPaths.length === 0)\n      return !0;\n    for (const n of this.jsonPaths)\n      if (n.equals(t))\n        return !0;\n    return !1;\n  }\n}\nasync function* Ey(e, t) {\n  const n = Ay(e), {\n    metadata: s\n  } = t, {\n    jsonpaths: r\n  } = t.json || {};\n  let i = !0;\n  const o = null, a = new Le(o, t), c = new Cy({\n    jsonpaths: r\n  });\n  for await (const f of n) {\n    const d = c.write(f), m = d.length > 0 && c.getStreamingJsonPathAsString();\n    if (d.length > 0 && i) {\n      if (s) {\n        var u;\n        yield {\n          shape: (t == null || (u = t.json) === null || u === void 0 ? void 0 : u.shape) || \"array-row-table\",\n          batchType: \"partial-result\",\n          data: [],\n          length: 0,\n          bytesUsed: 0,\n          container: c.getPartialResult(),\n          jsonpath: m\n        };\n      }\n      i = !1;\n    }\n    for (const p of d) {\n      a.addRow(p);\n      const C = a.getFullBatch({\n        jsonpath: m\n      });\n      C && (yield C);\n    }\n    a.chunkComplete(f);\n    const g = a.getFullBatch({\n      jsonpath: m\n    });\n    g && (yield g);\n  }\n  const l = c.getStreamingJsonPathAsString(), h = a.getFinalBatch({\n    jsonpath: l\n  });\n  h && (yield h), s && (yield {\n    shape: \"json\",\n    batchType: \"final-result\",\n    container: c.getPartialResult(),\n    jsonpath: c.getStreamingJsonPathAsString(),\n    data: [],\n    length: 0\n  });\n}\nconst vn = {\n  x: 0,\n  y: 1,\n  z: 2\n};\nfunction fc(e, t = {}) {\n  const { start: n = 0, end: s = e.length, plane: r = \"xy\" } = t, i = t.size || 2;\n  let o = 0;\n  const a = vn[r[0]], c = vn[r[1]];\n  for (let u = n, l = s - i; u < s; u += i)\n    o += (e[u + a] - e[l + a]) * (e[u + c] + e[l + c]), l = u;\n  return o / 2;\n}\nfunction Ty(e, t, n = 2, s, r = \"xy\") {\n  const i = t && t.length, o = i ? t[0] * n : e.length;\n  let a = dc(e, 0, o, n, !0, s && s[0], r);\n  const c = [];\n  if (!a || a.next === a.prev)\n    return c;\n  let u, l, h, f, d, m, g;\n  if (i && (a = My(e, t, a, n, s, r)), e.length > 80 * n) {\n    f = l = e[0], d = h = e[1];\n    for (let p = n; p < o; p += n)\n      m = e[p], g = e[p + 1], m < f && (f = m), g < d && (d = g), m > l && (l = m), g > h && (h = g);\n    u = Math.max(l - f, h - d), u = u !== 0 ? 32767 / u : 0;\n  }\n  return Ge(a, c, n, f, d, u, 0), c;\n}\nfunction dc(e, t, n, s, r, i, o) {\n  let a, c;\n  i === void 0 && (i = fc(e, { start: t, end: n, size: s, plane: o }));\n  let u = vn[o[0]], l = vn[o[1]];\n  if (r === i < 0)\n    for (a = t; a < n; a += s)\n      c = bo(a, e[a + u], e[a + l], c);\n  else\n    for (a = n - s; a >= t; a -= s)\n      c = bo(a, e[a + u], e[a + l], c);\n  return c && Kn(c, c.next) && (Ne(c), c = c.next), c;\n}\nfunction Yt(e, t) {\n  if (!e)\n    return e;\n  t || (t = e);\n  let n = e, s;\n  do\n    if (s = !1, !n.steiner && (Kn(n, n.next) || K(n.prev, n, n.next) === 0)) {\n      if (Ne(n), n = t = n.prev, n === n.next)\n        break;\n      s = !0;\n    } else\n      n = n.next;\n  while (s || n !== t);\n  return t;\n}\nfunction Ge(e, t, n, s, r, i, o) {\n  if (!e)\n    return;\n  !o && i && Fy(e, s, r, i);\n  let a = e, c, u;\n  for (; e.prev !== e.next; ) {\n    if (c = e.prev, u = e.next, i ? _y(e, s, r, i) : by(e)) {\n      t.push(c.i / n | 0), t.push(e.i / n | 0), t.push(u.i / n | 0), Ne(e), e = u.next, a = u.next;\n      continue;\n    }\n    if (e = u, e === a) {\n      o ? o === 1 ? (e = wy(Yt(e), t, n), Ge(e, t, n, s, r, i, 2)) : o === 2 && Ry(e, t, n, s, r, i) : Ge(Yt(e), t, n, s, r, i, 1);\n      break;\n    }\n  }\n}\nfunction by(e) {\n  const t = e.prev, n = e, s = e.next;\n  if (K(t, n, s) >= 0)\n    return !1;\n  const r = t.x, i = n.x, o = s.x, a = t.y, c = n.y, u = s.y, l = r < i ? r < o ? r : o : i < o ? i : o, h = a < c ? a < u ? a : u : c < u ? c : u, f = r > i ? r > o ? r : o : i > o ? i : o, d = a > c ? a > u ? a : u : c > u ? c : u;\n  let m = s.next;\n  for (; m !== t; ) {\n    if (m.x >= l && m.x <= f && m.y >= h && m.y <= d && he(r, a, i, c, o, u, m.x, m.y) && K(m.prev, m, m.next) >= 0)\n      return !1;\n    m = m.next;\n  }\n  return !0;\n}\nfunction _y(e, t, n, s) {\n  const r = e.prev, i = e, o = e.next;\n  if (K(r, i, o) >= 0)\n    return !1;\n  const a = r.x, c = i.x, u = o.x, l = r.y, h = i.y, f = o.y, d = a < c ? a < u ? a : u : c < u ? c : u, m = l < h ? l < f ? l : f : h < f ? h : f, g = a > c ? a > u ? a : u : c > u ? c : u, p = l > h ? l > f ? l : f : h > f ? h : f, C = Zs(d, m, t, n, s), w = Zs(g, p, t, n, s);\n  let y = e.prevZ, B = e.nextZ;\n  for (; y && y.z >= C && B && B.z <= w; ) {\n    if (y.x >= d && y.x <= g && y.y >= m && y.y <= p && y !== r && y !== o && he(a, l, c, h, u, f, y.x, y.y) && K(y.prev, y, y.next) >= 0 || (y = y.prevZ, B.x >= d && B.x <= g && B.y >= m && B.y <= p && B !== r && B !== o && he(a, l, c, h, u, f, B.x, B.y) && K(B.prev, B, B.next) >= 0))\n      return !1;\n    B = B.nextZ;\n  }\n  for (; y && y.z >= C; ) {\n    if (y.x >= d && y.x <= g && y.y >= m && y.y <= p && y !== r && y !== o && he(a, l, c, h, u, f, y.x, y.y) && K(y.prev, y, y.next) >= 0)\n      return !1;\n    y = y.prevZ;\n  }\n  for (; B && B.z <= w; ) {\n    if (B.x >= d && B.x <= g && B.y >= m && B.y <= p && B !== r && B !== o && he(a, l, c, h, u, f, B.x, B.y) && K(B.prev, B, B.next) >= 0)\n      return !1;\n    B = B.nextZ;\n  }\n  return !0;\n}\nfunction wy(e, t, n) {\n  let s = e;\n  do {\n    const r = s.prev, i = s.next.next;\n    !Kn(r, i) && mc(r, s, s.next, i) && Pe(r, i) && Pe(i, r) && (t.push(r.i / n | 0), t.push(s.i / n | 0), t.push(i.i / n | 0), Ne(s), Ne(s.next), s = e = i), s = s.next;\n  } while (s !== e);\n  return Yt(s);\n}\nfunction Ry(e, t, n, s, r, i) {\n  let o = e;\n  do {\n    let a = o.next.next;\n    for (; a !== o.prev; ) {\n      if (o.i !== a.i && Ly(o, a)) {\n        let c = gc(o, a);\n        o = Yt(o, o.next), c = Yt(c, c.next), Ge(o, t, n, s, r, i, 0), Ge(c, t, n, s, r, i, 0);\n        return;\n      }\n      a = a.next;\n    }\n    o = o.next;\n  } while (o !== e);\n}\nfunction My(e, t, n, s, r, i) {\n  const o = [];\n  let a, c, u, l, h;\n  for (a = 0, c = t.length; a < c; a++)\n    u = t[a] * s, l = a < c - 1 ? t[a + 1] * s : e.length, h = dc(e, u, l, s, !1, r && r[a + 1], i), h === h.next && (h.steiner = !0), o.push(Dy(h));\n  for (o.sort(Iy), a = 0; a < o.length; a++)\n    n = Sy(o[a], n);\n  return n;\n}\nfunction Iy(e, t) {\n  return e.x - t.x;\n}\nfunction Sy(e, t) {\n  const n = xy(e, t);\n  if (!n)\n    return t;\n  const s = gc(n, e);\n  return Yt(s, s.next), Yt(n, n.next);\n}\nfunction xy(e, t) {\n  let n = t;\n  const s = e.x, r = e.y;\n  let i = -1 / 0, o;\n  do {\n    if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {\n      const f = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);\n      if (f <= s && f > i && (i = f, o = n.x < n.next.x ? n : n.next, f === s))\n        return o;\n    }\n    n = n.next;\n  } while (n !== t);\n  if (!o)\n    return null;\n  const a = o, c = o.x, u = o.y;\n  let l = 1 / 0, h;\n  n = o;\n  do\n    s >= n.x && n.x >= c && s !== n.x && he(r < u ? s : i, r, c, u, r < u ? i : s, r, n.x, n.y) && (h = Math.abs(r - n.y) / (s - n.x), Pe(n, e) && (h < l || h === l && (n.x > o.x || n.x === o.x && Oy(o, n))) && (o = n, l = h)), n = n.next;\n  while (n !== a);\n  return o;\n}\nfunction Oy(e, t) {\n  return K(e.prev, e, t.prev) < 0 && K(t.next, e, e.next) < 0;\n}\nfunction Fy(e, t, n, s) {\n  let r = e;\n  do\n    r.z === 0 && (r.z = Zs(r.x, r.y, t, n, s)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;\n  while (r !== e);\n  r.prevZ.nextZ = null, r.prevZ = null, vy(r);\n}\nfunction vy(e) {\n  let t, n, s = 1, r, i, o, a, c, u;\n  do {\n    for (i = e, e = null, u = null, r = 0; i; ) {\n      for (r++, a = i, o = 0, n = 0; n < s && (o++, a = a.nextZ, !!a); n++)\n        ;\n      for (c = s; o > 0 || c > 0 && a; )\n        o !== 0 && (c === 0 || !a || i.z <= a.z) ? (t = i, i = i.nextZ, o--) : (t = a, a = a.nextZ, c--), u ? u.nextZ = t : e = t, t.prevZ = u, u = t;\n      i = a;\n    }\n    u.nextZ = null, s *= 2;\n  } while (r > 1);\n  return e;\n}\nfunction Zs(e, t, n, s, r) {\n  return e = (e - n) * r | 0, t = (t - s) * r | 0, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e | t << 1;\n}\nfunction Dy(e) {\n  let t = e, n = e;\n  do\n    (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next;\n  while (t !== e);\n  return n;\n}\nfunction he(e, t, n, s, r, i, o, a) {\n  return (r - o) * (t - a) >= (e - o) * (i - a) && (e - o) * (s - a) >= (n - o) * (t - a) && (n - o) * (i - a) >= (r - o) * (s - a);\n}\nfunction Ly(e, t) {\n  return e.next.i !== t.i && e.prev.i !== t.i && !Gy(e, t) && // dones't intersect other edges\n  (Pe(e, t) && Pe(t, e) && Py(e, t) && // locally visible\n  (K(e.prev, e, t.prev) || K(e, t.prev, t)) || // does not create opposite-facing sectors\n  Kn(e, t) && K(e.prev, e, e.next) > 0 && K(t.prev, t, t.next) > 0);\n}\nfunction K(e, t, n) {\n  return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);\n}\nfunction Kn(e, t) {\n  return e.x === t.x && e.y === t.y;\n}\nfunction mc(e, t, n, s) {\n  const r = mn(K(e, t, n)), i = mn(K(e, t, s)), o = mn(K(n, s, e)), a = mn(K(n, s, t));\n  return !!(r !== i && o !== a || r === 0 && dn(e, n, t) || i === 0 && dn(e, s, t) || o === 0 && dn(n, e, s) || a === 0 && dn(n, t, s));\n}\nfunction dn(e, t, n) {\n  return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y);\n}\nfunction mn(e) {\n  return e > 0 ? 1 : e < 0 ? -1 : 0;\n}\nfunction Gy(e, t) {\n  let n = e;\n  do {\n    if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && mc(n, n.next, e, t))\n      return !0;\n    n = n.next;\n  } while (n !== e);\n  return !1;\n}\nfunction Pe(e, t) {\n  return K(e.prev, e, e.next) < 0 ? K(e, t, e.next) >= 0 && K(e, e.prev, t) >= 0 : K(e, t, e.prev) < 0 || K(e, e.next, t) < 0;\n}\nfunction Py(e, t) {\n  let n = e, s = !1;\n  const r = (e.x + t.x) / 2, i = (e.y + t.y) / 2;\n  do\n    n.y > i != n.next.y > i && n.next.y !== n.y && r < (n.next.x - n.x) * (i - n.y) / (n.next.y - n.y) + n.x && (s = !s), n = n.next;\n  while (n !== e);\n  return s;\n}\nfunction gc(e, t) {\n  const n = new tr(e.i, e.x, e.y), s = new tr(t.i, t.x, t.y), r = e.next, i = t.prev;\n  return e.next = t, t.prev = e, n.next = r, r.prev = n, s.next = n, n.prev = s, i.next = s, s.prev = i, s;\n}\nfunction bo(e, t, n, s) {\n  const r = new tr(e, t, n);\n  return s ? (r.next = s.next, r.prev = s, s.next.prev = r, s.next = r) : (r.prev = r, r.next = r), r;\n}\nfunction Ne(e) {\n  e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ);\n}\nclass tr {\n  constructor(t, n, s) {\n    this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1, this.i = t, this.x = n, this.y = s;\n  }\n}\nfunction Ny(e, t, n) {\n  const s = Uy(e), r = Object.keys(s).filter((i) => s[i] !== Array);\n  return Hy(e, {\n    propArrayTypes: s,\n    ...t\n  }, {\n    numericPropKeys: n && n.numericPropKeys || r,\n    PositionDataType: n ? n.PositionDataType : Float32Array,\n    triangulate: n ? n.triangulate : !0\n  });\n}\nfunction Uy(e) {\n  const t = {};\n  for (const n of e)\n    if (n.properties)\n      for (const s in n.properties) {\n        const r = n.properties[s];\n        t[s] = zy(r, t[s]);\n      }\n  return t;\n}\nfunction Hy(e, t, n) {\n  const {\n    pointPositionsCount: s,\n    pointFeaturesCount: r,\n    linePositionsCount: i,\n    linePathsCount: o,\n    lineFeaturesCount: a,\n    polygonPositionsCount: c,\n    polygonObjectsCount: u,\n    polygonRingsCount: l,\n    polygonFeaturesCount: h,\n    propArrayTypes: f,\n    coordLength: d\n  } = t, {\n    numericPropKeys: m = [],\n    PositionDataType: g = Float32Array,\n    triangulate: p = !0\n  } = n, C = e[0] && \"id\" in e[0], w = e.length > 65535 ? Uint32Array : Uint16Array, y = {\n    type: \"Point\",\n    positions: new g(s * d),\n    globalFeatureIds: new w(s),\n    featureIds: r > 65535 ? new Uint32Array(s) : new Uint16Array(s),\n    numericProps: {},\n    properties: [],\n    fields: []\n  }, B = {\n    type: \"LineString\",\n    pathIndices: i > 65535 ? new Uint32Array(o + 1) : new Uint16Array(o + 1),\n    positions: new g(i * d),\n    globalFeatureIds: new w(i),\n    featureIds: a > 65535 ? new Uint32Array(i) : new Uint16Array(i),\n    numericProps: {},\n    properties: [],\n    fields: []\n  }, R = {\n    type: \"Polygon\",\n    polygonIndices: c > 65535 ? new Uint32Array(u + 1) : new Uint16Array(u + 1),\n    primitivePolygonIndices: c > 65535 ? new Uint32Array(l + 1) : new Uint16Array(l + 1),\n    positions: new g(c * d),\n    globalFeatureIds: new w(c),\n    featureIds: h > 65535 ? new Uint32Array(c) : new Uint16Array(c),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  p && (R.triangles = []);\n  for (const O of [y, B, R])\n    for (const F of m) {\n      const x = f[F];\n      O.numericProps[F] = new x(O.positions.length / d);\n    }\n  B.pathIndices[o] = i, R.polygonIndices[u] = c, R.primitivePolygonIndices[l] = c;\n  const E = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n  for (const O of e) {\n    const F = O.geometry, x = O.properties || {};\n    switch (F.type) {\n      case \"Point\":\n        Jy(F, y, E, d, x), y.properties.push(Ss(x, m)), C && y.fields.push({\n          id: O.id\n        }), E.pointFeature++;\n        break;\n      case \"LineString\":\n        Vy(F, B, E, d, x), B.properties.push(Ss(x, m)), C && B.fields.push({\n          id: O.id\n        }), E.lineFeature++;\n        break;\n      case \"Polygon\":\n        jy(F, R, E, d, x), R.properties.push(Ss(x, m)), C && R.fields.push({\n          id: O.id\n        }), E.polygonFeature++;\n        break;\n      default:\n        throw new Error(\"Invalid geometry type\");\n    }\n    E.feature++;\n  }\n  return Ky(y, B, R, d);\n}\nfunction Jy(e, t, n, s, r) {\n  t.positions.set(e.data, n.pointPosition * s);\n  const i = e.data.length / s;\n  Or(t, r, n.pointPosition, i), t.globalFeatureIds.fill(n.feature, n.pointPosition, n.pointPosition + i), t.featureIds.fill(n.pointFeature, n.pointPosition, n.pointPosition + i), n.pointPosition += i;\n}\nfunction Vy(e, t, n, s, r) {\n  t.positions.set(e.data, n.linePosition * s);\n  const i = e.data.length / s;\n  Or(t, r, n.linePosition, i), t.globalFeatureIds.fill(n.feature, n.linePosition, n.linePosition + i), t.featureIds.fill(n.lineFeature, n.linePosition, n.linePosition + i);\n  for (let o = 0, a = e.indices.length; o < a; ++o) {\n    const c = e.indices[o], u = o === a - 1 ? e.data.length : e.indices[o + 1];\n    t.pathIndices[n.linePath++] = n.linePosition, n.linePosition += (u - c) / s;\n  }\n}\nfunction jy(e, t, n, s, r) {\n  t.positions.set(e.data, n.polygonPosition * s);\n  const i = e.data.length / s;\n  Or(t, r, n.polygonPosition, i), t.globalFeatureIds.fill(n.feature, n.polygonPosition, n.polygonPosition + i), t.featureIds.fill(n.polygonFeature, n.polygonPosition, n.polygonPosition + i);\n  for (let o = 0, a = e.indices.length; o < a; ++o) {\n    const c = n.polygonPosition;\n    t.polygonIndices[n.polygonObject++] = c;\n    const u = e.areas[o], l = e.indices[o], h = e.indices[o + 1];\n    for (let d = 0, m = l.length; d < m; ++d) {\n      const g = l[d], p = d === m - 1 ? h === void 0 ? e.data.length : h[0] : l[d + 1];\n      t.primitivePolygonIndices[n.polygonRing++] = n.polygonPosition, n.polygonPosition += (p - g) / s;\n    }\n    const f = n.polygonPosition;\n    ky(t, u, l, {\n      startPosition: c,\n      endPosition: f,\n      coordLength: s\n    });\n  }\n}\nfunction ky(e, t, n, s) {\n  let {\n    startPosition: r,\n    endPosition: i,\n    coordLength: o\n  } = s;\n  if (!e.triangles)\n    return;\n  const a = r * o, c = i * o, u = e.positions.subarray(a, c), l = n[0], h = n.slice(1).map((d) => (d - l) / o), f = Ty(u, h, o, t);\n  for (let d = 0, m = f.length; d < m; ++d)\n    e.triangles.push(r + f[d]);\n}\nfunction Is(e, t) {\n  const n = {};\n  for (const s in e)\n    n[s] = {\n      value: e[s],\n      size: t\n    };\n  return n;\n}\nfunction Ky(e, t, n, s) {\n  const r = {\n    shape: \"binary-feature-collection\",\n    points: {\n      ...e,\n      positions: {\n        value: e.positions,\n        size: s\n      },\n      globalFeatureIds: {\n        value: e.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: e.featureIds,\n        size: 1\n      },\n      numericProps: Is(e.numericProps, 1)\n    },\n    lines: {\n      ...t,\n      positions: {\n        value: t.positions,\n        size: s\n      },\n      pathIndices: {\n        value: t.pathIndices,\n        size: 1\n      },\n      globalFeatureIds: {\n        value: t.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: t.featureIds,\n        size: 1\n      },\n      numericProps: Is(t.numericProps, 1)\n    },\n    polygons: {\n      ...n,\n      positions: {\n        value: n.positions,\n        size: s\n      },\n      polygonIndices: {\n        value: n.polygonIndices,\n        size: 1\n      },\n      primitivePolygonIndices: {\n        value: n.primitivePolygonIndices,\n        size: 1\n      },\n      globalFeatureIds: {\n        value: n.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: n.featureIds,\n        size: 1\n      },\n      numericProps: Is(n.numericProps, 1)\n    }\n  };\n  return r.polygons && n.triangles && (r.polygons.triangles = {\n    value: new Uint32Array(n.triangles),\n    size: 1\n  }), r;\n}\nfunction Or(e, t, n, s) {\n  for (const r in e.numericProps)\n    if (r in t) {\n      const i = t[r];\n      e.numericProps[r].fill(i, n, n + s);\n    }\n}\nfunction Ss(e, t) {\n  const n = {};\n  for (const s in e)\n    t.includes(s) || (n[s] = e[s]);\n  return n;\n}\nfunction zy(e, t) {\n  return t === Array || !Number.isFinite(e) ? Array : t === Float64Array || Math.fround(e) !== e ? Float64Array : Float32Array;\n}\nfunction Wy(e) {\n  let t = 0, n = 0, s = 0, r = 0, i = 0, o = 0, a = 0, c = 0, u = 0;\n  const l = /* @__PURE__ */ new Set();\n  for (const h of e) {\n    const f = h.geometry;\n    switch (f.type) {\n      case \"Point\":\n        n++, t++, l.add(f.coordinates.length);\n        break;\n      case \"MultiPoint\":\n        n++, t += f.coordinates.length;\n        for (const m of f.coordinates)\n          l.add(m.length);\n        break;\n      case \"LineString\":\n        i++, s += f.coordinates.length, r++;\n        for (const m of f.coordinates)\n          l.add(m.length);\n        break;\n      case \"MultiLineString\":\n        i++;\n        for (const m of f.coordinates) {\n          s += m.length, r++;\n          for (const g of m)\n            l.add(g.length);\n        }\n        break;\n      case \"Polygon\":\n        u++, a++, c += f.coordinates.length;\n        const d = f.coordinates.flat();\n        o += d.length;\n        for (const m of d)\n          l.add(m.length);\n        break;\n      case \"MultiPolygon\":\n        u++;\n        for (const m of f.coordinates) {\n          a++, c += m.length;\n          const g = m.flat();\n          o += g.length;\n          for (const p of g)\n            l.add(p.length);\n        }\n        break;\n      default:\n        throw new Error(`Unsupported geometry type: ${f.type}`);\n    }\n  }\n  return {\n    coordLength: l.size > 0 ? Math.max(...l) : 2,\n    pointPositionsCount: t,\n    pointFeaturesCount: n,\n    linePositionsCount: s,\n    linePathsCount: r,\n    lineFeaturesCount: i,\n    polygonPositionsCount: o,\n    polygonObjectsCount: a,\n    polygonRingsCount: c,\n    polygonFeaturesCount: u\n  };\n}\nfunction Xy(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n    coordLength: 2,\n    fixRingWinding: !0\n  };\n  return e.map((n) => Qy(n, t));\n}\nfunction _o(e, t, n, s) {\n  n.push(t.length), t.push(...e);\n  for (let r = e.length; r < s.coordLength; r++)\n    t.push(0);\n}\nfunction er(e, t, n, s) {\n  n.push(t.length);\n  for (const r of e) {\n    t.push(...r);\n    for (let i = r.length; i < s.coordLength; i++)\n      t.push(0);\n  }\n}\nfunction wo(e, t, n, s, r) {\n  let i = 0;\n  const o = [], a = [];\n  for (const c of e) {\n    const u = c.map((f) => f.slice(0, 2));\n    let l = fc(u.flat());\n    const h = l < 0;\n    r.fixRingWinding && (i === 0 && !h || i > 0 && h) && (c.reverse(), l = -l), o.push(l), er(c, t, a, r), i++;\n  }\n  i > 0 && (s.push(o), n.push(a));\n}\nfunction Qy(e, t) {\n  const {\n    geometry: n\n  } = e;\n  if (n.type === \"GeometryCollection\")\n    throw new Error(\"GeometryCollection type not supported\");\n  const s = [], r = [];\n  let i, o;\n  switch (n.type) {\n    case \"Point\":\n      o = \"Point\", _o(n.coordinates, s, r, t);\n      break;\n    case \"MultiPoint\":\n      o = \"Point\", n.coordinates.map((a) => _o(a, s, r, t));\n      break;\n    case \"LineString\":\n      o = \"LineString\", er(n.coordinates, s, r, t);\n      break;\n    case \"MultiLineString\":\n      o = \"LineString\", n.coordinates.map((a) => er(a, s, r, t));\n      break;\n    case \"Polygon\":\n      o = \"Polygon\", i = [], wo(n.coordinates, s, r, i, t);\n      break;\n    case \"MultiPolygon\":\n      o = \"Polygon\", i = [], n.coordinates.map((a) => wo(a, s, r, i, t));\n      break;\n    default:\n      throw new Error(`Unknown type: ${o}`);\n  }\n  return {\n    ...e,\n    geometry: {\n      type: o,\n      indices: r,\n      data: s,\n      areas: i\n    }\n  };\n}\nfunction Ac(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n    fixRingWinding: !0,\n    triangulate: !0\n  };\n  const n = Wy(e), s = n.coordLength, {\n    fixRingWinding: r\n  } = t, i = Xy(e, {\n    coordLength: s,\n    fixRingWinding: r\n  });\n  return Ny(i, n, {\n    numericPropKeys: t.numericPropKeys,\n    PositionDataType: t.PositionDataType || Float32Array,\n    triangulate: t.triangulate\n  });\n}\nconst qy = \"4.1.4\", Yy = {\n  name: \"GeoJSON\",\n  id: \"geojson\",\n  module: \"geojson\",\n  version: qy,\n  worker: !0,\n  extensions: [\"geojson\"],\n  mimeTypes: [\"application/geo+json\"],\n  category: \"geometry\",\n  text: !0,\n  options: {\n    geojson: {\n      shape: \"object-row-table\"\n    },\n    json: {\n      shape: \"object-row-table\",\n      jsonpaths: [\"$\", \"$.features\"]\n    },\n    gis: {\n      format: \"geojson\"\n    }\n  }\n}, Ue = {\n  ...Yy,\n  parse: $y,\n  parseTextSync: pc,\n  parseInBatches: Zy\n};\nasync function $y(e, t) {\n  return pc(new TextDecoder().decode(e), t);\n}\nfunction pc(e, t) {\n  var n;\n  t = {\n    ...Ue.options,\n    ...t\n  }, t.geojson = {\n    ...Ue.options.geojson,\n    ...t.geojson\n  }, t.gis = t.gis || {};\n  let s;\n  try {\n    s = JSON.parse(e);\n  } catch {\n    s = {};\n  }\n  const r = {\n    shape: \"geojson-table\",\n    type: \"FeatureCollection\",\n    features: ((n = s) === null || n === void 0 ? void 0 : n.features) || []\n  };\n  switch (t.gis.format) {\n    case \"binary\":\n      return Ac(r.features);\n    default:\n      return r;\n  }\n}\nfunction Zy(e, t) {\n  t = {\n    ...Ue.options,\n    ...t\n  }, t.json = {\n    ...Ue.options.geojson,\n    ...t.geojson\n  };\n  const n = Ey(e, t);\n  switch (t.gis.format) {\n    case \"binary\":\n      return tB(n);\n    default:\n      return n;\n  }\n}\nasync function* tB(e) {\n  for await (const t of e)\n    t.data = Ac(t.data), yield t;\n}\nfunction eB(e) {\n  let t = 0;\n  for (const s in e.attributes) {\n    const r = e.getAttribute(s);\n    t += r.count * r.itemSize * r.array.BYTES_PER_ELEMENT;\n  }\n  const n = e.getIndex();\n  return t += n ? n.count * n.itemSize * n.array.BYTES_PER_ELEMENT : 0, t;\n}\nfunction yc(e) {\n  const n = document.createElement(\"canvas\");\n  n.width = 64, n.height = 64;\n  const s = n.getContext(\"2d\");\n  s.rect(0, 0, 64, 64);\n  const r = s.createLinearGradient(0, 0, 64, 64);\n  for (let o = 0; o < e.length; o++) {\n    const a = e[o];\n    r.addColorStop(a[0], \"#\" + a[1].getHexString());\n  }\n  s.fillStyle = r, s.fill();\n  const i = new three__WEBPACK_IMPORTED_MODULE_0__.CanvasTexture(n);\n  return i.needsUpdate = !0, i.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, i.wrapS = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping, i.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping, i.repeat.set(2, 2), i;\n}\nfunction Ro(e) {\n  e.updateMatrix(), e.updateMatrixWorld(), e.matrixWorldInverse.copy(e.matrixWorld).invert();\n  const t = new three__WEBPACK_IMPORTED_MODULE_0__.Frustum();\n  return t.setFromProjectionMatrix(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse)), t;\n}\nfunction nB(e) {\n  const t = new three__WEBPACK_IMPORTED_MODULE_0__.Group(), n = new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(10, 5), s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(...e.projectPointOntoPlane([0, 0, 0])), r = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(e.normal.x, e.normal.y, e.normal.z), i = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(s).add(r);\n  n.lookAt(i), n.translate(s.x, s.y, s.z);\n  const o = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({ color: 65535, side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide }), a = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(n, o), c = new three__WEBPACK_IMPORTED_MODULE_0__.ArrowHelper(r, s, 5, 16776960);\n  return t.add(c), t.add(a), t;\n}\nfunction Mo(e) {\n  const { boundingVolume: t } = e;\n  let n = 0;\n  e.content && (n = Math.min(e.content.byteLength / 5e5, 1));\n  const s = new three__WEBPACK_IMPORTED_MODULE_0__.Color(n, 1, 0), r = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(1, 1, 1), i = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n  t.halfAxes ? i.copy(Bc(t.halfAxes)) : t.radius && r.scale(t.radius * 2, t.radius * 2, t.radius * 2), r.applyMatrix4(i);\n  const o = new three__WEBPACK_IMPORTED_MODULE_0__.EdgesGeometry(r), a = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(o, new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({ color: s }));\n  return a.position.copy(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(...t.center)), a;\n}\nfunction Bc(e) {\n  const t = e;\n  return new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray([\n    t[0] * 2,\n    t[1] * 2,\n    t[2] * 2,\n    0,\n    t[3] * 2,\n    t[4] * 2,\n    t[5] * 2,\n    0,\n    t[6] * 2,\n    t[7] * 2,\n    t[8] * 2,\n    0,\n    0,\n    0,\n    0,\n    1\n  ]);\n}\nfunction sB(e, t) {\n  const r = 2 * Math.PI * 6378137 / 2, i = t * r / 180;\n  let o = Math.log(Math.tan((90 + e) * Math.PI / 360)) / (Math.PI / 180);\n  return o = o * r / 180, new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(i, o);\n}\nfunction rB(e) {\n  let t = 0;\n  if (e.userData.mimeType == \"image/ktx2\" && e.mipmaps) {\n    for (let n = 0; n < e.mipmaps.length; n++)\n      t += e.mipmaps[n].data.byteLength;\n    return t;\n  } else if (e.image) {\n    const { image: n } = e, s = 4;\n    let r = [n.width, n.height];\n    for (; r[0] > 1 || r[1] > 1; )\n      t += r[0] * r[1] * s, r[0] = Math.max(Math.floor(r[0] / 2), 1), r[1] = Math.max(Math.floor(r[1] / 2), 1);\n    return t += 1 * 1 * s, t;\n  } else\n    return;\n}\nfunction Cc(e) {\n  return eB(e);\n}\nconst Ec = {\n  // From chroma spectral http://gka.github.io/chroma.js/\n  SPECTRAL: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.3686, 0.3098, 0.6353)],\n    [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.1961, 0.5333, 0.7412)],\n    [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.4, 0.7608, 0.6471)],\n    [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.6706, 0.8667, 0.6431)],\n    [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.902, 0.9608, 0.5961)],\n    [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 0.749)],\n    [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9961, 0.8784, 0.5451)],\n    [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9922, 0.6824, 0.3804)],\n    [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9569, 0.4275, 0.2627)],\n    [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.8353, 0.2431, 0.3098)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.6196, 39e-4, 0.2588)]\n  ],\n  PLASMA: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.241, 0.015, 0.61)],\n    [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.387, 1e-3, 0.654)],\n    [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.524, 0.025, 0.653)],\n    [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.651, 0.125, 0.596)],\n    [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.752, 0.227, 0.513)],\n    [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.837, 0.329, 0.431)],\n    [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.907, 0.435, 0.353)],\n    [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.963, 0.554, 0.272)],\n    [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.992, 0.681, 0.195)],\n    [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.987, 0.822, 0.144)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.94, 0.975, 0.131)]\n  ],\n  YELLOW_GREEN: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.1647, 0.2824, 0.3451)],\n    [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.1338, 0.3555, 0.4227)],\n    [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.061, 0.4319, 0.4864)],\n    [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0.5099, 0.5319)],\n    [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0.5881, 0.5569)],\n    [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.137, 0.665, 0.5614)],\n    [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.2906, 0.7395, 0.5477)],\n    [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.4453, 0.8099, 0.5201)],\n    [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.6102, 0.8748, 0.485)],\n    [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.7883, 0.9323, 0.4514)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9804, 0.9804, 0.4314)]\n  ],\n  VIRIDIS: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.267, 5e-3, 0.329)],\n    [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.283, 0.141, 0.458)],\n    [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.254, 0.265, 0.53)],\n    [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.207, 0.372, 0.553)],\n    [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.164, 0.471, 0.558)],\n    [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.128, 0.567, 0.551)],\n    [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.135, 0.659, 0.518)],\n    [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.267, 0.749, 0.441)],\n    [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.478, 0.821, 0.318)],\n    [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.741, 0.873, 0.15)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.993, 0.906, 0.144)]\n  ],\n  INFERNO: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.077, 0.042, 0.206)],\n    [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.225, 0.036, 0.388)],\n    [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.373, 0.074, 0.432)],\n    [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.522, 0.128, 0.42)],\n    [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.665, 0.182, 0.37)],\n    [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.797, 0.255, 0.287)],\n    [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.902, 0.364, 0.184)],\n    [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.969, 0.516, 0.063)],\n    [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.988, 0.683, 0.072)],\n    [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.961, 0.859, 0.298)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.988, 0.998, 0.645)]\n  ],\n  GRAYSCALE: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1)]\n  ],\n  // 16 samples of the TURBU color scheme\n  // values taken from: https://gist.github.com/mikhailov-work/ee72ba4191942acecc03fe6da94fc73f\n  // original file licensed under Apache-2.0\n  TURBO: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.18995, 0.07176, 0.23217)],\n    [0.07, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.25107, 0.25237, 0.63374)],\n    [0.13, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.27628, 0.42118, 0.89123)],\n    [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.25862, 0.57958, 0.99876)],\n    [0.27, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.15844, 0.73551, 0.92305)],\n    [0.33, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.09267, 0.86554, 0.7623)],\n    [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.19659, 0.94901, 0.59466)],\n    [0.47, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.42778, 0.99419, 0.38575)],\n    [0.53, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.64362, 0.98999, 0.23356)],\n    [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.80473, 0.92452, 0.20459)],\n    [0.67, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.93301, 0.81236, 0.22667)],\n    [0.73, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.99314, 0.67408, 0.20348)],\n    [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9836, 0.49291, 0.12849)],\n    [0.87, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.92105, 0.31489, 0.05475)],\n    [0.93, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.81608, 0.18462, 0.01809)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.66449, 0.08436, 424e-5)]\n  ],\n  RAINBOW: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.278, 0, 0.714)],\n    [1 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 1)],\n    [2 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 1, 1)],\n    [3 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 1, 0)],\n    [4 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 0)],\n    [5 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 0.64, 0)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 0, 0)]\n  ],\n  CONTOUR: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0)],\n    [0.03, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0)],\n    [0.04, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1)]\n  ]\n}, iB = `\n  varying vec3 vColor;\n  uniform float alpha;\n\n  void main() {\n    if (vColor == vec3(0.0, 0.0, 0.0)) {\n      discard;\n    } else {\n      gl_FragColor = vec4( vColor, alpha);\n    }\n  }\n`, oB = `\n  varying vec3 vColor;\n  uniform sampler2D gradient;\n  uniform sampler2D grayscale;\n  attribute float intensity;\n  attribute float classification;\n  uniform vec3 rootCenter;\n  uniform vec3 rootNormal;\n  uniform vec2 elevationRange;\n  uniform int coloring;\n  uniform bool hideGround;\n  uniform float maxIntensity;\n  uniform float intensityContrast;\n  uniform float pointSize;\n\n  #ifdef USE_COLOR\n  vec3 getRGB() {\n      vec3 rgb = color;\n      return rgb;\n  }\n  #endif\n\n  vec3 getElevation(){\n    vec4 world = modelMatrix * vec4( position, 1.0 );\n    float diff = abs(dot(rootNormal, (vec3(world) - rootCenter)));\n    float w = max(diff - elevationRange.x,0.0) / max(elevationRange.y - elevationRange.x,1.0);\n    vec3 cElevation = texture2D(gradient, vec2(w,1.0-w)).rgb;\n\n    return cElevation;\n  }\n\n  vec3 getIntensity(){\n    // TODO: real contrast enhancement. Check https://github.com/yuki-koyama/enhancer/blob/master/shaders/enhancer.fs\n    float intmod = pow(intensity, intensityContrast);\n    vec3 cIntensity = texture2D(grayscale, vec2(intmod / maxIntensity ,1.0-(intmod / maxIntensity))).rgb;\n    return cIntensity;\n  }\n\n  vec3 getClassification(){\n    float classNormalized = classification / 255.0;\n    vec3 cClassification = texture2D(gradient, vec2(classNormalized * 5.0,1.0-classNormalized * 5.0)).rgb;\n    return cClassification;\n  }\n\n  vec3 getColor(){\n      vec3 color;\n      if (hideGround && classification == 2.0) {\n         return vec3(0.0, 0.0, 0.0);               \n      }\n\n      if (coloring == 1) {\n        color = getIntensity();\n      }\n      else if (coloring == 2) {\n        color = getClassification();\n      } else if (coloring == 3) {\n        color = getElevation();\n      } \n      #ifdef USE_COLOR\n      else if (coloring == 4) {\n        color = getRGB();\n      }\n      #endif\n      else {\n        color = vec3(1.0, 1.0, 1.0);\n      }\n      return color;\n  }\n\n  void main() {\n      vColor = getColor();\n\n      gl_PointSize = pointSize;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  }\n`;\nvar Tc = /* @__PURE__ */ ((e) => (e[e.Intensity = 1] = \"Intensity\", e[e.Classification = 2] = \"Classification\", e[e.Elevation = 3] = \"Elevation\", e[e.RGB = 4] = \"RGB\", e[e.White = 5] = \"White\", e))(Tc || {}), Dn = /* @__PURE__ */ ((e) => (e[e.FlatTexture = 1] = \"FlatTexture\", e[e.ShadedTexture = 2] = \"ShadedTexture\", e[e.ShadedNoTexture = 3] = \"ShadedNoTexture\", e))(Dn || {});\nconst aB = Ec.RAINBOW, cB = typeof document < \"u\" ? yc(aB) : null, uB = Ec.GRAYSCALE, lB = typeof document < \"u\" ? yc(uB) : null, hB = {\n  throttleRequests: !0,\n  maxRequests: 64,\n  updateInterval: 0.1,\n  maxConcurrency: 1,\n  maximumScreenSpaceError: 16,\n  memoryAdjustedScreenSpaceError: !0,\n  maximumMemoryUsage: 400,\n  memoryCacheOverflow: 128,\n  viewDistanceScale: 1,\n  skipLevelOfDetail: !1,\n  resetTransform: !1,\n  updateTransforms: !0,\n  shading: Dn.FlatTexture,\n  transparent: !1,\n  pointCloudColoring: Tc.White,\n  pointSize: 1,\n  worker: !0,\n  wireframe: !1,\n  debug: !1,\n  gltfLoader: null,\n  basisTranscoderPath: null,\n  dracoDecoderPath: null,\n  material: null,\n  contentPostProcess: void 0,\n  preloadTilesCount: null,\n  collectAttributions: !1\n};\nclass CB {\n  /**\n  * Loads a tileset of 3D Tiles according to the given {@link LoaderProps}\n  * @public\n  *\n  * @param props - Properties for this load call {@link LoaderProps}.\n  * @returns An object containing the 3D Model to be added to the scene\n  * and a runtime engine to be updated every frame.\n  */\n  static async load(t) {\n    const n = { ...hB, ...t.options }, { url: s } = t, r = n.updateInterval, i = 5, o = {};\n    if (n.cesiumIONToken) {\n      o[\"cesium-ion\"] = {\n        accessToken: n.cesiumIONToken\n      };\n      const T = await hc.preload(s, o);\n      o.fetch = { headers: T.headers };\n    }\n    n.googleApiKey && (o.fetch = { headers: { \"X-GOOG-API-KEY\": n.googleApiKey } }, t.options.hasOwnProperty(\"collectAttributions\") || (n.collectAttributions = !0)), t.loadingManager && t.loadingManager.itemStart(s);\n    const a = await fe(s, Oe, {\n      ...o\n    }), c = {}, u = {}, l = [], h = new three__WEBPACK_IMPORTED_MODULE_0__.Group(), f = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n    n.debug || (f.visible = !1);\n    const d = {\n      pointSize: { type: \"f\", value: n.pointSize },\n      gradient: { type: \"t\", value: cB },\n      grayscale: { type: \"t\", value: lB },\n      rootCenter: { type: \"vec3\", value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3() },\n      rootNormal: { type: \"vec3\", value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3() },\n      coloring: { type: \"i\", value: n.pointCloudColoring },\n      hideGround: { type: \"b\", value: !0 },\n      elevationRange: { type: \"vec2\", value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 400) },\n      maxIntensity: { type: \"f\", value: 1 },\n      intensityContrast: { type: \"f\", value: 1 },\n      alpha: { type: \"f\", value: 1 }\n    }, m = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n      uniforms: d,\n      vertexShader: oB,\n      fragmentShader: iB,\n      transparent: n.transparent,\n      vertexColors: !0\n    });\n    let g = null, p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(), C, w, y;\n    n.gltfLoader ? C = n.gltfLoader : (C = new three__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader(), n.basisTranscoderPath && (w = new three__WEBPACK_IMPORTED_MODULE_0__.KTX2Loader(), w.detectSupport(t.renderer), w.setTranscoderPath(n.basisTranscoderPath + \"/\"), w.setWorkerLimit(1), C.setKTX2Loader(w)), n.dracoDecoderPath && (y = new three__WEBPACK_IMPORTED_MODULE_0__.DRACOLoader(), y.setDecoderPath(n.dracoDecoderPath + \"/\"), y.setWorkerLimit(n.maxConcurrency), C.setDRACOLoader(y)));\n    const B = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({ transparent: n.transparent }), R = {\n      maximumMemoryUsage: n.maximumMemoryUsage,\n      maximumScreenSpaceError: n.maximumScreenSpaceError,\n      memoryAdjustedScreenSpaceError: n.memoryAdjustedScreenSpaceError,\n      memoryCacheOverflow: n.memoryCacheOverflow,\n      viewDistanceScale: n.viewDistanceScale,\n      skipLevelOfDetail: n.skipLevelOfDetail,\n      updateTransforms: n.updateTransforms,\n      throttleRequests: n.throttleRequests,\n      maxRequests: n.maxRequests,\n      contentLoader: async (T) => {\n        let L = null;\n        switch (T.type) {\n          case zt.POINTCLOUD: {\n            L = dB(T, m, n, Ft);\n            break;\n          }\n          case zt.SCENEGRAPH:\n          case zt.MESH: {\n            L = await fB(C, T, B, n, Ft);\n            break;\n          }\n        }\n        if (L && (L.visible = !1, c[T.id] = L, h.add(c[T.id]), n.debug)) {\n          const W = Mo(T);\n          f.add(W), u[T.id] = W;\n        }\n      },\n      onTileLoad: async (T) => {\n        E && (n.resetTransform && !v && (T == null ? void 0 : T.depth) <= i && jt(T), ne = !0);\n      },\n      onTileUnload: (T) => {\n        l.push(T);\n      },\n      onTileError: (T, L) => {\n        console.error(\"Tile error\", T.id, L);\n      },\n      onTraversalComplete(T) {\n        return n.collectAttributions && (k = gB(T)), T;\n      }\n    }, E = new Vd(a, {\n      ...R,\n      loadOptions: {\n        ...o,\n        maxConcurrency: n.maxConcurrency,\n        worker: n.worker,\n        gltf: {\n          loadImages: !1\n        },\n        \"3d-tiles\": {\n          loadGLTF: !1\n        }\n      }\n    }), O = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), F = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), x = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    let v = !1, k = \"\";\n    if (E.root.boundingVolume ? (E.root.header.boundingVolume.region && console.warn(\"Cannot apply a model matrix to bounding volumes of type region. Tileset stays in original geo-coordinates.\"), F.setPosition(\n      E.root.boundingVolume.center[0],\n      E.root.boundingVolume.center[1],\n      E.root.boundingVolume.center[2]\n    )) : console.warn(\"Bounding volume not found, no transformations applied\"), n.debug) {\n      const T = Mo(E.root);\n      f.add(T), u[E.root.id] = T;\n    }\n    let X = !1, Q = !1;\n    d.rootCenter.value.copy(x), d.rootNormal.value.copy(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1).normalize()), E.stats.get(\"Loader concurrency\").count = n.maxConcurrency, E.stats.get(\"Maximum mem usage\").count = n.maximumMemoryUsage;\n    let D = 0, at = null, ee = null, ne = !1;\n    const ge = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1 / 0, 1 / 0, 1 / 0);\n    let Nt = null;\n    h.updateMatrixWorld(!0);\n    const nt = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(h.matrixWorld), Ft = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(nt).invert();\n    n.resetTransform && jt(E.root), n.debug && (u[E.root.id].applyMatrix4(O), f.matrixWorld.copy(h.matrixWorld));\n    function jt(T) {\n      if (!T.boundingVolume.halfAxes)\n        return;\n      const L = T.boundingVolume.halfAxes, W = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().extractRotation(Bc(L)).premultiply(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().extractRotation(Ft));\n      if (!new three__WEBPACK_IMPORTED_MODULE_0__.Euler().setFromRotationMatrix(W).equals(new three__WEBPACK_IMPORTED_MODULE_0__.Euler())) {\n        v = !0;\n        const Tt = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(\n          F.elements[12],\n          F.elements[13],\n          F.elements[14]\n        );\n        F.extractRotation(W), F.setPosition(Tt);\n      }\n      Ae();\n    }\n    function Ae() {\n      O.copy(nt), n.resetTransform && O.multiply(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(F).invert()), E.modelMatrix = new V(O.toArray());\n    }\n    function We(T, L, W, $) {\n      if (X || !$)\n        return;\n      (!Nt || $.aspect != ee) && (Nt = new Mn({\n        fov: $.fov / 180 * Math.PI,\n        aspectRatio: $.aspect,\n        near: $.near,\n        far: $.far\n      }).sseDenominator, ee = $.aspect, n.debug && console.log(\"Updated sse denonimator:\", Nt));\n      const Wn = Ro($).planes.map((q) => new et(q.normal.toArray(), q.constant)), bc = new ht(Wn), Fr = {\n        camera: {\n          position: ge.toArray()\n        },\n        height: W,\n        frameNumber: T._frameNumber,\n        sseDenominator: Nt,\n        cullingVolume: bc,\n        viewport: {\n          id: 0\n        }\n      };\n      T._cache.reset(), T._traverser.traverse(T.root, Fr, T.options);\n      for (const q of T.tiles)\n        q.selected ? L[q.id] ? L[q.id].visible = !0 : console.error(\"TILE SELECTED BUT NOT LOADED!!\", q.id) : L[q.id] && (L[q.id].visible = !1);\n      for (; l.length > 0; ) {\n        const q = l.pop();\n        L[q.id] && q.contentState == ut.UNLOADED && (h.remove(L[q.id]), xs(L[q.id]), delete L[q.id]), u[q.id] && (xs(u[q.id]), f.remove(u[q.id]), delete u[q.id]);\n      }\n      const Xn = T.stats.get(\"Tiles Loaded\").count, vr = T.stats.get(\"Tiles Loading\").count;\n      return t.onProgress && t.onProgress(\n        Xn,\n        Xn + vr\n      ), t.loadingManager && !Q && vr == 0 && (n.preloadTilesCount == null || Xn >= n.preloadTilesCount) && (Q = !0, t.loadingManager.itemEnd(t.url)), Fr;\n    }\n    function zn(T) {\n      const L = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), W = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion(), $ = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      T.decompose(L, W, $), h.position.copy(L), h.quaternion.copy(W), h.scale.copy($), h.updateMatrix(), h.updateMatrixWorld(!0), nt.copy(h.matrixWorld), Ft.copy(nt).invert(), Ae();\n    }\n    return {\n      model: h,\n      runtime: {\n        getTileset: () => E,\n        getStats: () => E.stats,\n        getDataAttributions: () => k,\n        showTiles: (T) => {\n          f.visible = T;\n        },\n        setWireframe: (T) => {\n          n.wireframe = T, h.traverse((L) => {\n            L instanceof three__WEBPACK_IMPORTED_MODULE_0__.Mesh && (L.material.wireframe = T);\n          });\n        },\n        setDebug: (T) => {\n          n.debug = T, f.visible = T;\n        },\n        setShading: (T) => {\n          n.shading = T;\n        },\n        getTileBoxes: () => f,\n        setViewDistanceScale: (T) => {\n          E.options.viewDistanceScale = T, E._frameNumber++, We(E, c, p.y, g);\n        },\n        setMaximumScreenSpaceError: (T) => {\n          E.options.maximumScreenSpaceError = T, E._frameNumber++, We(E, c, p.y, g);\n        },\n        setHideGround: (T) => {\n          d.hideGround.value = T;\n        },\n        setPointCloudColoring: (T) => {\n          d.coloring.value = T;\n        },\n        setElevationRange: (T) => {\n          d.elevationRange.value.set(T[0], T[1]);\n        },\n        setMaxIntensity: (T) => {\n          d.maxIntensity.value = T;\n        },\n        setIntensityContrast: (T) => {\n          d.intensityContrast.value = T;\n        },\n        setPointAlpha: (T) => {\n          d.alpha.value = T;\n        },\n        getLatLongHeightFromPosition: (T) => {\n          const L = E.ellipsoid.cartesianToCartographic(\n            new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(T).applyMatrix4(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(O).invert()).toArray()\n          );\n          return {\n            lat: L[1],\n            long: L[0],\n            height: L[2]\n          };\n        },\n        getPositionFromLatLongHeight: (T) => {\n          const L = E.ellipsoid.cartographicToCartesian([\n            T.long,\n            T.lat,\n            T.height\n          ]);\n          return new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(...L).applyMatrix4(O);\n        },\n        orientToGeocoord: (T) => {\n          const L = [T.long, T.lat, T.height], W = E.ellipsoid.cartographicToCartesian(L), $ = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray(E.ellipsoid.eastNorthUpToFixedFrame(W)), Tt = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeRotationFromEuler(\n            new three__WEBPACK_IMPORTED_MODULE_0__.Euler(Math.PI / 2, Math.PI / 2, 0)\n          ), Wn = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy($).multiply(Tt).invert();\n          zn(Wn);\n        },\n        getWebMercatorCoord: (T) => sB(T.lat, T.long),\n        getCameraFrustum: (T) => {\n          const W = Ro(T).planes.map((Tt) => new et(Tt.normal.toArray(), Tt.constant)).map((Tt) => nB(Tt)), $ = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n          for (const Tt of W)\n            $.add(Tt);\n          return $;\n        },\n        overlayGeoJSON: (T) => (T.applyMatrix4(O), T.updateMatrixWorld(), T),\n        update: function(T, L, W) {\n          if (g = W, p.copy(L), D += T, E && D >= r) {\n            if (!nt.equals(h.matrixWorld)) {\n              D = 0, nt.copy(h.matrixWorld), n.updateTransforms && Ae();\n              const $ = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().setFromMatrixPosition(nt);\n              d.rootCenter.value.copy($), d.rootNormal.value.copy(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1).applyMatrix4(nt).normalize()), Ft.copy(nt).invert(), n.debug && (u[E.root.id].matrixWorld.copy(O), u[E.root.id].applyMatrix4(nt));\n            }\n            at == null ? at = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(W.matrixWorld) : (ne || mB(W, at, ee)) && (D = 0, ne = !1, E._frameNumber++, W.getWorldPosition(ge), at.copy(W.matrixWorld), We(E, c, p.y, W));\n          }\n        },\n        dispose: function() {\n          for (X = !0, E._destroy(); h.children.length > 0; ) {\n            const T = h.children[0];\n            xs(T), h.remove(T);\n          }\n          for (; f.children.length > 0; ) {\n            const T = f.children[0];\n            f.remove(T), T.geometry.dispose(), T.material.dispose();\n          }\n          w && w.dispose(), y && y.dispose();\n        }\n      }\n    };\n  }\n  /**\n  * Loads a tileset of 3D Tiles according to the given {@link GeoJSONLoaderProps}\n  * Could be overlayed on geograpical 3D Tiles using {@link Runtime.overlayGeoJSON}\n  * @public\n  *\n  * @param props - Properties for this load call {@link GeoJSONLoaderProps}.\n  * @returns An object containing the 3D Model to be added to the scene\n  */\n  static async loadGeoJSON(t) {\n    const { url: n, height: s, featureToColor: r } = t;\n    return fe(n, Ue, { worker: !1, gis: { format: \"binary\" } }).then((i) => {\n      const o = i, a = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), c = o.polygons.positions.value.reduce((h, f, d, m) => {\n        if (d % 2 == 0) {\n          const g = [f, m[d + 1], s], p = J.WGS84.cartographicToCartesian(g);\n          h.push(...p);\n        }\n        return h;\n      }, []);\n      if (r) {\n        const h = o.polygons.numericProps[r.feature].value.reduce((f, d, m, g) => {\n          const p = r.colorMap(d);\n          return f[m * 3] = p.r, f[m * 3 + 1] = p.g, f[m * 3 + 2] = p.b, f;\n        }, []);\n        a.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(\n          h,\n          3\n        ));\n      }\n      a.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(\n        c,\n        3\n      )), a.setIndex(\n        new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(o.polygons.triangles.value, 1)\n      );\n      const u = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({ transparent: !0 });\n      return u.vertexColors = !0, new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(a, u);\n    });\n  }\n}\nasync function fB(e, t, n, s, r) {\n  return new Promise((i, o) => {\n    const a = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeRotationAxis(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0), Math.PI / 2), c = t.content.gltfUpAxis !== \"Z\", u = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray(t.computedTransform).premultiply(r);\n    c && u.multiply(a), t.content.byteLength || (t.content.byteLength = t.content.gltfArrayBuffer.byteLength), e.parse(\n      t.content.gltfArrayBuffer,\n      t.contentUrl ? t.contentUrl.substr(0, t.contentUrl.lastIndexOf(\"/\") + 1) : \"\",\n      (l) => {\n        t.userData.asset = l.asset;\n        const h = l.scenes[0];\n        h.applyMatrix4(u), t.content.texturesByteLength = 0, t.content.geometriesByteLength = 0, h.traverse((f) => {\n          if (f.type == \"Mesh\") {\n            const d = f;\n            t.content.geometriesByteLength += Cc(d.geometry);\n            const m = d.material, g = m.map, p = rB(g);\n            p && (t.content.texturesByteLength += p), s.material ? (d.material = s.material.clone(), m.dispose()) : s.shading == Dn.FlatTexture && d.material.type !== \"MeshBasicMaterial\" && (d.material = n.clone(), m.dispose()), s.shading != Dn.ShadedNoTexture ? d.material.type == \"ShaderMaterial\" ? d.material.uniforms.map = { value: g } : d.material.map = g : (g && g.dispose(), d.material.map = null), d.material.wireframe = s.wireframe, s.contentPostProcess && s.contentPostProcess(d);\n          }\n        }), t.content.gpuMemoryUsageInBytes = t.content.texturesByteLength + t.content.geometriesByteLength, i(h);\n      },\n      (l) => {\n        o(new Error(`error parsing gltf in tile ${t.id}: ${l}`));\n      }\n    );\n  });\n}\nfunction dB(e, t, n, s) {\n  const r = {\n    rtc_center: e.content.rtcCenter,\n    // eslint-disable-line camelcase\n    points: e.content.attributes.positions,\n    intensities: e.content.attributes.intensity,\n    classifications: e.content.attributes.classification,\n    rgb: null,\n    rgba: null\n  }, { colors: i } = e.content.attributes;\n  i && i.size === 3 && (r.rgb = i.value), i && i.size === 4 && (r.rgba = i.value);\n  const o = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n  o.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(r.points, 3));\n  const a = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray(e.computedTransform).premultiply(s);\n  r.rgba ? o.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(r.rgba, 4)) : r.rgb && o.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_0__.Uint8BufferAttribute(r.rgb, 3, !0)), r.intensities && o.setAttribute(\n    \"intensity\",\n    // Handles both 16bit or 8bit intensity values\n    new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(r.intensities, 1, !0)\n  ), r.classifications && o.setAttribute(\"classification\", new three__WEBPACK_IMPORTED_MODULE_0__.Uint8BufferAttribute(r.classifications, 1, !1)), e.content.geometriesByteLength = Cc(o), e.content.gpuMemoryUsageInBytes = e.content.geometriesByteLength;\n  const c = new three__WEBPACK_IMPORTED_MODULE_0__.Points(o, n.material || t);\n  if (r.rtc_center) {\n    const u = r.rtc_center;\n    a.multiply(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeTranslation(u[0], u[1], u[2]));\n  }\n  return c.applyMatrix4(a), n.contentPostProcess && n.contentPostProcess(c), c;\n}\nfunction Io(e) {\n  var t, n, s, r;\n  (t = e == null ? void 0 : e.uniforms) != null && t.map ? (s = (n = e == null ? void 0 : e.uniforms) == null ? void 0 : n.map.value) == null || s.dispose() : e.map && ((r = e.map) == null || r.dispose()), e.dispose();\n}\nfunction xs(e) {\n  e.traverse((t) => {\n    if (t.isMesh)\n      if (t.geometry.dispose(), t.material.isMaterial)\n        Io(t.material);\n      else\n        for (const n of t.material)\n          Io(n);\n  });\n  for (let t = e.children.length - 1; t >= 0; t--) {\n    const n = e.children[t];\n    e.remove(n);\n  }\n}\nfunction mB(e, t, n) {\n  return !e.matrixWorld.equals(t) || e.aspect != n;\n}\nfunction gB(e) {\n  const t = /* @__PURE__ */ new Map();\n  return e.forEach((r) => {\n    var o, a;\n    const i = (a = (o = r == null ? void 0 : r.userData) == null ? void 0 : o.asset) == null ? void 0 : a.copyright;\n    i && i.split(/;/g).map((u) => u.trim()).forEach((u) => {\n      u && t.set(u, (t.get(u) || 0) + 1);\n    });\n  }), Array.from(t).sort((r, i) => i[1] - r[1]).map(([r]) => r).join(\"; \");\n}\n\n\n\n//# sourceURL=webpack://aframe-loader-3dtiles-component/./node_modules/three-loader-3dtiles/dist/lib/three-loader-3dtiles.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});