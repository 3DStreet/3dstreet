/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("THREE"));
	else if(typeof define === 'function' && define.amd)
		define(["THREE"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("THREE")) : factory(root["THREE"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, (__WEBPACK_EXTERNAL_MODULE_three__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three-loader-3dtiles */ \"./node_modules/three-loader-3dtiles/dist/lib/three-loader-3dtiles.js\");\n/* harmony import */ var _textarea__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./textarea */ \"./textarea.js\");\n/* harmony import */ var _textarea__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_textarea__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\nconst POINT_CLOUD_COLORING = {\n  white: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.White,\n  intensity: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.Intensity,\n  classification: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.Classification,\n  elevation: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.Elevation,\n  rgb: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.RGB\n};\n/**\n * 3D Tiles component for A-Frame.\n */\n\nAFRAME.registerComponent('loader-3dtiles', {\n  schema: {\n    url: {\n      type: 'string'\n    },\n    cameraEl: {\n      type: 'selector'\n    },\n    maximumSSE: {\n      type: 'int',\n      default: 16\n    },\n    maximumMem: {\n      type: 'int',\n      default: 32\n    },\n    distanceScale: {\n      type: 'number',\n      default: 1.0\n    },\n    pointcloudColoring: {\n      type: 'string',\n      default: 'white'\n    },\n    pointcloudElevationRange: {\n      type: 'array',\n      default: ['0', '400']\n    },\n    wireframe: {\n      type: 'boolean',\n      default: false\n    },\n    showStats: {\n      type: 'boolean',\n      default: false\n    },\n    cesiumIONToken: {\n      type: 'string'\n    },\n    googleApiKey: {\n      type: 'string'\n    },\n    lat: {\n      type: 'number'\n    },\n    long: {\n      type: 'number'\n    },\n    height: {\n      type: 'number'\n    },\n    geoTransform: {\n      type: 'string',\n      default: 'Reset'\n    }\n  },\n  init: async function () {\n    this.camera = this.data.cameraEl?.object3D.children[0] ?? document.querySelector('a-scene').camera;\n\n    if (!this.camera) {\n      throw new Error('3D Tiles: Please add an active camera or specify the target camera via the cameraEl property');\n    }\n\n    const {\n      model,\n      runtime\n    } = await this._initTileset();\n    this.el.setObject3D('tileset', model);\n    this.originalCamera = this.camera;\n    this.el.sceneEl.renderer.preserveDrawingBuffer = true;\n    this.el.sceneEl.addEventListener('camera-set-active', e => {\n      // TODO: For some reason after closing the inspector this event is fired with an empty camera,\n      // so revert to the original camera used.\n      //\n      // TODO: Does not provide the right Inspector perspective camera\n      this.camera = e.detail.cameraEl.object3D.children[0] ?? this.originalCamera;\n    });\n    this.el.sceneEl.addEventListener('enter-vr', e => {\n      this.originalCamera = this.camera;\n\n      try {\n        this.camera = this.el.sceneEl.renderer.xr.getCamera(this.camera); // FOV Code from https://github.com/mrdoob/three.js/issues/21869\n\n        this.el.sceneEl.renderer.xr.getSession().requestAnimationFrame((time, frame) => {\n          const ref = this.el.sceneEl.renderer.xr.getReferenceSpace();\n          const pose = frame.getViewerPose(ref);\n\n          if (pose) {\n            const fovi = pose.views[0].projectionMatrix[5];\n            this.camera.fov = Math.atan2(1, fovi) * 2 * 180 / Math.PI;\n          }\n        });\n      } catch (e) {\n        console.warn('Could not get VR camera');\n      }\n    });\n    this.el.sceneEl.addEventListener('exit-vr', e => {\n      this.camera = this.originalCamera;\n    });\n\n    if (this.data.showStats) {\n      this.stats = this._initStats();\n    }\n\n    if (THREE.Cache.enabled) {\n      console.warn('3D Tiles loader cannot work with THREE.Cache, disabling.');\n      THREE.Cache.enabled = false;\n    }\n\n    await this._nextFrame();\n    this.runtime = runtime;\n    this.runtime.setElevationRange(this.data.pointcloudElevationRange.map(n => Number(n)));\n  },\n  update: async function (oldData) {\n    if (oldData.url !== this.data.url) {\n      if (this.runtime) {\n        this.runtime.dispose();\n        this.runtime = null;\n      }\n\n      const {\n        model,\n        runtime\n      } = await this._initTileset();\n      this.el.setObject3D('tileset', model);\n      await this._nextFrame();\n      this.runtime = runtime;\n    } else if (this.runtime) {\n      this.runtime.setPointCloudColoring(this._resolvePointcloudColoring(this.data.pointCloudColoring));\n      this.runtime.setWireframe(this.data.wireframe);\n      this.runtime.setViewDistanceScale(this.data.distanceScale);\n      this.runtime.setElevationRange(this.data.pointcloudElevationRange.map(n => Number(n)));\n    }\n\n    if (this.data.showStats && !this.stats) {\n      this.stats = this._initStats();\n    }\n\n    if (!this.data.showStats && this.stats) {\n      this.el.sceneEl.removeChild(this.stats);\n      this.stats = null;\n    } // set parameters for google 3dtiles API\n\n\n    if (this.data.lat && this.data.long && this.data.height) {\n      const {\n        model,\n        runtime\n      } = await this._initTileset();\n      console.log(this.data.lat, this.data.long, this.data.height);\n      this.runtime.orientToGeocoord({\n        lat: Number(this.data.lat),\n        long: Number(this.data.long),\n        height: Number(this.data.height)\n      });\n    }\n  },\n  tick: function (t, dt) {\n    if (this.runtime) {\n      this.runtime.update(dt, this.el.sceneEl.clientHeight, this.camera);\n\n      if (this.stats) {\n        const worldPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        this.camera.getWorldPosition(worldPos);\n        const stats = this.runtime.getStats();\n        this.stats.setAttribute('textarea', 'text', Object.values(stats.stats).map(s => `${s.name}: ${s.count}`).join('\\n'));\n        const newPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        newPos.copy(worldPos);\n        newPos.z -= 2;\n        this.stats.setAttribute('position', newPos);\n      }\n    }\n  },\n  remove: function () {\n    if (this.runtime) {\n      this.runtime.dispose();\n    }\n  },\n\n  _resolvePointcloudColoring() {\n    const pointCloudColoring = POINT_CLOUD_COLORING[this.data.pointcloudColoring];\n\n    if (!pointCloudColoring) {\n      console.warn('Invalid value for point cloud coloring');\n      return three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.White;\n    } else {\n      return pointCloudColoring;\n    }\n  },\n\n  _initTileset: async function () {\n    const pointCloudColoring = this._resolvePointcloudColoring(this.data.pointcloudColoring);\n\n    return three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.Loader3DTiles.load({\n      url: this.data.url,\n      renderer: this.el.sceneEl.renderer,\n      options: {\n        googleApiKey: this.data.googleApiKey,\n        cesiumIONToken: this.data.cesiumIONToken,\n        dracoDecoderPath: 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/draco',\n        basisTranscoderPath: 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/basis',\n        maximumScreenSpaceError: this.data.maximumSSE,\n        maximumMemoryUsage: this.data.maximumMem,\n        memoryCacheOverflow: 128,\n        pointCloudColoring: pointCloudColoring,\n        viewDistanceScale: this.data.distanceScale,\n        wireframe: this.data.wireframe,\n        updateTransforms: true,\n        geoTransform: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.GeoTransform[this.data.geoTransform]\n      }\n    });\n  },\n  _initStats: function () {\n    const stats = document.createElement('a-entity');\n    this.el.sceneEl.appendChild(stats);\n    stats.setAttribute('position', '-0.5 0 -1');\n    stats.setAttribute('textarea', {\n      cols: 30,\n      rows: 15,\n      text: '',\n      color: 'white',\n      disabledBackgroundColor: '#0c1e2c',\n      disabled: true\n    });\n    return stats;\n  },\n  _nextFrame: async function () {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        resolve();\n      }, 0);\n    });\n  }\n});\n\n//# sourceURL=webpack://aframe-loader-3dtiles-component/./index.js?");

/***/ }),

/***/ "./textarea.js":
/*!*********************!*\
  !*** ./textarea.js ***!
  \*********************/
/***/ (() => {

eval("if (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n/**\n * Textarea component for A-Frame.\n *\n * Ripped from: https://github.com/brianpeiris/aframe-textarea-component\n */\n\n\nAFRAME.registerComponent('textarea', {\n  schema: {\n    transparentBG: {\n      type: 'boolean',\n      default: false\n    },\n    cols: {\n      type: 'int',\n      default: 40\n    },\n    rows: {\n      type: 'int',\n      default: 20\n    },\n    color: {\n      type: 'color',\n      default: 'black'\n    },\n    backgroundColor: {\n      type: 'color',\n      default: 'white'\n    },\n    disabledBackgroundColor: {\n      type: 'color',\n      default: 'lightgrey'\n    },\n    disabled: {\n      type: 'boolean',\n      default: false\n    },\n    text: {\n      type: 'string',\n      default: ''\n    }\n  },\n  init: function () {\n    this.text = null;\n    this.lines = [];\n    this.lastBlink = 0;\n    this.blinkEnabled = !this.data.disabled;\n    this.charWidth = this.charHeight = null;\n    this.selectionStart = this.selectionEnd = 0;\n    this.endIndexInfo = this.startIndexInfo = null;\n    this.origin = {\n      x: 0,\n      y: 0\n    };\n    this.background = document.createElement('a-plane');\n    this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    this.el.appendChild(this.background);\n\n    if (this.data.transparentBG) {\n      this.background.setAttribute('material', {\n        opacity: 0,\n        transparent: true\n      });\n    }\n\n    this.textAnchor = document.createElement('a-entity');\n    this.el.appendChild(this.textAnchor);\n    this.textAnchor.setAttribute('text', {\n      mode: 'pre',\n      baseline: 'top',\n      anchor: 'center',\n      font: 'dejavu',\n      wrapCount: this.data.cols,\n      height: this.data.rows,\n      color: this.data.color\n    });\n\n    this._initTextarea();\n\n    this.el.addEventListener('textfontset', this._updateCharMetrics.bind(this));\n    this.el.addEventListener('char-metrics-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('text-changed', this._updateLines.bind(this));\n    this.el.addEventListener('text-changed', this._updateDisplayText.bind(this));\n    this.el.addEventListener('selection-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('selection-changed', this._updateHorizontalOrigin.bind(this));\n    this.el.addEventListener('lines-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('index-info-changed', this._updateOrigin.bind(this));\n    this.el.addEventListener('index-info-changed', this._updateHorizontalOrigin.bind(this));\n    this.el.addEventListener('origin-changed', this._updateDisplayText.bind(this));\n    this.el.addEventListener('click', this.focus.bind(this));\n  },\n  update: function (oldData) {\n    if (this.data.text !== oldData.text) {\n      this._updateTextarea();\n    }\n\n    if (this.data.backgroundColor !== oldData.backgroundColor || this.data.disabledBackgroundColor !== oldData.disabledBackgroundColor) {\n      this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    }\n\n    if (this.data.disabled !== oldData.disabled) {\n      this.blinkEnabled = !this.data.disabled;\n      this.textarea.disabled = this.data.disabled;\n      this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    }\n  },\n  focus: function () {\n    this.textarea.focus();\n  },\n  _initTextarea: function () {\n    this.textarea = document.createElement('textarea');\n    document.body.appendChild(this.textarea);\n\n    this._updateTextarea();\n  },\n  _updateTextarea: function () {\n    this.textarea.style.whiteSpace = 'pre';\n    this.textarea.style.overflow = 'hidden';\n    this.textarea.style.opacity = '0';\n    this.textarea.cols = this.data.cols;\n    this.textarea.rows = this.data.rows;\n    this.textarea.value = this.data.text;\n    this.textarea.selectionStart = 0;\n    this.textarea.selectionEnd = 0;\n\n    this._updateIndexInfo();\n  },\n  _emit: function (eventName, detail) {\n    this.el.emit(eventName, detail);\n  },\n  _updateCharMetrics: function (event) {\n    const layout = this.textAnchor.components.text.geometry.layout;\n    const fontWidthFactor = event.detail.fontObj.widthFactor;\n    this.charWidth = fontWidthFactor * this.textAnchor.object3DMap.text.scale.x;\n    this.charHeight = this.charWidth * layout.lineHeight / fontWidthFactor;\n    this.textAnchor.setAttribute('position', {\n      x: 0,\n      y: this.charHeight * this.data.rows / 2,\n      z: 0\n    });\n\n    if (!this.data.transparentBG) {\n      this.background.setAttribute('scale', {\n        x: 1.05,\n        y: this.charHeight * this.data.rows * 1.05,\n        z: 1\n      });\n      this.background.setAttribute('position', {\n        x: 0,\n        y: 0,\n        z: 0\n      });\n    }\n\n    this._emit('char-metrics-changed');\n  },\n  _checkAndUpdateSelection: function () {\n    if (this.selectionStart === this.textarea.selectionStart && this.selectionEnd === this.textarea.selectionEnd) {\n      return;\n    }\n\n    const lastStart = this.selectionStart;\n    const lastEnd = this.selectionEnd;\n    this.selectionStart = this.textarea.selectionStart;\n    this.selectionEnd = this.textarea.selectionEnd;\n\n    this._emit('selection-changed', {\n      start: {\n        old: lastStart,\n        new: this.selectionStart,\n        changed: this.selectionStart !== lastStart\n      },\n      end: {\n        old: lastEnd,\n        new: this.selectionEnd,\n        changed: this.selectionEnd !== lastEnd\n      }\n    });\n  },\n  tick: function (time) {\n    if (time - this.lastBlink > 500 && this.blinkEnabled) {\n      this.lastBlink = time;\n    }\n\n    this._checkAndUpdateSelection();\n\n    this._checkAndUpdateText();\n  },\n  _getIndexInfo: function (lineIndex, textIndex) {\n    const y = Math.max(0, lineIndex);\n    const line = this.lines[y];\n    const x = textIndex - line.start;\n    return {\n      line: line,\n      x: x * this.charWidth,\n      y: -this.charHeight * y + -this.charHeight / 2\n    };\n  },\n  _updateIndexInfo: function () {\n    if (!this.lines.length) {\n      return;\n    }\n\n    const lastStart = this.startIndexInfo && this.startIndexInfo.line.index;\n    const lastEnd = this.endIndexInfo && this.endIndexInfo.line.index;\n    this.startIndexInfo = null;\n    this.endIndexInfo = null;\n    let i;\n    let startChanged = false;\n    let endChanged = false;\n\n    for (i = 0; i <= this.lines.length; i++) {\n      const prevLine = this.lines[i - 1];\n      const lineStart = i === this.lines.length ? prevLine.start + prevLine.length + 1 : this.lines[i].start;\n\n      if (lineStart > this.selectionStart && !this.startIndexInfo) {\n        this.startIndexInfo = this._getIndexInfo(i - 1, this.selectionStart);\n\n        if (this.startIndexInfo.line.index !== lastStart) {\n          startChanged = true;\n        }\n      }\n\n      if (lineStart > this.selectionEnd) {\n        this.endIndexInfo = this._getIndexInfo(i - 1, this.selectionEnd);\n\n        if (this.endIndexInfo.line.index !== lastEnd) {\n          endChanged = true;\n        }\n\n        break;\n      }\n    }\n\n    if (startChanged || endChanged) {\n      this._emit('index-info-changed', {\n        start: {\n          changed: startChanged\n        },\n        end: {\n          changed: endChanged\n        }\n      });\n    }\n  },\n  _updateOrigin: function (event) {\n    let changed = false;\n\n    if (event.detail.end.changed) {\n      const end = this.origin.y + this.data.rows - 1;\n\n      if (this.endIndexInfo.line.index > end) {\n        this.origin.y = this.endIndexInfo.line.index + 1 - this.data.rows;\n        changed = true;\n      } else if (this.endIndexInfo.line.index < this.origin.y) {\n        this.origin.y = this.endIndexInfo.line.index;\n        changed = true;\n      }\n    }\n\n    if (event.detail.start.changed) {\n      if (this.startIndexInfo.line.index < this.origin.y) {\n        this.origin.y = this.startIndexInfo.line.index;\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      this._emit('origin-changed');\n    }\n  },\n  _updateHorizontalOrigin: function (event) {\n    if (!this.endIndexInfo) {\n      return;\n    }\n\n    let changed = true;\n\n    if (event.detail.end.changed) {\n      const endIndex = this.selectionEnd - this.endIndexInfo.line.start;\n\n      if (endIndex > this.origin.x + this.data.cols) {\n        this.origin.x = endIndex - this.data.cols;\n        changed = true;\n      } else if (endIndex < this.origin.x) {\n        this.origin.x = endIndex;\n        changed = true;\n      }\n    }\n\n    const startIndex = this.selectionStart - this.startIndexInfo.line.start;\n\n    if (event.detail.start.changed) {\n      if (startIndex > this.origin.x + this.data.cols) {\n        this.origin.x = startIndex - this.data.cols;\n        changed = true;\n      } else if (startIndex < this.origin.x) {\n        this.origin.x = startIndex;\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      this._emit('origin-changed');\n    }\n  },\n  _updateLines: function () {\n    this.lines = [];\n    const lines = this.text.split('\\n');\n    let counter = 0;\n\n    for (let i = 0; i < lines.length; i++) {\n      this.lines[i] = {\n        index: i,\n        length: lines[i].length,\n        start: counter\n      };\n      counter += lines[i].length + 1;\n    }\n\n    this._emit('lines-changed');\n  },\n  _getViewportText: function () {\n    return this.text.split('\\n').slice(this.origin.y, this.origin.y + this.data.rows).map(function (line) {\n      return line.substr(this.origin.x, this.data.cols) || ' ';\n    }.bind(this)).join('\\n');\n  },\n  _updateDisplayText: function () {\n    this.textAnchor.setAttribute('text', {\n      value: this._getViewportText()\n    });\n  },\n  _checkAndUpdateText: function () {\n    const text = this.textarea.value;\n\n    if (text === this.text) {\n      return;\n    }\n\n    this.text = text;\n\n    this._emit('text-changed');\n  }\n});\n\n//# sourceURL=webpack://aframe-loader-3dtiles-component/./textarea.js?");

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_three__;

/***/ }),

/***/ "./node_modules/three-loader-3dtiles/dist/lib/three-loader-3dtiles.js":
/*!****************************************************************************!*\
  !*** ./node_modules/three-loader-3dtiles/dist/lib/three-loader-3dtiles.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GeoTransform\": () => (/* binding */ Rt),\n/* harmony export */   \"Loader3DTiles\": () => (/* binding */ Hp),\n/* harmony export */   \"PointCloudColoring\": () => (/* binding */ Pa),\n/* harmony export */   \"Shading\": () => (/* binding */ yn)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three/examples/jsm/loaders/KTX2Loader.js */ \"three\");\n\n\n\n\nasync function Re(e, t, n, s) {\n  return s._parse(e, t, n, s);\n}\nfunction U(e, t) {\n  if (!e)\n    throw new Error(t || \"loader assertion failed.\");\n}\nconst Cn = !!(typeof process != \"object\" || String(process) !== \"[object process]\" || process.browser), lr = typeof process < \"u\" && process.version && /v([0-9]*)/.exec(process.version);\nlr && parseFloat(lr[1]);\nfunction sc(e, t) {\n  return $i(e || {}, t);\n}\nfunction $i(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  if (n > 3)\n    return t;\n  const s = {\n    ...e\n  };\n  for (const [r, i] of Object.entries(t))\n    i && typeof i == \"object\" && !Array.isArray(i) ? s[r] = $i(s[r] || {}, t[r], n + 1) : s[r] = t[r];\n  return s;\n}\nconst rc = \"latest\";\nfunction ic() {\n  var e;\n  return (e = globalThis._loadersgl_) !== null && e !== void 0 && e.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = \"4.1.1\"), globalThis._loadersgl_.version;\n}\nconst Zi = ic();\nfunction Lt(e, t) {\n  if (!e)\n    throw new Error(t || \"loaders.gl assertion failed.\");\n}\nconst Bt = typeof process != \"object\" || String(process) !== \"[object process]\" || process.browser, Ds = typeof importScripts == \"function\", oc = typeof window < \"u\" && typeof window.orientation < \"u\", hr = typeof process < \"u\" && process.version && /v([0-9]*)/.exec(process.version);\nhr && parseFloat(hr[1]);\nclass ac {\n  constructor(t, n) {\n    this.name = void 0, this.workerThread = void 0, this.isRunning = !0, this.result = void 0, this._resolve = () => {\n    }, this._reject = () => {\n    }, this.name = t, this.workerThread = n, this.result = new Promise((s, r) => {\n      this._resolve = s, this._reject = r;\n    });\n  }\n  postMessage(t, n) {\n    this.workerThread.postMessage({\n      source: \"loaders.gl\",\n      type: t,\n      payload: n\n    });\n  }\n  done(t) {\n    Lt(this.isRunning), this.isRunning = !1, this._resolve(t);\n  }\n  error(t) {\n    Lt(this.isRunning), this.isRunning = !1, this._reject(t);\n  }\n}\nclass On {\n  terminate() {\n  }\n}\nconst vn = /* @__PURE__ */ new Map();\nfunction cc(e) {\n  Lt(e.source && !e.url || !e.source && e.url);\n  let t = vn.get(e.source || e.url);\n  return t || (e.url && (t = uc(e.url), vn.set(e.url, t)), e.source && (t = to(e.source), vn.set(e.source, t))), Lt(t), t;\n}\nfunction uc(e) {\n  if (!e.startsWith(\"http\"))\n    return e;\n  const t = lc(e);\n  return to(t);\n}\nfunction to(e) {\n  const t = new Blob([e], {\n    type: \"application/javascript\"\n  });\n  return URL.createObjectURL(t);\n}\nfunction lc(e) {\n  return `try {\n  importScripts('${e}');\n} catch (error) {\n  console.error(error);\n  throw error;\n}`;\n}\nfunction eo(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = n || /* @__PURE__ */ new Set();\n  if (e) {\n    if (fr(e))\n      s.add(e);\n    else if (fr(e.buffer))\n      s.add(e.buffer);\n    else if (!ArrayBuffer.isView(e)) {\n      if (t && typeof e == \"object\")\n        for (const r in e)\n          eo(e[r], t, s);\n    }\n  }\n  return n === void 0 ? Array.from(s) : [];\n}\nfunction fr(e) {\n  return e ? e instanceof ArrayBuffer || typeof MessagePort < \"u\" && e instanceof MessagePort || typeof ImageBitmap < \"u\" && e instanceof ImageBitmap || typeof OffscreenCanvas < \"u\" && e instanceof OffscreenCanvas : !1;\n}\nconst xn = () => {\n};\nclass hs {\n  static isSupported() {\n    return typeof Worker < \"u\" && Bt || typeof On < \"u\" && !Bt;\n  }\n  constructor(t) {\n    this.name = void 0, this.source = void 0, this.url = void 0, this.terminated = !1, this.worker = void 0, this.onMessage = void 0, this.onError = void 0, this._loadableURL = \"\";\n    const {\n      name: n,\n      source: s,\n      url: r\n    } = t;\n    Lt(s || r), this.name = n, this.source = s, this.url = r, this.onMessage = xn, this.onError = (i) => console.log(i), this.worker = Bt ? this._createBrowserWorker() : this._createNodeWorker();\n  }\n  destroy() {\n    this.onMessage = xn, this.onError = xn, this.worker.terminate(), this.terminated = !0;\n  }\n  get isRunning() {\n    return !!this.onMessage;\n  }\n  postMessage(t, n) {\n    n = n || eo(t), this.worker.postMessage(t, n);\n  }\n  _getErrorFromErrorEvent(t) {\n    let n = \"Failed to load \";\n    return n += `worker ${this.name} from ${this.url}. `, t.message && (n += `${t.message} in `), t.lineno && (n += `:${t.lineno}:${t.colno}`), new Error(n);\n  }\n  _createBrowserWorker() {\n    this._loadableURL = cc({\n      source: this.source,\n      url: this.url\n    });\n    const t = new Worker(this._loadableURL, {\n      name: this.name\n    });\n    return t.onmessage = (n) => {\n      n.data ? this.onMessage(n.data) : this.onError(new Error(\"No data received\"));\n    }, t.onerror = (n) => {\n      this.onError(this._getErrorFromErrorEvent(n)), this.terminated = !0;\n    }, t.onmessageerror = (n) => console.error(n), t;\n  }\n  _createNodeWorker() {\n    let t;\n    if (this.url) {\n      const s = this.url.includes(\":/\") || this.url.startsWith(\"/\") ? this.url : `./${this.url}`;\n      t = new On(s, {\n        eval: !1\n      });\n    } else if (this.source)\n      t = new On(this.source, {\n        eval: !0\n      });\n    else\n      throw new Error(\"no worker\");\n    return t.on(\"message\", (n) => {\n      this.onMessage(n);\n    }), t.on(\"error\", (n) => {\n      this.onError(n);\n    }), t.on(\"exit\", (n) => {\n    }), t;\n  }\n}\nclass hc {\n  static isSupported() {\n    return hs.isSupported();\n  }\n  constructor(t) {\n    this.name = \"unnamed\", this.source = void 0, this.url = void 0, this.maxConcurrency = 1, this.maxMobileConcurrency = 1, this.onDebug = () => {\n    }, this.reuseWorkers = !0, this.props = {}, this.jobQueue = [], this.idleQueue = [], this.count = 0, this.isDestroyed = !1, this.source = t.source, this.url = t.url, this.setProps(t);\n  }\n  destroy() {\n    this.idleQueue.forEach((t) => t.destroy()), this.isDestroyed = !0;\n  }\n  setProps(t) {\n    this.props = {\n      ...this.props,\n      ...t\n    }, t.name !== void 0 && (this.name = t.name), t.maxConcurrency !== void 0 && (this.maxConcurrency = t.maxConcurrency), t.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = t.maxMobileConcurrency), t.reuseWorkers !== void 0 && (this.reuseWorkers = t.reuseWorkers), t.onDebug !== void 0 && (this.onDebug = t.onDebug);\n  }\n  async startJob(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (i, o, a) => i.done(a), s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (i, o) => i.error(o);\n    const r = new Promise((i) => (this.jobQueue.push({\n      name: t,\n      onMessage: n,\n      onError: s,\n      onStart: i\n    }), this));\n    return this._startQueuedJob(), await r;\n  }\n  async _startQueuedJob() {\n    if (!this.jobQueue.length)\n      return;\n    const t = this._getAvailableWorker();\n    if (!t)\n      return;\n    const n = this.jobQueue.shift();\n    if (n) {\n      this.onDebug({\n        message: \"Starting job\",\n        name: n.name,\n        workerThread: t,\n        backlog: this.jobQueue.length\n      });\n      const s = new ac(n.name, t);\n      t.onMessage = (r) => n.onMessage(s, r.type, r.payload), t.onError = (r) => n.onError(s, r), n.onStart(s);\n      try {\n        await s.result;\n      } catch (r) {\n        console.error(`Worker exception: ${r}`);\n      } finally {\n        this.returnWorkerToQueue(t);\n      }\n    }\n  }\n  returnWorkerToQueue(t) {\n    !Bt || this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency() ? (t.destroy(), this.count--) : this.idleQueue.push(t), this.isDestroyed || this._startQueuedJob();\n  }\n  _getAvailableWorker() {\n    if (this.idleQueue.length > 0)\n      return this.idleQueue.shift() || null;\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const t = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new hs({\n        name: t,\n        source: this.source,\n        url: this.url\n      });\n    }\n    return null;\n  }\n  _getMaxConcurrency() {\n    return oc ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n}\nconst fc = {\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  reuseWorkers: !0,\n  onDebug: () => {\n  }\n};\nclass Ot {\n  static isSupported() {\n    return hs.isSupported();\n  }\n  static getWorkerFarm() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    return Ot._workerFarm = Ot._workerFarm || new Ot({}), Ot._workerFarm.setProps(t), Ot._workerFarm;\n  }\n  constructor(t) {\n    this.props = void 0, this.workerPools = /* @__PURE__ */ new Map(), this.props = {\n      ...fc\n    }, this.setProps(t), this.workerPools = /* @__PURE__ */ new Map();\n  }\n  destroy() {\n    for (const t of this.workerPools.values())\n      t.destroy();\n    this.workerPools = /* @__PURE__ */ new Map();\n  }\n  setProps(t) {\n    this.props = {\n      ...this.props,\n      ...t\n    };\n    for (const n of this.workerPools.values())\n      n.setProps(this._getWorkerPoolProps());\n  }\n  getWorkerPool(t) {\n    const {\n      name: n,\n      source: s,\n      url: r\n    } = t;\n    let i = this.workerPools.get(n);\n    return i || (i = new hc({\n      name: n,\n      source: s,\n      url: r\n    }), i.setProps(this._getWorkerPoolProps()), this.workerPools.set(n, i)), i;\n  }\n  _getWorkerPoolProps() {\n    return {\n      maxConcurrency: this.props.maxConcurrency,\n      maxMobileConcurrency: this.props.maxMobileConcurrency,\n      reuseWorkers: this.props.reuseWorkers,\n      onDebug: this.props.onDebug\n    };\n  }\n}\nOt._workerFarm = void 0;\nfunction dc(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  const n = t[e.id] || {}, s = Bt ? `${e.id}-worker.js` : `${e.id}-worker-node.js`;\n  let r = n.workerUrl;\n  if (!r && e.id === \"compression\" && (r = t.workerUrl), t._workerType === \"test\" && (Bt ? r = `modules/${e.module}/dist/${s}` : r = `modules/${e.module}/src/workers/${e.id}-worker-node.ts`), !r) {\n    let i = e.version;\n    i === \"latest\" && (i = rc);\n    const o = i ? `@${i}` : \"\";\n    r = `https://unpkg.com/@loaders.gl/${e.module}${o}/dist/${s}`;\n  }\n  return Lt(r), r;\n}\nfunction mc(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Zi;\n  Lt(e, \"no worker provided\");\n  const n = e.version;\n  return !(!t || !n);\n}\nconst Ac = {}, gc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  default: Ac\n}, Symbol.toStringTag, { value: \"Module\" })), Ln = {};\nasync function zt(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n  return t && (e = pc(e, t, n, s)), Ln[e] = Ln[e] || Bc(e), await Ln[e];\n}\nfunction pc(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n  if (!n.useLocalLibraries && e.startsWith(\"http\"))\n    return e;\n  s = s || e;\n  const r = n.modules || {};\n  return r[s] ? r[s] : Bt ? n.CDN ? (Lt(n.CDN.startsWith(\"http\")), `${n.CDN}/${t}@${Zi}/dist/libs/${s}`) : Ds ? `../src/libs/${s}` : `modules/${t}/src/libs/${s}` : `modules/${t}/dist/libs/${s}`;\n}\nasync function Bc(e) {\n  if (e.endsWith(\"wasm\"))\n    return await Cc(e);\n  if (!Bt)\n    try {\n      return gc && void 0;\n    } catch (n) {\n      return console.error(n), null;\n    }\n  if (Ds)\n    return importScripts(e);\n  const t = await Tc(e);\n  return yc(t, e);\n}\nfunction yc(e, t) {\n  if (!Bt)\n    return;\n  if (Ds)\n    return eval.call(globalThis, e), null;\n  const n = document.createElement(\"script\");\n  n.id = t;\n  try {\n    n.appendChild(document.createTextNode(e));\n  } catch {\n    n.text = e;\n  }\n  return document.body.appendChild(n), null;\n}\nasync function Cc(e) {\n  return await (await fetch(e)).arrayBuffer();\n}\nasync function Tc(e) {\n  return await (await fetch(e)).text();\n}\nfunction Ec(e, t) {\n  return !Ot.isSupported() || !Bt && !(t != null && t._nodeWorkers) ? !1 : e.worker && (t == null ? void 0 : t.worker);\n}\nasync function bc(e, t, n, s, r) {\n  const i = e.id, o = dc(e, n), c = Ot.getWorkerFarm(n).getWorkerPool({\n    name: i,\n    url: o\n  });\n  n = JSON.parse(JSON.stringify(n)), s = JSON.parse(JSON.stringify(s || {}));\n  const u = await c.startJob(\"process-on-worker\", _c.bind(null, r));\n  return u.postMessage(\"process\", {\n    input: t,\n    options: n,\n    context: s\n  }), await (await u.result).result;\n}\nasync function _c(e, t, n, s) {\n  switch (n) {\n    case \"done\":\n      t.done(s);\n      break;\n    case \"error\":\n      t.error(new Error(s.error));\n      break;\n    case \"process\":\n      const {\n        id: r,\n        input: i,\n        options: o\n      } = s;\n      try {\n        const a = await e(i, o);\n        t.postMessage(\"done\", {\n          id: r,\n          result: a\n        });\n      } catch (a) {\n        const c = a instanceof Error ? a.message : \"unknown error\";\n        t.postMessage(\"error\", {\n          id: r,\n          error: c\n        });\n      }\n      break;\n    default:\n      console.warn(`parse-with-worker unknown message ${n}`);\n  }\n}\nfunction wc(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;\n  return typeof e == \"string\" ? e.slice(0, t) : ArrayBuffer.isView(e) ? dr(e.buffer, e.byteOffset, t) : e instanceof ArrayBuffer ? dr(e, 0, t) : \"\";\n}\nfunction dr(e, t, n) {\n  if (e.byteLength <= t + n)\n    return \"\";\n  const s = new DataView(e);\n  let r = \"\";\n  for (let i = 0; i < n; i++)\n    r += String.fromCharCode(s.getUint8(t + i));\n  return r;\n}\nfunction Mc(e) {\n  try {\n    return JSON.parse(e);\n  } catch {\n    throw new Error(`Failed to parse JSON from data starting with \"${wc(e)}\"`);\n  }\n}\nfunction Rc(e, t, n) {\n  if (n = n || e.byteLength, e.byteLength < n || t.byteLength < n)\n    return !1;\n  const s = new Uint8Array(e), r = new Uint8Array(t);\n  for (let i = 0; i < s.length; ++i)\n    if (s[i] !== r[i])\n      return !1;\n  return !0;\n}\nfunction Ic() {\n  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)\n    t[n] = arguments[n];\n  return Sc(t);\n}\nfunction Sc(e) {\n  const t = e.map((i) => i instanceof ArrayBuffer ? new Uint8Array(i) : i), n = t.reduce((i, o) => i + o.byteLength, 0), s = new Uint8Array(n);\n  let r = 0;\n  for (const i of t)\n    s.set(i, r), r += i.byteLength;\n  return s.buffer;\n}\nfunction Fs(e, t, n) {\n  const s = n !== void 0 ? new Uint8Array(e).subarray(t, t + n) : new Uint8Array(e).subarray(t);\n  return new Uint8Array(s).buffer;\n}\nfunction Ie(e, t) {\n  return U(e >= 0), U(t > 0), e + (t - 1) & ~(t - 1);\n}\nfunction Dc(e, t, n) {\n  let s;\n  if (e instanceof ArrayBuffer)\n    s = new Uint8Array(e);\n  else {\n    const r = e.byteOffset, i = e.byteLength;\n    s = new Uint8Array(e.buffer || e.arrayBuffer, r, i);\n  }\n  return t.set(s, n), n + Ie(s.byteLength, 4);\n}\nasync function Fc(e) {\n  const t = [];\n  for await (const n of e)\n    t.push(n);\n  return Ic(...t);\n}\nfunction mr() {\n  let e;\n  if (typeof window < \"u\" && window.performance)\n    e = window.performance.now();\n  else if (typeof process < \"u\" && process.hrtime) {\n    const t = process.hrtime();\n    e = t[0] * 1e3 + t[1] / 1e6;\n  } else\n    e = Date.now();\n  return e;\n}\nclass Ar {\n  constructor(t, n) {\n    this.name = void 0, this.type = void 0, this.sampleSize = 1, this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this.name = t, this.type = n, this.reset();\n  }\n  reset() {\n    return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this;\n  }\n  setSampleSize(t) {\n    return this.sampleSize = t, this;\n  }\n  incrementCount() {\n    return this.addCount(1), this;\n  }\n  decrementCount() {\n    return this.subtractCount(1), this;\n  }\n  addCount(t) {\n    return this._count += t, this._samples++, this._checkSampling(), this;\n  }\n  subtractCount(t) {\n    return this._count -= t, this._samples++, this._checkSampling(), this;\n  }\n  addTime(t) {\n    return this._time += t, this.lastTiming = t, this._samples++, this._checkSampling(), this;\n  }\n  timeStart() {\n    return this._startTime = mr(), this._timerPending = !0, this;\n  }\n  timeEnd() {\n    return this._timerPending ? (this.addTime(mr() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this;\n  }\n  getSampleAverageCount() {\n    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;\n  }\n  getSampleAverageTime() {\n    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;\n  }\n  getSampleHz() {\n    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;\n  }\n  getAverageCount() {\n    return this.samples > 0 ? this.count / this.samples : 0;\n  }\n  getAverageTime() {\n    return this.samples > 0 ? this.time / this.samples : 0;\n  }\n  getHz() {\n    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;\n  }\n  _checkSampling() {\n    this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0);\n  }\n}\nclass no {\n  constructor(t) {\n    this.id = void 0, this.stats = {}, this.id = t.id, this.stats = {}, this._initializeStats(t.stats), Object.seal(this);\n  }\n  get(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"count\";\n    return this._getOrCreate({\n      name: t,\n      type: n\n    });\n  }\n  get size() {\n    return Object.keys(this.stats).length;\n  }\n  reset() {\n    for (const t of Object.values(this.stats))\n      t.reset();\n    return this;\n  }\n  forEach(t) {\n    for (const n of Object.values(this.stats))\n      t(n);\n  }\n  getTable() {\n    const t = {};\n    return this.forEach((n) => {\n      t[n.name] = {\n        time: n.time || 0,\n        count: n.count || 0,\n        average: n.getAverageTime() || 0,\n        hz: n.getHz() || 0\n      };\n    }), t;\n  }\n  _initializeStats() {\n    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((n) => this._getOrCreate(n));\n  }\n  _getOrCreate(t) {\n    const {\n      name: n,\n      type: s\n    } = t;\n    let r = this.stats[n];\n    return r || (t instanceof Ar ? r = t : r = new Ar(n, s), this.stats[n] = r), r;\n  }\n}\nconst Oc = \"Queued Requests\", vc = \"Active Requests\", xc = \"Cancelled Requests\", Lc = \"Queued Requests Ever\", Gc = \"Active Requests Ever\", Uc = {\n  id: \"request-scheduler\",\n  throttleRequests: !0,\n  maxRequests: 6\n};\nclass Pc {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    this.props = void 0, this.stats = void 0, this.activeRequestCount = 0, this.requestQueue = [], this.requestMap = /* @__PURE__ */ new Map(), this.deferredUpdate = null, this.props = {\n      ...Uc,\n      ...t\n    }, this.stats = new no({\n      id: this.props.id\n    }), this.stats.get(Oc), this.stats.get(vc), this.stats.get(xc), this.stats.get(Lc), this.stats.get(Gc);\n  }\n  scheduleRequest(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => 0;\n    if (!this.props.throttleRequests)\n      return Promise.resolve({\n        done: () => {\n        }\n      });\n    if (this.requestMap.has(t))\n      return this.requestMap.get(t);\n    const s = {\n      handle: t,\n      priority: 0,\n      getPriority: n\n    }, r = new Promise((i) => (s.resolve = i, s));\n    return this.requestQueue.push(s), this.requestMap.set(t, r), this._issueNewRequests(), r;\n  }\n  _issueRequest(t) {\n    const {\n      handle: n,\n      resolve: s\n    } = t;\n    let r = !1;\n    const i = () => {\n      r || (r = !0, this.requestMap.delete(n), this.activeRequestCount--, this._issueNewRequests());\n    };\n    return this.activeRequestCount++, s ? s({\n      done: i\n    }) : Promise.resolve({\n      done: i\n    });\n  }\n  _issueNewRequests() {\n    this.deferredUpdate || (this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0));\n  }\n  _issueNewRequestsAsync() {\n    this.deferredUpdate = null;\n    const t = Math.max(this.props.maxRequests - this.activeRequestCount, 0);\n    if (t !== 0) {\n      this._updateAllRequests();\n      for (let n = 0; n < t; ++n) {\n        const s = this.requestQueue.shift();\n        s && this._issueRequest(s);\n      }\n    }\n  }\n  _updateAllRequests() {\n    const t = this.requestQueue;\n    for (let n = 0; n < t.length; ++n) {\n      const s = t[n];\n      this._updateRequest(s) || (t.splice(n, 1), this.requestMap.delete(s.handle), n--);\n    }\n    t.sort((n, s) => n.priority - s.priority);\n  }\n  _updateRequest(t) {\n    return t.priority = t.getPriority(t.handle), t.priority < 0 ? (t.resolve(null), !1) : !0;\n  }\n}\nlet Nc = \"\";\nconst gr = {};\nfunction Hc(e) {\n  for (const t in gr)\n    if (e.startsWith(t)) {\n      const n = gr[t];\n      e = e.replace(t, n);\n    }\n  return !e.startsWith(\"http://\") && !e.startsWith(\"https://\") && (e = `${Nc}${e}`), e;\n}\nfunction Jc(e) {\n  return e && typeof e == \"object\" && e.isBuffer;\n}\nfunction so(e) {\n  if (Jc(e))\n    return e;\n  if (e instanceof ArrayBuffer)\n    return e;\n  if (ArrayBuffer.isView(e))\n    return e.byteOffset === 0 && e.byteLength === e.buffer.byteLength ? e.buffer : e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);\n  if (typeof e == \"string\") {\n    const t = e;\n    return new TextEncoder().encode(t).buffer;\n  }\n  if (e && typeof e == \"object\" && e._toArrayBuffer)\n    return e._toArrayBuffer();\n  throw new Error(\"toArrayBuffer\");\n}\nfunction Vc() {\n  var e;\n  if (typeof process < \"u\" && typeof process.cwd < \"u\")\n    return process.cwd();\n  const t = (e = window.location) === null || e === void 0 ? void 0 : e.pathname;\n  return (t == null ? void 0 : t.slice(0, t.lastIndexOf(\"/\") + 1)) || \"\";\n}\nfunction ro(e) {\n  const t = e ? e.lastIndexOf(\"/\") : -1;\n  return t >= 0 ? e.substr(t + 1) : \"\";\n}\nfunction Os(e) {\n  const t = e ? e.lastIndexOf(\"/\") : -1;\n  return t >= 0 ? e.substr(0, t) : \"\";\n}\nfunction kc() {\n  const e = [];\n  for (let r = 0; r < arguments.length; r++)\n    e[r] = r < 0 || arguments.length <= r ? void 0 : arguments[r];\n  let t = \"\", n = !1, s;\n  for (let r = e.length - 1; r >= -1 && !n; r--) {\n    let i;\n    r >= 0 ? i = e[r] : (s === void 0 && (s = Vc()), i = s), i.length !== 0 && (t = `${i}/${t}`, n = i.charCodeAt(0) === pe);\n  }\n  return t = jc(t, !n), n ? `/${t}` : t.length > 0 ? t : \".\";\n}\nconst pe = 47, Gn = 46;\nfunction jc(e, t) {\n  let n = \"\", s = -1, r = 0, i, o = !1;\n  for (let a = 0; a <= e.length; ++a) {\n    if (a < e.length)\n      i = e.charCodeAt(a);\n    else {\n      if (i === pe)\n        break;\n      i = pe;\n    }\n    if (i === pe) {\n      if (!(s === a - 1 || r === 1))\n        if (s !== a - 1 && r === 2) {\n          if (n.length < 2 || !o || n.charCodeAt(n.length - 1) !== Gn || n.charCodeAt(n.length - 2) !== Gn) {\n            if (n.length > 2) {\n              const c = n.length - 1;\n              let u = c;\n              for (; u >= 0 && n.charCodeAt(u) !== pe; --u)\n                ;\n              if (u !== c) {\n                n = u === -1 ? \"\" : n.slice(0, u), s = a, r = 0, o = !1;\n                continue;\n              }\n            } else if (n.length === 2 || n.length === 1) {\n              n = \"\", s = a, r = 0, o = !1;\n              continue;\n            }\n          }\n          t && (n.length > 0 ? n += \"/..\" : n = \"..\", o = !0);\n        } else {\n          const c = e.slice(s + 1, a);\n          n.length > 0 ? n += `/${c}` : n = c, o = !1;\n        }\n      s = a, r = 0;\n    } else\n      i === Gn && r !== -1 ? ++r : r = -1;\n  }\n  return n;\n}\nconst Kc = (e) => typeof e == \"boolean\", ye = (e) => typeof e == \"function\", Se = (e) => e !== null && typeof e == \"object\", pr = (e) => Se(e) && e.constructor === {}.constructor, zc = (e) => !!e && typeof e[Symbol.iterator] == \"function\", Wc = (e) => e && typeof e[Symbol.asyncIterator] == \"function\", Xt = (e) => typeof Response < \"u\" && e instanceof Response || e && e.arrayBuffer && e.text && e.json, Qt = (e) => typeof Blob < \"u\" && e instanceof Blob, Xc = (e) => e && typeof e == \"object\" && e.isBuffer, Qc = (e) => typeof ReadableStream < \"u\" && e instanceof ReadableStream || Se(e) && ye(e.tee) && ye(e.cancel) && ye(e.getReader), qc = (e) => Se(e) && ye(e.read) && ye(e.pipe) && Kc(e.readable), io = (e) => Qc(e) || qc(e), Yc = /^data:([-\\w.]+\\/[-\\w.+]+)(;|,)/, $c = /^([-\\w.]+\\/[-\\w.+]+)/;\nfunction Zc(e) {\n  const t = $c.exec(e);\n  return t ? t[1] : e;\n}\nfunction Br(e) {\n  const t = Yc.exec(e);\n  return t ? t[1] : \"\";\n}\nconst oo = /\\?.*/;\nfunction tu(e) {\n  const t = e.match(oo);\n  return t && t[0];\n}\nfunction vs(e) {\n  return e.replace(oo, \"\");\n}\nfunction Tn(e) {\n  return Xt(e) ? e.url : Qt(e) ? e.name || \"\" : typeof e == \"string\" ? e : \"\";\n}\nfunction xs(e) {\n  if (Xt(e)) {\n    const t = e, n = t.headers.get(\"content-type\") || \"\", s = vs(t.url);\n    return Zc(n) || Br(s);\n  }\n  return Qt(e) ? e.type || \"\" : typeof e == \"string\" ? Br(e) : \"\";\n}\nfunction eu(e) {\n  return Xt(e) ? e.headers[\"content-length\"] || -1 : Qt(e) ? e.size : typeof e == \"string\" ? e.length : e instanceof ArrayBuffer || ArrayBuffer.isView(e) ? e.byteLength : -1;\n}\nasync function ao(e) {\n  if (Xt(e))\n    return e;\n  const t = {}, n = eu(e);\n  n >= 0 && (t[\"content-length\"] = String(n));\n  const s = Tn(e), r = xs(e);\n  r && (t[\"content-type\"] = r);\n  const i = await ru(e);\n  i && (t[\"x-first-bytes\"] = i), typeof e == \"string\" && (e = new TextEncoder().encode(e));\n  const o = new Response(e, {\n    headers: t\n  });\n  return Object.defineProperty(o, \"url\", {\n    value: s\n  }), o;\n}\nasync function nu(e) {\n  if (!e.ok) {\n    const t = await su(e);\n    throw new Error(t);\n  }\n}\nasync function su(e) {\n  let t = `Failed to fetch resource ${e.url} (${e.status}): `;\n  try {\n    const n = e.headers.get(\"Content-Type\");\n    let s = e.statusText;\n    n != null && n.includes(\"application/json\") && (s += ` ${await e.text()}`), t += s, t = t.length > 60 ? `${t.slice(0, 60)}...` : t;\n  } catch {\n  }\n  return t;\n}\nasync function ru(e) {\n  if (typeof e == \"string\")\n    return `data:,${e.slice(0, 5)}`;\n  if (e instanceof Blob) {\n    const n = e.slice(0, 5);\n    return await new Promise((s) => {\n      const r = new FileReader();\n      r.onload = (i) => {\n        var o;\n        return s(i == null || (o = i.target) === null || o === void 0 ? void 0 : o.result);\n      }, r.readAsDataURL(n);\n    });\n  }\n  if (e instanceof ArrayBuffer) {\n    const n = e.slice(0, 5);\n    return `data:base64,${iu(n)}`;\n  }\n  return null;\n}\nfunction iu(e) {\n  let t = \"\";\n  const n = new Uint8Array(e);\n  for (let s = 0; s < n.byteLength; s++)\n    t += String.fromCharCode(n[s]);\n  return btoa(t);\n}\nfunction ou(e) {\n  return !au(e) && !cu(e);\n}\nfunction au(e) {\n  return e.startsWith(\"http:\") || e.startsWith(\"https:\");\n}\nfunction cu(e) {\n  return e.startsWith(\"data:\");\n}\nasync function _e(e, t) {\n  if (typeof e == \"string\") {\n    const r = Hc(e);\n    if (ou(r)) {\n      var n;\n      if ((n = globalThis.loaders) !== null && n !== void 0 && n.fetchNode) {\n        var s;\n        return (s = globalThis.loaders) === null || s === void 0 ? void 0 : s.fetchNode(r, t);\n      }\n    }\n    return await fetch(r, t);\n  }\n  return await ao(e);\n}\nfunction uu(e) {\n  if (typeof window < \"u\" && typeof window.process == \"object\" && window.process.type === \"renderer\" || typeof process < \"u\" && typeof process.versions == \"object\" && process.versions.electron)\n    return !0;\n  const t = typeof navigator == \"object\" && typeof navigator.userAgent == \"string\" && navigator.userAgent, n = e || t;\n  return !!(n && n.indexOf(\"Electron\") >= 0);\n}\nfunction De() {\n  return !(typeof process == \"object\" && String(process) === \"[object process]\" && !process.browser) || uu();\n}\nconst Ue = globalThis.window || globalThis.self || globalThis.global, le = globalThis.process || {}, co = typeof __VERSION__ < \"u\" ? __VERSION__ : \"untranspiled source\";\nDe();\nfunction lu(e) {\n  try {\n    const t = window[e], n = \"__storage_test__\";\n    return t.setItem(n, n), t.removeItem(n), t;\n  } catch {\n    return null;\n  }\n}\nclass hu {\n  constructor(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"sessionStorage\";\n    this.storage = void 0, this.id = void 0, this.config = void 0, this.storage = lu(s), this.id = t, this.config = n, this._loadConfiguration();\n  }\n  getConfiguration() {\n    return this.config;\n  }\n  setConfiguration(t) {\n    if (Object.assign(this.config, t), this.storage) {\n      const n = JSON.stringify(this.config);\n      this.storage.setItem(this.id, n);\n    }\n  }\n  _loadConfiguration() {\n    let t = {};\n    if (this.storage) {\n      const n = this.storage.getItem(this.id);\n      t = n ? JSON.parse(n) : {};\n    }\n    return Object.assign(this.config, t), this;\n  }\n}\nfunction fu(e) {\n  let t;\n  return e < 10 ? t = \"\".concat(e.toFixed(2), \"ms\") : e < 100 ? t = \"\".concat(e.toFixed(1), \"ms\") : e < 1e3 ? t = \"\".concat(e.toFixed(0), \"ms\") : t = \"\".concat((e / 1e3).toFixed(2), \"s\"), t;\n}\nfunction du(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;\n  const n = Math.max(t - e.length, 0);\n  return \"\".concat(\" \".repeat(n)).concat(e);\n}\nfunction Un(e, t, n) {\n  let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;\n  const r = e.src.replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\");\n  e.width > s && (n = Math.min(n, s / e.width));\n  const i = e.width * n, o = e.height * n, a = [\"font-size:1px;\", \"padding:\".concat(Math.floor(o / 2), \"px \").concat(Math.floor(i / 2), \"px;\"), \"line-height:\".concat(o, \"px;\"), \"background:url(\".concat(r, \");\"), \"background-size:\".concat(i, \"px \").concat(o, \"px;\"), \"color:transparent;\"].join(\"\");\n  return [\"\".concat(t, \" %c+\"), a];\n}\nlet cn;\n(function(e) {\n  e[e.BLACK = 30] = \"BLACK\", e[e.RED = 31] = \"RED\", e[e.GREEN = 32] = \"GREEN\", e[e.YELLOW = 33] = \"YELLOW\", e[e.BLUE = 34] = \"BLUE\", e[e.MAGENTA = 35] = \"MAGENTA\", e[e.CYAN = 36] = \"CYAN\", e[e.WHITE = 37] = \"WHITE\", e[e.BRIGHT_BLACK = 90] = \"BRIGHT_BLACK\", e[e.BRIGHT_RED = 91] = \"BRIGHT_RED\", e[e.BRIGHT_GREEN = 92] = \"BRIGHT_GREEN\", e[e.BRIGHT_YELLOW = 93] = \"BRIGHT_YELLOW\", e[e.BRIGHT_BLUE = 94] = \"BRIGHT_BLUE\", e[e.BRIGHT_MAGENTA = 95] = \"BRIGHT_MAGENTA\", e[e.BRIGHT_CYAN = 96] = \"BRIGHT_CYAN\", e[e.BRIGHT_WHITE = 97] = \"BRIGHT_WHITE\";\n})(cn || (cn = {}));\nconst mu = 10;\nfunction yr(e) {\n  return typeof e != \"string\" ? e : (e = e.toUpperCase(), cn[e] || cn.WHITE);\n}\nfunction Au(e, t, n) {\n  if (!De && typeof e == \"string\") {\n    if (t) {\n      const s = yr(t);\n      e = \"\\x1B[\".concat(s, \"m\").concat(e, \"\\x1B[39m\");\n    }\n    if (n) {\n      const s = yr(n);\n      e = \"\\x1B[\".concat(s + mu, \"m\").concat(e, \"\\x1B[49m\");\n    }\n  }\n  return e;\n}\nfunction gu(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [\"constructor\"];\n  const n = Object.getPrototypeOf(e), s = Object.getOwnPropertyNames(n), r = e;\n  for (const i of s) {\n    const o = r[i];\n    typeof o == \"function\" && (t.find((a) => i === a) || (r[i] = o.bind(e)));\n  }\n}\nfunction un(e, t) {\n  if (!e)\n    throw new Error(t || \"Assertion failed\");\n}\nfunction Zt() {\n  let e;\n  if (De() && Ue.performance) {\n    var t, n;\n    e = Ue == null || (t = Ue.performance) === null || t === void 0 || (n = t.now) === null || n === void 0 ? void 0 : n.call(t);\n  } else if (\"hrtime\" in le) {\n    var s;\n    const r = le == null || (s = le.hrtime) === null || s === void 0 ? void 0 : s.call(le);\n    e = r[0] * 1e3 + r[1] / 1e6;\n  } else\n    e = Date.now();\n  return e;\n}\nconst te = {\n  debug: De() && console.debug || console.log,\n  log: console.log,\n  info: console.info,\n  warn: console.warn,\n  error: console.error\n}, pu = {\n  enabled: !0,\n  level: 0\n};\nfunction At() {\n}\nconst Cr = {}, Tr = {\n  once: !0\n};\nclass En {\n  constructor() {\n    let {\n      id: t\n    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {\n      id: \"\"\n    };\n    this.id = void 0, this.VERSION = co, this._startTs = Zt(), this._deltaTs = Zt(), this._storage = void 0, this.userData = {}, this.LOG_THROTTLE_TIMEOUT = 0, this.id = t, this.userData = {}, this._storage = new hu(\"__probe-\".concat(this.id, \"__\"), pu), this.timeStamp(\"\".concat(this.id, \" started\")), gu(this), Object.seal(this);\n  }\n  set level(t) {\n    this.setLevel(t);\n  }\n  get level() {\n    return this.getLevel();\n  }\n  isEnabled() {\n    return this._storage.config.enabled;\n  }\n  getLevel() {\n    return this._storage.config.level;\n  }\n  getTotal() {\n    return Number((Zt() - this._startTs).toPrecision(10));\n  }\n  getDelta() {\n    return Number((Zt() - this._deltaTs).toPrecision(10));\n  }\n  set priority(t) {\n    this.level = t;\n  }\n  get priority() {\n    return this.level;\n  }\n  getPriority() {\n    return this.level;\n  }\n  enable() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;\n    return this._storage.setConfiguration({\n      enabled: t\n    }), this;\n  }\n  setLevel(t) {\n    return this._storage.setConfiguration({\n      level: t\n    }), this;\n  }\n  get(t) {\n    return this._storage.config[t];\n  }\n  set(t, n) {\n    this._storage.setConfiguration({\n      [t]: n\n    });\n  }\n  settings() {\n    console.table ? console.table(this._storage.config) : console.log(this._storage.config);\n  }\n  assert(t, n) {\n    un(t, n);\n  }\n  warn(t) {\n    return this._getLogFunction(0, t, te.warn, arguments, Tr);\n  }\n  error(t) {\n    return this._getLogFunction(0, t, te.error, arguments);\n  }\n  deprecated(t, n) {\n    return this.warn(\"`\".concat(t, \"` is deprecated and will be removed in a later version. Use `\").concat(n, \"` instead\"));\n  }\n  removed(t, n) {\n    return this.error(\"`\".concat(t, \"` has been removed. Use `\").concat(n, \"` instead\"));\n  }\n  probe(t, n) {\n    return this._getLogFunction(t, n, te.log, arguments, {\n      time: !0,\n      once: !0\n    });\n  }\n  log(t, n) {\n    return this._getLogFunction(t, n, te.debug, arguments);\n  }\n  info(t, n) {\n    return this._getLogFunction(t, n, console.info, arguments);\n  }\n  once(t, n) {\n    return this._getLogFunction(t, n, te.debug || te.info, arguments, Tr);\n  }\n  table(t, n, s) {\n    return n ? this._getLogFunction(t, n, console.table || At, s && [s], {\n      tag: Tu(n)\n    }) : At;\n  }\n  image(t) {\n    let {\n      logLevel: n,\n      priority: s,\n      image: r,\n      message: i = \"\",\n      scale: o = 1\n    } = t;\n    return this._shouldLog(n || s) ? De() ? Cu({\n      image: r,\n      message: i,\n      scale: o\n    }) : yu() : At;\n  }\n  time(t, n) {\n    return this._getLogFunction(t, n, console.time ? console.time : console.info);\n  }\n  timeEnd(t, n) {\n    return this._getLogFunction(t, n, console.timeEnd ? console.timeEnd : console.info);\n  }\n  timeStamp(t, n) {\n    return this._getLogFunction(t, n, console.timeStamp || At);\n  }\n  group(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {\n      collapsed: !1\n    };\n    const r = Er({\n      logLevel: t,\n      message: n,\n      opts: s\n    }), {\n      collapsed: i\n    } = s;\n    return r.method = (i ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(r);\n  }\n  groupCollapsed(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return this.group(t, n, Object.assign({}, s, {\n      collapsed: !0\n    }));\n  }\n  groupEnd(t) {\n    return this._getLogFunction(t, \"\", console.groupEnd || At);\n  }\n  withGroup(t, n, s) {\n    this.group(t, n)();\n    try {\n      s();\n    } finally {\n      this.groupEnd(t)();\n    }\n  }\n  trace() {\n    console.trace && console.trace();\n  }\n  _shouldLog(t) {\n    return this.isEnabled() && this.getLevel() >= uo(t);\n  }\n  _getLogFunction(t, n, s, r, i) {\n    if (this._shouldLog(t)) {\n      i = Er({\n        logLevel: t,\n        message: n,\n        args: r,\n        opts: i\n      }), s = s || i.method, un(s), i.total = this.getTotal(), i.delta = this.getDelta(), this._deltaTs = Zt();\n      const o = i.tag || i.message;\n      if (i.once && o)\n        if (!Cr[o])\n          Cr[o] = Zt();\n        else\n          return At;\n      return n = Bu(this.id, i.message, i), s.bind(console, n, ...i.args);\n    }\n    return At;\n  }\n}\nEn.VERSION = co;\nfunction uo(e) {\n  if (!e)\n    return 0;\n  let t;\n  switch (typeof e) {\n    case \"number\":\n      t = e;\n      break;\n    case \"object\":\n      t = e.logLevel || e.priority || 0;\n      break;\n    default:\n      return 0;\n  }\n  return un(Number.isFinite(t) && t >= 0), t;\n}\nfunction Er(e) {\n  const {\n    logLevel: t,\n    message: n\n  } = e;\n  e.logLevel = uo(t);\n  const s = e.args ? Array.from(e.args) : [];\n  for (; s.length && s.shift() !== n; )\n    ;\n  switch (typeof t) {\n    case \"string\":\n    case \"function\":\n      n !== void 0 && s.unshift(n), e.message = t;\n      break;\n    case \"object\":\n      Object.assign(e, t);\n      break;\n  }\n  typeof e.message == \"function\" && (e.message = e.message());\n  const r = typeof e.message;\n  return un(r === \"string\" || r === \"object\"), Object.assign(e, {\n    args: s\n  }, e.opts);\n}\nfunction Bu(e, t, n) {\n  if (typeof t == \"string\") {\n    const s = n.time ? du(fu(n.total)) : \"\";\n    t = n.time ? \"\".concat(e, \": \").concat(s, \"  \").concat(t) : \"\".concat(e, \": \").concat(t), t = Au(t, n.color, n.background);\n  }\n  return t;\n}\nfunction yu(e) {\n  return console.warn(\"removed\"), At;\n}\nfunction Cu(e) {\n  let {\n    image: t,\n    message: n = \"\",\n    scale: s = 1\n  } = e;\n  if (typeof t == \"string\") {\n    const i = new Image();\n    return i.onload = () => {\n      const o = Un(i, n, s);\n      console.log(...o);\n    }, i.src = t, At;\n  }\n  const r = t.nodeName || \"\";\n  if (r.toLowerCase() === \"img\")\n    return console.log(...Un(t, n, s)), At;\n  if (r.toLowerCase() === \"canvas\") {\n    const i = new Image();\n    return i.onload = () => console.log(...Un(i, n, s)), i.src = t.toDataURL(), At;\n  }\n  return At;\n}\nfunction Tu(e) {\n  for (const t in e)\n    for (const n in e[t])\n      return n || \"untitled\";\n  return \"empty\";\n}\nconst lo = new En({\n  id: \"@probe.gl/log\"\n}), br = new En({\n  id: \"loaders.gl\"\n});\nclass Eu {\n  log() {\n    return () => {\n    };\n  }\n  info() {\n    return () => {\n    };\n  }\n  warn() {\n    return () => {\n    };\n  }\n  error() {\n    return () => {\n    };\n  }\n}\nclass bu {\n  constructor() {\n    this.console = void 0, this.console = console;\n  }\n  log() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++)\n      n[s] = arguments[s];\n    return this.console.log.bind(this.console, ...n);\n  }\n  info() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++)\n      n[s] = arguments[s];\n    return this.console.info.bind(this.console, ...n);\n  }\n  warn() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++)\n      n[s] = arguments[s];\n    return this.console.warn.bind(this.console, ...n);\n  }\n  error() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++)\n      n[s] = arguments[s];\n    return this.console.error.bind(this.console, ...n);\n  }\n}\nconst ho = {\n  fetch: null,\n  mimeType: void 0,\n  nothrow: !1,\n  log: new bu(),\n  useLocalLibraries: !1,\n  CDN: \"https://unpkg.com/@loaders.gl\",\n  worker: !0,\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  reuseWorkers: Cn,\n  _nodeWorkers: !1,\n  _workerType: \"\",\n  limit: 0,\n  _limitMB: 0,\n  batchSize: \"auto\",\n  batchDebounceMs: 0,\n  metadata: !1,\n  transforms: []\n}, _u = {\n  throws: \"nothrow\",\n  dataType: \"(no longer used)\",\n  uri: \"baseUri\",\n  method: \"fetch.method\",\n  headers: \"fetch.headers\",\n  body: \"fetch.body\",\n  mode: \"fetch.mode\",\n  credentials: \"fetch.credentials\",\n  cache: \"fetch.cache\",\n  redirect: \"fetch.redirect\",\n  referrer: \"fetch.referrer\",\n  referrerPolicy: \"fetch.referrerPolicy\",\n  integrity: \"fetch.integrity\",\n  keepalive: \"fetch.keepalive\",\n  signal: \"fetch.signal\"\n};\nfunction fo() {\n  globalThis.loaders = globalThis.loaders || {};\n  const {\n    loaders: e\n  } = globalThis;\n  return e._state = e._state || {}, e._state;\n}\nfunction mo() {\n  const e = fo();\n  return e.globalOptions = e.globalOptions || {\n    ...ho\n  }, e.globalOptions;\n}\nfunction wu(e, t, n, s) {\n  return n = n || [], n = Array.isArray(n) ? n : [n], Mu(e, n), Iu(t, e, s);\n}\nfunction Mu(e, t) {\n  _r(e, null, ho, _u, t);\n  for (const n of t) {\n    const s = e && e[n.id] || {}, r = n.options && n.options[n.id] || {}, i = n.deprecatedOptions && n.deprecatedOptions[n.id] || {};\n    _r(s, n.id, r, i, t);\n  }\n}\nfunction _r(e, t, n, s, r) {\n  const i = t || \"Top level\", o = t ? `${t}.` : \"\";\n  for (const a in e) {\n    const c = !t && Se(e[a]), u = a === \"baseUri\" && !t, l = a === \"workerUrl\" && t;\n    if (!(a in n) && !u && !l) {\n      if (a in s)\n        br.warn(`${i} loader option '${o}${a}' no longer supported, use '${s[a]}'`)();\n      else if (!c) {\n        const h = Ru(a, r);\n        br.warn(`${i} loader option '${o}${a}' not recognized. ${h}`)();\n      }\n    }\n  }\n}\nfunction Ru(e, t) {\n  const n = e.toLowerCase();\n  let s = \"\";\n  for (const r of t)\n    for (const i in r.options) {\n      if (e === i)\n        return `Did you mean '${r.id}.${i}'?`;\n      const o = i.toLowerCase();\n      (n.startsWith(o) || o.startsWith(n)) && (s = s || `Did you mean '${r.id}.${i}'?`);\n    }\n  return s;\n}\nfunction Iu(e, t, n) {\n  const r = {\n    ...e.options || {}\n  };\n  return Su(r, n), r.log === null && (r.log = new Eu()), wr(r, mo()), wr(r, t), r;\n}\nfunction wr(e, t) {\n  for (const n in t)\n    if (n in t) {\n      const s = t[n];\n      pr(s) && pr(e[n]) ? e[n] = {\n        ...e[n],\n        ...t[n]\n      } : e[n] = t[n];\n    }\n}\nfunction Su(e, t) {\n  t && !(\"baseUri\" in e) && (e.baseUri = t);\n}\nfunction Ls(e) {\n  var t;\n  return e ? (Array.isArray(e) && (e = e[0]), Array.isArray((t = e) === null || t === void 0 ? void 0 : t.extensions)) : !1;\n}\nfunction Ao(e) {\n  var t, n;\n  U(e, \"null loader\"), U(Ls(e), \"invalid loader\");\n  let s;\n  return Array.isArray(e) && (s = e[1], e = e[0], e = {\n    ...e,\n    options: {\n      ...e.options,\n      ...s\n    }\n  }), ((t = e) !== null && t !== void 0 && t.parseTextSync || (n = e) !== null && n !== void 0 && n.parseText) && (e.text = !0), e.text || (e.binary = !0), e;\n}\nconst Du = () => {\n  const e = fo();\n  return e.loaderRegistry = e.loaderRegistry || [], e.loaderRegistry;\n};\nfunction Fu() {\n  return Du();\n}\nconst Ou = new En({\n  id: \"loaders.gl\"\n}), vu = /\\.([^.]+)$/;\nasync function xu(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], n = arguments.length > 2 ? arguments[2] : void 0, s = arguments.length > 3 ? arguments[3] : void 0;\n  if (!go(e))\n    return null;\n  let r = Mr(e, t, {\n    ...n,\n    nothrow: !0\n  }, s);\n  if (r)\n    return r;\n  if (Qt(e) && (e = await e.slice(0, 10).arrayBuffer(), r = Mr(e, t, n, s)), !r && !(n != null && n.nothrow))\n    throw new Error(po(e));\n  return r;\n}\nfunction Mr(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], n = arguments.length > 2 ? arguments[2] : void 0, s = arguments.length > 3 ? arguments[3] : void 0;\n  if (!go(e))\n    return null;\n  if (t && !Array.isArray(t))\n    return Ao(t);\n  let r = [];\n  t && (r = r.concat(t)), n != null && n.ignoreRegisteredLoaders || r.push(...Fu()), Gu(r);\n  const i = Lu(e, r, n, s);\n  if (!i && !(n != null && n.nothrow))\n    throw new Error(po(e));\n  return i;\n}\nfunction Lu(e, t, n, s) {\n  const r = Tn(e), i = xs(e), o = vs(r) || (s == null ? void 0 : s.url);\n  let a = null, c = \"\";\n  if (n != null && n.mimeType && (a = Pn(t, n == null ? void 0 : n.mimeType), c = `match forced by supplied MIME type ${n == null ? void 0 : n.mimeType}`), a = a || Uu(t, o), c = c || (a ? `matched url ${o}` : \"\"), a = a || Pn(t, i), c = c || (a ? `matched MIME type ${i}` : \"\"), a = a || Nu(t, e), c = c || (a ? `matched initial data ${Bo(e)}` : \"\"), n != null && n.fallbackMimeType && (a = a || Pn(t, n == null ? void 0 : n.fallbackMimeType), c = c || (a ? `matched fallback MIME type ${i}` : \"\")), c) {\n    var u;\n    Ou.log(1, `selectLoader selected ${(u = a) === null || u === void 0 ? void 0 : u.name}: ${c}.`);\n  }\n  return a;\n}\nfunction go(e) {\n  return !(e instanceof Response && e.status === 204);\n}\nfunction po(e) {\n  const t = Tn(e), n = xs(e);\n  let s = \"No valid loader found (\";\n  s += t ? `${ro(t)}, ` : \"no url provided, \", s += `MIME type: ${n ? `\"${n}\"` : \"not provided\"}, `;\n  const r = e ? Bo(e) : \"\";\n  return s += r ? ` first bytes: \"${r}\"` : \"first bytes: not available\", s += \")\", s;\n}\nfunction Gu(e) {\n  for (const t of e)\n    Ao(t);\n}\nfunction Uu(e, t) {\n  const n = t && vu.exec(t), s = n && n[1];\n  return s ? Pu(e, s) : null;\n}\nfunction Pu(e, t) {\n  t = t.toLowerCase();\n  for (const n of e)\n    for (const s of n.extensions)\n      if (s.toLowerCase() === t)\n        return n;\n  return null;\n}\nfunction Pn(e, t) {\n  for (const n of e)\n    if (n.mimeTypes && n.mimeTypes.includes(t) || t === `application/x.${n.id}`)\n      return n;\n  return null;\n}\nfunction Nu(e, t) {\n  if (!t)\n    return null;\n  for (const n of e)\n    if (typeof t == \"string\") {\n      if (Hu(t, n))\n        return n;\n    } else if (ArrayBuffer.isView(t)) {\n      if (Rr(t.buffer, t.byteOffset, n))\n        return n;\n    } else if (t instanceof ArrayBuffer && Rr(t, 0, n))\n      return n;\n  return null;\n}\nfunction Hu(e, t) {\n  return t.testText ? t.testText(e) : (Array.isArray(t.tests) ? t.tests : [t.tests]).some((s) => e.startsWith(s));\n}\nfunction Rr(e, t, n) {\n  return (Array.isArray(n.tests) ? n.tests : [n.tests]).some((r) => Ju(e, t, n, r));\n}\nfunction Ju(e, t, n, s) {\n  if (s instanceof ArrayBuffer)\n    return Rc(s, e, s.byteLength);\n  switch (typeof s) {\n    case \"function\":\n      return s(e);\n    case \"string\":\n      const r = fs(e, t, s.length);\n      return s === r;\n    default:\n      return !1;\n  }\n}\nfunction Bo(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;\n  return typeof e == \"string\" ? e.slice(0, t) : ArrayBuffer.isView(e) ? fs(e.buffer, e.byteOffset, t) : e instanceof ArrayBuffer ? fs(e, 0, t) : \"\";\n}\nfunction fs(e, t, n) {\n  if (e.byteLength < t + n)\n    return \"\";\n  const s = new DataView(e);\n  let r = \"\";\n  for (let i = 0; i < n; i++)\n    r += String.fromCharCode(s.getUint8(t + i));\n  return r;\n}\nconst Vu = 256 * 1024;\nfunction* ku(e, t) {\n  const n = (t == null ? void 0 : t.chunkSize) || Vu;\n  let s = 0;\n  const r = new TextEncoder();\n  for (; s < e.length; ) {\n    const i = Math.min(e.length - s, n), o = e.slice(s, s + i);\n    s += i, yield r.encode(o);\n  }\n}\nconst ju = 256 * 1024;\nfunction Ku(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  return function* () {\n    const {\n      chunkSize: n = ju\n    } = t;\n    let s = 0;\n    for (; s < e.byteLength; ) {\n      const r = Math.min(e.byteLength - s, n), i = new ArrayBuffer(r), o = new Uint8Array(e, s, r);\n      new Uint8Array(i).set(o), s += r, yield i;\n    }\n  }();\n}\nconst zu = 1024 * 1024;\nasync function* Wu(e, t) {\n  const n = (t == null ? void 0 : t.chunkSize) || zu;\n  let s = 0;\n  for (; s < e.size; ) {\n    const r = s + n, i = await e.slice(s, r).arrayBuffer();\n    s = r, yield i;\n  }\n}\nfunction Ir(e, t) {\n  return Cn ? Xu(e, t) : Qu(e);\n}\nasync function* Xu(e, t) {\n  const n = e.getReader();\n  let s;\n  try {\n    for (; ; ) {\n      const r = s || n.read();\n      t != null && t._streamReadAhead && (s = n.read());\n      const {\n        done: i,\n        value: o\n      } = await r;\n      if (i)\n        return;\n      yield so(o);\n    }\n  } catch {\n    n.releaseLock();\n  }\n}\nasync function* Qu(e, t) {\n  for await (const n of e)\n    yield so(n);\n}\nfunction qu(e, t) {\n  if (typeof e == \"string\")\n    return ku(e, t);\n  if (e instanceof ArrayBuffer)\n    return Ku(e, t);\n  if (Qt(e))\n    return Wu(e, t);\n  if (io(e))\n    return Ir(e, t);\n  if (Xt(e))\n    return Ir(e.body, t);\n  throw new Error(\"makeIterator\");\n}\nconst yo = \"Cannot convert supplied data type\";\nfunction Yu(e, t, n) {\n  if (t.text && typeof e == \"string\")\n    return e;\n  if (Xc(e) && (e = e.buffer), e instanceof ArrayBuffer) {\n    const s = e;\n    return t.text && !t.binary ? new TextDecoder(\"utf8\").decode(s) : s;\n  }\n  if (ArrayBuffer.isView(e)) {\n    if (t.text && !t.binary)\n      return new TextDecoder(\"utf8\").decode(e);\n    let s = e.buffer;\n    const r = e.byteLength || e.length;\n    return (e.byteOffset !== 0 || r !== s.byteLength) && (s = s.slice(e.byteOffset, e.byteOffset + r)), s;\n  }\n  throw new Error(yo);\n}\nasync function $u(e, t, n) {\n  const s = e instanceof ArrayBuffer || ArrayBuffer.isView(e);\n  if (typeof e == \"string\" || s)\n    return Yu(e, t);\n  if (Qt(e) && (e = await ao(e)), Xt(e)) {\n    const r = e;\n    return await nu(r), t.binary ? await r.arrayBuffer() : await r.text();\n  }\n  if (io(e) && (e = qu(e, n)), zc(e) || Wc(e))\n    return Fc(e);\n  throw new Error(yo);\n}\nfunction Co(e, t) {\n  const n = mo(), s = e || n;\n  return typeof s.fetch == \"function\" ? s.fetch : Se(s.fetch) ? (r) => _e(r, s.fetch) : t != null && t.fetch ? t == null ? void 0 : t.fetch : _e;\n}\nfunction Zu(e, t, n) {\n  if (n)\n    return n;\n  const s = {\n    fetch: Co(t, e),\n    ...e\n  };\n  if (s.url) {\n    const r = vs(s.url);\n    s.baseUrl = r, s.queryString = tu(s.url), s.filename = ro(r), s.baseUrl = Os(r);\n  }\n  return Array.isArray(s.loaders) || (s.loaders = null), s;\n}\nfunction tl(e, t) {\n  if (e && !Array.isArray(e))\n    return e;\n  let n;\n  if (e && (n = Array.isArray(e) ? e : [e]), t && t.loaders) {\n    const s = Array.isArray(t.loaders) ? t.loaders : [t.loaders];\n    n = n ? [...n, ...s] : s;\n  }\n  return n && n.length ? n : void 0;\n}\nasync function ln(e, t, n, s) {\n  t && !Array.isArray(t) && !Ls(t) && (s = void 0, n = t, t = void 0), e = await e, n = n || {};\n  const r = Tn(e), o = tl(t, s), a = await xu(e, o, n);\n  return a ? (n = wu(n, a, o, r), s = Zu({\n    url: r,\n    _parse: ln,\n    loaders: o\n  }, n, s || null), await el(a, e, n, s)) : null;\n}\nasync function el(e, t, n, s) {\n  if (mc(e), n = sc(e.options, n), Xt(t)) {\n    const i = t, {\n      ok: o,\n      redirected: a,\n      status: c,\n      statusText: u,\n      type: l,\n      url: h\n    } = i, f = Object.fromEntries(i.headers.entries());\n    s.response = {\n      headers: f,\n      ok: o,\n      redirected: a,\n      status: c,\n      statusText: u,\n      type: l,\n      url: h\n    };\n  }\n  t = await $u(t, e, n);\n  const r = e;\n  if (r.parseTextSync && typeof t == \"string\")\n    return r.parseTextSync(t, n, s);\n  if (Ec(e, n))\n    return await bc(e, t, n, s, ln);\n  if (r.parseText && typeof t == \"string\")\n    return await r.parseText(t, n, s);\n  if (r.parse)\n    return await r.parse(t, n, s);\n  throw Lt(!r.parseSync), new Error(`${e.id} loader - no parser found and worker is disabled`);\n}\nfunction nl(e) {\n  switch (e.constructor) {\n    case Int8Array:\n      return \"int8\";\n    case Uint8Array:\n    case Uint8ClampedArray:\n      return \"uint8\";\n    case Int16Array:\n      return \"int16\";\n    case Uint16Array:\n      return \"uint16\";\n    case Int32Array:\n      return \"int32\";\n    case Uint32Array:\n      return \"uint32\";\n    case Float32Array:\n      return \"float32\";\n    case Float64Array:\n      return \"float64\";\n    default:\n      return \"null\";\n  }\n}\nfunction sl(e) {\n  let t = 1 / 0, n = 1 / 0, s = 1 / 0, r = -1 / 0, i = -1 / 0, o = -1 / 0;\n  const a = e.POSITION ? e.POSITION.value : [], c = a && a.length;\n  for (let u = 0; u < c; u += 3) {\n    const l = a[u], h = a[u + 1], f = a[u + 2];\n    t = l < t ? l : t, n = h < n ? h : n, s = f < s ? f : s, r = l > r ? l : r, i = h > i ? h : i, o = f > o ? f : o;\n  }\n  return [[t, n, s], [r, i, o]];\n}\nfunction rl(e, t, n) {\n  const s = nl(t.value), r = n || il(t);\n  return {\n    name: e,\n    type: {\n      type: \"fixed-size-list\",\n      listSize: t.size,\n      children: [{\n        name: \"value\",\n        type: s\n      }]\n    },\n    nullable: !1,\n    metadata: r\n  };\n}\nfunction il(e) {\n  const t = {};\n  return \"byteOffset\" in e && (t.byteOffset = e.byteOffset.toString(10)), \"byteStride\" in e && (t.byteStride = e.byteStride.toString(10)), \"normalized\" in e && (t.normalized = e.normalized.toString()), t;\n}\nasync function Fe(e, t, n, s) {\n  let r, i;\n  !Array.isArray(t) && !Ls(t) ? (r = [], i = t) : (r = t, i = n);\n  const o = Co(i);\n  let a = e;\n  return typeof e == \"string\" && (a = await o(e)), Qt(e) && (a = await o(e)), Array.isArray(r) ? await ln(a, r, i) : await ln(a, r, i);\n}\nconst ol = 1 / Math.PI * 180, al = 1 / 180 * Math.PI, cl = {\n  EPSILON: 1e-12,\n  debug: !1,\n  precision: 4,\n  printTypes: !1,\n  printDegrees: !1,\n  printRowMajor: !0,\n  _cartographicRadians: !1\n};\nglobalThis.mathgl = globalThis.mathgl || {\n  config: {\n    ...cl\n  }\n};\nconst Q = globalThis.mathgl.config;\nfunction ul(e, {\n  precision: t = Q.precision\n} = {}) {\n  return e = dl(e), \"\".concat(parseFloat(e.toPrecision(t)));\n}\nfunction Wt(e) {\n  return Array.isArray(e) || ArrayBuffer.isView(e) && !(e instanceof DataView);\n}\nfunction ds(e) {\n  return hl(e);\n}\nfunction ll(e) {\n  return Et(e);\n}\nfunction hl(e, t) {\n  return Gs(e, (n) => n * al, t);\n}\nfunction Et(e, t) {\n  return Gs(e, (n) => n * ol, t);\n}\nfunction fl(e, t, n) {\n  return Gs(e, (s) => Math.max(t, Math.min(n, s)));\n}\nfunction Nt(e, t, n) {\n  const s = Q.EPSILON;\n  n && (Q.EPSILON = n);\n  try {\n    if (e === t)\n      return !0;\n    if (Wt(e) && Wt(t)) {\n      if (e.length !== t.length)\n        return !1;\n      for (let r = 0; r < e.length; ++r)\n        if (!Nt(e[r], t[r]))\n          return !1;\n      return !0;\n    }\n    return e && e.equals ? e.equals(t) : t && t.equals ? t.equals(e) : typeof e == \"number\" && typeof t == \"number\" ? Math.abs(e - t) <= Q.EPSILON * Math.max(1, Math.abs(e), Math.abs(t)) : !1;\n  } finally {\n    Q.EPSILON = s;\n  }\n}\nfunction dl(e) {\n  return Math.round(e / Q.EPSILON) * Q.EPSILON;\n}\nfunction ml(e) {\n  return e.clone ? e.clone() : new Array(e.length);\n}\nfunction Gs(e, t, n) {\n  if (Wt(e)) {\n    const s = e;\n    n = n || ml(s);\n    for (let r = 0; r < n.length && r < s.length; ++r) {\n      const i = typeof e == \"number\" ? e : e[r];\n      n[r] = t(i, r, n);\n    }\n    return n;\n  }\n  return t(e);\n}\nfunction Al(e) {\n  function t() {\n    var n = Reflect.construct(e, Array.from(arguments));\n    return Object.setPrototypeOf(n, Object.getPrototypeOf(this)), n;\n  }\n  return t.prototype = Object.create(e.prototype, {\n    constructor: {\n      value: e,\n      enumerable: !1,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e, t;\n}\nclass Us extends Al(Array) {\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  fromArray(t, n = 0) {\n    for (let s = 0; s < this.ELEMENTS; ++s)\n      this[s] = t[s + n];\n    return this.check();\n  }\n  toArray(t = [], n = 0) {\n    for (let s = 0; s < this.ELEMENTS; ++s)\n      t[n + s] = this[s];\n    return t;\n  }\n  toObject(t) {\n    return t;\n  }\n  from(t) {\n    return Array.isArray(t) ? this.copy(t) : this.fromObject(t);\n  }\n  to(t) {\n    return t === this ? this : Wt(t) ? this.toArray(t) : this.toObject(t);\n  }\n  toTarget(t) {\n    return t ? this.to(t) : this;\n  }\n  toFloat32Array() {\n    return new Float32Array(this);\n  }\n  toString() {\n    return this.formatString(Q);\n  }\n  formatString(t) {\n    let n = \"\";\n    for (let s = 0; s < this.ELEMENTS; ++s)\n      n += (s > 0 ? \", \" : \"\") + ul(this[s], t);\n    return \"\".concat(t.printTypes ? this.constructor.name : \"\", \"[\").concat(n, \"]\");\n  }\n  equals(t) {\n    if (!t || this.length !== t.length)\n      return !1;\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      if (!Nt(this[n], t[n]))\n        return !1;\n    return !0;\n  }\n  exactEquals(t) {\n    if (!t || this.length !== t.length)\n      return !1;\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      if (this[n] !== t[n])\n        return !1;\n    return !0;\n  }\n  negate() {\n    for (let t = 0; t < this.ELEMENTS; ++t)\n      this[t] = -this[t];\n    return this.check();\n  }\n  lerp(t, n, s) {\n    if (s === void 0)\n      return this.lerp(this, t, n);\n    for (let r = 0; r < this.ELEMENTS; ++r) {\n      const i = t[r], o = typeof n == \"number\" ? n : n[r];\n      this[r] = i + s * (o - i);\n    }\n    return this.check();\n  }\n  min(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      this[n] = Math.min(t[n], this[n]);\n    return this.check();\n  }\n  max(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      this[n] = Math.max(t[n], this[n]);\n    return this.check();\n  }\n  clamp(t, n) {\n    for (let s = 0; s < this.ELEMENTS; ++s)\n      this[s] = Math.min(Math.max(this[s], t[s]), n[s]);\n    return this.check();\n  }\n  add(...t) {\n    for (const n of t)\n      for (let s = 0; s < this.ELEMENTS; ++s)\n        this[s] += n[s];\n    return this.check();\n  }\n  subtract(...t) {\n    for (const n of t)\n      for (let s = 0; s < this.ELEMENTS; ++s)\n        this[s] -= n[s];\n    return this.check();\n  }\n  scale(t) {\n    if (typeof t == \"number\")\n      for (let n = 0; n < this.ELEMENTS; ++n)\n        this[n] *= t;\n    else\n      for (let n = 0; n < this.ELEMENTS && n < t.length; ++n)\n        this[n] *= t[n];\n    return this.check();\n  }\n  multiplyByScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      this[n] *= t;\n    return this.check();\n  }\n  check() {\n    if (Q.debug && !this.validate())\n      throw new Error(\"math.gl: \".concat(this.constructor.name, \" some fields set to invalid numbers'\"));\n    return this;\n  }\n  validate() {\n    let t = this.length === this.ELEMENTS;\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      t = t && Number.isFinite(this[n]);\n    return t;\n  }\n  sub(t) {\n    return this.subtract(t);\n  }\n  setScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      this[n] = t;\n    return this.check();\n  }\n  addScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      this[n] += t;\n    return this.check();\n  }\n  subScalar(t) {\n    return this.addScalar(-t);\n  }\n  multiplyScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      this[n] *= t;\n    return this.check();\n  }\n  divideScalar(t) {\n    return this.multiplyByScalar(1 / t);\n  }\n  clampScalar(t, n) {\n    for (let s = 0; s < this.ELEMENTS; ++s)\n      this[s] = Math.min(Math.max(this[s], t), n);\n    return this.check();\n  }\n  get elements() {\n    return this;\n  }\n}\nfunction gl(e, t) {\n  if (e.length !== t)\n    return !1;\n  for (let n = 0; n < e.length; ++n)\n    if (!Number.isFinite(e[n]))\n      return !1;\n  return !0;\n}\nfunction G(e) {\n  if (!Number.isFinite(e))\n    throw new Error(\"Invalid number \".concat(JSON.stringify(e)));\n  return e;\n}\nfunction Ce(e, t, n = \"\") {\n  if (Q.debug && !gl(e, t))\n    throw new Error(\"math.gl: \".concat(n, \" some fields set to invalid numbers'\"));\n  return e;\n}\nfunction J(e, t) {\n  if (!e)\n    throw new Error(\"math.gl assertion \".concat(t));\n}\nclass Ps extends Us {\n  get x() {\n    return this[0];\n  }\n  set x(t) {\n    this[0] = G(t);\n  }\n  get y() {\n    return this[1];\n  }\n  set y(t) {\n    this[1] = G(t);\n  }\n  len() {\n    return Math.sqrt(this.lengthSquared());\n  }\n  magnitude() {\n    return this.len();\n  }\n  lengthSquared() {\n    let t = 0;\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      t += this[n] * this[n];\n    return t;\n  }\n  magnitudeSquared() {\n    return this.lengthSquared();\n  }\n  distance(t) {\n    return Math.sqrt(this.distanceSquared(t));\n  }\n  distanceSquared(t) {\n    let n = 0;\n    for (let s = 0; s < this.ELEMENTS; ++s) {\n      const r = this[s] - t[s];\n      n += r * r;\n    }\n    return G(n);\n  }\n  dot(t) {\n    let n = 0;\n    for (let s = 0; s < this.ELEMENTS; ++s)\n      n += this[s] * t[s];\n    return G(n);\n  }\n  normalize() {\n    const t = this.magnitude();\n    if (t !== 0)\n      for (let n = 0; n < this.ELEMENTS; ++n)\n        this[n] /= t;\n    return this.check();\n  }\n  multiply(...t) {\n    for (const n of t)\n      for (let s = 0; s < this.ELEMENTS; ++s)\n        this[s] *= n[s];\n    return this.check();\n  }\n  divide(...t) {\n    for (const n of t)\n      for (let s = 0; s < this.ELEMENTS; ++s)\n        this[s] /= n[s];\n    return this.check();\n  }\n  lengthSq() {\n    return this.lengthSquared();\n  }\n  distanceTo(t) {\n    return this.distance(t);\n  }\n  distanceToSquared(t) {\n    return this.distanceSquared(t);\n  }\n  getComponent(t) {\n    return J(t >= 0 && t < this.ELEMENTS, \"index is out of range\"), G(this[t]);\n  }\n  setComponent(t, n) {\n    return J(t >= 0 && t < this.ELEMENTS, \"index is out of range\"), this[t] = n, this.check();\n  }\n  addVectors(t, n) {\n    return this.copy(t).add(n);\n  }\n  subVectors(t, n) {\n    return this.copy(t).subtract(n);\n  }\n  multiplyVectors(t, n) {\n    return this.copy(t).multiply(n);\n  }\n  addScaledVector(t, n) {\n    return this.add(new this.constructor(t).multiplyScalar(n));\n  }\n}\nconst Te = 1e-6;\nlet _t = typeof Float32Array < \"u\" ? Float32Array : Array;\nfunction pl() {\n  const e = new _t(2);\n  return _t != Float32Array && (e[0] = 0, e[1] = 0), e;\n}\nfunction Bl(e, t, n) {\n  const s = t[0], r = t[1];\n  return e[0] = n[0] * s + n[2] * r, e[1] = n[1] * s + n[3] * r, e;\n}\nfunction yl(e, t, n) {\n  const s = t[0], r = t[1];\n  return e[0] = n[0] * s + n[2] * r + n[4], e[1] = n[1] * s + n[3] * r + n[5], e;\n}\nfunction To(e, t, n) {\n  const s = t[0], r = t[1];\n  return e[0] = n[0] * s + n[3] * r + n[6], e[1] = n[1] * s + n[4] * r + n[7], e;\n}\nfunction Eo(e, t, n) {\n  const s = t[0], r = t[1];\n  return e[0] = n[0] * s + n[4] * r + n[12], e[1] = n[1] * s + n[5] * r + n[13], e;\n}\n(function() {\n  const e = pl();\n  return function(t, n, s, r, i, o) {\n    let a, c;\n    for (n || (n = 2), s || (s = 0), r ? c = Math.min(r * n + s, t.length) : c = t.length, a = s; a < c; a += n)\n      e[0] = t[a], e[1] = t[a + 1], i(e, e, o), t[a] = e[0], t[a + 1] = e[1];\n    return t;\n  };\n})();\nfunction bo(e, t, n) {\n  const s = t[0], r = t[1], i = n[3] * s + n[7] * r || 1;\n  return e[0] = (n[0] * s + n[4] * r) / i, e[1] = (n[1] * s + n[5] * r) / i, e;\n}\nfunction _o(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = n[3] * s + n[7] * r + n[11] * i || 1;\n  return e[0] = (n[0] * s + n[4] * r + n[8] * i) / o, e[1] = (n[1] * s + n[5] * r + n[9] * i) / o, e[2] = (n[2] * s + n[6] * r + n[10] * i) / o, e;\n}\nfunction Cl(e, t, n) {\n  const s = t[0], r = t[1];\n  return e[0] = n[0] * s + n[2] * r, e[1] = n[1] * s + n[3] * r, e[2] = t[2], e;\n}\nfunction Tl(e, t, n) {\n  const s = t[0], r = t[1];\n  return e[0] = n[0] * s + n[2] * r, e[1] = n[1] * s + n[3] * r, e[2] = t[2], e[3] = t[3], e;\n}\nfunction wo(e, t, n) {\n  const s = t[0], r = t[1], i = t[2];\n  return e[0] = n[0] * s + n[3] * r + n[6] * i, e[1] = n[1] * s + n[4] * r + n[7] * i, e[2] = n[2] * s + n[5] * r + n[8] * i, e[3] = t[3], e;\n}\nclass bn extends Ps {\n  constructor(t = 0, n = 0) {\n    super(2), Wt(t) && arguments.length === 1 ? this.copy(t) : (Q.debug && (G(t), G(n)), this[0] = t, this[1] = n);\n  }\n  set(t, n) {\n    return this[0] = t, this[1] = n, this.check();\n  }\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this.check();\n  }\n  fromObject(t) {\n    return Q.debug && (G(t.x), G(t.y)), this[0] = t.x, this[1] = t.y, this.check();\n  }\n  toObject(t) {\n    return t.x = this[0], t.y = this[1], t;\n  }\n  get ELEMENTS() {\n    return 2;\n  }\n  horizontalAngle() {\n    return Math.atan2(this.y, this.x);\n  }\n  verticalAngle() {\n    return Math.atan2(this.x, this.y);\n  }\n  transform(t) {\n    return this.transformAsPoint(t);\n  }\n  transformAsPoint(t) {\n    return Eo(this, this, t), this.check();\n  }\n  transformAsVector(t) {\n    return bo(this, this, t), this.check();\n  }\n  transformByMatrix3(t) {\n    return To(this, this, t), this.check();\n  }\n  transformByMatrix2x3(t) {\n    return yl(this, this, t), this.check();\n  }\n  transformByMatrix2(t) {\n    return Bl(this, this, t), this.check();\n  }\n}\nfunction Mo() {\n  const e = new _t(3);\n  return _t != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e;\n}\nfunction Ro(e) {\n  const t = e[0], n = e[1], s = e[2];\n  return Math.sqrt(t * t + n * n + s * s);\n}\nfunction Sr(e, t, n) {\n  const s = new _t(3);\n  return s[0] = e, s[1] = t, s[2] = n, s;\n}\nfunction El(e, t) {\n  const n = t[0], s = t[1], r = t[2];\n  let i = n * n + s * s + r * r;\n  return i > 0 && (i = 1 / Math.sqrt(i)), e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i, e;\n}\nfunction Ns(e, t) {\n  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];\n}\nfunction nn(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = n[0], a = n[1], c = n[2];\n  return e[0] = r * c - i * a, e[1] = i * o - s * c, e[2] = s * a - r * o, e;\n}\nfunction Hs(e, t, n) {\n  const s = t[0], r = t[1], i = t[2];\n  let o = n[3] * s + n[7] * r + n[11] * i + n[15];\n  return o = o || 1, e[0] = (n[0] * s + n[4] * r + n[8] * i + n[12]) / o, e[1] = (n[1] * s + n[5] * r + n[9] * i + n[13]) / o, e[2] = (n[2] * s + n[6] * r + n[10] * i + n[14]) / o, e;\n}\nfunction Io(e, t, n) {\n  const s = t[0], r = t[1], i = t[2];\n  return e[0] = s * n[0] + r * n[3] + i * n[6], e[1] = s * n[1] + r * n[4] + i * n[7], e[2] = s * n[2] + r * n[5] + i * n[8], e;\n}\nfunction So(e, t, n) {\n  const s = n[0], r = n[1], i = n[2], o = n[3], a = t[0], c = t[1], u = t[2];\n  let l = r * u - i * c, h = i * a - s * u, f = s * c - r * a, d = r * f - i * h, A = i * l - s * f, g = s * h - r * l;\n  const p = o * 2;\n  return l *= p, h *= p, f *= p, d *= 2, A *= 2, g *= 2, e[0] = a + l + d, e[1] = c + h + A, e[2] = u + f + g, e;\n}\nfunction bl(e, t, n, s) {\n  const r = [], i = [];\n  return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], i[0] = r[0], i[1] = r[1] * Math.cos(s) - r[2] * Math.sin(s), i[2] = r[1] * Math.sin(s) + r[2] * Math.cos(s), e[0] = i[0] + n[0], e[1] = i[1] + n[1], e[2] = i[2] + n[2], e;\n}\nfunction _l(e, t, n, s) {\n  const r = [], i = [];\n  return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], i[0] = r[2] * Math.sin(s) + r[0] * Math.cos(s), i[1] = r[1], i[2] = r[2] * Math.cos(s) - r[0] * Math.sin(s), e[0] = i[0] + n[0], e[1] = i[1] + n[1], e[2] = i[2] + n[2], e;\n}\nfunction wl(e, t, n, s) {\n  const r = [], i = [];\n  return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], i[0] = r[0] * Math.cos(s) - r[1] * Math.sin(s), i[1] = r[0] * Math.sin(s) + r[1] * Math.cos(s), i[2] = r[2], e[0] = i[0] + n[0], e[1] = i[1] + n[1], e[2] = i[2] + n[2], e;\n}\nfunction Ml(e, t) {\n  const n = e[0], s = e[1], r = e[2], i = t[0], o = t[1], a = t[2], c = Math.sqrt((n * n + s * s + r * r) * (i * i + o * o + a * a)), u = c && Ns(e, t) / c;\n  return Math.acos(Math.min(Math.max(u, -1), 1));\n}\nconst Rl = Ro;\n(function() {\n  const e = Mo();\n  return function(t, n, s, r, i, o) {\n    let a, c;\n    for (n || (n = 3), s || (s = 0), r ? c = Math.min(r * n + s, t.length) : c = t.length, a = s; a < c; a += n)\n      e[0] = t[a], e[1] = t[a + 1], e[2] = t[a + 2], i(e, e, o), t[a] = e[0], t[a + 1] = e[1], t[a + 2] = e[2];\n    return t;\n  };\n})();\nconst Nn = [0, 0, 0];\nlet Pe;\nclass m extends Ps {\n  static get ZERO() {\n    return Pe || (Pe = new m(0, 0, 0), Object.freeze(Pe)), Pe;\n  }\n  constructor(t = 0, n = 0, s = 0) {\n    super(-0, -0, -0), arguments.length === 1 && Wt(t) ? this.copy(t) : (Q.debug && (G(t), G(n), G(s)), this[0] = t, this[1] = n, this[2] = s);\n  }\n  set(t, n, s) {\n    return this[0] = t, this[1] = n, this[2] = s, this.check();\n  }\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this.check();\n  }\n  fromObject(t) {\n    return Q.debug && (G(t.x), G(t.y), G(t.z)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this.check();\n  }\n  toObject(t) {\n    return t.x = this[0], t.y = this[1], t.z = this[2], t;\n  }\n  get ELEMENTS() {\n    return 3;\n  }\n  get z() {\n    return this[2];\n  }\n  set z(t) {\n    this[2] = G(t);\n  }\n  angle(t) {\n    return Ml(this, t);\n  }\n  cross(t) {\n    return nn(this, this, t), this.check();\n  }\n  rotateX({\n    radians: t,\n    origin: n = Nn\n  }) {\n    return bl(this, this, n, t), this.check();\n  }\n  rotateY({\n    radians: t,\n    origin: n = Nn\n  }) {\n    return _l(this, this, n, t), this.check();\n  }\n  rotateZ({\n    radians: t,\n    origin: n = Nn\n  }) {\n    return wl(this, this, n, t), this.check();\n  }\n  transform(t) {\n    return this.transformAsPoint(t);\n  }\n  transformAsPoint(t) {\n    return Hs(this, this, t), this.check();\n  }\n  transformAsVector(t) {\n    return _o(this, this, t), this.check();\n  }\n  transformByMatrix3(t) {\n    return Io(this, this, t), this.check();\n  }\n  transformByMatrix2(t) {\n    return Cl(this, this, t), this.check();\n  }\n  transformByQuaternion(t) {\n    return So(this, this, t), this.check();\n  }\n}\nlet Ne;\nclass Js extends Ps {\n  static get ZERO() {\n    return Ne || (Ne = new Js(0, 0, 0, 0), Object.freeze(Ne)), Ne;\n  }\n  constructor(t = 0, n = 0, s = 0, r = 0) {\n    super(-0, -0, -0, -0), Wt(t) && arguments.length === 1 ? this.copy(t) : (Q.debug && (G(t), G(n), G(s), G(r)), this[0] = t, this[1] = n, this[2] = s, this[3] = r);\n  }\n  set(t, n, s, r) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this.check();\n  }\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this.check();\n  }\n  fromObject(t) {\n    return Q.debug && (G(t.x), G(t.y), G(t.z), G(t.w)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this[3] = t.w, this;\n  }\n  toObject(t) {\n    return t.x = this[0], t.y = this[1], t.z = this[2], t.w = this[3], t;\n  }\n  get ELEMENTS() {\n    return 4;\n  }\n  get z() {\n    return this[2];\n  }\n  set z(t) {\n    this[2] = G(t);\n  }\n  get w() {\n    return this[3];\n  }\n  set w(t) {\n    this[3] = G(t);\n  }\n  transform(t) {\n    return Hs(this, this, t), this.check();\n  }\n  transformByMatrix3(t) {\n    return wo(this, this, t), this.check();\n  }\n  transformByMatrix2(t) {\n    return Tl(this, this, t), this.check();\n  }\n  transformByQuaternion(t) {\n    return So(this, this, t), this.check();\n  }\n  applyMatrix4(t) {\n    return t.transform(this, this), this;\n  }\n}\nclass Do extends Us {\n  toString() {\n    let t = \"[\";\n    if (Q.printRowMajor) {\n      t += \"row-major:\";\n      for (let n = 0; n < this.RANK; ++n)\n        for (let s = 0; s < this.RANK; ++s)\n          t += \" \".concat(this[s * this.RANK + n]);\n    } else {\n      t += \"column-major:\";\n      for (let n = 0; n < this.ELEMENTS; ++n)\n        t += \" \".concat(this[n]);\n    }\n    return t += \"]\", t;\n  }\n  getElementIndex(t, n) {\n    return n * this.RANK + t;\n  }\n  getElement(t, n) {\n    return this[n * this.RANK + t];\n  }\n  setElement(t, n, s) {\n    return this[n * this.RANK + t] = G(s), this;\n  }\n  getColumn(t, n = new Array(this.RANK).fill(-0)) {\n    const s = t * this.RANK;\n    for (let r = 0; r < this.RANK; ++r)\n      n[r] = this[s + r];\n    return n;\n  }\n  setColumn(t, n) {\n    const s = t * this.RANK;\n    for (let r = 0; r < this.RANK; ++r)\n      this[s + r] = n[r];\n    return this;\n  }\n}\nfunction Il() {\n  const e = new _t(9);\n  return _t != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[5] = 0, e[6] = 0, e[7] = 0), e[0] = 1, e[4] = 1, e[8] = 1, e;\n}\nfunction Sl(e, t) {\n  if (e === t) {\n    const n = t[1], s = t[2], r = t[5];\n    e[1] = t[3], e[2] = t[6], e[3] = n, e[5] = t[7], e[6] = s, e[7] = r;\n  } else\n    e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8];\n  return e;\n}\nfunction Dl(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[3], o = t[4], a = t[5], c = t[6], u = t[7], l = t[8], h = l * o - a * u, f = -l * i + a * c, d = u * i - o * c;\n  let A = n * h + s * f + r * d;\n  return A ? (A = 1 / A, e[0] = h * A, e[1] = (-l * s + r * u) * A, e[2] = (a * s - r * o) * A, e[3] = f * A, e[4] = (l * n - r * c) * A, e[5] = (-a * n + r * i) * A, e[6] = d * A, e[7] = (-u * n + s * c) * A, e[8] = (o * n - s * i) * A, e) : null;\n}\nfunction Fl(e) {\n  const t = e[0], n = e[1], s = e[2], r = e[3], i = e[4], o = e[5], a = e[6], c = e[7], u = e[8];\n  return t * (u * i - o * c) + n * (-u * r + o * a) + s * (c * r - i * a);\n}\nfunction Dr(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = t[4], c = t[5], u = t[6], l = t[7], h = t[8], f = n[0], d = n[1], A = n[2], g = n[3], p = n[4], y = n[5], _ = n[6], b = n[7], w = n[8];\n  return e[0] = f * s + d * o + A * u, e[1] = f * r + d * a + A * l, e[2] = f * i + d * c + A * h, e[3] = g * s + p * o + y * u, e[4] = g * r + p * a + y * l, e[5] = g * i + p * c + y * h, e[6] = _ * s + b * o + w * u, e[7] = _ * r + b * a + w * l, e[8] = _ * i + b * c + w * h, e;\n}\nfunction Ol(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = t[4], c = t[5], u = t[6], l = t[7], h = t[8], f = n[0], d = n[1];\n  return e[0] = s, e[1] = r, e[2] = i, e[3] = o, e[4] = a, e[5] = c, e[6] = f * s + d * o + u, e[7] = f * r + d * a + l, e[8] = f * i + d * c + h, e;\n}\nfunction vl(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = t[4], c = t[5], u = t[6], l = t[7], h = t[8], f = Math.sin(n), d = Math.cos(n);\n  return e[0] = d * s + f * o, e[1] = d * r + f * a, e[2] = d * i + f * c, e[3] = d * o - f * s, e[4] = d * a - f * r, e[5] = d * c - f * i, e[6] = u, e[7] = l, e[8] = h, e;\n}\nfunction Fr(e, t, n) {\n  const s = n[0], r = n[1];\n  return e[0] = s * t[0], e[1] = s * t[1], e[2] = s * t[2], e[3] = r * t[3], e[4] = r * t[4], e[5] = r * t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e;\n}\nfunction xl(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[3], o = n + n, a = s + s, c = r + r, u = n * o, l = s * o, h = s * a, f = r * o, d = r * a, A = r * c, g = i * o, p = i * a, y = i * c;\n  return e[0] = 1 - h - A, e[3] = l - y, e[6] = f + p, e[1] = l + y, e[4] = 1 - u - A, e[7] = d - g, e[2] = f - p, e[5] = d + g, e[8] = 1 - u - h, e;\n}\nvar ms;\n(function(e) {\n  e[e.COL0ROW0 = 0] = \"COL0ROW0\", e[e.COL0ROW1 = 1] = \"COL0ROW1\", e[e.COL0ROW2 = 2] = \"COL0ROW2\", e[e.COL1ROW0 = 3] = \"COL1ROW0\", e[e.COL1ROW1 = 4] = \"COL1ROW1\", e[e.COL1ROW2 = 5] = \"COL1ROW2\", e[e.COL2ROW0 = 6] = \"COL2ROW0\", e[e.COL2ROW1 = 7] = \"COL2ROW1\", e[e.COL2ROW2 = 8] = \"COL2ROW2\";\n})(ms || (ms = {}));\nconst Ll = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);\nclass j extends Do {\n  static get IDENTITY() {\n    return Ul();\n  }\n  static get ZERO() {\n    return Gl();\n  }\n  get ELEMENTS() {\n    return 9;\n  }\n  get RANK() {\n    return 3;\n  }\n  get INDICES() {\n    return ms;\n  }\n  constructor(t, ...n) {\n    super(-0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(t) ? this.copy(t) : n.length > 0 ? this.copy([t, ...n]) : this.identity();\n  }\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this[4] = t[4], this[5] = t[5], this[6] = t[6], this[7] = t[7], this[8] = t[8], this.check();\n  }\n  identity() {\n    return this.copy(Ll);\n  }\n  fromObject(t) {\n    return this.check();\n  }\n  fromQuaternion(t) {\n    return xl(this, t), this.check();\n  }\n  set(t, n, s, r, i, o, a, c, u) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this[4] = i, this[5] = o, this[6] = a, this[7] = c, this[8] = u, this.check();\n  }\n  setRowMajor(t, n, s, r, i, o, a, c, u) {\n    return this[0] = t, this[1] = r, this[2] = a, this[3] = n, this[4] = i, this[5] = c, this[6] = s, this[7] = o, this[8] = u, this.check();\n  }\n  determinant() {\n    return Fl(this);\n  }\n  transpose() {\n    return Sl(this, this), this.check();\n  }\n  invert() {\n    return Dl(this, this), this.check();\n  }\n  multiplyLeft(t) {\n    return Dr(this, t, this), this.check();\n  }\n  multiplyRight(t) {\n    return Dr(this, this, t), this.check();\n  }\n  rotate(t) {\n    return vl(this, this, t), this.check();\n  }\n  scale(t) {\n    return Array.isArray(t) ? Fr(this, this, t) : Fr(this, this, [t, t]), this.check();\n  }\n  translate(t) {\n    return Ol(this, this, t), this.check();\n  }\n  transform(t, n) {\n    let s;\n    switch (t.length) {\n      case 2:\n        s = To(n || [-0, -0], t, this);\n        break;\n      case 3:\n        s = Io(n || [-0, -0, -0], t, this);\n        break;\n      case 4:\n        s = wo(n || [-0, -0, -0, -0], t, this);\n        break;\n      default:\n        throw new Error(\"Illegal vector\");\n    }\n    return Ce(s, t.length), s;\n  }\n  transformVector(t, n) {\n    return this.transform(t, n);\n  }\n  transformVector2(t, n) {\n    return this.transform(t, n);\n  }\n  transformVector3(t, n) {\n    return this.transform(t, n);\n  }\n}\nlet He, Je = null;\nfunction Gl() {\n  return He || (He = new j([0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(He)), He;\n}\nfunction Ul() {\n  return Je || (Je = new j(), Object.freeze(Je)), Je;\n}\nfunction Pl(e) {\n  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;\n}\nfunction Nl(e, t) {\n  if (e === t) {\n    const n = t[1], s = t[2], r = t[3], i = t[6], o = t[7], a = t[11];\n    e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = n, e[6] = t[9], e[7] = t[13], e[8] = s, e[9] = i, e[11] = t[14], e[12] = r, e[13] = o, e[14] = a;\n  } else\n    e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];\n  return e;\n}\nfunction Hl(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[3], o = t[4], a = t[5], c = t[6], u = t[7], l = t[8], h = t[9], f = t[10], d = t[11], A = t[12], g = t[13], p = t[14], y = t[15], _ = n * a - s * o, b = n * c - r * o, w = n * u - i * o, M = s * c - r * a, C = s * u - i * a, D = r * u - i * c, F = l * g - h * A, I = l * p - f * A, S = l * y - d * A, V = h * p - f * g, K = h * y - d * g, k = f * y - d * p;\n  let O = _ * k - b * K + w * V + M * S - C * I + D * F;\n  return O ? (O = 1 / O, e[0] = (a * k - c * K + u * V) * O, e[1] = (r * K - s * k - i * V) * O, e[2] = (g * D - p * C + y * M) * O, e[3] = (f * C - h * D - d * M) * O, e[4] = (c * S - o * k - u * I) * O, e[5] = (n * k - r * S + i * I) * O, e[6] = (p * w - A * D - y * b) * O, e[7] = (l * D - f * w + d * b) * O, e[8] = (o * K - a * S + u * F) * O, e[9] = (s * S - n * K - i * F) * O, e[10] = (A * C - g * w + y * _) * O, e[11] = (h * w - l * C - d * _) * O, e[12] = (a * I - o * V - c * F) * O, e[13] = (n * V - s * I + r * F) * O, e[14] = (g * b - A * M - p * _) * O, e[15] = (l * M - h * b + f * _) * O, e) : null;\n}\nfunction Jl(e) {\n  const t = e[0], n = e[1], s = e[2], r = e[3], i = e[4], o = e[5], a = e[6], c = e[7], u = e[8], l = e[9], h = e[10], f = e[11], d = e[12], A = e[13], g = e[14], p = e[15], y = t * o - n * i, _ = t * a - s * i, b = n * a - s * o, w = u * A - l * d, M = u * g - h * d, C = l * g - h * A, D = t * C - n * M + s * w, F = i * C - o * M + a * w, I = u * b - l * _ + h * y, S = d * b - A * _ + g * y;\n  return c * D - r * F + p * I - f * S;\n}\nfunction Or(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = t[4], c = t[5], u = t[6], l = t[7], h = t[8], f = t[9], d = t[10], A = t[11], g = t[12], p = t[13], y = t[14], _ = t[15];\n  let b = n[0], w = n[1], M = n[2], C = n[3];\n  return e[0] = b * s + w * a + M * h + C * g, e[1] = b * r + w * c + M * f + C * p, e[2] = b * i + w * u + M * d + C * y, e[3] = b * o + w * l + M * A + C * _, b = n[4], w = n[5], M = n[6], C = n[7], e[4] = b * s + w * a + M * h + C * g, e[5] = b * r + w * c + M * f + C * p, e[6] = b * i + w * u + M * d + C * y, e[7] = b * o + w * l + M * A + C * _, b = n[8], w = n[9], M = n[10], C = n[11], e[8] = b * s + w * a + M * h + C * g, e[9] = b * r + w * c + M * f + C * p, e[10] = b * i + w * u + M * d + C * y, e[11] = b * o + w * l + M * A + C * _, b = n[12], w = n[13], M = n[14], C = n[15], e[12] = b * s + w * a + M * h + C * g, e[13] = b * r + w * c + M * f + C * p, e[14] = b * i + w * u + M * d + C * y, e[15] = b * o + w * l + M * A + C * _, e;\n}\nfunction Vl(e, t, n) {\n  const s = n[0], r = n[1], i = n[2];\n  let o, a, c, u, l, h, f, d, A, g, p, y;\n  return t === e ? (e[12] = t[0] * s + t[4] * r + t[8] * i + t[12], e[13] = t[1] * s + t[5] * r + t[9] * i + t[13], e[14] = t[2] * s + t[6] * r + t[10] * i + t[14], e[15] = t[3] * s + t[7] * r + t[11] * i + t[15]) : (o = t[0], a = t[1], c = t[2], u = t[3], l = t[4], h = t[5], f = t[6], d = t[7], A = t[8], g = t[9], p = t[10], y = t[11], e[0] = o, e[1] = a, e[2] = c, e[3] = u, e[4] = l, e[5] = h, e[6] = f, e[7] = d, e[8] = A, e[9] = g, e[10] = p, e[11] = y, e[12] = o * s + l * r + A * i + t[12], e[13] = a * s + h * r + g * i + t[13], e[14] = c * s + f * r + p * i + t[14], e[15] = u * s + d * r + y * i + t[15]), e;\n}\nfunction kl(e, t, n) {\n  const s = n[0], r = n[1], i = n[2];\n  return e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s, e[3] = t[3] * s, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * i, e[9] = t[9] * i, e[10] = t[10] * i, e[11] = t[11] * i, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;\n}\nfunction jl(e, t, n, s) {\n  let r = s[0], i = s[1], o = s[2], a = Math.sqrt(r * r + i * i + o * o), c, u, l, h, f, d, A, g, p, y, _, b, w, M, C, D, F, I, S, V, K, k, O, st;\n  return a < Te ? null : (a = 1 / a, r *= a, i *= a, o *= a, u = Math.sin(n), c = Math.cos(n), l = 1 - c, h = t[0], f = t[1], d = t[2], A = t[3], g = t[4], p = t[5], y = t[6], _ = t[7], b = t[8], w = t[9], M = t[10], C = t[11], D = r * r * l + c, F = i * r * l + o * u, I = o * r * l - i * u, S = r * i * l - o * u, V = i * i * l + c, K = o * i * l + r * u, k = r * o * l + i * u, O = i * o * l - r * u, st = o * o * l + c, e[0] = h * D + g * F + b * I, e[1] = f * D + p * F + w * I, e[2] = d * D + y * F + M * I, e[3] = A * D + _ * F + C * I, e[4] = h * S + g * V + b * K, e[5] = f * S + p * V + w * K, e[6] = d * S + y * V + M * K, e[7] = A * S + _ * V + C * K, e[8] = h * k + g * O + b * st, e[9] = f * k + p * O + w * st, e[10] = d * k + y * O + M * st, e[11] = A * k + _ * O + C * st, t !== e && (e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e);\n}\nfunction Kl(e, t, n) {\n  const s = Math.sin(n), r = Math.cos(n), i = t[4], o = t[5], a = t[6], c = t[7], u = t[8], l = t[9], h = t[10], f = t[11];\n  return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = i * r + u * s, e[5] = o * r + l * s, e[6] = a * r + h * s, e[7] = c * r + f * s, e[8] = u * r - i * s, e[9] = l * r - o * s, e[10] = h * r - a * s, e[11] = f * r - c * s, e;\n}\nfunction zl(e, t, n) {\n  const s = Math.sin(n), r = Math.cos(n), i = t[0], o = t[1], a = t[2], c = t[3], u = t[8], l = t[9], h = t[10], f = t[11];\n  return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = i * r - u * s, e[1] = o * r - l * s, e[2] = a * r - h * s, e[3] = c * r - f * s, e[8] = i * s + u * r, e[9] = o * s + l * r, e[10] = a * s + h * r, e[11] = c * s + f * r, e;\n}\nfunction Wl(e, t, n) {\n  const s = Math.sin(n), r = Math.cos(n), i = t[0], o = t[1], a = t[2], c = t[3], u = t[4], l = t[5], h = t[6], f = t[7];\n  return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = i * r + u * s, e[1] = o * r + l * s, e[2] = a * r + h * s, e[3] = c * r + f * s, e[4] = u * r - i * s, e[5] = l * r - o * s, e[6] = h * r - a * s, e[7] = f * r - c * s, e;\n}\nfunction Xl(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[4], o = t[5], a = t[6], c = t[8], u = t[9], l = t[10];\n  return e[0] = Math.sqrt(n * n + s * s + r * r), e[1] = Math.sqrt(i * i + o * o + a * a), e[2] = Math.sqrt(c * c + u * u + l * l), e;\n}\nfunction Ql(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[3], o = n + n, a = s + s, c = r + r, u = n * o, l = s * o, h = s * a, f = r * o, d = r * a, A = r * c, g = i * o, p = i * a, y = i * c;\n  return e[0] = 1 - h - A, e[1] = l + y, e[2] = f - p, e[3] = 0, e[4] = l - y, e[5] = 1 - u - A, e[6] = d + g, e[7] = 0, e[8] = f + p, e[9] = d - g, e[10] = 1 - u - h, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;\n}\nfunction ql(e, t, n, s, r, i, o) {\n  const a = 1 / (n - t), c = 1 / (r - s), u = 1 / (i - o);\n  return e[0] = i * 2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i * 2 * c, e[6] = 0, e[7] = 0, e[8] = (n + t) * a, e[9] = (r + s) * c, e[10] = (o + i) * u, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = o * i * 2 * u, e[15] = 0, e;\n}\nfunction Yl(e, t, n, s, r) {\n  const i = 1 / Math.tan(t / 2);\n  if (e[0] = i / n, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, r != null && r !== 1 / 0) {\n    const o = 1 / (s - r);\n    e[10] = (r + s) * o, e[14] = 2 * r * s * o;\n  } else\n    e[10] = -1, e[14] = -2 * s;\n  return e;\n}\nconst $l = Yl;\nfunction Zl(e, t, n, s, r, i, o) {\n  const a = 1 / (t - n), c = 1 / (s - r), u = 1 / (i - o);\n  return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * u, e[11] = 0, e[12] = (t + n) * a, e[13] = (r + s) * c, e[14] = (o + i) * u, e[15] = 1, e;\n}\nconst th = Zl;\nfunction eh(e, t, n, s) {\n  let r, i, o, a, c, u, l, h, f, d;\n  const A = t[0], g = t[1], p = t[2], y = s[0], _ = s[1], b = s[2], w = n[0], M = n[1], C = n[2];\n  return Math.abs(A - w) < Te && Math.abs(g - M) < Te && Math.abs(p - C) < Te ? Pl(e) : (h = A - w, f = g - M, d = p - C, r = 1 / Math.sqrt(h * h + f * f + d * d), h *= r, f *= r, d *= r, i = _ * d - b * f, o = b * h - y * d, a = y * f - _ * h, r = Math.sqrt(i * i + o * o + a * a), r ? (r = 1 / r, i *= r, o *= r, a *= r) : (i = 0, o = 0, a = 0), c = f * a - d * o, u = d * i - h * a, l = h * o - f * i, r = Math.sqrt(c * c + u * u + l * l), r ? (r = 1 / r, c *= r, u *= r, l *= r) : (c = 0, u = 0, l = 0), e[0] = i, e[1] = c, e[2] = h, e[3] = 0, e[4] = o, e[5] = u, e[6] = f, e[7] = 0, e[8] = a, e[9] = l, e[10] = d, e[11] = 0, e[12] = -(i * A + o * g + a * p), e[13] = -(c * A + u * g + l * p), e[14] = -(h * A + f * g + d * p), e[15] = 1, e);\n}\nfunction nh() {\n  const e = new _t(4);\n  return _t != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0), e;\n}\nfunction sh(e, t, n) {\n  return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e;\n}\nfunction rh(e, t, n) {\n  return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e;\n}\nfunction ih(e) {\n  const t = e[0], n = e[1], s = e[2], r = e[3];\n  return Math.sqrt(t * t + n * n + s * s + r * r);\n}\nfunction oh(e) {\n  const t = e[0], n = e[1], s = e[2], r = e[3];\n  return t * t + n * n + s * s + r * r;\n}\nfunction ah(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[3];\n  let o = n * n + s * s + r * r + i * i;\n  return o > 0 && (o = 1 / Math.sqrt(o)), e[0] = n * o, e[1] = s * o, e[2] = r * o, e[3] = i * o, e;\n}\nfunction ch(e, t) {\n  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];\n}\nfunction uh(e, t, n, s) {\n  const r = t[0], i = t[1], o = t[2], a = t[3];\n  return e[0] = r + s * (n[0] - r), e[1] = i + s * (n[1] - i), e[2] = o + s * (n[2] - o), e[3] = a + s * (n[3] - a), e;\n}\nfunction lh(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = t[3];\n  return e[0] = n[0] * s + n[4] * r + n[8] * i + n[12] * o, e[1] = n[1] * s + n[5] * r + n[9] * i + n[13] * o, e[2] = n[2] * s + n[6] * r + n[10] * i + n[14] * o, e[3] = n[3] * s + n[7] * r + n[11] * i + n[15] * o, e;\n}\nfunction hh(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = n[0], a = n[1], c = n[2], u = n[3], l = u * s + a * i - c * r, h = u * r + c * s - o * i, f = u * i + o * r - a * s, d = -o * s - a * r - c * i;\n  return e[0] = l * u + d * -o + h * -c - f * -a, e[1] = h * u + d * -a + f * -o - l * -c, e[2] = f * u + d * -c + l * -a - h * -o, e[3] = t[3], e;\n}\n(function() {\n  const e = nh();\n  return function(t, n, s, r, i, o) {\n    let a, c;\n    for (n || (n = 4), s || (s = 0), r ? c = Math.min(r * n + s, t.length) : c = t.length, a = s; a < c; a += n)\n      e[0] = t[a], e[1] = t[a + 1], e[2] = t[a + 2], e[3] = t[a + 3], i(e, e, o), t[a] = e[0], t[a + 1] = e[1], t[a + 2] = e[2], t[a + 3] = e[3];\n    return t;\n  };\n})();\nvar As;\n(function(e) {\n  e[e.COL0ROW0 = 0] = \"COL0ROW0\", e[e.COL0ROW1 = 1] = \"COL0ROW1\", e[e.COL0ROW2 = 2] = \"COL0ROW2\", e[e.COL0ROW3 = 3] = \"COL0ROW3\", e[e.COL1ROW0 = 4] = \"COL1ROW0\", e[e.COL1ROW1 = 5] = \"COL1ROW1\", e[e.COL1ROW2 = 6] = \"COL1ROW2\", e[e.COL1ROW3 = 7] = \"COL1ROW3\", e[e.COL2ROW0 = 8] = \"COL2ROW0\", e[e.COL2ROW1 = 9] = \"COL2ROW1\", e[e.COL2ROW2 = 10] = \"COL2ROW2\", e[e.COL2ROW3 = 11] = \"COL2ROW3\", e[e.COL3ROW0 = 12] = \"COL3ROW0\", e[e.COL3ROW1 = 13] = \"COL3ROW1\", e[e.COL3ROW2 = 14] = \"COL3ROW2\", e[e.COL3ROW3 = 15] = \"COL3ROW3\";\n})(As || (As = {}));\nconst fh = 45 * Math.PI / 180, dh = 1, Hn = 0.1, Jn = 500, mh = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\nclass N extends Do {\n  static get IDENTITY() {\n    return gh();\n  }\n  static get ZERO() {\n    return Ah();\n  }\n  get ELEMENTS() {\n    return 16;\n  }\n  get RANK() {\n    return 4;\n  }\n  get INDICES() {\n    return As;\n  }\n  constructor(t) {\n    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(t) ? this.copy(t) : this.identity();\n  }\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this[4] = t[4], this[5] = t[5], this[6] = t[6], this[7] = t[7], this[8] = t[8], this[9] = t[9], this[10] = t[10], this[11] = t[11], this[12] = t[12], this[13] = t[13], this[14] = t[14], this[15] = t[15], this.check();\n  }\n  set(t, n, s, r, i, o, a, c, u, l, h, f, d, A, g, p) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this[4] = i, this[5] = o, this[6] = a, this[7] = c, this[8] = u, this[9] = l, this[10] = h, this[11] = f, this[12] = d, this[13] = A, this[14] = g, this[15] = p, this.check();\n  }\n  setRowMajor(t, n, s, r, i, o, a, c, u, l, h, f, d, A, g, p) {\n    return this[0] = t, this[1] = i, this[2] = u, this[3] = d, this[4] = n, this[5] = o, this[6] = l, this[7] = A, this[8] = s, this[9] = a, this[10] = h, this[11] = g, this[12] = r, this[13] = c, this[14] = f, this[15] = p, this.check();\n  }\n  toRowMajor(t) {\n    return t[0] = this[0], t[1] = this[4], t[2] = this[8], t[3] = this[12], t[4] = this[1], t[5] = this[5], t[6] = this[9], t[7] = this[13], t[8] = this[2], t[9] = this[6], t[10] = this[10], t[11] = this[14], t[12] = this[3], t[13] = this[7], t[14] = this[11], t[15] = this[15], t;\n  }\n  identity() {\n    return this.copy(mh);\n  }\n  fromObject(t) {\n    return this.check();\n  }\n  fromQuaternion(t) {\n    return Ql(this, t), this.check();\n  }\n  frustum(t) {\n    const {\n      left: n,\n      right: s,\n      bottom: r,\n      top: i,\n      near: o = Hn,\n      far: a = Jn\n    } = t;\n    return a === 1 / 0 ? ph(this, n, s, r, i, o) : ql(this, n, s, r, i, o, a), this.check();\n  }\n  lookAt(t) {\n    const {\n      eye: n,\n      center: s = [0, 0, 0],\n      up: r = [0, 1, 0]\n    } = t;\n    return eh(this, n, s, r), this.check();\n  }\n  ortho(t) {\n    const {\n      left: n,\n      right: s,\n      bottom: r,\n      top: i,\n      near: o = Hn,\n      far: a = Jn\n    } = t;\n    return th(this, n, s, r, i, o, a), this.check();\n  }\n  orthographic(t) {\n    const {\n      fovy: n = fh,\n      aspect: s = dh,\n      focalDistance: r = 1,\n      near: i = Hn,\n      far: o = Jn\n    } = t;\n    vr(n);\n    const a = n / 2, c = r * Math.tan(a), u = c * s;\n    return this.ortho({\n      left: -u,\n      right: u,\n      bottom: -c,\n      top: c,\n      near: i,\n      far: o\n    });\n  }\n  perspective(t) {\n    const {\n      fovy: n = 45 * Math.PI / 180,\n      aspect: s = 1,\n      near: r = 0.1,\n      far: i = 500\n    } = t;\n    return vr(n), $l(this, n, s, r, i), this.check();\n  }\n  determinant() {\n    return Jl(this);\n  }\n  getScale(t = [-0, -0, -0]) {\n    return t[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), t[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), t[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), t;\n  }\n  getTranslation(t = [-0, -0, -0]) {\n    return t[0] = this[12], t[1] = this[13], t[2] = this[14], t;\n  }\n  getRotation(t, n) {\n    t = t || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], n = n || [-0, -0, -0];\n    const s = this.getScale(n), r = 1 / s[0], i = 1 / s[1], o = 1 / s[2];\n    return t[0] = this[0] * r, t[1] = this[1] * i, t[2] = this[2] * o, t[3] = 0, t[4] = this[4] * r, t[5] = this[5] * i, t[6] = this[6] * o, t[7] = 0, t[8] = this[8] * r, t[9] = this[9] * i, t[10] = this[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n  }\n  getRotationMatrix3(t, n) {\n    t = t || [-0, -0, -0, -0, -0, -0, -0, -0, -0], n = n || [-0, -0, -0];\n    const s = this.getScale(n), r = 1 / s[0], i = 1 / s[1], o = 1 / s[2];\n    return t[0] = this[0] * r, t[1] = this[1] * i, t[2] = this[2] * o, t[3] = this[4] * r, t[4] = this[5] * i, t[5] = this[6] * o, t[6] = this[8] * r, t[7] = this[9] * i, t[8] = this[10] * o, t;\n  }\n  transpose() {\n    return Nl(this, this), this.check();\n  }\n  invert() {\n    return Hl(this, this), this.check();\n  }\n  multiplyLeft(t) {\n    return Or(this, t, this), this.check();\n  }\n  multiplyRight(t) {\n    return Or(this, this, t), this.check();\n  }\n  rotateX(t) {\n    return Kl(this, this, t), this.check();\n  }\n  rotateY(t) {\n    return zl(this, this, t), this.check();\n  }\n  rotateZ(t) {\n    return Wl(this, this, t), this.check();\n  }\n  rotateXYZ(t) {\n    return this.rotateX(t[0]).rotateY(t[1]).rotateZ(t[2]);\n  }\n  rotateAxis(t, n) {\n    return jl(this, this, t, n), this.check();\n  }\n  scale(t) {\n    return kl(this, this, Array.isArray(t) ? t : [t, t, t]), this.check();\n  }\n  translate(t) {\n    return Vl(this, this, t), this.check();\n  }\n  transform(t, n) {\n    return t.length === 4 ? (n = lh(n || [-0, -0, -0, -0], t, this), Ce(n, 4), n) : this.transformAsPoint(t, n);\n  }\n  transformAsPoint(t, n) {\n    const {\n      length: s\n    } = t;\n    let r;\n    switch (s) {\n      case 2:\n        r = Eo(n || [-0, -0], t, this);\n        break;\n      case 3:\n        r = Hs(n || [-0, -0, -0], t, this);\n        break;\n      default:\n        throw new Error(\"Illegal vector\");\n    }\n    return Ce(r, t.length), r;\n  }\n  transformAsVector(t, n) {\n    let s;\n    switch (t.length) {\n      case 2:\n        s = bo(n || [-0, -0], t, this);\n        break;\n      case 3:\n        s = _o(n || [-0, -0, -0], t, this);\n        break;\n      default:\n        throw new Error(\"Illegal vector\");\n    }\n    return Ce(s, t.length), s;\n  }\n  transformPoint(t, n) {\n    return this.transformAsPoint(t, n);\n  }\n  transformVector(t, n) {\n    return this.transformAsPoint(t, n);\n  }\n  transformDirection(t, n) {\n    return this.transformAsVector(t, n);\n  }\n  makeRotationX(t) {\n    return this.identity().rotateX(t);\n  }\n  makeTranslation(t, n, s) {\n    return this.identity().translate([t, n, s]);\n  }\n}\nlet Ve, ke;\nfunction Ah() {\n  return Ve || (Ve = new N([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Ve)), Ve;\n}\nfunction gh() {\n  return ke || (ke = new N(), Object.freeze(ke)), ke;\n}\nfunction vr(e) {\n  if (e > Math.PI * 2)\n    throw Error(\"expected radians\");\n}\nfunction ph(e, t, n, s, r, i) {\n  const o = 2 * i / (n - t), a = 2 * i / (r - s), c = (n + t) / (n - t), u = (r + s) / (r - s), l = -1, h = -1, f = -2 * i;\n  return e[0] = o, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = a, e[6] = 0, e[7] = 0, e[8] = c, e[9] = u, e[10] = l, e[11] = h, e[12] = 0, e[13] = 0, e[14] = f, e[15] = 0, e;\n}\nfunction xr() {\n  const e = new _t(4);\n  return _t != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e[3] = 1, e;\n}\nfunction Bh(e) {\n  return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;\n}\nfunction Fo(e, t, n) {\n  n = n * 0.5;\n  const s = Math.sin(n);\n  return e[0] = s * t[0], e[1] = s * t[1], e[2] = s * t[2], e[3] = Math.cos(n), e;\n}\nfunction Lr(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = n[0], c = n[1], u = n[2], l = n[3];\n  return e[0] = s * l + o * a + r * u - i * c, e[1] = r * l + o * c + i * a - s * u, e[2] = i * l + o * u + s * c - r * a, e[3] = o * l - s * a - r * c - i * u, e;\n}\nfunction yh(e, t, n) {\n  n *= 0.5;\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = Math.sin(n), c = Math.cos(n);\n  return e[0] = s * c + o * a, e[1] = r * c + i * a, e[2] = i * c - r * a, e[3] = o * c - s * a, e;\n}\nfunction Ch(e, t, n) {\n  n *= 0.5;\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = Math.sin(n), c = Math.cos(n);\n  return e[0] = s * c - i * a, e[1] = r * c + o * a, e[2] = i * c + s * a, e[3] = o * c - r * a, e;\n}\nfunction Th(e, t, n) {\n  n *= 0.5;\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = Math.sin(n), c = Math.cos(n);\n  return e[0] = s * c + r * a, e[1] = r * c - s * a, e[2] = i * c + o * a, e[3] = o * c - i * a, e;\n}\nfunction Eh(e, t) {\n  const n = t[0], s = t[1], r = t[2];\n  return e[0] = n, e[1] = s, e[2] = r, e[3] = Math.sqrt(Math.abs(1 - n * n - s * s - r * r)), e;\n}\nfunction sn(e, t, n, s) {\n  const r = t[0], i = t[1], o = t[2], a = t[3];\n  let c = n[0], u = n[1], l = n[2], h = n[3], f, d, A, g, p;\n  return f = r * c + i * u + o * l + a * h, f < 0 && (f = -f, c = -c, u = -u, l = -l, h = -h), 1 - f > Te ? (d = Math.acos(f), p = Math.sin(d), A = Math.sin((1 - s) * d) / p, g = Math.sin(s * d) / p) : (A = 1 - s, g = s), e[0] = A * r + g * c, e[1] = A * i + g * u, e[2] = A * o + g * l, e[3] = A * a + g * h, e;\n}\nfunction bh(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[3], o = n * n + s * s + r * r + i * i, a = o ? 1 / o : 0;\n  return e[0] = -n * a, e[1] = -s * a, e[2] = -r * a, e[3] = i * a, e;\n}\nfunction _h(e, t) {\n  return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e;\n}\nfunction Oo(e, t) {\n  const n = t[0] + t[4] + t[8];\n  let s;\n  if (n > 0)\n    s = Math.sqrt(n + 1), e[3] = 0.5 * s, s = 0.5 / s, e[0] = (t[5] - t[7]) * s, e[1] = (t[6] - t[2]) * s, e[2] = (t[1] - t[3]) * s;\n  else {\n    let r = 0;\n    t[4] > t[0] && (r = 1), t[8] > t[r * 3 + r] && (r = 2);\n    const i = (r + 1) % 3, o = (r + 2) % 3;\n    s = Math.sqrt(t[r * 3 + r] - t[i * 3 + i] - t[o * 3 + o] + 1), e[r] = 0.5 * s, s = 0.5 / s, e[3] = (t[i * 3 + o] - t[o * 3 + i]) * s, e[i] = (t[i * 3 + r] + t[r * 3 + i]) * s, e[o] = (t[o * 3 + r] + t[r * 3 + o]) * s;\n  }\n  return e;\n}\nconst wh = sh, Mh = rh, Rh = ch, Ih = uh, Sh = ih, Dh = oh, vo = ah, Fh = function() {\n  const e = Mo(), t = Sr(1, 0, 0), n = Sr(0, 1, 0);\n  return function(s, r, i) {\n    const o = Ns(r, i);\n    return o < -0.999999 ? (nn(e, t, r), Rl(e) < 1e-6 && nn(e, n, r), El(e, e), Fo(s, e, Math.PI), s) : o > 0.999999 ? (s[0] = 0, s[1] = 0, s[2] = 0, s[3] = 1, s) : (nn(e, r, i), s[0] = e[0], s[1] = e[1], s[2] = e[2], s[3] = 1 + o, vo(s, s));\n  };\n}();\n(function() {\n  const e = xr(), t = xr();\n  return function(n, s, r, i, o, a) {\n    return sn(e, s, o, a), sn(t, r, i, a), sn(n, e, t, 2 * a * (1 - a)), n;\n  };\n})();\n(function() {\n  const e = Il();\n  return function(t, n, s, r) {\n    return e[0] = s[0], e[3] = s[1], e[6] = s[2], e[1] = r[0], e[4] = r[1], e[7] = r[2], e[2] = -n[0], e[5] = -n[1], e[8] = -n[2], vo(t, Oo(t, e));\n  };\n})();\nconst Oh = [0, 0, 0, 1];\nclass hn extends Us {\n  constructor(t = 0, n = 0, s = 0, r = 1) {\n    super(-0, -0, -0, -0), Array.isArray(t) && arguments.length === 1 ? this.copy(t) : this.set(t, n, s, r);\n  }\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this.check();\n  }\n  set(t, n, s, r) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this.check();\n  }\n  fromObject(t) {\n    return this[0] = t.x, this[1] = t.y, this[2] = t.z, this[3] = t.w, this.check();\n  }\n  fromMatrix3(t) {\n    return Oo(this, t), this.check();\n  }\n  fromAxisRotation(t, n) {\n    return Fo(this, t, n), this.check();\n  }\n  identity() {\n    return Bh(this), this.check();\n  }\n  setAxisAngle(t, n) {\n    return this.fromAxisRotation(t, n);\n  }\n  get ELEMENTS() {\n    return 4;\n  }\n  get x() {\n    return this[0];\n  }\n  set x(t) {\n    this[0] = G(t);\n  }\n  get y() {\n    return this[1];\n  }\n  set y(t) {\n    this[1] = G(t);\n  }\n  get z() {\n    return this[2];\n  }\n  set z(t) {\n    this[2] = G(t);\n  }\n  get w() {\n    return this[3];\n  }\n  set w(t) {\n    this[3] = G(t);\n  }\n  len() {\n    return Sh(this);\n  }\n  lengthSquared() {\n    return Dh(this);\n  }\n  dot(t) {\n    return Rh(this, t);\n  }\n  rotationTo(t, n) {\n    return Fh(this, t, n), this.check();\n  }\n  add(t) {\n    return wh(this, this, t), this.check();\n  }\n  calculateW() {\n    return Eh(this, this), this.check();\n  }\n  conjugate() {\n    return _h(this, this), this.check();\n  }\n  invert() {\n    return bh(this, this), this.check();\n  }\n  lerp(t, n, s) {\n    return s === void 0 ? this.lerp(this, t, n) : (Ih(this, t, n, s), this.check());\n  }\n  multiplyRight(t) {\n    return Lr(this, this, t), this.check();\n  }\n  multiplyLeft(t) {\n    return Lr(this, t, this), this.check();\n  }\n  normalize() {\n    const t = this.len(), n = t > 0 ? 1 / t : 0;\n    return this[0] = this[0] * n, this[1] = this[1] * n, this[2] = this[2] * n, this[3] = this[3] * n, t === 0 && (this[3] = 1), this.check();\n  }\n  rotateX(t) {\n    return yh(this, this, t), this.check();\n  }\n  rotateY(t) {\n    return Ch(this, this, t), this.check();\n  }\n  rotateZ(t) {\n    return Th(this, this, t), this.check();\n  }\n  scale(t) {\n    return Mh(this, this, t), this.check();\n  }\n  slerp(t, n, s) {\n    let r, i, o;\n    switch (arguments.length) {\n      case 1:\n        ({\n          start: r = Oh,\n          target: i,\n          ratio: o\n        } = t);\n        break;\n      case 2:\n        r = this, i = t, o = n;\n        break;\n      default:\n        r = t, i = n, o = s;\n    }\n    return sn(this, r, i, o), this.check();\n  }\n  transformVector4(t, n = new Js()) {\n    return hh(n, t, this), Ce(n, 4);\n  }\n  lengthSq() {\n    return this.lengthSquared();\n  }\n  setFromAxisAngle(t, n) {\n    return this.setAxisAngle(t, n);\n  }\n  premultiply(t) {\n    return this.multiplyLeft(t);\n  }\n  multiply(t) {\n    return this.multiplyRight(t);\n  }\n}\nfunction we(e) {\n  \"@babel/helpers - typeof\";\n  return we = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, we(e);\n}\nfunction vh(e, t) {\n  if (we(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var s = n.call(e, t || \"default\");\n    if (we(s) != \"object\")\n      return s;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction xh(e) {\n  var t = vh(e, \"string\");\n  return we(t) == \"symbol\" ? t : String(t);\n}\nfunction R(e, t, n) {\n  return t = xh(t), t in e ? Object.defineProperty(e, t, {\n    value: n,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[t] = n, e;\n}\nconst Lh = 0.1, Gh = 1e-12, xo = 1e-15, Uh = 1e-20, Ph = 6378137, Nh = 6378137, Hh = 6356752314245179e-9;\nfunction _n(e) {\n  return e;\n}\nnew m();\nfunction Jh(e, t = [], n = _n) {\n  return \"longitude\" in e ? (t[0] = n(e.longitude), t[1] = n(e.latitude), t[2] = e.height) : \"x\" in e ? (t[0] = n(e.x), t[1] = n(e.y), t[2] = e.z) : (t[0] = n(e[0]), t[1] = n(e[1]), t[2] = e[2]), t;\n}\nfunction Vh(e, t = []) {\n  return Jh(e, t, Q._cartographicRadians ? _n : ds);\n}\nfunction kh(e, t, n = _n) {\n  return \"longitude\" in t ? (t.longitude = n(e[0]), t.latitude = n(e[1]), t.height = e[2]) : \"x\" in t ? (t.x = n(e[0]), t.y = n(e[1]), t.z = e[2]) : (t[0] = n(e[0]), t[1] = n(e[1]), t[2] = e[2]), t;\n}\nfunction jh(e, t) {\n  return kh(e, t, Q._cartographicRadians ? _n : ll);\n}\nconst Gr = 1e-14, Kh = new m(), Ur = {\n  up: {\n    south: \"east\",\n    north: \"west\",\n    west: \"south\",\n    east: \"north\"\n  },\n  down: {\n    south: \"west\",\n    north: \"east\",\n    west: \"north\",\n    east: \"south\"\n  },\n  south: {\n    up: \"west\",\n    down: \"east\",\n    west: \"down\",\n    east: \"up\"\n  },\n  north: {\n    up: \"east\",\n    down: \"west\",\n    west: \"up\",\n    east: \"down\"\n  },\n  west: {\n    up: \"north\",\n    down: \"south\",\n    north: \"down\",\n    south: \"up\"\n  },\n  east: {\n    up: \"south\",\n    down: \"north\",\n    north: \"up\",\n    south: \"down\"\n  }\n}, Vn = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1]\n}, he = {\n  east: new m(),\n  north: new m(),\n  up: new m(),\n  west: new m(),\n  south: new m(),\n  down: new m()\n}, zh = new m(), Wh = new m(), Xh = new m();\nfunction Pr(e, t, n, s, r, i) {\n  const o = Ur[t] && Ur[t][n];\n  J(o && (!s || s === o));\n  let a, c, u;\n  const l = Kh.copy(r);\n  if (Nt(l.x, 0, Gr) && Nt(l.y, 0, Gr)) {\n    const f = Math.sign(l.z);\n    a = zh.fromArray(Vn[t]), t !== \"east\" && t !== \"west\" && a.scale(f), c = Wh.fromArray(Vn[n]), n !== \"east\" && n !== \"west\" && c.scale(f), u = Xh.fromArray(Vn[s]), s !== \"east\" && s !== \"west\" && u.scale(f);\n  } else {\n    const {\n      up: f,\n      east: d,\n      north: A\n    } = he;\n    d.set(-l.y, l.x, 0).normalize(), e.geodeticSurfaceNormal(l, f), A.copy(f).cross(d);\n    const {\n      down: g,\n      west: p,\n      south: y\n    } = he;\n    g.copy(f).scale(-1), p.copy(d).scale(-1), y.copy(A).scale(-1), a = he[t], c = he[n], u = he[s];\n  }\n  return i[0] = a.x, i[1] = a.y, i[2] = a.z, i[3] = 0, i[4] = c.x, i[5] = c.y, i[6] = c.z, i[7] = 0, i[8] = u.x, i[9] = u.y, i[10] = u.z, i[11] = 0, i[12] = l.x, i[13] = l.y, i[14] = l.z, i[15] = 1, i;\n}\nconst ee = new m(), Qh = new m(), qh = new m();\nfunction Yh(e, t, n = []) {\n  const {\n    oneOverRadii: s,\n    oneOverRadiiSquared: r,\n    centerToleranceSquared: i\n  } = t;\n  ee.from(e);\n  const o = ee.x, a = ee.y, c = ee.z, u = s.x, l = s.y, h = s.z, f = o * o * u * u, d = a * a * l * l, A = c * c * h * h, g = f + d + A, p = Math.sqrt(1 / g);\n  if (!Number.isFinite(p))\n    return;\n  const y = Qh;\n  if (y.copy(e).scale(p), g < i)\n    return y.to(n);\n  const _ = r.x, b = r.y, w = r.z, M = qh;\n  M.set(y.x * _ * 2, y.y * b * 2, y.z * w * 2);\n  let C = (1 - p) * ee.len() / (0.5 * M.len()), D = 0, F, I, S, V;\n  do {\n    C -= D, F = 1 / (1 + C * _), I = 1 / (1 + C * b), S = 1 / (1 + C * w);\n    const K = F * F, k = I * I, O = S * S, st = K * F, Yt = k * I, ue = O * S;\n    V = f * K + d * k + A * O - 1;\n    const ut = -2 * (f * st * _ + d * Yt * b + A * ue * w);\n    D = V / ut;\n  } while (Math.abs(V) > Gh);\n  return ee.scale([F, I, S]).to(n);\n}\nconst je = new m(), Nr = new m(), $h = new m(), Tt = new m(), Zh = new m(), Ke = new m();\nclass H {\n  constructor(t = 0, n = 0, s = 0) {\n    R(this, \"radii\", void 0), R(this, \"radiiSquared\", void 0), R(this, \"radiiToTheFourth\", void 0), R(this, \"oneOverRadii\", void 0), R(this, \"oneOverRadiiSquared\", void 0), R(this, \"minimumRadius\", void 0), R(this, \"maximumRadius\", void 0), R(this, \"centerToleranceSquared\", Lh), R(this, \"squaredXOverSquaredZ\", void 0), J(t >= 0), J(n >= 0), J(s >= 0), this.radii = new m(t, n, s), this.radiiSquared = new m(t * t, n * n, s * s), this.radiiToTheFourth = new m(t * t * t * t, n * n * n * n, s * s * s * s), this.oneOverRadii = new m(t === 0 ? 0 : 1 / t, n === 0 ? 0 : 1 / n, s === 0 ? 0 : 1 / s), this.oneOverRadiiSquared = new m(t === 0 ? 0 : 1 / (t * t), n === 0 ? 0 : 1 / (n * n), s === 0 ? 0 : 1 / (s * s)), this.minimumRadius = Math.min(t, n, s), this.maximumRadius = Math.max(t, n, s), this.radiiSquared.z !== 0 && (this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z), Object.freeze(this);\n  }\n  equals(t) {\n    return this === t || !!(t && this.radii.equals(t.radii));\n  }\n  toString() {\n    return this.radii.toString();\n  }\n  cartographicToCartesian(t, n = [0, 0, 0]) {\n    const s = Nr, r = $h, [, , i] = t;\n    this.geodeticSurfaceNormalCartographic(t, s), r.copy(this.radiiSquared).scale(s);\n    const o = Math.sqrt(s.dot(r));\n    return r.scale(1 / o), s.scale(i), r.add(s), r.to(n);\n  }\n  cartesianToCartographic(t, n = [0, 0, 0]) {\n    Ke.from(t);\n    const s = this.scaleToGeodeticSurface(Ke, Tt);\n    if (!s)\n      return;\n    const r = this.geodeticSurfaceNormal(s, Nr), i = Zh;\n    i.copy(Ke).subtract(s);\n    const o = Math.atan2(r.y, r.x), a = Math.asin(r.z), c = Math.sign(Ns(i, Ke)) * Ro(i);\n    return jh([o, a, c], n);\n  }\n  eastNorthUpToFixedFrame(t, n = new N()) {\n    return Pr(this, \"east\", \"north\", \"up\", t, n);\n  }\n  localFrameToFixedFrame(t, n, s, r, i = new N()) {\n    return Pr(this, t, n, s, r, i);\n  }\n  geocentricSurfaceNormal(t, n = [0, 0, 0]) {\n    return je.from(t).normalize().to(n);\n  }\n  geodeticSurfaceNormalCartographic(t, n = [0, 0, 0]) {\n    const s = Vh(t), r = s[0], i = s[1], o = Math.cos(i);\n    return je.set(o * Math.cos(r), o * Math.sin(r), Math.sin(i)).normalize(), je.to(n);\n  }\n  geodeticSurfaceNormal(t, n = [0, 0, 0]) {\n    return je.from(t).scale(this.oneOverRadiiSquared).normalize().to(n);\n  }\n  scaleToGeodeticSurface(t, n) {\n    return Yh(t, this, n);\n  }\n  scaleToGeocentricSurface(t, n = [0, 0, 0]) {\n    Tt.from(t);\n    const s = Tt.x, r = Tt.y, i = Tt.z, o = this.oneOverRadiiSquared, a = 1 / Math.sqrt(s * s * o.x + r * r * o.y + i * i * o.z);\n    return Tt.multiplyScalar(a).to(n);\n  }\n  transformPositionToScaledSpace(t, n = [0, 0, 0]) {\n    return Tt.from(t).scale(this.oneOverRadii).to(n);\n  }\n  transformPositionFromScaledSpace(t, n = [0, 0, 0]) {\n    return Tt.from(t).scale(this.radii).to(n);\n  }\n  getSurfaceNormalIntersectionWithZAxis(t, n = 0, s = [0, 0, 0]) {\n    J(Nt(this.radii.x, this.radii.y, xo)), J(this.radii.z > 0), Tt.from(t);\n    const r = Tt.z * (1 - this.squaredXOverSquaredZ);\n    if (!(Math.abs(r) >= this.radii.z - n))\n      return Tt.set(0, 0, r).to(s);\n  }\n}\nR(H, \"WGS84\", new H(Ph, Nh, Hh));\nclass tf {\n  constructor(t, n, s) {\n    this.item = void 0, this.previous = void 0, this.next = void 0, this.item = t, this.previous = n, this.next = s;\n  }\n}\nclass ef {\n  constructor() {\n    this.head = null, this.tail = null, this._length = 0;\n  }\n  get length() {\n    return this._length;\n  }\n  add(t) {\n    const n = new tf(t, this.tail, null);\n    return this.tail ? (this.tail.next = n, this.tail = n) : (this.head = n, this.tail = n), ++this._length, n;\n  }\n  remove(t) {\n    t && (t.previous && t.next ? (t.previous.next = t.next, t.next.previous = t.previous) : t.previous ? (t.previous.next = null, this.tail = t.previous) : t.next ? (t.next.previous = null, this.head = t.next) : (this.head = null, this.tail = null), t.next = null, t.previous = null, --this._length);\n  }\n  splice(t, n) {\n    t !== n && (this.remove(n), this._insert(t, n));\n  }\n  _insert(t, n) {\n    const s = t.next;\n    t.next = n, this.tail === t ? this.tail = n : s.previous = n, n.next = s, n.previous = t, ++this._length;\n  }\n}\nclass nf {\n  constructor() {\n    this._list = void 0, this._sentinel = void 0, this._trimTiles = void 0, this._list = new ef(), this._sentinel = this._list.add(\"sentinel\"), this._trimTiles = !1;\n  }\n  reset() {\n    this._list.splice(this._list.tail, this._sentinel);\n  }\n  touch(t) {\n    const n = t._cacheNode;\n    n && this._list.splice(this._sentinel, n);\n  }\n  add(t, n, s) {\n    n._cacheNode || (n._cacheNode = this._list.add(n), s && s(t, n));\n  }\n  unloadTile(t, n, s) {\n    const r = n._cacheNode;\n    r && (this._list.remove(r), n._cacheNode = null, s && s(t, n));\n  }\n  unloadTiles(t, n) {\n    const s = this._trimTiles;\n    this._trimTiles = !1;\n    const r = this._list, i = t.maximumMemoryUsage * 1024 * 1024, o = this._sentinel;\n    let a = r.head;\n    for (; a !== o && (t.gpuMemoryUsageInBytes > i || s); ) {\n      const c = a.item;\n      a = a.next, this.unloadTile(t, c, n);\n    }\n  }\n  trim() {\n    this._trimTiles = !0;\n  }\n}\nfunction sf(e, t) {\n  U(e), U(t);\n  const {\n    rtcCenter: n,\n    gltfUpAxis: s\n  } = t, {\n    computedTransform: r,\n    boundingVolume: {\n      center: i\n    }\n  } = e;\n  let o = new N(r);\n  switch (n && o.translate(n), s) {\n    case \"Z\":\n      break;\n    case \"Y\":\n      const h = new N().rotateX(Math.PI / 2);\n      o = o.multiplyRight(h);\n      break;\n    case \"X\":\n      const f = new N().rotateY(-Math.PI / 2);\n      o = o.multiplyRight(f);\n      break;\n  }\n  t.isQuantized && o.translate(t.quantizedVolumeOffset).scale(t.quantizedVolumeScale);\n  const a = new m(i);\n  t.cartesianModelMatrix = o, t.cartesianOrigin = a;\n  const c = H.WGS84.cartesianToCartographic(a, new m()), l = H.WGS84.eastNorthUpToFixedFrame(a).invert();\n  t.cartographicModelMatrix = l.multiplyRight(o), t.cartographicOrigin = c, t.coordinateSystem || (t.modelMatrix = t.cartographicModelMatrix);\n}\nconst ht = {\n  OUTSIDE: -1,\n  INTERSECTING: 0,\n  INSIDE: 1\n};\nnew m();\nnew m();\nconst fe = new m(), Hr = new m();\nclass Oe {\n  constructor(t = [0, 0, 0], n = 0) {\n    R(this, \"center\", void 0), R(this, \"radius\", void 0), this.radius = -0, this.center = new m(), this.fromCenterRadius(t, n);\n  }\n  fromCenterRadius(t, n) {\n    return this.center.from(t), this.radius = n, this;\n  }\n  fromCornerPoints(t, n) {\n    return n = fe.from(n), this.center = new m().from(t).add(n).scale(0.5), this.radius = this.center.distance(n), this;\n  }\n  equals(t) {\n    return this === t || !!t && this.center.equals(t.center) && this.radius === t.radius;\n  }\n  clone() {\n    return new Oe(this.center, this.radius);\n  }\n  union(t) {\n    const n = this.center, s = this.radius, r = t.center, i = t.radius, o = fe.copy(r).subtract(n), a = o.magnitude();\n    if (s >= a + i)\n      return this.clone();\n    if (i >= a + s)\n      return t.clone();\n    const c = (s + a + i) * 0.5;\n    return Hr.copy(o).scale((-s + c) / a).add(n), this.center.copy(Hr), this.radius = c, this;\n  }\n  expand(t) {\n    const s = fe.from(t).subtract(this.center).magnitude();\n    return s > this.radius && (this.radius = s), this;\n  }\n  transform(t) {\n    this.center.transform(t);\n    const n = Xl(fe, t);\n    return this.radius = Math.max(n[0], Math.max(n[1], n[2])) * this.radius, this;\n  }\n  distanceSquaredTo(t) {\n    const n = this.distanceTo(t);\n    return n * n;\n  }\n  distanceTo(t) {\n    const s = fe.from(t).subtract(this.center);\n    return Math.max(0, s.len() - this.radius);\n  }\n  intersectPlane(t) {\n    const n = this.center, s = this.radius, i = t.normal.dot(n) + t.distance;\n    return i < -s ? ht.OUTSIDE : i < s ? ht.INTERSECTING : ht.INSIDE;\n  }\n}\nconst rf = new m(), of = new m(), ze = new m(), We = new m(), Xe = new m(), af = new m(), cf = new m(), Ft = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\nclass ve {\n  constructor(t = [0, 0, 0], n = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {\n    R(this, \"center\", void 0), R(this, \"halfAxes\", void 0), this.center = new m().from(t), this.halfAxes = new j(n);\n  }\n  get halfSize() {\n    const t = this.halfAxes.getColumn(0), n = this.halfAxes.getColumn(1), s = this.halfAxes.getColumn(2);\n    return [new m(t).len(), new m(n).len(), new m(s).len()];\n  }\n  get quaternion() {\n    const t = this.halfAxes.getColumn(0), n = this.halfAxes.getColumn(1), s = this.halfAxes.getColumn(2), r = new m(t).normalize(), i = new m(n).normalize(), o = new m(s).normalize();\n    return new hn().fromMatrix3(new j([...r, ...i, ...o]));\n  }\n  fromCenterHalfSizeQuaternion(t, n, s) {\n    const r = new hn(s), i = new j().fromQuaternion(r);\n    return i[0] = i[0] * n[0], i[1] = i[1] * n[0], i[2] = i[2] * n[0], i[3] = i[3] * n[1], i[4] = i[4] * n[1], i[5] = i[5] * n[1], i[6] = i[6] * n[2], i[7] = i[7] * n[2], i[8] = i[8] * n[2], this.center = new m().from(t), this.halfAxes = i, this;\n  }\n  clone() {\n    return new ve(this.center, this.halfAxes);\n  }\n  equals(t) {\n    return this === t || !!t && this.center.equals(t.center) && this.halfAxes.equals(t.halfAxes);\n  }\n  getBoundingSphere(t = new Oe()) {\n    const n = this.halfAxes, s = n.getColumn(0, ze), r = n.getColumn(1, We), i = n.getColumn(2, Xe), o = rf.copy(s).add(r).add(i);\n    return t.center.copy(this.center), t.radius = o.magnitude(), t;\n  }\n  intersectPlane(t) {\n    const n = this.center, s = t.normal, r = this.halfAxes, i = s.x, o = s.y, a = s.z, c = Math.abs(i * r[Ft.COLUMN0ROW0] + o * r[Ft.COLUMN0ROW1] + a * r[Ft.COLUMN0ROW2]) + Math.abs(i * r[Ft.COLUMN1ROW0] + o * r[Ft.COLUMN1ROW1] + a * r[Ft.COLUMN1ROW2]) + Math.abs(i * r[Ft.COLUMN2ROW0] + o * r[Ft.COLUMN2ROW1] + a * r[Ft.COLUMN2ROW2]), u = s.dot(n) + t.distance;\n    return u <= -c ? ht.OUTSIDE : u >= c ? ht.INSIDE : ht.INTERSECTING;\n  }\n  distanceTo(t) {\n    return Math.sqrt(this.distanceSquaredTo(t));\n  }\n  distanceSquaredTo(t) {\n    const n = of.from(t).subtract(this.center), s = this.halfAxes, r = s.getColumn(0, ze), i = s.getColumn(1, We), o = s.getColumn(2, Xe), a = r.magnitude(), c = i.magnitude(), u = o.magnitude();\n    r.normalize(), i.normalize(), o.normalize();\n    let l = 0, h;\n    return h = Math.abs(n.dot(r)) - a, h > 0 && (l += h * h), h = Math.abs(n.dot(i)) - c, h > 0 && (l += h * h), h = Math.abs(n.dot(o)) - u, h > 0 && (l += h * h), l;\n  }\n  computePlaneDistances(t, n, s = [-0, -0]) {\n    let r = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;\n    const o = this.center, a = this.halfAxes, c = a.getColumn(0, ze), u = a.getColumn(1, We), l = a.getColumn(2, Xe), h = af.copy(c).add(u).add(l).add(o), f = cf.copy(h).subtract(t);\n    let d = n.dot(f);\n    return r = Math.min(d, r), i = Math.max(d, i), h.copy(o).add(c).add(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), h.copy(o).add(c).subtract(u).add(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), h.copy(o).add(c).subtract(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).add(u).add(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).add(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).subtract(u).add(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).subtract(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), s[0] = r, s[1] = i, s;\n  }\n  transform(t) {\n    this.center.transformAsPoint(t);\n    const n = this.halfAxes.getColumn(0, ze);\n    n.transformAsPoint(t);\n    const s = this.halfAxes.getColumn(1, We);\n    s.transformAsPoint(t);\n    const r = this.halfAxes.getColumn(2, Xe);\n    return r.transformAsPoint(t), this.halfAxes = new j([...n, ...s, ...r]), this;\n  }\n  getTransform() {\n    throw new Error(\"not implemented\");\n  }\n}\nconst Jr = new m(), Vr = new m();\nclass Y {\n  constructor(t = [0, 0, 1], n = 0) {\n    R(this, \"normal\", void 0), R(this, \"distance\", void 0), this.normal = new m(), this.distance = -0, this.fromNormalDistance(t, n);\n  }\n  fromNormalDistance(t, n) {\n    return J(Number.isFinite(n)), this.normal.from(t).normalize(), this.distance = n, this;\n  }\n  fromPointNormal(t, n) {\n    t = Jr.from(t), this.normal.from(n).normalize();\n    const s = -this.normal.dot(t);\n    return this.distance = s, this;\n  }\n  fromCoefficients(t, n, s, r) {\n    return this.normal.set(t, n, s), J(Nt(this.normal.len(), 1)), this.distance = r, this;\n  }\n  clone() {\n    return new Y(this.normal, this.distance);\n  }\n  equals(t) {\n    return Nt(this.distance, t.distance) && Nt(this.normal, t.normal);\n  }\n  getPointDistance(t) {\n    return this.normal.dot(t) + this.distance;\n  }\n  transform(t) {\n    const n = Vr.copy(this.normal).transformAsVector(t).normalize(), s = this.normal.scale(-this.distance).transform(t);\n    return this.fromPointNormal(s, n);\n  }\n  projectPointOntoPlane(t, n = [0, 0, 0]) {\n    const s = Jr.from(t), r = this.getPointDistance(s), i = Vr.copy(this.normal).scale(r);\n    return s.subtract(i).to(n);\n  }\n}\nconst kr = [new m([1, 0, 0]), new m([0, 1, 0]), new m([0, 0, 1])], jr = new m(), uf = new m();\nclass at {\n  constructor(t = []) {\n    R(this, \"planes\", void 0), this.planes = t;\n  }\n  fromBoundingSphere(t) {\n    this.planes.length = 2 * kr.length;\n    const n = t.center, s = t.radius;\n    let r = 0;\n    for (const i of kr) {\n      let o = this.planes[r], a = this.planes[r + 1];\n      o || (o = this.planes[r] = new Y()), a || (a = this.planes[r + 1] = new Y());\n      const c = jr.copy(i).scale(-s).add(n);\n      o.fromPointNormal(c, i);\n      const u = jr.copy(i).scale(s).add(n), l = uf.copy(i).negate();\n      a.fromPointNormal(u, l), r += 2;\n    }\n    return this;\n  }\n  computeVisibility(t) {\n    let n = ht.INSIDE;\n    for (const s of this.planes)\n      switch (t.intersectPlane(s)) {\n        case ht.OUTSIDE:\n          return ht.OUTSIDE;\n        case ht.INTERSECTING:\n          n = ht.INTERSECTING;\n          break;\n      }\n    return n;\n  }\n  computeVisibilityWithPlaneMask(t, n) {\n    if (J(Number.isFinite(n), \"parentPlaneMask is required.\"), n === at.MASK_OUTSIDE || n === at.MASK_INSIDE)\n      return n;\n    let s = at.MASK_INSIDE;\n    const r = this.planes;\n    for (let i = 0; i < this.planes.length; ++i) {\n      const o = i < 31 ? 1 << i : 0;\n      if (i < 31 && !(n & o))\n        continue;\n      const a = r[i], c = t.intersectPlane(a);\n      if (c === ht.OUTSIDE)\n        return at.MASK_OUTSIDE;\n      c === ht.INTERSECTING && (s |= o);\n    }\n    return s;\n  }\n}\nR(at, \"MASK_OUTSIDE\", 4294967295);\nR(at, \"MASK_INSIDE\", 0);\nR(at, \"MASK_INDETERMINATE\", 2147483647);\nconst lf = new m(), hf = new m(), ff = new m(), df = new m(), mf = new m();\nclass fn {\n  constructor(t = {}) {\n    R(this, \"left\", void 0), R(this, \"_left\", void 0), R(this, \"right\", void 0), R(this, \"_right\", void 0), R(this, \"top\", void 0), R(this, \"_top\", void 0), R(this, \"bottom\", void 0), R(this, \"_bottom\", void 0), R(this, \"near\", void 0), R(this, \"_near\", void 0), R(this, \"far\", void 0), R(this, \"_far\", void 0), R(this, \"_cullingVolume\", new at([new Y(), new Y(), new Y(), new Y(), new Y(), new Y()])), R(this, \"_perspectiveMatrix\", new N()), R(this, \"_infinitePerspective\", new N());\n    const {\n      near: n = 1,\n      far: s = 5e8\n    } = t;\n    this.left = t.left, this._left = void 0, this.right = t.right, this._right = void 0, this.top = t.top, this._top = void 0, this.bottom = t.bottom, this._bottom = void 0, this.near = n, this._near = n, this.far = s, this._far = s;\n  }\n  clone() {\n    return new fn({\n      right: this.right,\n      left: this.left,\n      top: this.top,\n      bottom: this.bottom,\n      near: this.near,\n      far: this.far\n    });\n  }\n  equals(t) {\n    return t && t instanceof fn && this.right === t.right && this.left === t.left && this.top === t.top && this.bottom === t.bottom && this.near === t.near && this.far === t.far;\n  }\n  get projectionMatrix() {\n    return this._update(), this._perspectiveMatrix;\n  }\n  get infiniteProjectionMatrix() {\n    return this._update(), this._infinitePerspective;\n  }\n  computeCullingVolume(t, n, s) {\n    J(t, \"position is required.\"), J(n, \"direction is required.\"), J(s, \"up is required.\");\n    const r = this._cullingVolume.planes;\n    s = lf.copy(s).normalize();\n    const i = hf.copy(n).cross(s).normalize(), o = ff.copy(n).multiplyByScalar(this.near).add(t), a = df.copy(n).multiplyByScalar(this.far).add(t);\n    let c = mf;\n    return c.copy(i).multiplyByScalar(this.left).add(o).subtract(t).cross(s), r[0].fromPointNormal(t, c), c.copy(i).multiplyByScalar(this.right).add(o).subtract(t).cross(s).negate(), r[1].fromPointNormal(t, c), c.copy(s).multiplyByScalar(this.bottom).add(o).subtract(t).cross(i).negate(), r[2].fromPointNormal(t, c), c.copy(s).multiplyByScalar(this.top).add(o).subtract(t).cross(i), r[3].fromPointNormal(t, c), c = new m().copy(n), r[4].fromPointNormal(o, c), c.negate(), r[5].fromPointNormal(a, c), this._cullingVolume;\n  }\n  getPixelDimensions(t, n, s, r) {\n    this._update(), J(Number.isFinite(t) && Number.isFinite(n)), J(t > 0), J(n > 0), J(s > 0), J(r);\n    const i = 1 / this.near;\n    let o = this.top * i;\n    const a = 2 * s * o / n;\n    o = this.right * i;\n    const c = 2 * s * o / t;\n    return r.x = c, r.y = a, r;\n  }\n  _update() {\n    J(Number.isFinite(this.right) && Number.isFinite(this.left) && Number.isFinite(this.top) && Number.isFinite(this.bottom) && Number.isFinite(this.near) && Number.isFinite(this.far));\n    const {\n      top: t,\n      bottom: n,\n      right: s,\n      left: r,\n      near: i,\n      far: o\n    } = this;\n    (t !== this._top || n !== this._bottom || r !== this._left || s !== this._right || i !== this._near || o !== this._far) && (J(this.near > 0 && this.near < this.far, \"near must be greater than zero and less than far.\"), this._left = r, this._right = s, this._top = t, this._bottom = n, this._near = i, this._far = o, this._perspectiveMatrix = new N().frustum({\n      left: r,\n      right: s,\n      bottom: n,\n      top: t,\n      near: i,\n      far: o\n    }), this._infinitePerspective = new N().frustum({\n      left: r,\n      right: s,\n      bottom: n,\n      top: t,\n      near: i,\n      far: 1 / 0\n    }));\n  }\n}\nconst Af = (e) => e !== null && typeof e < \"u\";\nclass dn {\n  constructor(t = {}) {\n    R(this, \"_offCenterFrustum\", new fn()), R(this, \"fov\", void 0), R(this, \"_fov\", void 0), R(this, \"_fovy\", void 0), R(this, \"_sseDenominator\", void 0), R(this, \"aspectRatio\", void 0), R(this, \"_aspectRatio\", void 0), R(this, \"near\", void 0), R(this, \"_near\", void 0), R(this, \"far\", void 0), R(this, \"_far\", void 0), R(this, \"xOffset\", void 0), R(this, \"_xOffset\", void 0), R(this, \"yOffset\", void 0), R(this, \"_yOffset\", void 0);\n    const {\n      fov: n,\n      aspectRatio: s,\n      near: r = 1,\n      far: i = 5e8,\n      xOffset: o = 0,\n      yOffset: a = 0\n    } = t;\n    this.fov = n, this.aspectRatio = s, this.near = r, this.far = i, this.xOffset = o, this.yOffset = a;\n  }\n  clone() {\n    return new dn({\n      aspectRatio: this.aspectRatio,\n      fov: this.fov,\n      near: this.near,\n      far: this.far\n    });\n  }\n  equals(t) {\n    return !Af(t) || !(t instanceof dn) ? !1 : (this._update(), t._update(), this.fov === t.fov && this.aspectRatio === t.aspectRatio && this.near === t.near && this.far === t.far && this._offCenterFrustum.equals(t._offCenterFrustum));\n  }\n  get projectionMatrix() {\n    return this._update(), this._offCenterFrustum.projectionMatrix;\n  }\n  get infiniteProjectionMatrix() {\n    return this._update(), this._offCenterFrustum.infiniteProjectionMatrix;\n  }\n  get fovy() {\n    return this._update(), this._fovy;\n  }\n  get sseDenominator() {\n    return this._update(), this._sseDenominator;\n  }\n  computeCullingVolume(t, n, s) {\n    return this._update(), this._offCenterFrustum.computeCullingVolume(t, n, s);\n  }\n  getPixelDimensions(t, n, s, r) {\n    return this._update(), this._offCenterFrustum.getPixelDimensions(t, n, s, r || new bn());\n  }\n  _update() {\n    J(Number.isFinite(this.fov) && Number.isFinite(this.aspectRatio) && Number.isFinite(this.near) && Number.isFinite(this.far));\n    const t = this._offCenterFrustum;\n    (this.fov !== this._fov || this.aspectRatio !== this._aspectRatio || this.near !== this._near || this.far !== this._far || this.xOffset !== this._xOffset || this.yOffset !== this._yOffset) && (J(this.fov >= 0 && this.fov < Math.PI), J(this.aspectRatio > 0), J(this.near >= 0 && this.near < this.far), this._aspectRatio = this.aspectRatio, this._fov = this.fov, this._fovy = this.aspectRatio <= 1 ? this.fov : Math.atan(Math.tan(this.fov * 0.5) / this.aspectRatio) * 2, this._near = this.near, this._far = this.far, this._sseDenominator = 2 * Math.tan(0.5 * this._fovy), this._xOffset = this.xOffset, this._yOffset = this.yOffset, t.top = this.near * Math.tan(0.5 * this._fovy), t.bottom = -t.top, t.right = this.aspectRatio * t.top, t.left = -t.right, t.near = this.near, t.far = this.far, t.right += this.xOffset, t.left += this.xOffset, t.top += this.yOffset, t.bottom += this.yOffset);\n  }\n}\nnew m();\nnew m();\nnew m();\nnew m();\nnew m();\nnew m();\nnew m();\nnew m();\nnew m();\nnew m();\nnew m();\nnew m();\nconst Mt = new j(), gf = new j(), pf = new j(), Qe = new j(), Kr = new j();\nfunction Bf(e, t = {}) {\n  const n = Uh, s = 10;\n  let r = 0, i = 0;\n  const o = gf, a = pf;\n  o.identity(), a.copy(e);\n  const c = n * yf(a);\n  for (; i < s && Cf(a) > c; )\n    Tf(a, Qe), Kr.copy(Qe).transpose(), a.multiplyRight(Qe), a.multiplyLeft(Kr), o.multiplyRight(Qe), ++r > 2 && (++i, r = 0);\n  return t.unitary = o.toTarget(t.unitary), t.diagonal = a.toTarget(t.diagonal), t;\n}\nfunction yf(e) {\n  let t = 0;\n  for (let n = 0; n < 9; ++n) {\n    const s = e[n];\n    t += s * s;\n  }\n  return Math.sqrt(t);\n}\nconst gs = [1, 0, 0], ps = [2, 2, 1];\nfunction Cf(e) {\n  let t = 0;\n  for (let n = 0; n < 3; ++n) {\n    const s = e[Mt.getElementIndex(ps[n], gs[n])];\n    t += 2 * s * s;\n  }\n  return Math.sqrt(t);\n}\nfunction Tf(e, t) {\n  const n = xo;\n  let s = 0, r = 1;\n  for (let u = 0; u < 3; ++u) {\n    const l = Math.abs(e[Mt.getElementIndex(ps[u], gs[u])]);\n    l > s && (r = u, s = l);\n  }\n  const i = gs[r], o = ps[r];\n  let a = 1, c = 0;\n  if (Math.abs(e[Mt.getElementIndex(o, i)]) > n) {\n    const u = e[Mt.getElementIndex(o, o)], l = e[Mt.getElementIndex(i, i)], h = e[Mt.getElementIndex(o, i)], f = (u - l) / 2 / h;\n    let d;\n    f < 0 ? d = -1 / (-f + Math.sqrt(1 + f * f)) : d = 1 / (f + Math.sqrt(1 + f * f)), a = 1 / Math.sqrt(1 + d * d), c = d * a;\n  }\n  return j.IDENTITY.to(t), t[Mt.getElementIndex(i, i)] = t[Mt.getElementIndex(o, o)] = a, t[Mt.getElementIndex(o, i)] = c, t[Mt.getElementIndex(i, o)] = -c, t;\n}\nconst Ut = new m(), Ef = new m(), bf = new m(), _f = new m(), wf = new m(), Mf = new j(), Rf = {\n  diagonal: new j(),\n  unitary: new j()\n};\nfunction If(e, t = new ve()) {\n  if (!e || e.length === 0)\n    return t.halfAxes = new j([0, 0, 0, 0, 0, 0, 0, 0, 0]), t.center = new m(), t;\n  const n = e.length, s = new m(0, 0, 0);\n  for (const I of e)\n    s.add(I);\n  const r = 1 / n;\n  s.multiplyByScalar(r);\n  let i = 0, o = 0, a = 0, c = 0, u = 0, l = 0;\n  for (const I of e) {\n    const S = Ut.copy(I).subtract(s);\n    i += S.x * S.x, o += S.x * S.y, a += S.x * S.z, c += S.y * S.y, u += S.y * S.z, l += S.z * S.z;\n  }\n  i *= r, o *= r, a *= r, c *= r, u *= r, l *= r;\n  const h = Mf;\n  h[0] = i, h[1] = o, h[2] = a, h[3] = o, h[4] = c, h[5] = u, h[6] = a, h[7] = u, h[8] = l;\n  const {\n    unitary: f\n  } = Bf(h, Rf), d = t.halfAxes.copy(f);\n  let A = d.getColumn(0, bf), g = d.getColumn(1, _f), p = d.getColumn(2, wf), y = -Number.MAX_VALUE, _ = -Number.MAX_VALUE, b = -Number.MAX_VALUE, w = Number.MAX_VALUE, M = Number.MAX_VALUE, C = Number.MAX_VALUE;\n  for (const I of e)\n    Ut.copy(I), y = Math.max(Ut.dot(A), y), _ = Math.max(Ut.dot(g), _), b = Math.max(Ut.dot(p), b), w = Math.min(Ut.dot(A), w), M = Math.min(Ut.dot(g), M), C = Math.min(Ut.dot(p), C);\n  A = A.multiplyByScalar(0.5 * (w + y)), g = g.multiplyByScalar(0.5 * (M + _)), p = p.multiplyByScalar(0.5 * (C + b)), t.center.copy(A).add(g).add(p);\n  const D = Ef.set(y - w, _ - M, b - C).multiplyByScalar(0.5), F = new j([D[0], 0, 0, 0, D[1], 0, 0, 0, D[2]]);\n  return t.halfAxes.multiplyRight(F), t;\n}\nconst zr = new m(), kn = new m(), Bs = new at([new Y(), new Y(), new Y(), new Y(), new Y(), new Y()]);\nfunction Sf(e, t) {\n  const {\n    cameraDirection: n,\n    cameraUp: s,\n    height: r\n  } = e, {\n    metersPerUnit: i\n  } = e.distanceScales, o = rn(e, e.center), a = H.WGS84.eastNorthUpToFixedFrame(o), c = e.unprojectPosition(e.cameraPosition), u = H.WGS84.cartographicToCartesian(c, new m()), l = new m(a.transformAsVector(new m(n).scale(i))).normalize(), h = new m(a.transformAsVector(new m(s).scale(i))).normalize();\n  Ff(e);\n  const f = e.constructor, {\n    longitude: d,\n    latitude: A,\n    width: g,\n    bearing: p,\n    zoom: y\n  } = e, _ = new f({\n    longitude: d,\n    latitude: A,\n    height: r,\n    width: g,\n    bearing: p,\n    zoom: y,\n    pitch: 0\n  });\n  return {\n    camera: {\n      position: u,\n      direction: l,\n      up: h\n    },\n    viewport: e,\n    topDownViewport: _,\n    height: r,\n    cullingVolume: Bs,\n    frameNumber: t,\n    sseDenominator: 1.15\n  };\n}\nfunction Df(e, t, n) {\n  if (n === 0 || e.length <= n)\n    return [e, []];\n  const s = [], {\n    longitude: r,\n    latitude: i\n  } = t.viewport;\n  for (const [u, l] of e.entries()) {\n    const [h, f] = l.header.mbs, d = Math.abs(r - h), A = Math.abs(i - f), g = Math.sqrt(A * A + d * d);\n    s.push([u, g]);\n  }\n  const o = s.sort((u, l) => u[1] - l[1]), a = [];\n  for (let u = 0; u < n; u++)\n    a.push(e[o[u][0]]);\n  const c = [];\n  for (let u = n; u < o.length; u++)\n    c.push(e[o[u][0]]);\n  return [a, c];\n}\nfunction Ff(e) {\n  const t = e.getFrustumPlanes(), n = Wr(t.near, e.cameraPosition), s = rn(e, n), r = rn(e, e.cameraPosition, kn);\n  let i = 0;\n  Bs.planes[i++].fromPointNormal(s, zr.copy(s).subtract(r));\n  for (const o in t) {\n    if (o === \"near\")\n      continue;\n    const a = t[o], c = Wr(a, n, kn), u = rn(e, c, kn);\n    Bs.planes[i++].fromPointNormal(u, zr.copy(s).subtract(u));\n  }\n}\nfunction Wr(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new m();\n  const s = e.normal.dot(t);\n  return n.copy(e.normal).scale(e.distance - s).add(t), n;\n}\nfunction rn(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new m();\n  const s = e.unprojectPosition(t);\n  return H.WGS84.cartographicToCartesian(s, n);\n}\nconst Of = 6378137, vf = 6378137, ys = 6356752314245179e-9, ie = new m();\nfunction xf(e, t) {\n  if (e instanceof ve) {\n    const {\n      halfAxes: n\n    } = e, s = Gf(n);\n    return Math.log2(ys / (s + t[2]));\n  } else if (e instanceof Oe) {\n    const {\n      radius: n\n    } = e;\n    return Math.log2(ys / (n + t[2]));\n  } else if (e.width && e.height) {\n    const {\n      width: n,\n      height: s\n    } = e, r = Math.log2(Of / n), i = Math.log2(vf / s);\n    return (r + i) / 2;\n  }\n  return 1;\n}\nfunction Lo(e, t, n) {\n  H.WGS84.cartographicToCartesian([e.xmax, e.ymax, e.zmax], ie);\n  const s = Math.sqrt(Math.pow(ie[0] - n[0], 2) + Math.pow(ie[1] - n[1], 2) + Math.pow(ie[2] - n[2], 2));\n  return Math.log2(ys / (s + t[2]));\n}\nfunction Lf(e, t, n) {\n  const [s, r, i, o] = e;\n  return Lo({\n    xmin: s,\n    xmax: i,\n    ymin: r,\n    ymax: o,\n    zmin: 0,\n    zmax: 0\n  }, t, n);\n}\nfunction Gf(e) {\n  e.getColumn(0, ie);\n  const t = e.getColumn(1), n = e.getColumn(2);\n  return ie.add(t).add(n).len();\n}\nconst it = {\n  UNLOADED: 0,\n  LOADING: 1,\n  PROCESSING: 2,\n  READY: 3,\n  EXPIRED: 4,\n  FAILED: 5\n};\nlet xt = function(e) {\n  return e[e.ADD = 1] = \"ADD\", e[e.REPLACE = 2] = \"REPLACE\", e;\n}({}), jt = function(e) {\n  return e.EMPTY = \"empty\", e.SCENEGRAPH = \"scenegraph\", e.POINTCLOUD = \"pointcloud\", e.MESH = \"mesh\", e;\n}({}), dt = function(e) {\n  return e.I3S = \"I3S\", e.TILES3D = \"TILES3D\", e;\n}({}), wn = function(e) {\n  return e.GEOMETRIC_ERROR = \"geometricError\", e.MAX_SCREEN_THRESHOLD = \"maxScreenThreshold\", e;\n}({});\nconst Uf = {\n  NOT_COMPUTED: -1,\n  USE_OPTIMIZATION: 1,\n  SKIP_OPTIMIZATION: 0\n};\nfunction Go(e) {\n  return e != null;\n}\nconst $ = new m(), on = new m(), Pf = new m(), Nf = new m(), Vt = new m(), Xr = new m(), Qr = new m(), qr = new m();\nfunction jn(e, t, n) {\n  if (U(e, \"3D Tile: boundingVolume must be defined\"), e.box)\n    return Uo(e.box, t, n);\n  if (e.region)\n    return Vf(e.region);\n  if (e.sphere)\n    return Jf(e.sphere, t, n);\n  throw new Error(\"3D Tile: boundingVolume must contain a sphere, region, or box\");\n}\nfunction Hf(e, t) {\n  if (e.box)\n    return kf(t);\n  if (e.region) {\n    const [n, s, r, i, o, a] = e.region;\n    return [[Et(n), Et(s), o], [Et(r), Et(i), a]];\n  }\n  if (e.sphere)\n    return jf(t);\n  throw new Error(\"Unkown boundingVolume type\");\n}\nfunction Uo(e, t, n) {\n  const s = new m(e[0], e[1], e[2]);\n  t.transform(s, s);\n  let r = [];\n  if (e.length === 10) {\n    const u = e.slice(3, 6), l = new hn();\n    l.fromArray(e, 6);\n    const h = new m([1, 0, 0]), f = new m([0, 1, 0]), d = new m([0, 0, 1]);\n    h.transformByQuaternion(l), h.scale(u[0]), f.transformByQuaternion(l), f.scale(u[1]), d.transformByQuaternion(l), d.scale(u[2]), r = [...h.toArray(), ...f.toArray(), ...d.toArray()];\n  } else\n    r = [...e.slice(3, 6), ...e.slice(6, 9), ...e.slice(9, 12)];\n  const i = t.transformAsVector(r.slice(0, 3)), o = t.transformAsVector(r.slice(3, 6)), a = t.transformAsVector(r.slice(6, 9)), c = new j([i[0], i[1], i[2], o[0], o[1], o[2], a[0], a[1], a[2]]);\n  return Go(n) ? (n.center = s, n.halfAxes = c, n) : new ve(s, c);\n}\nfunction Jf(e, t, n) {\n  const s = new m(e[0], e[1], e[2]);\n  t.transform(s, s);\n  const r = t.getScale(on), i = Math.max(Math.max(r[0], r[1]), r[2]), o = e[3] * i;\n  return Go(n) ? (n.center = s, n.radius = o, n) : new Oe(s, o);\n}\nfunction Vf(e) {\n  const [t, n, s, r, i, o] = e, a = H.WGS84.cartographicToCartesian([Et(t), Et(r), i], Pf), c = H.WGS84.cartographicToCartesian([Et(s), Et(n), o], Nf), u = new m().addVectors(a, c).multiplyByScalar(0.5);\n  return H.WGS84.cartesianToCartographic(u, Vt), H.WGS84.cartographicToCartesian([Et(s), Vt[1], Vt[2]], Xr), H.WGS84.cartographicToCartesian([Vt[0], Et(r), Vt[2]], Qr), H.WGS84.cartographicToCartesian([Vt[0], Vt[1], o], qr), Uo([...u, ...Xr.subtract(u), ...Qr.subtract(u), ...qr.subtract(u)], new N());\n}\nfunction kf(e) {\n  const t = Po(), {\n    halfAxes: n\n  } = e, s = new m(n.getColumn(0)), r = new m(n.getColumn(1)), i = new m(n.getColumn(2));\n  for (let o = 0; o < 2; o++) {\n    for (let a = 0; a < 2; a++) {\n      for (let c = 0; c < 2; c++)\n        $.copy(e.center), $.add(s), $.add(r), $.add(i), No(t, $), i.negate();\n      r.negate();\n    }\n    s.negate();\n  }\n  return t;\n}\nfunction jf(e) {\n  const t = Po(), {\n    center: n,\n    radius: s\n  } = e, r = H.WGS84.scaleToGeodeticSurface(n, $);\n  let i;\n  r ? i = H.WGS84.geodeticSurfaceNormal(r) : i = new m(0, 0, 1);\n  let o = new m(i[2], -i[1], 0);\n  o.len() > 0 ? o.normalize() : o = new m(0, 1, 0);\n  const a = o.clone().cross(i);\n  for (const c of [o, a, i]) {\n    on.copy(c).scale(s);\n    for (let u = 0; u < 2; u++)\n      $.copy(n), $.add(on), No(t, $), on.negate();\n  }\n  return t;\n}\nfunction Po() {\n  return [[1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]];\n}\nfunction No(e, t) {\n  H.WGS84.cartesianToCartographic(t, $), e[0][0] = Math.min(e[0][0], $[0]), e[0][1] = Math.min(e[0][1], $[1]), e[0][2] = Math.min(e[0][2], $[2]), e[1][0] = Math.max(e[1][0], $[0]), e[1][1] = Math.max(e[1][1], $[1]), e[1][2] = Math.max(e[1][2], $[2]);\n}\nnew m();\nnew m();\nnew N();\nnew m();\nnew m();\nnew m();\nfunction Kf(e, t) {\n  const n = e * t;\n  return 1 - Math.exp(-(n * n));\n}\nfunction zf(e, t) {\n  if (e.dynamicScreenSpaceError && e.dynamicScreenSpaceErrorComputedDensity) {\n    const n = e.dynamicScreenSpaceErrorComputedDensity, s = e.dynamicScreenSpaceErrorFactor;\n    return Kf(t, n) * s;\n  }\n  return 0;\n}\nfunction Wf(e, t, n) {\n  const s = e.tileset, r = e.parent && e.parent.lodMetricValue || e.lodMetricValue, i = n ? r : e.lodMetricValue;\n  if (i === 0)\n    return 0;\n  const o = Math.max(e._distanceToCamera, 1e-7), {\n    height: a,\n    sseDenominator: c\n  } = t, {\n    viewDistanceScale: u\n  } = s.options;\n  let l = i * a * (u || 1) / (o * c);\n  return l -= zf(s, o), l;\n}\nconst Kn = new m(), Yr = new m(), Pt = new m(), $r = new m(), Xf = new m(), zn = new N(), Zr = new N();\nfunction Qf(e, t) {\n  if (e.lodMetricValue === 0 || isNaN(e.lodMetricValue))\n    return \"DIG\";\n  const n = 2 * Ho(e, t);\n  return n < 2 ? \"OUT\" : !e.header.children || n <= e.lodMetricValue ? \"DRAW\" : e.header.children ? \"DIG\" : \"OUT\";\n}\nfunction Ho(e, t) {\n  const {\n    topDownViewport: n\n  } = t, s = e.header.mbs[1], r = e.header.mbs[0], i = e.header.mbs[2], o = e.header.mbs[3], a = [...e.boundingVolume.center], c = n.unprojectPosition(n.cameraPosition);\n  H.WGS84.cartographicToCartesian(c, Kn), Yr.copy(Kn).subtract(a).normalize(), H.WGS84.eastNorthUpToFixedFrame(a, zn), Zr.copy(zn).invert(), Pt.copy(Kn).transform(Zr);\n  const u = Math.sqrt(Pt[0] * Pt[0] + Pt[1] * Pt[1]), l = u * u / Pt[2];\n  $r.copy([Pt[0], Pt[1], l]);\n  const f = $r.transform(zn).subtract(a).normalize(), A = Yr.cross(f).normalize().scale(o).add(a), g = H.WGS84.cartesianToCartographic(A), p = n.project([r, s, i]), y = n.project(g);\n  return Xf.copy(p).subtract(y).magnitude();\n}\nfunction qf(e) {\n  return {\n    assetGltfUpAxis: e.asset && e.asset.gltfUpAxis || \"Y\"\n  };\n}\nclass ti {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n    this._map = /* @__PURE__ */ new Map(), this._array = void 0, this._length = void 0, this._array = new Array(t), this._length = t;\n  }\n  get length() {\n    return this._length;\n  }\n  set length(t) {\n    this._length = t, t > this._array.length && (this._array.length = t);\n  }\n  get values() {\n    return this._array;\n  }\n  get(t) {\n    return U(t < this._array.length), this._array[t];\n  }\n  set(t, n) {\n    U(t >= 0), t >= this.length && (this.length = t + 1), this._map.has(this._array[t]) && this._map.delete(this._array[t]), this._array[t] = n, this._map.set(n, t);\n  }\n  delete(t) {\n    const n = this._map.get(t);\n    n >= 0 && (this._array.splice(n, 1), this._map.delete(t), this.length--);\n  }\n  peek() {\n    return this._array[this._length - 1];\n  }\n  push(t) {\n    if (!this._map.has(t)) {\n      const n = this.length++;\n      this._array[n] = t, this._map.set(t, n);\n    }\n  }\n  pop() {\n    const t = this._array[--this.length];\n    return this._map.delete(t), t;\n  }\n  reserve(t) {\n    U(t >= 0), t > this._array.length && (this._array.length = t);\n  }\n  resize(t) {\n    U(t >= 0), this.length = t;\n  }\n  trim(t) {\n    t == null && (t = this.length), this._array.length = t;\n  }\n  reset() {\n    this._array = [], this._map = /* @__PURE__ */ new Map(), this._length = 0;\n  }\n  find(t) {\n    return this._map.has(t);\n  }\n}\nconst Yf = {\n  loadSiblings: !1,\n  skipLevelOfDetail: !1,\n  updateTransforms: !0,\n  onTraversalEnd: () => {\n  },\n  viewportTraversersMap: {},\n  basePath: \"\"\n};\nclass Mn {\n  traversalFinished(t) {\n    return !0;\n  }\n  constructor(t) {\n    this.options = void 0, this.root = null, this.selectedTiles = {}, this.requestedTiles = {}, this.emptyTiles = {}, this.lastUpdate = (/* @__PURE__ */ new Date()).getTime(), this.updateDebounceTime = 1e3, this._traversalStack = new ti(), this._emptyTraversalStack = new ti(), this._frameNumber = null, this.options = {\n      ...Yf,\n      ...t\n    };\n  }\n  traverse(t, n, s) {\n    this.root = t, this.options = {\n      ...this.options,\n      ...s\n    }, this.reset(), this.updateTile(t, n), this._frameNumber = n.frameNumber, this.executeTraversal(t, n);\n  }\n  reset() {\n    this.requestedTiles = {}, this.selectedTiles = {}, this.emptyTiles = {}, this._traversalStack.reset(), this._emptyTraversalStack.reset();\n  }\n  executeTraversal(t, n) {\n    const s = this._traversalStack;\n    for (t._selectionDepth = 1, s.push(t); s.length > 0; ) {\n      const i = s.pop();\n      let o = !1;\n      this.canTraverse(i, n) && (this.updateChildTiles(i, n), o = this.updateAndPushChildren(i, n, s, i.hasRenderContent ? i._selectionDepth + 1 : i._selectionDepth));\n      const a = i.parent, c = !!(!a || a._shouldRefine), u = !o;\n      i.hasRenderContent ? i.refine === xt.ADD ? (this.loadTile(i, n), this.selectTile(i, n)) : i.refine === xt.REPLACE && (this.loadTile(i, n), u && this.selectTile(i, n)) : (this.emptyTiles[i.id] = i, this.loadTile(i, n), u && this.selectTile(i, n)), this.touchTile(i, n), i._shouldRefine = o && c;\n    }\n    const r = (/* @__PURE__ */ new Date()).getTime();\n    (this.traversalFinished(n) || r - this.lastUpdate > this.updateDebounceTime) && (this.lastUpdate = r, this.options.onTraversalEnd(n));\n  }\n  updateChildTiles(t, n) {\n    const s = t.children;\n    for (const r of s)\n      this.updateTile(r, n);\n  }\n  updateAndPushChildren(t, n, s, r) {\n    const {\n      loadSiblings: i,\n      skipLevelOfDetail: o\n    } = this.options, a = t.children;\n    a.sort(this.compareDistanceToCamera.bind(this));\n    const c = t.refine === xt.REPLACE && t.hasRenderContent && !o;\n    let u = !1, l = !0;\n    for (const h of a)\n      if (h._selectionDepth = r, h.isVisibleAndInRequestVolume ? (s.find(h) && s.delete(h), s.push(h), u = !0) : (c || i) && (this.loadTile(h, n), this.touchTile(h, n)), c) {\n        let f;\n        if (h._inRequestVolume ? h.hasRenderContent ? f = h.contentAvailable : f = this.executeEmptyTraversal(h, n) : f = !1, l = l && f, !l)\n          return !1;\n      }\n    return u || (l = !1), l;\n  }\n  updateTile(t, n) {\n    this.updateTileVisibility(t, n);\n  }\n  selectTile(t, n) {\n    this.shouldSelectTile(t) && (t._selectedFrame = n.frameNumber, this.selectedTiles[t.id] = t);\n  }\n  loadTile(t, n) {\n    this.shouldLoadTile(t) && (t._requestedFrame = n.frameNumber, t._priority = t._getPriority(), this.requestedTiles[t.id] = t);\n  }\n  touchTile(t, n) {\n    t.tileset._cache.touch(t), t._touchedFrame = n.frameNumber;\n  }\n  canTraverse(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;\n    return t.hasChildren ? t.hasTilesetContent ? !t.contentExpired : !r && !t.isVisibleAndInRequestVolume ? !1 : this.shouldRefine(t, n, s) : !1;\n  }\n  shouldLoadTile(t) {\n    return t.hasUnloadedContent || t.contentExpired;\n  }\n  shouldSelectTile(t) {\n    return t.contentAvailable && !this.options.skipLevelOfDetail;\n  }\n  shouldRefine(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, r = t._screenSpaceError;\n    return s && (r = t.getScreenSpaceError(n, !0)), r > t.tileset.memoryAdjustedScreenSpaceError;\n  }\n  updateTileVisibility(t, n) {\n    const s = [];\n    if (this.options.viewportTraversersMap)\n      for (const r in this.options.viewportTraversersMap)\n        this.options.viewportTraversersMap[r] === n.viewport.id && s.push(r);\n    else\n      s.push(n.viewport.id);\n    t.updateVisibility(n, s);\n  }\n  compareDistanceToCamera(t, n) {\n    return t._distanceToCamera - n._distanceToCamera;\n  }\n  anyChildrenVisible(t, n) {\n    let s = !1;\n    for (const r of t.children)\n      r.updateVisibility(n), s = s || r.isVisibleAndInRequestVolume;\n    return s;\n  }\n  executeEmptyTraversal(t, n) {\n    let s = !0;\n    const r = this._emptyTraversalStack;\n    for (r.push(t); r.length > 0; ) {\n      const i = r.pop(), o = !i.hasRenderContent && this.canTraverse(i, n, !1, !1), a = !i.hasRenderContent && i.children.length === 0;\n      if (!o && !i.contentAvailable && !a && (s = !1), this.updateTile(i, n), i.isVisibleAndInRequestVolume || (this.loadTile(i, n), this.touchTile(i, n)), o) {\n        const c = i.children;\n        for (const u of c)\n          r.push(u);\n      }\n    }\n    return s;\n  }\n}\nconst ei = new m();\nfunction $f(e) {\n  return e != null;\n}\nclass Cs {\n  constructor(t, n, s) {\n    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"\";\n    this.tileset = void 0, this.header = void 0, this.id = void 0, this.url = void 0, this.parent = void 0, this.refine = void 0, this.type = void 0, this.contentUrl = void 0, this.lodMetricType = \"geometricError\", this.lodMetricValue = 0, this.boundingVolume = null, this.content = null, this.contentState = it.UNLOADED, this.gpuMemoryUsageInBytes = 0, this.children = [], this.depth = 0, this.viewportIds = [], this.transform = new N(), this.extensions = null, this.implicitTiling = null, this.userData = {}, this.computedTransform = void 0, this.hasEmptyContent = !1, this.hasTilesetContent = !1, this.traverser = new Mn({}), this._cacheNode = null, this._frameNumber = null, this._expireDate = null, this._expiredContent = null, this._boundingBox = void 0, this._distanceToCamera = 0, this._screenSpaceError = 0, this._visibilityPlaneMask = void 0, this._visible = void 0, this._contentBoundingVolume = void 0, this._viewerRequestVolume = void 0, this._initialTransform = new N(), this._priority = 0, this._selectedFrame = 0, this._requestedFrame = 0, this._selectionDepth = 0, this._touchedFrame = 0, this._centerZDepth = 0, this._shouldRefine = !1, this._stackLength = 0, this._visitedFrame = 0, this._inRequestVolume = !1, this._lodJudge = null, this.header = n, this.tileset = t, this.id = r || n.id, this.url = n.url, this.parent = s, this.refine = this._getRefine(n.refine), this.type = n.type, this.contentUrl = n.contentUrl, this._initializeLodMetric(n), this._initializeTransforms(n), this._initializeBoundingVolumes(n), this._initializeContent(n), this._initializeRenderingState(n), Object.seal(this);\n  }\n  destroy() {\n    this.header = null;\n  }\n  isDestroyed() {\n    return this.header === null;\n  }\n  get selected() {\n    return this._selectedFrame === this.tileset._frameNumber;\n  }\n  get isVisible() {\n    return this._visible;\n  }\n  get isVisibleAndInRequestVolume() {\n    return this._visible && this._inRequestVolume;\n  }\n  get hasRenderContent() {\n    return !this.hasEmptyContent && !this.hasTilesetContent;\n  }\n  get hasChildren() {\n    return this.children.length > 0 || this.header.children && this.header.children.length > 0;\n  }\n  get contentReady() {\n    return this.contentState === it.READY || this.hasEmptyContent;\n  }\n  get contentAvailable() {\n    return !!(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);\n  }\n  get hasUnloadedContent() {\n    return this.hasRenderContent && this.contentUnloaded;\n  }\n  get contentUnloaded() {\n    return this.contentState === it.UNLOADED;\n  }\n  get contentExpired() {\n    return this.contentState === it.EXPIRED;\n  }\n  get contentFailed() {\n    return this.contentState === it.FAILED;\n  }\n  get distanceToCamera() {\n    return this._distanceToCamera;\n  }\n  get screenSpaceError() {\n    return this._screenSpaceError;\n  }\n  get boundingBox() {\n    return this._boundingBox || (this._boundingBox = Hf(this.header.boundingVolume, this.boundingVolume)), this._boundingBox;\n  }\n  getScreenSpaceError(t, n) {\n    switch (this.tileset.type) {\n      case dt.I3S:\n        return Ho(this, t);\n      case dt.TILES3D:\n        return Wf(this, t, n);\n      default:\n        throw new Error(\"Unsupported tileset type\");\n    }\n  }\n  unselect() {\n    this._selectedFrame = 0;\n  }\n  _getGpuMemoryUsageInBytes() {\n    return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;\n  }\n  _getPriority() {\n    const t = this.tileset._traverser, {\n      skipLevelOfDetail: n\n    } = t.options, s = this.refine === xt.ADD || n;\n    if (s && !this.isVisible && this._visible !== void 0 || this.tileset._frameNumber - this._touchedFrame >= 1 || this.contentState === it.UNLOADED)\n      return -1;\n    const r = this.parent, o = r && (!s || this._screenSpaceError === 0 || r.hasTilesetContent) ? r._screenSpaceError : this._screenSpaceError, a = t.root ? t.root._screenSpaceError : 0;\n    return Math.max(a - o, 0);\n  }\n  async loadContent() {\n    if (this.hasEmptyContent)\n      return !1;\n    if (this.content)\n      return !0;\n    this.contentExpired && (this._expireDate = null), this.contentState = it.LOADING;\n    const n = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));\n    if (!n)\n      return this.contentState = it.UNLOADED, !1;\n    try {\n      const s = this.tileset.getTileUrl(this.contentUrl), r = this.tileset.loader, i = {\n        ...this.tileset.loadOptions,\n        [r.id]: {\n          ...this.tileset.loadOptions[r.id],\n          isTileset: this.type === \"json\",\n          ...this._getLoaderSpecificOptions(r.id)\n        }\n      };\n      return this.content = await Fe(s, r, i), this.tileset.options.contentLoader && await this.tileset.options.contentLoader(this), this._isTileset() && this.tileset._initializeTileHeaders(this.content, this), this.contentState = it.READY, this._onContentLoaded(), !0;\n    } catch (s) {\n      throw this.contentState = it.FAILED, s;\n    } finally {\n      n.done();\n    }\n  }\n  unloadContent() {\n    return this.content && this.content.destroy && this.content.destroy(), this.content = null, this.header.content && this.header.content.destroy && this.header.content.destroy(), this.header.content = null, this.contentState = it.UNLOADED, !0;\n  }\n  updateVisibility(t, n) {\n    if (this._frameNumber === t.frameNumber)\n      return;\n    const s = this.parent, r = s ? s._visibilityPlaneMask : at.MASK_INDETERMINATE;\n    if (this.tileset._traverser.options.updateTransforms) {\n      const i = s ? s.computedTransform : this.tileset.modelMatrix;\n      this._updateTransform(i);\n    }\n    this._distanceToCamera = this.distanceToTile(t), this._screenSpaceError = this.getScreenSpaceError(t, !1), this._visibilityPlaneMask = this.visibility(t, r), this._visible = this._visibilityPlaneMask !== at.MASK_OUTSIDE, this._inRequestVolume = this.insideViewerRequestVolume(t), this._frameNumber = t.frameNumber, this.viewportIds = n;\n  }\n  visibility(t, n) {\n    const {\n      cullingVolume: s\n    } = t, {\n      boundingVolume: r\n    } = this;\n    return s.computeVisibilityWithPlaneMask(r, n);\n  }\n  contentVisibility() {\n    return !0;\n  }\n  distanceToTile(t) {\n    const n = this.boundingVolume;\n    return Math.sqrt(Math.max(n.distanceSquaredTo(t.camera.position), 0));\n  }\n  cameraSpaceZDepth(t) {\n    let {\n      camera: n\n    } = t;\n    const s = this.boundingVolume;\n    return ei.subVectors(s.center, n.position), n.direction.dot(ei);\n  }\n  insideViewerRequestVolume(t) {\n    const n = this._viewerRequestVolume;\n    return !n || n.distanceSquaredTo(t.camera.position) <= 0;\n  }\n  updateExpiration() {\n    if ($f(this._expireDate) && this.contentReady && !this.hasEmptyContent) {\n      const t = Date.now();\n      Date.lessThan(this._expireDate, t) && (this.contentState = it.EXPIRED, this._expiredContent = this.content);\n    }\n  }\n  get extras() {\n    return this.header.extras;\n  }\n  _initializeLodMetric(t) {\n    \"lodMetricType\" in t ? this.lodMetricType = t.lodMetricType : (this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType, console.warn(\"3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType\")), \"lodMetricValue\" in t ? this.lodMetricValue = t.lodMetricValue : (this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue, console.warn(\"3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue\"));\n  }\n  _initializeTransforms(t) {\n    this.transform = t.transform ? new N(t.transform) : new N();\n    const n = this.parent, s = this.tileset, r = n && n.computedTransform ? n.computedTransform.clone() : s.modelMatrix.clone();\n    this.computedTransform = new N(r).multiplyRight(this.transform);\n    const i = n && n._initialTransform ? n._initialTransform.clone() : new N();\n    this._initialTransform = new N(i).multiplyRight(this.transform);\n  }\n  _initializeBoundingVolumes(t) {\n    this._contentBoundingVolume = null, this._viewerRequestVolume = null, this._updateBoundingVolume(t);\n  }\n  _initializeContent(t) {\n    this.content = {\n      _tileset: this.tileset,\n      _tile: this\n    }, this.hasEmptyContent = !0, this.contentState = it.UNLOADED, this.hasTilesetContent = !1, t.contentUrl && (this.content = null, this.hasEmptyContent = !1);\n  }\n  _initializeRenderingState(t) {\n    this.depth = t.level || (this.parent ? this.parent.depth + 1 : 0), this._shouldRefine = !1, this._distanceToCamera = 0, this._centerZDepth = 0, this._screenSpaceError = 0, this._visibilityPlaneMask = at.MASK_INDETERMINATE, this._visible = void 0, this._inRequestVolume = !1, this._stackLength = 0, this._selectionDepth = 0, this._frameNumber = 0, this._touchedFrame = 0, this._visitedFrame = 0, this._selectedFrame = 0, this._requestedFrame = 0, this._priority = 0;\n  }\n  _getRefine(t) {\n    return t || this.parent && this.parent.refine || xt.REPLACE;\n  }\n  _isTileset() {\n    return this.contentUrl.indexOf(\".json\") !== -1;\n  }\n  _onContentLoaded() {\n    switch (this.content && this.content.type) {\n      case \"vctr\":\n      case \"geom\":\n        this.tileset._traverser.disableSkipLevelOfDetail = !0;\n        break;\n    }\n    this._isTileset() ? this.hasTilesetContent = !0 : this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();\n  }\n  _updateBoundingVolume(t) {\n    this.boundingVolume = jn(t.boundingVolume, this.computedTransform, this.boundingVolume);\n    const n = t.content;\n    n && (n.boundingVolume && (this._contentBoundingVolume = jn(n.boundingVolume, this.computedTransform, this._contentBoundingVolume)), t.viewerRequestVolume && (this._viewerRequestVolume = jn(t.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume)));\n  }\n  _updateTransform() {\n    const n = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new N()).clone().multiplyRight(this.transform);\n    n.equals(this.computedTransform) || (this.computedTransform = n, this._updateBoundingVolume(this.header));\n  }\n  _getLoaderSpecificOptions(t) {\n    switch (t) {\n      case \"i3s\":\n        return {\n          ...this.tileset.options.i3s,\n          _tileOptions: {\n            attributeUrls: this.header.attributeUrls,\n            textureUrl: this.header.textureUrl,\n            textureFormat: this.header.textureFormat,\n            textureLoaderOptions: this.header.textureLoaderOptions,\n            materialDefinition: this.header.materialDefinition,\n            isDracoGeometry: this.header.isDracoGeometry,\n            mbs: this.header.mbs\n          },\n          _tilesetOptions: {\n            store: this.tileset.tileset.store,\n            attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,\n            fields: this.tileset.tileset.fields\n          },\n          isTileHeader: !1\n        };\n      case \"3d-tiles\":\n      case \"cesium-ion\":\n      default:\n        return qf(this.tileset.tileset);\n    }\n  }\n}\nclass Zf extends Mn {\n  compareDistanceToCamera(t, n) {\n    return n._distanceToCamera === 0 && t._distanceToCamera === 0 ? n._centerZDepth - t._centerZDepth : n._distanceToCamera - t._distanceToCamera;\n  }\n  updateTileVisibility(t, n) {\n    if (super.updateTileVisibility(t, n), !t.isVisibleAndInRequestVolume)\n      return;\n    const s = t.children.length > 0;\n    if (t.hasTilesetContent && s) {\n      const o = t.children[0];\n      this.updateTileVisibility(o, n), t._visible = o._visible;\n      return;\n    }\n    if (this.meetsScreenSpaceErrorEarly(t, n)) {\n      t._visible = !1;\n      return;\n    }\n    const r = t.refine === xt.REPLACE, i = t._optimChildrenWithinParent === Uf.USE_OPTIMIZATION;\n    if (r && i && s && !this.anyChildrenVisible(t, n)) {\n      t._visible = !1;\n      return;\n    }\n  }\n  meetsScreenSpaceErrorEarly(t, n) {\n    const {\n      parent: s\n    } = t;\n    return !s || s.hasTilesetContent || s.refine !== xt.ADD ? !1 : !this.shouldRefine(t, n, !0);\n  }\n}\nclass td {\n  constructor() {\n    this.frameNumberMap = /* @__PURE__ */ new Map();\n  }\n  register(t, n) {\n    const s = this.frameNumberMap.get(t) || /* @__PURE__ */ new Map(), r = s.get(n) || 0;\n    s.set(n, r + 1), this.frameNumberMap.set(t, s);\n  }\n  deregister(t, n) {\n    const s = this.frameNumberMap.get(t);\n    if (!s)\n      return;\n    const r = s.get(n) || 1;\n    s.set(n, r - 1);\n  }\n  isZero(t, n) {\n    var s;\n    return (((s = this.frameNumberMap.get(t)) === null || s === void 0 ? void 0 : s.get(n)) || 0) === 0;\n  }\n}\nconst Wn = {\n  REQUESTED: \"REQUESTED\",\n  COMPLETED: \"COMPLETED\",\n  ERROR: \"ERROR\"\n};\nclass ed {\n  constructor() {\n    this._statusMap = void 0, this.pendingTilesRegister = new td(), this._statusMap = {};\n  }\n  add(t, n, s, r) {\n    if (!this._statusMap[n]) {\n      const {\n        frameNumber: i,\n        viewport: {\n          id: o\n        }\n      } = r;\n      this._statusMap[n] = {\n        request: t,\n        callback: s,\n        key: n,\n        frameState: r,\n        status: Wn.REQUESTED\n      }, this.pendingTilesRegister.register(o, i), t().then((a) => {\n        this._statusMap[n].status = Wn.COMPLETED;\n        const {\n          frameNumber: c,\n          viewport: {\n            id: u\n          }\n        } = this._statusMap[n].frameState;\n        this.pendingTilesRegister.deregister(u, c), this._statusMap[n].callback(a, r);\n      }).catch((a) => {\n        this._statusMap[n].status = Wn.ERROR;\n        const {\n          frameNumber: c,\n          viewport: {\n            id: u\n          }\n        } = this._statusMap[n].frameState;\n        this.pendingTilesRegister.deregister(u, c), s(a);\n      });\n    }\n  }\n  update(t, n) {\n    if (this._statusMap[t]) {\n      const {\n        frameNumber: s,\n        viewport: {\n          id: r\n        }\n      } = this._statusMap[t].frameState;\n      this.pendingTilesRegister.deregister(r, s);\n      const {\n        frameNumber: i,\n        viewport: {\n          id: o\n        }\n      } = n;\n      this.pendingTilesRegister.register(o, i), this._statusMap[t].frameState = n;\n    }\n  }\n  find(t) {\n    return this._statusMap[t];\n  }\n  hasPendingTiles(t, n) {\n    return !this.pendingTilesRegister.isZero(t, n);\n  }\n}\nclass nd extends Mn {\n  constructor(t) {\n    super(t), this._tileManager = void 0, this._tileManager = new ed();\n  }\n  traversalFinished(t) {\n    return !this._tileManager.hasPendingTiles(t.viewport.id, this._frameNumber || 0);\n  }\n  shouldRefine(t, n) {\n    return t._lodJudge = Qf(t, n), t._lodJudge === \"DIG\";\n  }\n  updateChildTiles(t, n) {\n    const s = t.header.children || [], r = t.children, i = t.tileset;\n    for (const o of s) {\n      const a = `${o.id}-${n.viewport.id}`, c = r && r.find((u) => u.id === a);\n      if (c)\n        c && this.updateTile(c, n);\n      else {\n        let u = () => this._loadTile(o.id, i);\n        this._tileManager.find(a) ? this._tileManager.update(a, n) : (i.tileset.nodePages && (u = () => i.tileset.nodePagesTile.formTileFromNodePages(o.id)), this._tileManager.add(u, a, (h) => this._onTileLoad(h, t, a), n));\n      }\n    }\n    return !1;\n  }\n  async _loadTile(t, n) {\n    const {\n      loader: s\n    } = n, r = n.getTileUrl(`${n.url}/nodes/${t}`), i = {\n      ...n.loadOptions,\n      i3s: {\n        ...n.loadOptions.i3s,\n        isTileHeader: !0\n      }\n    };\n    return await Fe(r, s, i);\n  }\n  _onTileLoad(t, n, s) {\n    const r = new Cs(n.tileset, t, n, s);\n    n.children.push(r);\n    const i = this._tileManager.find(r.id).frameState;\n    this.updateTile(r, i), this._frameNumber === i.frameNumber && (this.traversalFinished(i) || (/* @__PURE__ */ new Date()).getTime() - this.lastUpdate > this.updateDebounceTime) && this.executeTraversal(r, i);\n  }\n}\nconst sd = {\n  description: \"\",\n  ellipsoid: H.WGS84,\n  modelMatrix: new N(),\n  throttleRequests: !0,\n  maxRequests: 64,\n  maximumMemoryUsage: 32,\n  memoryCacheOverflow: 1,\n  maximumTilesSelected: 0,\n  debounceTime: 0,\n  onTileLoad: () => {\n  },\n  onTileUnload: () => {\n  },\n  onTileError: () => {\n  },\n  onTraversalComplete: (e) => e,\n  contentLoader: void 0,\n  viewDistanceScale: 1,\n  maximumScreenSpaceError: 8,\n  memoryAdjustedScreenSpaceError: !1,\n  loadTiles: !0,\n  updateTransforms: !0,\n  viewportTraversersMap: null,\n  loadOptions: {\n    fetch: {}\n  },\n  attributions: [],\n  basePath: \"\",\n  i3s: {}\n}, qe = \"Tiles In Tileset(s)\", Xn = \"Tiles In Memory\", ni = \"Tiles In View\", si = \"Tiles To Render\", ri = \"Tiles Loaded\", Qn = \"Tiles Loading\", ii = \"Tiles Unloaded\", oi = \"Failed Tile Loads\", ai = \"Points/Vertices\", qn = \"Tile Memory Use\", ci = \"Maximum Screen Space Error\";\nclass rd {\n  constructor(t, n) {\n    this.options = void 0, this.loadOptions = void 0, this.type = void 0, this.tileset = void 0, this.loader = void 0, this.url = void 0, this.basePath = void 0, this.modelMatrix = void 0, this.ellipsoid = void 0, this.lodMetricType = void 0, this.lodMetricValue = void 0, this.refine = void 0, this.root = null, this.roots = {}, this.asset = {}, this.description = \"\", this.properties = void 0, this.extras = null, this.attributions = {}, this.credits = {}, this.stats = void 0, this.contentFormats = {\n      draco: !1,\n      meshopt: !1,\n      dds: !1,\n      ktx2: !1\n    }, this.cartographicCenter = null, this.cartesianCenter = null, this.zoom = 1, this.boundingVolume = null, this.dynamicScreenSpaceErrorComputedDensity = 0, this.maximumMemoryUsage = 32, this.gpuMemoryUsageInBytes = 0, this.memoryAdjustedScreenSpaceError = 0, this._cacheBytes = 0, this._cacheOverflowBytes = 0, this._frameNumber = 0, this._queryParams = {}, this._extensionsUsed = [], this._tiles = {}, this._pendingCount = 0, this.selectedTiles = [], this.traverseCounter = 0, this.geometricError = 0, this.lastUpdatedVieports = null, this._requestedTiles = [], this._emptyTiles = [], this.frameStateData = {}, this._traverser = void 0, this._cache = new nf(), this._requestScheduler = void 0, this.updatePromise = null, this.tilesetInitializationPromise = void 0, this.options = {\n      ...sd,\n      ...n\n    }, this.tileset = t, this.loader = t.loader, this.type = t.type, this.url = t.url, this.basePath = t.basePath || Os(this.url), this.modelMatrix = this.options.modelMatrix, this.ellipsoid = this.options.ellipsoid, this.lodMetricType = t.lodMetricType, this.lodMetricValue = t.lodMetricValue, this.refine = t.root.refine, this.loadOptions = this.options.loadOptions || {}, this._traverser = this._initializeTraverser(), this._requestScheduler = new Pc({\n      throttleRequests: this.options.throttleRequests,\n      maxRequests: this.options.maxRequests\n    }), this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError, this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024, this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024, this.stats = new no({\n      id: this.url\n    }), this._initializeStats(), this.tilesetInitializationPromise = this._initializeTileSet(t);\n  }\n  destroy() {\n    this._destroy();\n  }\n  isLoaded() {\n    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;\n  }\n  get tiles() {\n    return Object.values(this._tiles);\n  }\n  get frameNumber() {\n    return this._frameNumber;\n  }\n  get queryParams() {\n    return new URLSearchParams(this._queryParams).toString();\n  }\n  setProps(t) {\n    this.options = {\n      ...this.options,\n      ...t\n    };\n  }\n  getTileUrl(t) {\n    if (t.startsWith(\"data:\"))\n      return t;\n    let s = t;\n    return this.queryParams.length && (s = `${t}${t.includes(\"?\") ? \"&\" : \"?\"}${this.queryParams}`), s;\n  }\n  hasExtension(t) {\n    return this._extensionsUsed.indexOf(t) > -1;\n  }\n  update() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n    this.tilesetInitializationPromise.then(() => {\n      !t && this.lastUpdatedVieports ? t = this.lastUpdatedVieports : this.lastUpdatedVieports = t, t && this.doUpdate(t);\n    });\n  }\n  async selectTiles() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n    return await this.tilesetInitializationPromise, t && (this.lastUpdatedVieports = t), this.updatePromise || (this.updatePromise = new Promise((n) => {\n      setTimeout(() => {\n        this.lastUpdatedVieports && this.doUpdate(this.lastUpdatedVieports), n(this._frameNumber), this.updatePromise = null;\n      }, this.options.debounceTime);\n    })), this.updatePromise;\n  }\n  adjustScreenSpaceError() {\n    this.gpuMemoryUsageInBytes < this._cacheBytes ? this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError) : this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes && (this.memoryAdjustedScreenSpaceError *= 1.02);\n  }\n  doUpdate(t) {\n    if (\"loadTiles\" in this.options && !this.options.loadTiles || this.traverseCounter > 0)\n      return;\n    const n = t instanceof Array ? t : [t];\n    this._cache.reset(), this._frameNumber++, this.traverseCounter = n.length;\n    const s = [];\n    for (const r of n) {\n      const i = r.id;\n      this._needTraverse(i) ? s.push(i) : this.traverseCounter--;\n    }\n    for (const r of n) {\n      const i = r.id;\n      if (this.roots[i] || (this.roots[i] = this._initializeTileHeaders(this.tileset, null)), !s.includes(i))\n        continue;\n      const o = Sf(r, this._frameNumber);\n      this._traverser.traverse(this.roots[i], o, this.options);\n    }\n  }\n  _needTraverse(t) {\n    let n = t;\n    return this.options.viewportTraversersMap && (n = this.options.viewportTraversersMap[t]), n === t;\n  }\n  _onTraversalEnd(t) {\n    const n = t.viewport.id;\n    this.frameStateData[n] || (this.frameStateData[n] = {\n      selectedTiles: [],\n      _requestedTiles: [],\n      _emptyTiles: []\n    });\n    const s = this.frameStateData[n], r = Object.values(this._traverser.selectedTiles), [i, o] = Df(r, t, this.options.maximumTilesSelected);\n    s.selectedTiles = i;\n    for (const a of o)\n      a.unselect();\n    s._requestedTiles = Object.values(this._traverser.requestedTiles), s._emptyTiles = Object.values(this._traverser.emptyTiles), this.traverseCounter--, !(this.traverseCounter > 0) && this._updateTiles();\n  }\n  _updateTiles() {\n    this.selectedTiles = [], this._requestedTiles = [], this._emptyTiles = [];\n    for (const t in this.frameStateData) {\n      const n = this.frameStateData[t];\n      this.selectedTiles = this.selectedTiles.concat(n.selectedTiles), this._requestedTiles = this._requestedTiles.concat(n._requestedTiles), this._emptyTiles = this._emptyTiles.concat(n._emptyTiles);\n    }\n    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);\n    for (const t of this.selectedTiles)\n      this._tiles[t.id] = t;\n    this._loadTiles(), this._unloadTiles(), this._updateStats();\n  }\n  _tilesChanged(t, n) {\n    if (t.length !== n.length)\n      return !0;\n    const s = new Set(t.map((o) => o.id)), r = new Set(n.map((o) => o.id));\n    let i = t.filter((o) => !r.has(o.id)).length > 0;\n    return i = i || n.filter((o) => !s.has(o.id)).length > 0, i;\n  }\n  _loadTiles() {\n    for (const t of this._requestedTiles)\n      t.contentUnloaded && this._loadTile(t);\n  }\n  _unloadTiles() {\n    this._cache.unloadTiles(this, (t, n) => t._unloadTile(n));\n  }\n  _updateStats() {\n    let t = 0, n = 0;\n    for (const s of this.selectedTiles)\n      s.contentAvailable && s.content && (t++, s.content.pointCount ? n += s.content.pointCount : n += s.content.vertexCount);\n    this.stats.get(ni).count = this.selectedTiles.length, this.stats.get(si).count = t, this.stats.get(ai).count = n, this.stats.get(ci).count = this.memoryAdjustedScreenSpaceError;\n  }\n  async _initializeTileSet(t) {\n    this.type === dt.I3S && (this.calculateViewPropsI3S(), t.root = await t.root), this.root = this._initializeTileHeaders(t, null), this.type === dt.TILES3D && (this._initializeTiles3DTileset(t), this.calculateViewPropsTiles3D()), this.type === dt.I3S && this._initializeI3STileset();\n  }\n  calculateViewPropsI3S() {\n    var t;\n    const n = this.tileset.fullExtent;\n    if (n) {\n      const {\n        xmin: r,\n        xmax: i,\n        ymin: o,\n        ymax: a,\n        zmin: c,\n        zmax: u\n      } = n;\n      this.cartographicCenter = new m(r + (i - r) / 2, o + (a - o) / 2, c + (u - c) / 2), this.cartesianCenter = new m(), H.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = Lo(n, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n    const s = (t = this.tileset.store) === null || t === void 0 ? void 0 : t.extent;\n    if (s) {\n      const [r, i, o, a] = s;\n      this.cartographicCenter = new m(r + (o - r) / 2, i + (a - i) / 2, 0), this.cartesianCenter = new m(), H.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = Lf(s, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n    console.warn(\"Extent is not defined in the tileset header\"), this.cartographicCenter = new m(), this.zoom = 1;\n  }\n  calculateViewPropsTiles3D() {\n    const t = this.root, {\n      center: n\n    } = t.boundingVolume;\n    if (!n) {\n      console.warn(\"center was not pre-calculated for the root tile\"), this.cartographicCenter = new m(), this.zoom = 1;\n      return;\n    }\n    n[0] !== 0 || n[1] !== 0 || n[2] !== 0 ? (this.cartographicCenter = new m(), H.WGS84.cartesianToCartographic(n, this.cartographicCenter)) : this.cartographicCenter = new m(0, 0, -H.WGS84.radii[0]), this.cartesianCenter = n, this.zoom = xf(t.boundingVolume, this.cartographicCenter);\n  }\n  _initializeStats() {\n    this.stats.get(qe), this.stats.get(Qn), this.stats.get(Xn), this.stats.get(ni), this.stats.get(si), this.stats.get(ri), this.stats.get(ii), this.stats.get(oi), this.stats.get(ai), this.stats.get(qn, \"memory\"), this.stats.get(ci);\n  }\n  _initializeTileHeaders(t, n) {\n    const s = new Cs(this, t.root, n);\n    if (n && (n.children.push(s), s.depth = n.depth + 1), this.type === dt.TILES3D) {\n      const i = [];\n      for (i.push(s); i.length > 0; ) {\n        const o = i.pop();\n        this.stats.get(qe).incrementCount();\n        const a = o.header.children || [];\n        for (const c of a) {\n          var r;\n          const u = new Cs(this, c, o);\n          if ((r = u.contentUrl) !== null && r !== void 0 && r.includes(\"?session=\")) {\n            const h = new URL(u.contentUrl).searchParams.get(\"session\");\n            h && (this._queryParams.session = h);\n          }\n          o.children.push(u), u.depth = o.depth + 1, i.push(u);\n        }\n      }\n    }\n    return s;\n  }\n  _initializeTraverser() {\n    let t;\n    switch (this.type) {\n      case dt.TILES3D:\n        t = Zf;\n        break;\n      case dt.I3S:\n        t = nd;\n        break;\n      default:\n        t = Mn;\n    }\n    return new t({\n      basePath: this.basePath,\n      onTraversalEnd: this._onTraversalEnd.bind(this)\n    });\n  }\n  _destroyTileHeaders(t) {\n    this._destroySubtree(t);\n  }\n  async _loadTile(t) {\n    let n;\n    try {\n      this._onStartTileLoading(), n = await t.loadContent();\n    } catch (s) {\n      this._onTileLoadError(t, s instanceof Error ? s : new Error(\"load failed\"));\n    } finally {\n      this._onEndTileLoading(), this._onTileLoad(t, n);\n    }\n  }\n  _onTileLoadError(t, n) {\n    this.stats.get(oi).incrementCount();\n    const s = n.message || n.toString(), r = t.url;\n    console.error(`A 3D tile failed to load: ${t.url} ${s}`), this.options.onTileError(t, s, r);\n  }\n  _onTileLoad(t, n) {\n    if (n) {\n      if (this.type === dt.I3S) {\n        var s, r;\n        const i = ((s = this.tileset) === null || s === void 0 || (r = s.nodePagesTile) === null || r === void 0 ? void 0 : r.nodesInNodePages) || 0;\n        this.stats.get(qe).reset(), this.stats.get(qe).addCount(i);\n      }\n      t && t.content && sf(t, t.content), this.updateContentTypes(t), this._addTileToCache(t), this.options.onTileLoad(t);\n    }\n  }\n  updateContentTypes(t) {\n    if (this.type === dt.I3S)\n      switch (t.header.isDracoGeometry && (this.contentFormats.draco = !0), t.header.textureFormat) {\n        case \"dds\":\n          this.contentFormats.dds = !0;\n          break;\n        case \"ktx2\":\n          this.contentFormats.ktx2 = !0;\n          break;\n      }\n    else if (this.type === dt.TILES3D) {\n      var n;\n      const {\n        extensionsRemoved: s = []\n      } = ((n = t.content) === null || n === void 0 ? void 0 : n.gltf) || {};\n      s.includes(\"KHR_draco_mesh_compression\") && (this.contentFormats.draco = !0), s.includes(\"EXT_meshopt_compression\") && (this.contentFormats.meshopt = !0), s.includes(\"KHR_texture_basisu\") && (this.contentFormats.ktx2 = !0);\n    }\n  }\n  _onStartTileLoading() {\n    this._pendingCount++, this.stats.get(Qn).incrementCount();\n  }\n  _onEndTileLoading() {\n    this._pendingCount--, this.stats.get(Qn).decrementCount();\n  }\n  _addTileToCache(t) {\n    this._cache.add(this, t, (n) => n._updateCacheStats(t));\n  }\n  _updateCacheStats(t) {\n    this.stats.get(ri).incrementCount(), this.stats.get(Xn).incrementCount(), this.gpuMemoryUsageInBytes += t.gpuMemoryUsageInBytes || 0, this.stats.get(qn).count = this.gpuMemoryUsageInBytes, this.options.memoryAdjustedScreenSpaceError && this.adjustScreenSpaceError();\n  }\n  _unloadTile(t) {\n    this.gpuMemoryUsageInBytes -= t.gpuMemoryUsageInBytes || 0, this.stats.get(Xn).decrementCount(), this.stats.get(ii).incrementCount(), this.stats.get(qn).count = this.gpuMemoryUsageInBytes, this.options.onTileUnload(t), t.unloadContent();\n  }\n  _destroy() {\n    const t = [];\n    for (this.root && t.push(this.root); t.length > 0; ) {\n      const n = t.pop();\n      for (const s of n.children)\n        t.push(s);\n      this._destroyTile(n);\n    }\n    this.root = null;\n  }\n  _destroySubtree(t) {\n    const n = t, s = [];\n    for (s.push(n); s.length > 0; ) {\n      t = s.pop();\n      for (const r of t.children)\n        s.push(r);\n      t !== n && this._destroyTile(t);\n    }\n    n.children = [];\n  }\n  _destroyTile(t) {\n    this._cache.unloadTile(this, t), this._unloadTile(t), t.destroy();\n  }\n  _initializeTiles3DTileset(t) {\n    if (t.queryString) {\n      const n = new URLSearchParams(t.queryString), s = Object.fromEntries(n.entries());\n      this._queryParams = {\n        ...this._queryParams,\n        ...s\n      };\n    }\n    if (this.asset = t.asset, !this.asset)\n      throw new Error(\"Tileset must have an asset property.\");\n    if (this.asset.version !== \"0.0\" && this.asset.version !== \"1.0\" && this.asset.version !== \"1.1\")\n      throw new Error(\"The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.\");\n    \"tilesetVersion\" in this.asset && (this._queryParams.v = this.asset.tilesetVersion), this.credits = {\n      attributions: this.options.attributions || []\n    }, this.description = this.options.description || \"\", this.properties = t.properties, this.geometricError = t.geometricError, this._extensionsUsed = t.extensionsUsed || [], this.extras = t.extras;\n  }\n  _initializeI3STileset() {\n    this.loadOptions.i3s && \"token\" in this.loadOptions.i3s && (this._queryParams.token = this.loadOptions.i3s.token);\n  }\n}\nconst Jo = \"4.1.1\", de = {\n  COMPOSITE: \"cmpt\",\n  POINT_CLOUD: \"pnts\",\n  BATCHED_3D_MODEL: \"b3dm\",\n  INSTANCED_3D_MODEL: \"i3dm\",\n  GEOMETRY: \"geom\",\n  VECTOR: \"vect\",\n  GLTF: \"glTF\"\n};\nfunction Vo(e, t, n) {\n  U(e instanceof ArrayBuffer);\n  const s = new TextDecoder(\"utf8\"), r = new Uint8Array(e, t, n);\n  return s.decode(r);\n}\nfunction id(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n  const n = new DataView(e);\n  return `${String.fromCharCode(n.getUint8(t + 0))}${String.fromCharCode(n.getUint8(t + 1))}${String.fromCharCode(n.getUint8(t + 2))}${String.fromCharCode(n.getUint8(t + 3))}`;\n}\nconst od = \"4.1.1\", ad = {\n  name: \"Draco\",\n  id: \"draco\",\n  module: \"draco\",\n  version: od,\n  worker: !0,\n  extensions: [\"drc\"],\n  mimeTypes: [\"application/octet-stream\"],\n  binary: !0,\n  tests: [\"DRACO\"],\n  options: {\n    draco: {\n      decoderType: typeof WebAssembly == \"object\" ? \"wasm\" : \"js\",\n      libraryPath: \"libs/\",\n      extraAttributes: {},\n      attributeNameEntry: void 0\n    }\n  }\n};\nfunction cd(e, t, n) {\n  const s = ko(t.metadata), r = [], i = ud(t.attributes);\n  for (const o in e) {\n    const a = e[o], c = ui(o, a, i[o]);\n    r.push(c);\n  }\n  if (n) {\n    const o = ui(\"indices\", n);\n    r.push(o);\n  }\n  return {\n    fields: r,\n    metadata: s\n  };\n}\nfunction ud(e) {\n  const t = {};\n  for (const n in e) {\n    const s = e[n];\n    t[s.name || \"undefined\"] = s;\n  }\n  return t;\n}\nfunction ui(e, t, n) {\n  const s = n ? ko(n.metadata) : void 0;\n  return rl(e, t, s);\n}\nfunction ko(e) {\n  Object.entries(e);\n  const t = {};\n  for (const n in e)\n    t[`${n}.string`] = JSON.stringify(e[n]);\n  return t;\n}\nconst li = {\n  POSITION: \"POSITION\",\n  NORMAL: \"NORMAL\",\n  COLOR: \"COLOR_0\",\n  TEX_COORD: \"TEXCOORD_0\"\n}, ld = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n}, hd = 4;\nclass fd {\n  constructor(t) {\n    this.draco = void 0, this.decoder = void 0, this.metadataQuerier = void 0, this.draco = t, this.decoder = new this.draco.Decoder(), this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n  destroy() {\n    this.draco.destroy(this.decoder), this.draco.destroy(this.metadataQuerier);\n  }\n  parseSync(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const s = new this.draco.DecoderBuffer();\n    s.Init(new Int8Array(t), t.byteLength), this._disableAttributeTransforms(n);\n    const r = this.decoder.GetEncodedGeometryType(s), i = r === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();\n    try {\n      let o;\n      switch (r) {\n        case this.draco.TRIANGULAR_MESH:\n          o = this.decoder.DecodeBufferToMesh(s, i);\n          break;\n        case this.draco.POINT_CLOUD:\n          o = this.decoder.DecodeBufferToPointCloud(s, i);\n          break;\n        default:\n          throw new Error(\"DRACO: Unknown geometry type.\");\n      }\n      if (!o.ok() || !i.ptr) {\n        const f = `DRACO decompression failed: ${o.error_msg()}`;\n        throw new Error(f);\n      }\n      const a = this._getDracoLoaderData(i, r, n), c = this._getMeshData(i, a, n), u = sl(c.attributes), l = cd(c.attributes, a, c.indices);\n      return {\n        loader: \"draco\",\n        loaderData: a,\n        header: {\n          vertexCount: i.num_points(),\n          boundingBox: u\n        },\n        ...c,\n        schema: l\n      };\n    } finally {\n      this.draco.destroy(s), i && this.draco.destroy(i);\n    }\n  }\n  _getDracoLoaderData(t, n, s) {\n    const r = this._getTopLevelMetadata(t), i = this._getDracoAttributes(t, s);\n    return {\n      geometry_type: n,\n      num_attributes: t.num_attributes(),\n      num_points: t.num_points(),\n      num_faces: t instanceof this.draco.Mesh ? t.num_faces() : 0,\n      metadata: r,\n      attributes: i\n    };\n  }\n  _getDracoAttributes(t, n) {\n    const s = {};\n    for (let r = 0; r < t.num_attributes(); r++) {\n      const i = this.decoder.GetAttribute(t, r), o = this._getAttributeMetadata(t, r);\n      s[i.unique_id()] = {\n        unique_id: i.unique_id(),\n        attribute_type: i.attribute_type(),\n        data_type: i.data_type(),\n        num_components: i.num_components(),\n        byte_offset: i.byte_offset(),\n        byte_stride: i.byte_stride(),\n        normalized: i.normalized(),\n        attribute_index: r,\n        metadata: o\n      };\n      const a = this._getQuantizationTransform(i, n);\n      a && (s[i.unique_id()].quantization_transform = a);\n      const c = this._getOctahedronTransform(i, n);\n      c && (s[i.unique_id()].octahedron_transform = c);\n    }\n    return s;\n  }\n  _getMeshData(t, n, s) {\n    const r = this._getMeshAttributes(n, t, s);\n    if (!r.POSITION)\n      throw new Error(\"DRACO: No position attribute found.\");\n    if (t instanceof this.draco.Mesh)\n      switch (s.topology) {\n        case \"triangle-strip\":\n          return {\n            topology: \"triangle-strip\",\n            mode: 4,\n            attributes: r,\n            indices: {\n              value: this._getTriangleStripIndices(t),\n              size: 1\n            }\n          };\n        case \"triangle-list\":\n        default:\n          return {\n            topology: \"triangle-list\",\n            mode: 5,\n            attributes: r,\n            indices: {\n              value: this._getTriangleListIndices(t),\n              size: 1\n            }\n          };\n      }\n    return {\n      topology: \"point-list\",\n      mode: 0,\n      attributes: r\n    };\n  }\n  _getMeshAttributes(t, n, s) {\n    const r = {};\n    for (const i of Object.values(t.attributes)) {\n      const o = this._deduceAttributeName(i, s);\n      i.name = o;\n      const {\n        value: a,\n        size: c\n      } = this._getAttributeValues(n, i);\n      r[o] = {\n        value: a,\n        size: c,\n        byteOffset: i.byte_offset,\n        byteStride: i.byte_stride,\n        normalized: i.normalized\n      };\n    }\n    return r;\n  }\n  _getTriangleListIndices(t) {\n    const s = t.num_faces() * 3, r = s * hd, i = this.draco._malloc(r);\n    try {\n      return this.decoder.GetTrianglesUInt32Array(t, r, i), new Uint32Array(this.draco.HEAPF32.buffer, i, s).slice();\n    } finally {\n      this.draco._free(i);\n    }\n  }\n  _getTriangleStripIndices(t) {\n    const n = new this.draco.DracoInt32Array();\n    try {\n      return this.decoder.GetTriangleStripsFromMesh(t, n), Ad(n);\n    } finally {\n      this.draco.destroy(n);\n    }\n  }\n  _getAttributeValues(t, n) {\n    const s = ld[n.data_type], r = n.num_components, o = t.num_points() * r, a = o * s.BYTES_PER_ELEMENT, c = dd(this.draco, s);\n    let u;\n    const l = this.draco._malloc(a);\n    try {\n      const h = this.decoder.GetAttribute(t, n.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(t, h, c, a, l), u = new s(this.draco.HEAPF32.buffer, l, o).slice();\n    } finally {\n      this.draco._free(l);\n    }\n    return {\n      value: u,\n      size: r\n    };\n  }\n  _deduceAttributeName(t, n) {\n    const s = t.unique_id;\n    for (const [o, a] of Object.entries(n.extraAttributes || {}))\n      if (a === s)\n        return o;\n    const r = t.attribute_type;\n    for (const o in li)\n      if (this.draco[o] === r)\n        return li[o];\n    const i = n.attributeNameEntry || \"name\";\n    return t.metadata[i] ? t.metadata[i].string : `CUSTOM_ATTRIBUTE_${s}`;\n  }\n  _getTopLevelMetadata(t) {\n    const n = this.decoder.GetMetadata(t);\n    return this._getDracoMetadata(n);\n  }\n  _getAttributeMetadata(t, n) {\n    const s = this.decoder.GetAttributeMetadata(t, n);\n    return this._getDracoMetadata(s);\n  }\n  _getDracoMetadata(t) {\n    if (!t || !t.ptr)\n      return {};\n    const n = {}, s = this.metadataQuerier.NumEntries(t);\n    for (let r = 0; r < s; r++) {\n      const i = this.metadataQuerier.GetEntryName(t, r);\n      n[i] = this._getDracoMetadataField(t, i);\n    }\n    return n;\n  }\n  _getDracoMetadataField(t, n) {\n    const s = new this.draco.DracoInt32Array();\n    try {\n      this.metadataQuerier.GetIntEntryArray(t, n, s);\n      const r = md(s);\n      return {\n        int: this.metadataQuerier.GetIntEntry(t, n),\n        string: this.metadataQuerier.GetStringEntry(t, n),\n        double: this.metadataQuerier.GetDoubleEntry(t, n),\n        intArray: r\n      };\n    } finally {\n      this.draco.destroy(s);\n    }\n  }\n  _disableAttributeTransforms(t) {\n    const {\n      quantizedAttributes: n = [],\n      octahedronAttributes: s = []\n    } = t, r = [...n, ...s];\n    for (const i of r)\n      this.decoder.SkipAttributeTransform(this.draco[i]);\n  }\n  _getQuantizationTransform(t, n) {\n    const {\n      quantizedAttributes: s = []\n    } = n, r = t.attribute_type();\n    if (s.map((o) => this.decoder[o]).includes(r)) {\n      const o = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (o.InitFromAttribute(t))\n          return {\n            quantization_bits: o.quantization_bits(),\n            range: o.range(),\n            min_values: new Float32Array([1, 2, 3]).map((a) => o.min_value(a))\n          };\n      } finally {\n        this.draco.destroy(o);\n      }\n    }\n    return null;\n  }\n  _getOctahedronTransform(t, n) {\n    const {\n      octahedronAttributes: s = []\n    } = n, r = t.attribute_type();\n    if (s.map((o) => this.decoder[o]).includes(r)) {\n      const o = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (o.InitFromAttribute(t))\n          return {\n            quantization_bits: o.quantization_bits()\n          };\n      } finally {\n        this.draco.destroy(o);\n      }\n    }\n    return null;\n  }\n}\nfunction dd(e, t) {\n  switch (t) {\n    case Float32Array:\n      return e.DT_FLOAT32;\n    case Int8Array:\n      return e.DT_INT8;\n    case Int16Array:\n      return e.DT_INT16;\n    case Int32Array:\n      return e.DT_INT32;\n    case Uint8Array:\n      return e.DT_UINT8;\n    case Uint16Array:\n      return e.DT_UINT16;\n    case Uint32Array:\n      return e.DT_UINT32;\n    default:\n      return e.DT_INVALID;\n  }\n}\nfunction md(e) {\n  const t = e.size(), n = new Int32Array(t);\n  for (let s = 0; s < t; s++)\n    n[s] = e.GetValue(s);\n  return n;\n}\nfunction Ad(e) {\n  const t = e.size(), n = new Int32Array(t);\n  for (let s = 0; s < t; s++)\n    n[s] = e.GetValue(s);\n  return n;\n}\nconst gd = \"1.5.6\", pd = \"1.4.1\", Yn = `https://www.gstatic.com/draco/versioned/decoders/${gd}`, ot = {\n  DECODER: \"draco_wasm_wrapper.js\",\n  DECODER_WASM: \"draco_decoder.wasm\",\n  FALLBACK_DECODER: \"draco_decoder.js\",\n  ENCODER: \"draco_encoder.js\"\n}, $n = {\n  [ot.DECODER]: `${Yn}/${ot.DECODER}`,\n  [ot.DECODER_WASM]: `${Yn}/${ot.DECODER_WASM}`,\n  [ot.FALLBACK_DECODER]: `${Yn}/${ot.FALLBACK_DECODER}`,\n  [ot.ENCODER]: `https://raw.githubusercontent.com/google/draco/${pd}/javascript/${ot.ENCODER}`\n};\nlet me;\nasync function Bd(e) {\n  const t = e.modules || {};\n  return t.draco3d ? me = me || t.draco3d.createDecoderModule({}).then((n) => ({\n    draco: n\n  })) : me = me || yd(e), await me;\n}\nasync function yd(e) {\n  let t, n;\n  switch (e.draco && e.draco.decoderType) {\n    case \"js\":\n      t = await zt($n[ot.FALLBACK_DECODER], \"draco\", e, ot.FALLBACK_DECODER);\n      break;\n    case \"wasm\":\n    default:\n      [t, n] = await Promise.all([await zt($n[ot.DECODER], \"draco\", e, ot.DECODER), await zt($n[ot.DECODER_WASM], \"draco\", e, ot.DECODER_WASM)]);\n  }\n  return t = t || globalThis.DracoDecoderModule, await Cd(t, n);\n}\nfunction Cd(e, t) {\n  const n = {};\n  return t && (n.wasmBinary = t), new Promise((s) => {\n    e({\n      ...n,\n      onModuleLoaded: (r) => s({\n        draco: r\n      })\n    });\n  });\n}\nconst jo = {\n  ...ad,\n  parse: Td\n};\nasync function Td(e, t) {\n  const {\n    draco: n\n  } = await Bd(t), s = new fd(n);\n  try {\n    return s.parseSync(e, t == null ? void 0 : t.draco);\n  } finally {\n    s.destroy();\n  }\n}\nconst Ed = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6\n}, W = {\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  DOUBLE: 5130\n}, x = {\n  ...Ed,\n  ...W\n}, Zn = {\n  [W.DOUBLE]: Float64Array,\n  [W.FLOAT]: Float32Array,\n  [W.UNSIGNED_SHORT]: Uint16Array,\n  [W.UNSIGNED_INT]: Uint32Array,\n  [W.UNSIGNED_BYTE]: Uint8Array,\n  [W.BYTE]: Int8Array,\n  [W.SHORT]: Int16Array,\n  [W.INT]: Int32Array\n}, bd = {\n  DOUBLE: W.DOUBLE,\n  FLOAT: W.FLOAT,\n  UNSIGNED_SHORT: W.UNSIGNED_SHORT,\n  UNSIGNED_INT: W.UNSIGNED_INT,\n  UNSIGNED_BYTE: W.UNSIGNED_BYTE,\n  BYTE: W.BYTE,\n  SHORT: W.SHORT,\n  INT: W.INT\n}, ts = \"Failed to convert GL type\";\nclass Dt {\n  static fromTypedArray(t) {\n    t = ArrayBuffer.isView(t) ? t.constructor : t;\n    for (const n in Zn)\n      if (Zn[n] === t)\n        return n;\n    throw new Error(ts);\n  }\n  static fromName(t) {\n    const n = bd[t];\n    if (!n)\n      throw new Error(ts);\n    return n;\n  }\n  static getArrayType(t) {\n    switch (t) {\n      case W.UNSIGNED_SHORT_5_6_5:\n      case W.UNSIGNED_SHORT_4_4_4_4:\n      case W.UNSIGNED_SHORT_5_5_5_1:\n        return Uint16Array;\n      default:\n        const n = Zn[t];\n        if (!n)\n          throw new Error(ts);\n        return n;\n    }\n  }\n  static getByteSize(t) {\n    return Dt.getArrayType(t).BYTES_PER_ELEMENT;\n  }\n  static validate(t) {\n    return !!Dt.getArrayType(t);\n  }\n  static createTypedArray(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r = arguments.length > 3 ? arguments[3] : void 0;\n    r === void 0 && (r = (n.byteLength - s) / Dt.getByteSize(t));\n    const i = Dt.getArrayType(t);\n    return new i(n, s, r);\n  }\n}\nfunction _d(e, t) {\n  if (!e)\n    throw new Error(`math.gl assertion failed. ${t}`);\n}\nfunction wd(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];\n  const n = e >> 11 & 31, s = e >> 5 & 63, r = e & 31;\n  return t[0] = n << 3, t[1] = s << 2, t[2] = r << 3, t;\n}\nnew bn();\nnew m();\nnew bn();\nnew bn();\nfunction hi(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 255;\n  return fl(e, 0, t) / t * 2 - 1;\n}\nfunction fi(e) {\n  return e < 0 ? -1 : 1;\n}\nfunction Md(e, t, n, s) {\n  if (_d(s), e < 0 || e > n || t < 0 || t > n)\n    throw new Error(`x and y must be unsigned normalized integers between 0 and ${n}`);\n  if (s.x = hi(e, n), s.y = hi(t, n), s.z = 1 - (Math.abs(s.x) + Math.abs(s.y)), s.z < 0) {\n    const r = s.x;\n    s.x = (1 - Math.abs(s.y)) * fi(r), s.y = (1 - Math.abs(r)) * fi(s.y);\n  }\n  return s.normalize();\n}\nfunction Rd(e, t, n) {\n  return Md(e, t, 255, n);\n}\nclass Vs {\n  constructor(t, n) {\n    this.json = void 0, this.buffer = void 0, this.featuresLength = 0, this._cachedTypedArrays = {}, this.json = t, this.buffer = n;\n  }\n  getExtension(t) {\n    return this.json.extensions && this.json.extensions[t];\n  }\n  hasProperty(t) {\n    return !!this.json[t];\n  }\n  getGlobalProperty(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : x.UNSIGNED_INT, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n    const r = this.json[t];\n    return r && Number.isFinite(r.byteOffset) ? this._getTypedArrayFromBinary(t, n, s, 1, r.byteOffset) : r;\n  }\n  getPropertyArray(t, n, s) {\n    const r = this.json[t];\n    return r && Number.isFinite(r.byteOffset) ? (\"componentType\" in r && (n = Dt.fromName(r.componentType)), this._getTypedArrayFromBinary(t, n, s, this.featuresLength, r.byteOffset)) : this._getTypedArrayFromArray(t, n, r);\n  }\n  getProperty(t, n, s, r, i) {\n    const o = this.json[t];\n    if (!o)\n      return o;\n    const a = this.getPropertyArray(t, n, s);\n    if (s === 1)\n      return a[r];\n    for (let c = 0; c < s; ++c)\n      i[c] = a[s * r + c];\n    return i;\n  }\n  _getTypedArrayFromBinary(t, n, s, r, i) {\n    const o = this._cachedTypedArrays;\n    let a = o[t];\n    return a || (a = Dt.createTypedArray(n, this.buffer.buffer, this.buffer.byteOffset + i, r * s), o[t] = a), a;\n  }\n  _getTypedArrayFromArray(t, n, s) {\n    const r = this._cachedTypedArrays;\n    let i = r[t];\n    return i || (i = Dt.createTypedArray(n, s), r[t] = i), i;\n  }\n}\nconst Id = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n}, Sd = {\n  SCALAR: (e, t) => e[t],\n  VEC2: (e, t) => [e[2 * t + 0], e[2 * t + 1]],\n  VEC3: (e, t) => [e[3 * t + 0], e[3 * t + 1], e[3 * t + 2]],\n  VEC4: (e, t) => [e[4 * t + 0], e[4 * t + 1], e[4 * t + 2], e[4 * t + 3]],\n  MAT2: (e, t) => [e[4 * t + 0], e[4 * t + 1], e[4 * t + 2], e[4 * t + 3]],\n  MAT3: (e, t) => [e[9 * t + 0], e[9 * t + 1], e[9 * t + 2], e[9 * t + 3], e[9 * t + 4], e[9 * t + 5], e[9 * t + 6], e[9 * t + 7], e[9 * t + 8]],\n  MAT4: (e, t) => [e[16 * t + 0], e[16 * t + 1], e[16 * t + 2], e[16 * t + 3], e[16 * t + 4], e[16 * t + 5], e[16 * t + 6], e[16 * t + 7], e[16 * t + 8], e[16 * t + 9], e[16 * t + 10], e[16 * t + 11], e[16 * t + 12], e[16 * t + 13], e[16 * t + 14], e[16 * t + 15]]\n}, Dd = {\n  SCALAR: (e, t, n) => {\n    t[n] = e;\n  },\n  VEC2: (e, t, n) => {\n    t[2 * n + 0] = e[0], t[2 * n + 1] = e[1];\n  },\n  VEC3: (e, t, n) => {\n    t[3 * n + 0] = e[0], t[3 * n + 1] = e[1], t[3 * n + 2] = e[2];\n  },\n  VEC4: (e, t, n) => {\n    t[4 * n + 0] = e[0], t[4 * n + 1] = e[1], t[4 * n + 2] = e[2], t[4 * n + 3] = e[3];\n  },\n  MAT2: (e, t, n) => {\n    t[4 * n + 0] = e[0], t[4 * n + 1] = e[1], t[4 * n + 2] = e[2], t[4 * n + 3] = e[3];\n  },\n  MAT3: (e, t, n) => {\n    t[9 * n + 0] = e[0], t[9 * n + 1] = e[1], t[9 * n + 2] = e[2], t[9 * n + 3] = e[3], t[9 * n + 4] = e[4], t[9 * n + 5] = e[5], t[9 * n + 6] = e[6], t[9 * n + 7] = e[7], t[9 * n + 8] = e[8], t[9 * n + 9] = e[9];\n  },\n  MAT4: (e, t, n) => {\n    t[16 * n + 0] = e[0], t[16 * n + 1] = e[1], t[16 * n + 2] = e[2], t[16 * n + 3] = e[3], t[16 * n + 4] = e[4], t[16 * n + 5] = e[5], t[16 * n + 6] = e[6], t[16 * n + 7] = e[7], t[16 * n + 8] = e[8], t[16 * n + 9] = e[9], t[16 * n + 10] = e[10], t[16 * n + 11] = e[11], t[16 * n + 12] = e[12], t[16 * n + 13] = e[13], t[16 * n + 14] = e[14], t[16 * n + 15] = e[15];\n  }\n};\nfunction Fd(e, t, n, s) {\n  const {\n    componentType: r\n  } = e;\n  U(e.componentType);\n  const i = typeof r == \"string\" ? Dt.fromName(r) : r, o = Id[e.type], a = Sd[e.type], c = Dd[e.type];\n  return n += e.byteOffset, {\n    values: Dt.createTypedArray(i, t, n, o * s),\n    type: i,\n    size: o,\n    unpacker: a,\n    packer: c\n  };\n}\nconst It = (e) => e !== void 0;\nfunction Od(e, t, n) {\n  if (!t)\n    return null;\n  let s = e.getExtension(\"3DTILES_batch_table_hierarchy\");\n  const r = t.HIERARCHY;\n  return r && (console.warn(\"3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.\"), t.extensions = t.extensions || {}, t.extensions[\"3DTILES_batch_table_hierarchy\"] = r, s = r), s ? vd(s, n) : null;\n}\nfunction vd(e, t) {\n  let n, s, r;\n  const i = e.instancesLength, o = e.classes;\n  let a = e.classIds, c = e.parentCounts, u = e.parentIds, l = i;\n  It(a.byteOffset) && (a.componentType = defaultValue(a.componentType, GL.UNSIGNED_SHORT), a.type = AttributeType.SCALAR, r = getBinaryAccessor(a), a = r.createArrayBufferView(t.buffer, t.byteOffset + a.byteOffset, i));\n  let h;\n  if (It(c))\n    for (It(c.byteOffset) && (c.componentType = defaultValue(c.componentType, GL.UNSIGNED_SHORT), c.type = AttributeType.SCALAR, r = getBinaryAccessor(c), c = r.createArrayBufferView(t.buffer, t.byteOffset + c.byteOffset, i)), h = new Uint16Array(i), l = 0, n = 0; n < i; ++n)\n      h[n] = l, l += c[n];\n  It(u) && It(u.byteOffset) && (u.componentType = defaultValue(u.componentType, GL.UNSIGNED_SHORT), u.type = AttributeType.SCALAR, r = getBinaryAccessor(u), u = r.createArrayBufferView(t.buffer, t.byteOffset + u.byteOffset, l));\n  const f = o.length;\n  for (n = 0; n < f; ++n) {\n    const p = o[n].length, y = o[n].instances, _ = getBinaryProperties(p, y, t);\n    o[n].instances = combine(_, y);\n  }\n  const d = new Array(f).fill(0), A = new Uint16Array(i);\n  for (n = 0; n < i; ++n)\n    s = a[n], A[n] = d[s], ++d[s];\n  const g = {\n    classes: o,\n    classIds: a,\n    classIndexes: A,\n    parentCounts: c,\n    parentIndexes: h,\n    parentIds: u\n  };\n  return Gd(g), g;\n}\nfunction Ae(e, t, n) {\n  if (!e)\n    return;\n  const s = e.parentCounts;\n  return e.parentIds ? n(e, t) : s > 0 ? xd(e, t, n) : Ld(e, t, n);\n}\nfunction xd(e, t, n) {\n  const s = e.classIds, r = e.parentCounts, i = e.parentIds, o = e.parentIndexes, a = s.length, c = scratchVisited;\n  c.length = Math.max(c.length, a);\n  const u = ++marker, l = scratchStack;\n  for (l.length = 0, l.push(t); l.length > 0; ) {\n    if (t = l.pop(), c[t] === u)\n      continue;\n    c[t] = u;\n    const h = n(e, t);\n    if (It(h))\n      return h;\n    const f = r[t], d = o[t];\n    for (let A = 0; A < f; ++A) {\n      const g = i[d + A];\n      g !== t && l.push(g);\n    }\n  }\n  return null;\n}\nfunction Ld(e, t, n) {\n  let s = !0;\n  for (; s; ) {\n    const r = n(e, t);\n    if (It(r))\n      return r;\n    const i = e.parentIds[t];\n    s = i !== t, t = i;\n  }\n  throw new Error(\"traverseHierarchySingleParent\");\n}\nfunction Gd(e) {\n  const n = e.classIds.length;\n  for (let s = 0; s < n; ++s)\n    Ko(e, s, stack);\n}\nfunction Ko(e, t, n) {\n  const s = e.parentCounts, r = e.parentIds, i = e.parentIndexes, a = e.classIds.length;\n  if (!It(r))\n    return;\n  assert(t < a, `Parent index ${t} exceeds the total number of instances: ${a}`), assert(n.indexOf(t) === -1, \"Circular dependency detected in the batch table hierarchy.\"), n.push(t);\n  const c = It(s) ? s[t] : 1, u = It(s) ? i[t] : t;\n  for (let l = 0; l < c; ++l) {\n    const h = r[u + l];\n    h !== t && Ko(e, h, n);\n  }\n  n.pop(t);\n}\nfunction rt(e) {\n  return e != null;\n}\nconst Ye = (e, t) => e, Ud = {\n  HIERARCHY: !0,\n  extensions: !0,\n  extras: !0\n};\nclass zo {\n  constructor(t, n, s) {\n    var r;\n    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    this.json = void 0, this.binary = void 0, this.featureCount = void 0, this._extensions = void 0, this._properties = void 0, this._binaryProperties = void 0, this._hierarchy = void 0, U(s >= 0), this.json = t || {}, this.binary = n, this.featureCount = s, this._extensions = ((r = this.json) === null || r === void 0 ? void 0 : r.extensions) || {}, this._properties = {};\n    for (const o in this.json)\n      Ud[o] || (this._properties[o] = this.json[o]);\n    this._binaryProperties = this._initializeBinaryProperties(), i[\"3DTILES_batch_table_hierarchy\"] && (this._hierarchy = Od(this, this.json, this.binary));\n  }\n  getExtension(t) {\n    return this.json && this.json.extensions && this.json.extensions[t];\n  }\n  memorySizeInBytes() {\n    return 0;\n  }\n  isClass(t, n) {\n    if (this._checkBatchId(t), U(typeof n == \"string\", n), this._hierarchy) {\n      const s = Ae(this._hierarchy, t, (r, i) => {\n        const o = r.classIds[i];\n        return r.classes[o].name === n;\n      });\n      return rt(s);\n    }\n    return !1;\n  }\n  isExactClass(t, n) {\n    return U(typeof n == \"string\", n), this.getExactClassName(t) === n;\n  }\n  getExactClassName(t) {\n    if (this._checkBatchId(t), this._hierarchy) {\n      const n = this._hierarchy.classIds[t];\n      return this._hierarchy.classes[n].name;\n    }\n  }\n  hasProperty(t, n) {\n    return this._checkBatchId(t), U(typeof n == \"string\", n), rt(this._properties[n]) || this._hasPropertyInHierarchy(t, n);\n  }\n  getPropertyNames(t, n) {\n    this._checkBatchId(t), n = rt(n) ? n : [], n.length = 0;\n    const s = Object.keys(this._properties);\n    return n.push(...s), this._hierarchy && this._getPropertyNamesInHierarchy(t, n), n;\n  }\n  getProperty(t, n) {\n    if (this._checkBatchId(t), U(typeof n == \"string\", n), this._binaryProperties) {\n      const r = this._binaryProperties[n];\n      if (rt(r))\n        return this._getBinaryProperty(r, t);\n    }\n    const s = this._properties[n];\n    if (rt(s))\n      return Ye(s[t]);\n    if (this._hierarchy) {\n      const r = this._getHierarchyProperty(t, n);\n      if (rt(r))\n        return r;\n    }\n  }\n  setProperty(t, n, s) {\n    const r = this.featureCount;\n    if (this._checkBatchId(t), U(typeof n == \"string\", n), this._binaryProperties) {\n      const o = this._binaryProperties[n];\n      if (o) {\n        this._setBinaryProperty(o, t, s);\n        return;\n      }\n    }\n    if (this._hierarchy && this._setHierarchyProperty(this, t, n, s))\n      return;\n    let i = this._properties[n];\n    rt(i) || (this._properties[n] = new Array(r), i = this._properties[n]), i[t] = Ye(s);\n  }\n  _checkBatchId(t) {\n    if (!(t >= 0 && t < this.featureCount))\n      throw new Error(\"batchId not in range [0, featureCount - 1].\");\n  }\n  _getBinaryProperty(t, n) {\n    return t.unpack(t.typedArray, n);\n  }\n  _setBinaryProperty(t, n, s) {\n    t.pack(s, t.typedArray, n);\n  }\n  _initializeBinaryProperties() {\n    let t = null;\n    for (const n in this._properties) {\n      const s = this._properties[n], r = this._initializeBinaryProperty(n, s);\n      r && (t = t || {}, t[n] = r);\n    }\n    return t;\n  }\n  _initializeBinaryProperty(t, n) {\n    if (\"byteOffset\" in n) {\n      const s = n;\n      U(this.binary, `Property ${t} requires a batch table binary.`), U(s.type, `Property ${t} requires a type.`);\n      const r = Fd(s, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);\n      return {\n        typedArray: r.values,\n        componentCount: r.size,\n        unpack: r.unpacker,\n        pack: r.packer\n      };\n    }\n    return null;\n  }\n  _hasPropertyInHierarchy(t, n) {\n    if (!this._hierarchy)\n      return !1;\n    const s = Ae(this._hierarchy, t, (r, i) => {\n      const o = r.classIds[i], a = r.classes[o].instances;\n      return rt(a[n]);\n    });\n    return rt(s);\n  }\n  _getPropertyNamesInHierarchy(t, n) {\n    Ae(this._hierarchy, t, (s, r) => {\n      const i = s.classIds[r], o = s.classes[i].instances;\n      for (const a in o)\n        o.hasOwnProperty(a) && n.indexOf(a) === -1 && n.push(a);\n    });\n  }\n  _getHierarchyProperty(t, n) {\n    return Ae(this._hierarchy, t, (s, r) => {\n      const i = s.classIds[r], o = s.classes[i], a = s.classIndexes[r], c = o.instances[n];\n      return rt(c) ? rt(c.typedArray) ? this._getBinaryProperty(c, a) : Ye(c[a]) : null;\n    });\n  }\n  _setHierarchyProperty(t, n, s, r) {\n    const i = Ae(this._hierarchy, n, (o, a) => {\n      const c = o.classIds[a], u = o.classes[c], l = o.classIndexes[a], h = u.instances[s];\n      return rt(h) ? (U(a === n, `Inherited property \"${s}\" is read-only.`), rt(h.typedArray) ? this._setBinaryProperty(h, l, r) : h[l] = Ye(r), !0) : !1;\n    });\n    return rt(i);\n  }\n}\nconst es = 4;\nfunction Rn(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  const s = new DataView(t);\n  if (e.magic = s.getUint32(n, !0), n += es, e.version = s.getUint32(n, !0), n += es, e.byteLength = s.getUint32(n, !0), n += es, e.version !== 1)\n    throw new Error(`3D Tile Version ${e.version} not supported`);\n  return n;\n}\nconst ne = 4, di = \"b3dm tile in legacy format.\";\nfunction ks(e, t, n) {\n  const s = new DataView(t);\n  let r;\n  e.header = e.header || {};\n  let i = s.getUint32(n, !0);\n  n += ne;\n  let o = s.getUint32(n, !0);\n  n += ne;\n  let a = s.getUint32(n, !0);\n  n += ne;\n  let c = s.getUint32(n, !0);\n  return n += ne, a >= 570425344 ? (n -= ne * 2, r = i, a = o, c = 0, i = 0, o = 0, console.warn(di)) : c >= 570425344 && (n -= ne, r = a, a = i, c = o, i = 0, o = 0, console.warn(di)), e.header.featureTableJsonByteLength = i, e.header.featureTableBinaryByteLength = o, e.header.batchTableJsonByteLength = a, e.header.batchTableBinaryByteLength = c, e.header.batchLength = r, n;\n}\nfunction js(e, t, n, s) {\n  return n = Pd(e, t, n), n = Nd(e, t, n), n;\n}\nfunction Pd(e, t, n, s) {\n  const {\n    featureTableJsonByteLength: r,\n    featureTableBinaryByteLength: i,\n    batchLength: o\n  } = e.header || {};\n  if (e.featureTableJson = {\n    BATCH_LENGTH: o || 0\n  }, r && r > 0) {\n    const a = Vo(t, n, r);\n    e.featureTableJson = JSON.parse(a);\n  }\n  return n += r || 0, e.featureTableBinary = new Uint8Array(t, n, i), n += i || 0, n;\n}\nfunction Nd(e, t, n, s) {\n  const {\n    batchTableJsonByteLength: r,\n    batchTableBinaryByteLength: i\n  } = e.header || {};\n  if (r && r > 0) {\n    const o = Vo(t, n, r);\n    e.batchTableJson = JSON.parse(o), n += r, i && i > 0 && (e.batchTableBinary = new Uint8Array(t, n, i), e.batchTableBinary = new Uint8Array(e.batchTableBinary), n += i);\n  }\n  return n;\n}\nfunction Wo(e, t, n) {\n  if (!t && (!e || !e.batchIds || !n))\n    return null;\n  const {\n    batchIds: s,\n    isRGB565: r,\n    pointCount: i = 0\n  } = e;\n  if (s && n) {\n    const o = new Uint8ClampedArray(i * 3);\n    for (let a = 0; a < i; a++) {\n      const c = s[a], l = n.getProperty(c, \"dimensions\").map((h) => h * 255);\n      o[a * 3] = l[0], o[a * 3 + 1] = l[1], o[a * 3 + 2] = l[2];\n    }\n    return {\n      type: x.UNSIGNED_BYTE,\n      value: o,\n      size: 3,\n      normalized: !0\n    };\n  }\n  if (t && r) {\n    const o = new Uint8ClampedArray(i * 3);\n    for (let a = 0; a < i; a++) {\n      const c = wd(t[a]);\n      o[a * 3] = c[0], o[a * 3 + 1] = c[1], o[a * 3 + 2] = c[2];\n    }\n    return {\n      type: x.UNSIGNED_BYTE,\n      value: o,\n      size: 3,\n      normalized: !0\n    };\n  }\n  return t && t.length === i * 3 ? {\n    type: x.UNSIGNED_BYTE,\n    value: t,\n    size: 3,\n    normalized: !0\n  } : {\n    type: x.UNSIGNED_BYTE,\n    value: t || new Uint8ClampedArray(),\n    size: 4,\n    normalized: !0\n  };\n}\nconst mi = new m();\nfunction Hd(e, t) {\n  if (!t)\n    return null;\n  if (e.isOctEncoded16P) {\n    const n = new Float32Array((e.pointsLength || 0) * 3);\n    for (let s = 0; s < (e.pointsLength || 0); s++)\n      Rd(t[s * 2], t[s * 2 + 1], mi), mi.toArray(n, s * 3);\n    return {\n      type: x.FLOAT,\n      size: 2,\n      value: n\n    };\n  }\n  return {\n    type: x.FLOAT,\n    size: 2,\n    value: t\n  };\n}\nfunction Jd(e, t, n) {\n  return e.isQuantized ? n[\"3d-tiles\"] && n[\"3d-tiles\"].decodeQuantizedPositions ? (e.isQuantized = !1, Vd(e, t)) : {\n    type: x.UNSIGNED_SHORT,\n    value: t,\n    size: 3,\n    normalized: !0\n  } : t;\n}\nfunction Vd(e, t) {\n  const n = new m(), s = new Float32Array(e.pointCount * 3);\n  for (let r = 0; r < e.pointCount; r++)\n    n.set(t[r * 3], t[r * 3 + 1], t[r * 3 + 2]).scale(1 / e.quantizedRange).multiply(e.quantizedVolumeScale).add(e.quantizedVolumeOffset).toArray(s, r * 3);\n  return s;\n}\nasync function kd(e, t, n, s, r) {\n  n = Rn(e, t, n), n = ks(e, t, n), n = js(e, t, n), jd(e);\n  const {\n    featureTable: i,\n    batchTable: o\n  } = Kd(e);\n  return await qd(e, i, o, s, r), zd(e, i, s), Wd(e, i, o), Xd(e, i), n;\n}\nfunction jd(e) {\n  e.attributes = {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, e.isQuantized = !1, e.isTranslucent = !1, e.isRGB565 = !1, e.isOctEncoded16P = !1;\n}\nfunction Kd(e) {\n  const t = new Vs(e.featureTableJson, e.featureTableBinary), n = t.getGlobalProperty(\"POINTS_LENGTH\");\n  if (!Number.isFinite(n))\n    throw new Error(\"POINTS_LENGTH must be defined\");\n  t.featuresLength = n, e.featuresLength = n, e.pointsLength = n, e.pointCount = n, e.rtcCenter = t.getGlobalProperty(\"RTC_CENTER\", x.FLOAT, 3);\n  const s = Qd(e, t);\n  return {\n    featureTable: t,\n    batchTable: s\n  };\n}\nfunction zd(e, t, n) {\n  if (e.attributes = e.attributes || {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, !e.attributes.positions) {\n    if (t.hasProperty(\"POSITION\"))\n      e.attributes.positions = t.getPropertyArray(\"POSITION\", x.FLOAT, 3);\n    else if (t.hasProperty(\"POSITION_QUANTIZED\")) {\n      const s = t.getPropertyArray(\"POSITION_QUANTIZED\", x.UNSIGNED_SHORT, 3);\n      if (e.isQuantized = !0, e.quantizedRange = 65535, e.quantizedVolumeScale = t.getGlobalProperty(\"QUANTIZED_VOLUME_SCALE\", x.FLOAT, 3), !e.quantizedVolumeScale)\n        throw new Error(\"QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\");\n      if (e.quantizedVolumeOffset = t.getGlobalProperty(\"QUANTIZED_VOLUME_OFFSET\", x.FLOAT, 3), !e.quantizedVolumeOffset)\n        throw new Error(\"QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\");\n      e.attributes.positions = Jd(e, s, n);\n    }\n  }\n  if (!e.attributes.positions)\n    throw new Error(\"Either POSITION or POSITION_QUANTIZED must be defined.\");\n}\nfunction Wd(e, t, n) {\n  if (e.attributes = e.attributes || {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, !e.attributes.colors) {\n    let s = null;\n    t.hasProperty(\"RGBA\") ? (s = t.getPropertyArray(\"RGBA\", x.UNSIGNED_BYTE, 4), e.isTranslucent = !0) : t.hasProperty(\"RGB\") ? s = t.getPropertyArray(\"RGB\", x.UNSIGNED_BYTE, 3) : t.hasProperty(\"RGB565\") && (s = t.getPropertyArray(\"RGB565\", x.UNSIGNED_SHORT, 1), e.isRGB565 = !0), e.attributes.colors = Wo(e, s, n);\n  }\n  t.hasProperty(\"CONSTANT_RGBA\") && (e.constantRGBA = t.getGlobalProperty(\"CONSTANT_RGBA\", x.UNSIGNED_BYTE, 4));\n}\nfunction Xd(e, t) {\n  if (e.attributes = e.attributes || {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, !e.attributes.normals) {\n    let n = null;\n    t.hasProperty(\"NORMAL\") ? n = t.getPropertyArray(\"NORMAL\", x.FLOAT, 3) : t.hasProperty(\"NORMAL_OCT16P\") && (n = t.getPropertyArray(\"NORMAL_OCT16P\", x.UNSIGNED_BYTE, 2), e.isOctEncoded16P = !0), e.attributes.normals = Hd(e, n);\n  }\n}\nfunction Qd(e, t) {\n  let n = null;\n  if (!e.batchIds && t.hasProperty(\"BATCH_ID\") && (e.batchIds = t.getPropertyArray(\"BATCH_ID\", x.UNSIGNED_SHORT, 1), e.batchIds)) {\n    const s = t.getGlobalProperty(\"BATCH_LENGTH\");\n    if (!s)\n      throw new Error(\"Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.\");\n    const {\n      batchTableJson: r,\n      batchTableBinary: i\n    } = e;\n    n = new zo(r, i, s);\n  }\n  return n;\n}\nasync function qd(e, t, n, s, r) {\n  let i, o, a;\n  const c = e.batchTableJson && e.batchTableJson.extensions && e.batchTableJson.extensions[\"3DTILES_draco_point_compression\"];\n  c && (a = c.properties);\n  const u = t.getExtension(\"3DTILES_draco_point_compression\");\n  if (u) {\n    o = u.properties;\n    const h = u.byteOffset, f = u.byteLength;\n    if (!o || !Number.isFinite(h) || !f)\n      throw new Error(\"Draco properties, byteOffset, and byteLength must be defined\");\n    i = (e.featureTableBinary || []).slice(h, h + f), e.hasPositions = Number.isFinite(o.POSITION), e.hasColors = Number.isFinite(o.RGB) || Number.isFinite(o.RGBA), e.hasNormals = Number.isFinite(o.NORMAL), e.hasBatchIds = Number.isFinite(o.BATCH_ID), e.isTranslucent = Number.isFinite(o.RGBA);\n  }\n  if (!i)\n    return !0;\n  const l = {\n    buffer: i,\n    properties: {\n      ...o,\n      ...a\n    },\n    featureTableProperties: o,\n    batchTableProperties: a,\n    dequantizeInShader: !1\n  };\n  return await Yd(e, l, s, r);\n}\nasync function Yd(e, t, n, s) {\n  if (!s)\n    return;\n  const r = {\n    ...n,\n    draco: {\n      ...n == null ? void 0 : n.draco,\n      extraAttributes: t.batchTableProperties || {}\n    }\n  };\n  delete r[\"3d-tiles\"];\n  const i = await Re(t.buffer, jo, r, s), o = i.attributes.POSITION && i.attributes.POSITION.value, a = i.attributes.COLOR_0 && i.attributes.COLOR_0.value, c = i.attributes.NORMAL && i.attributes.NORMAL.value, u = i.attributes.BATCH_ID && i.attributes.BATCH_ID.value, l = o && i.attributes.POSITION.value.quantization, h = c && i.attributes.NORMAL.value.quantization;\n  if (l) {\n    const d = i.POSITION.data.quantization, A = d.range;\n    e.quantizedVolumeScale = new m(A, A, A), e.quantizedVolumeOffset = new m(d.minValues), e.quantizedRange = (1 << d.quantizationBits) - 1, e.isQuantizedDraco = !0;\n  }\n  h && (e.octEncodedRange = (1 << i.NORMAL.data.quantization.quantizationBits) - 1, e.isOctEncodedDraco = !0);\n  const f = {};\n  if (t.batchTableProperties)\n    for (const d of Object.keys(t.batchTableProperties))\n      i.attributes[d] && i.attributes[d].value && (f[d.toLowerCase()] = i.attributes[d].value);\n  e.attributes = {\n    positions: o,\n    colors: Wo(e, a, void 0),\n    normals: c,\n    batchIds: u,\n    ...f\n  };\n}\nconst $d = \"4.1.1\";\nvar ns;\nconst Zd = (ns = globalThis.loaders) === null || ns === void 0 ? void 0 : ns.parseImageNode, Ts = typeof Image < \"u\", Es = typeof ImageBitmap < \"u\", tm = !!Zd, bs = Cn ? !0 : tm;\nfunction em(e) {\n  switch (e) {\n    case \"auto\":\n      return Es || Ts || bs;\n    case \"imagebitmap\":\n      return Es;\n    case \"image\":\n      return Ts;\n    case \"data\":\n      return bs;\n    default:\n      throw new Error(`@loaders.gl/images: image ${e} not supported in this environment`);\n  }\n}\nfunction nm() {\n  if (Es)\n    return \"imagebitmap\";\n  if (Ts)\n    return \"image\";\n  if (bs)\n    return \"data\";\n  throw new Error(\"Install '@loaders.gl/polyfills' to parse images under Node.js\");\n}\nfunction sm(e) {\n  const t = rm(e);\n  if (!t)\n    throw new Error(\"Not an image\");\n  return t;\n}\nfunction Xo(e) {\n  switch (sm(e)) {\n    case \"data\":\n      return e;\n    case \"image\":\n    case \"imagebitmap\":\n      const t = document.createElement(\"canvas\"), n = t.getContext(\"2d\");\n      if (!n)\n        throw new Error(\"getImageData\");\n      return t.width = e.width, t.height = e.height, n.drawImage(e, 0, 0), n.getImageData(0, 0, e.width, e.height);\n    default:\n      throw new Error(\"getImageData\");\n  }\n}\nfunction rm(e) {\n  return typeof ImageBitmap < \"u\" && e instanceof ImageBitmap ? \"imagebitmap\" : typeof Image < \"u\" && e instanceof Image ? \"image\" : e && typeof e == \"object\" && e.data && e.width && e.height ? \"data\" : null;\n}\nconst im = /^data:image\\/svg\\+xml/, om = /\\.svg((\\?|#).*)?$/;\nfunction Ks(e) {\n  return e && (im.test(e) || om.test(e));\n}\nfunction am(e, t) {\n  if (Ks(t)) {\n    let s = new TextDecoder().decode(e);\n    try {\n      typeof unescape == \"function\" && typeof encodeURIComponent == \"function\" && (s = unescape(encodeURIComponent(s)));\n    } catch (i) {\n      throw new Error(i.message);\n    }\n    return `data:image/svg+xml;base64,${btoa(s)}`;\n  }\n  return Qo(e, t);\n}\nfunction Qo(e, t) {\n  if (Ks(t))\n    throw new Error(\"SVG cannot be parsed directly to imagebitmap\");\n  return new Blob([new Uint8Array(e)]);\n}\nasync function qo(e, t, n) {\n  const s = am(e, n), r = self.URL || self.webkitURL, i = typeof s != \"string\" && r.createObjectURL(s);\n  try {\n    return await cm(i || s, t);\n  } finally {\n    i && r.revokeObjectURL(i);\n  }\n}\nasync function cm(e, t) {\n  const n = new Image();\n  return n.src = e, t.image && t.image.decode && n.decode ? (await n.decode(), n) : await new Promise((s, r) => {\n    try {\n      n.onload = () => s(n), n.onerror = (i) => {\n        const o = i instanceof Error ? i.message : \"error\";\n        r(new Error(o));\n      };\n    } catch (i) {\n      r(i);\n    }\n  });\n}\nconst um = {};\nlet Ai = !0;\nasync function lm(e, t, n) {\n  let s;\n  Ks(n) ? s = await qo(e, t, n) : s = Qo(e, n);\n  const r = t && t.imagebitmap;\n  return await hm(s, r);\n}\nasync function hm(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n  if ((fm(t) || !Ai) && (t = null), t)\n    try {\n      return await createImageBitmap(e, t);\n    } catch (n) {\n      console.warn(n), Ai = !1;\n    }\n  return await createImageBitmap(e);\n}\nfunction fm(e) {\n  for (const t in e || um)\n    return !1;\n  return !0;\n}\nfunction dm(e) {\n  return !pm(e, \"ftyp\", 4) || !(e[8] & 96) ? null : mm(e);\n}\nfunction mm(e) {\n  switch (Am(e, 8, 12).replace(\"\\0\", \" \").trim()) {\n    case \"avif\":\n    case \"avis\":\n      return {\n        extension: \"avif\",\n        mimeType: \"image/avif\"\n      };\n    default:\n      return null;\n  }\n}\nfunction Am(e, t, n) {\n  return String.fromCharCode(...e.slice(t, n));\n}\nfunction gm(e) {\n  return [...e].map((t) => t.charCodeAt(0));\n}\nfunction pm(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  const s = gm(t);\n  for (let r = 0; r < s.length; ++r)\n    if (s[r] !== e[r + n])\n      return !1;\n  return !0;\n}\nconst St = !1, Ee = !0;\nfunction zs(e) {\n  const t = xe(e);\n  return ym(t) || Em(t) || Cm(t) || Tm(t) || Bm(t);\n}\nfunction Bm(e) {\n  const t = new Uint8Array(e instanceof DataView ? e.buffer : e), n = dm(t);\n  return n ? {\n    mimeType: n.mimeType,\n    width: 0,\n    height: 0\n  } : null;\n}\nfunction ym(e) {\n  const t = xe(e);\n  return t.byteLength >= 24 && t.getUint32(0, St) === 2303741511 ? {\n    mimeType: \"image/png\",\n    width: t.getUint32(16, St),\n    height: t.getUint32(20, St)\n  } : null;\n}\nfunction Cm(e) {\n  const t = xe(e);\n  return t.byteLength >= 10 && t.getUint32(0, St) === 1195984440 ? {\n    mimeType: \"image/gif\",\n    width: t.getUint16(6, Ee),\n    height: t.getUint16(8, Ee)\n  } : null;\n}\nfunction Tm(e) {\n  const t = xe(e);\n  return t.byteLength >= 14 && t.getUint16(0, St) === 16973 && t.getUint32(2, Ee) === t.byteLength ? {\n    mimeType: \"image/bmp\",\n    width: t.getUint32(18, Ee),\n    height: t.getUint32(22, Ee)\n  } : null;\n}\nfunction Em(e) {\n  const t = xe(e);\n  if (!(t.byteLength >= 3 && t.getUint16(0, St) === 65496 && t.getUint8(2) === 255))\n    return null;\n  const {\n    tableMarkers: s,\n    sofMarkers: r\n  } = bm();\n  let i = 2;\n  for (; i + 9 < t.byteLength; ) {\n    const o = t.getUint16(i, St);\n    if (r.has(o))\n      return {\n        mimeType: \"image/jpeg\",\n        height: t.getUint16(i + 5, St),\n        width: t.getUint16(i + 7, St)\n      };\n    if (!s.has(o))\n      return null;\n    i += 2, i += t.getUint16(i, St);\n  }\n  return null;\n}\nfunction bm() {\n  const e = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);\n  for (let n = 65504; n < 65520; ++n)\n    e.add(n);\n  return {\n    tableMarkers: e,\n    sofMarkers: /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502])\n  };\n}\nfunction xe(e) {\n  if (e instanceof DataView)\n    return e;\n  if (ArrayBuffer.isView(e))\n    return new DataView(e.buffer);\n  if (e instanceof ArrayBuffer)\n    return new DataView(e);\n  throw new Error(\"toDataView\");\n}\nasync function _m(e, t) {\n  var n;\n  const {\n    mimeType: s\n  } = zs(e) || {}, r = (n = globalThis.loaders) === null || n === void 0 ? void 0 : n.parseImageNode;\n  return U(r), await r(e, s);\n}\nasync function wm(e, t, n) {\n  t = t || {};\n  const r = (t.image || {}).type || \"auto\", {\n    url: i\n  } = n || {}, o = Mm(r);\n  let a;\n  switch (o) {\n    case \"imagebitmap\":\n      a = await lm(e, t, i);\n      break;\n    case \"image\":\n      a = await qo(e, t, i);\n      break;\n    case \"data\":\n      a = await _m(e);\n      break;\n    default:\n      U(!1);\n  }\n  return r === \"data\" && (a = Xo(a)), a;\n}\nfunction Mm(e) {\n  switch (e) {\n    case \"auto\":\n    case \"data\":\n      return nm();\n    default:\n      return em(e), e;\n  }\n}\nconst Rm = [\"png\", \"jpg\", \"jpeg\", \"gif\", \"webp\", \"bmp\", \"ico\", \"svg\", \"avif\"], Im = [\"image/png\", \"image/jpeg\", \"image/gif\", \"image/webp\", \"image/avif\", \"image/bmp\", \"image/vnd.microsoft.icon\", \"image/svg+xml\"], Sm = {\n  image: {\n    type: \"auto\",\n    decode: !0\n  }\n}, Dm = {\n  id: \"image\",\n  module: \"images\",\n  name: \"Images\",\n  version: $d,\n  mimeTypes: Im,\n  extensions: Rm,\n  parse: wm,\n  tests: [(e) => !!zs(new DataView(e))],\n  options: Sm\n}, ss = {};\nfunction Fm(e) {\n  if (ss[e] === void 0) {\n    const t = Cn ? vm(e) : Om(e);\n    ss[e] = t;\n  }\n  return ss[e];\n}\nfunction Om(e) {\n  var t, n;\n  const s = [\"image/png\", \"image/jpeg\", \"image/gif\"], r = ((t = globalThis.loaders) === null || t === void 0 ? void 0 : t.imageFormatsNode) || s;\n  return !!((n = globalThis.loaders) === null || n === void 0 ? void 0 : n.parseImageNode) && r.includes(e);\n}\nfunction vm(e) {\n  switch (e) {\n    case \"image/avif\":\n    case \"image/webp\":\n      return xm(e);\n    default:\n      return !0;\n  }\n}\nfunction xm(e) {\n  try {\n    return document.createElement(\"canvas\").toDataURL(e).indexOf(`data:${e}`) === 0;\n  } catch {\n    return !1;\n  }\n}\nfunction ft(e, t) {\n  if (!e)\n    throw new Error(t || \"assert failed: gltf\");\n}\nconst Yo = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n}, $o = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n}, Lm = 1.33, gi = [\"SCALAR\", \"VEC2\", \"VEC3\", \"VEC4\"], Gm = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]], Um = new Map(Gm), Pm = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n}, Nm = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n}, Hm = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nfunction Zo(e) {\n  return gi[e - 1] || gi[0];\n}\nfunction Ws(e) {\n  const t = Um.get(e.constructor);\n  if (!t)\n    throw new Error(\"Illegal typed array\");\n  return t;\n}\nfunction Xs(e, t) {\n  const n = Hm[e.componentType], s = Pm[e.type], r = Nm[e.componentType], i = e.count * s, o = e.count * s * r;\n  ft(o >= 0 && o <= t.byteLength);\n  const a = $o[e.componentType], c = Yo[e.type];\n  return {\n    ArrayType: n,\n    length: i,\n    byteLength: o,\n    componentByteSize: a,\n    numberOfComponentsInElement: c\n  };\n}\nfunction ta(e) {\n  let {\n    images: t,\n    bufferViews: n\n  } = e;\n  t = t || [], n = n || [];\n  const s = t.map((o) => o.bufferView);\n  n = n.filter((o) => !s.includes(o));\n  const r = n.reduce((o, a) => o + a.byteLength, 0), i = t.reduce((o, a) => {\n    const {\n      width: c,\n      height: u\n    } = a.image;\n    return o + c * u;\n  }, 0);\n  return r + Math.ceil(4 * i * Lm);\n}\nfunction Jm(e, t, n) {\n  const s = e.bufferViews[n];\n  ft(s);\n  const r = s.buffer, i = t[r];\n  ft(i);\n  const o = (s.byteOffset || 0) + i.byteOffset;\n  return new Uint8Array(i.arrayBuffer, o, s.byteLength);\n}\nfunction Vm(e, t, n) {\n  var s, r;\n  const i = typeof n == \"number\" ? (s = e.accessors) === null || s === void 0 ? void 0 : s[n] : n;\n  if (!i)\n    throw new Error(`No gltf accessor ${JSON.stringify(n)}`);\n  const o = (r = e.bufferViews) === null || r === void 0 ? void 0 : r[i.bufferView || 0];\n  if (!o)\n    throw new Error(`No gltf buffer view for accessor ${o}`);\n  const {\n    arrayBuffer: a,\n    byteOffset: c\n  } = t[o.buffer], u = (c || 0) + (i.byteOffset || 0) + (o.byteOffset || 0), {\n    ArrayType: l,\n    length: h,\n    componentByteSize: f,\n    numberOfComponentsInElement: d\n  } = Xs(i, o), A = f * d, g = o.byteStride || A;\n  if (typeof o.byteStride > \"u\" || o.byteStride === A)\n    return new l(a, u, h);\n  const p = new l(h);\n  for (let y = 0; y < i.count; y++) {\n    const _ = new l(a, u + y * g, d);\n    p.set(_, y * d);\n  }\n  return p;\n}\nfunction km() {\n  return {\n    asset: {\n      version: \"2.0\",\n      generator: \"loaders.gl\"\n    },\n    buffers: [],\n    extensions: {},\n    extensionsRequired: [],\n    extensionsUsed: []\n  };\n}\nclass Z {\n  constructor(t) {\n    this.gltf = void 0, this.sourceBuffers = void 0, this.byteLength = void 0, this.gltf = {\n      json: (t == null ? void 0 : t.json) || km(),\n      buffers: (t == null ? void 0 : t.buffers) || [],\n      images: (t == null ? void 0 : t.images) || []\n    }, this.sourceBuffers = [], this.byteLength = 0, this.gltf.buffers && this.gltf.buffers[0] && (this.byteLength = this.gltf.buffers[0].byteLength, this.sourceBuffers = [this.gltf.buffers[0]]);\n  }\n  get json() {\n    return this.gltf.json;\n  }\n  getApplicationData(t) {\n    return this.json[t];\n  }\n  getExtraData(t) {\n    return (this.json.extras || {})[t];\n  }\n  hasExtension(t) {\n    const n = this.getUsedExtensions().find((r) => r === t), s = this.getRequiredExtensions().find((r) => r === t);\n    return typeof n == \"string\" || typeof s == \"string\";\n  }\n  getExtension(t) {\n    const n = this.getUsedExtensions().find((r) => r === t), s = this.json.extensions || {};\n    return n ? s[t] : null;\n  }\n  getRequiredExtension(t) {\n    return this.getRequiredExtensions().find((s) => s === t) ? this.getExtension(t) : null;\n  }\n  getRequiredExtensions() {\n    return this.json.extensionsRequired || [];\n  }\n  getUsedExtensions() {\n    return this.json.extensionsUsed || [];\n  }\n  getRemovedExtensions() {\n    return this.json.extensionsRemoved || [];\n  }\n  getObjectExtension(t, n) {\n    return (t.extensions || {})[n];\n  }\n  getScene(t) {\n    return this.getObject(\"scenes\", t);\n  }\n  getNode(t) {\n    return this.getObject(\"nodes\", t);\n  }\n  getSkin(t) {\n    return this.getObject(\"skins\", t);\n  }\n  getMesh(t) {\n    return this.getObject(\"meshes\", t);\n  }\n  getMaterial(t) {\n    return this.getObject(\"materials\", t);\n  }\n  getAccessor(t) {\n    return this.getObject(\"accessors\", t);\n  }\n  getTexture(t) {\n    return this.getObject(\"textures\", t);\n  }\n  getSampler(t) {\n    return this.getObject(\"samplers\", t);\n  }\n  getImage(t) {\n    return this.getObject(\"images\", t);\n  }\n  getBufferView(t) {\n    return this.getObject(\"bufferViews\", t);\n  }\n  getBuffer(t) {\n    return this.getObject(\"buffers\", t);\n  }\n  getObject(t, n) {\n    if (typeof n == \"object\")\n      return n;\n    const s = this.json[t] && this.json[t][n];\n    if (!s)\n      throw new Error(`glTF file error: Could not find ${t}[${n}]`);\n    return s;\n  }\n  getTypedArrayForBufferView(t) {\n    t = this.getBufferView(t);\n    const n = t.buffer, s = this.gltf.buffers[n];\n    ft(s);\n    const r = (t.byteOffset || 0) + s.byteOffset;\n    return new Uint8Array(s.arrayBuffer, r, t.byteLength);\n  }\n  getTypedArrayForAccessor(t) {\n    const n = this.getAccessor(t);\n    return Vm(this.gltf.json, this.gltf.buffers, n);\n  }\n  getTypedArrayForImageData(t) {\n    t = this.getAccessor(t);\n    const n = this.getBufferView(t.bufferView), r = this.getBuffer(n.buffer).data, i = n.byteOffset || 0;\n    return new Uint8Array(r, i, n.byteLength);\n  }\n  addApplicationData(t, n) {\n    return this.json[t] = n, this;\n  }\n  addExtraData(t, n) {\n    return this.json.extras = this.json.extras || {}, this.json.extras[t] = n, this;\n  }\n  addObjectExtension(t, n, s) {\n    return t.extensions = t.extensions || {}, t.extensions[n] = s, this.registerUsedExtension(n), this;\n  }\n  setObjectExtension(t, n, s) {\n    const r = t.extensions || {};\n    r[n] = s;\n  }\n  removeObjectExtension(t, n) {\n    const s = (t == null ? void 0 : t.extensions) || {};\n    if (s[n]) {\n      this.json.extensionsRemoved = this.json.extensionsRemoved || [];\n      const r = this.json.extensionsRemoved;\n      r.includes(n) || r.push(n);\n    }\n    delete s[n];\n  }\n  addExtension(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return ft(n), this.json.extensions = this.json.extensions || {}, this.json.extensions[t] = n, this.registerUsedExtension(t), n;\n  }\n  addRequiredExtension(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return ft(n), this.addExtension(t, n), this.registerRequiredExtension(t), n;\n  }\n  registerUsedExtension(t) {\n    this.json.extensionsUsed = this.json.extensionsUsed || [], this.json.extensionsUsed.find((n) => n === t) || this.json.extensionsUsed.push(t);\n  }\n  registerRequiredExtension(t) {\n    this.registerUsedExtension(t), this.json.extensionsRequired = this.json.extensionsRequired || [], this.json.extensionsRequired.find((n) => n === t) || this.json.extensionsRequired.push(t);\n  }\n  removeExtension(t) {\n    var n;\n    if ((n = this.json.extensions) !== null && n !== void 0 && n[t]) {\n      this.json.extensionsRemoved = this.json.extensionsRemoved || [];\n      const s = this.json.extensionsRemoved;\n      s.includes(t) || s.push(t);\n    }\n    this.json.extensions && delete this.json.extensions[t], this.json.extensionsRequired && this._removeStringFromArray(this.json.extensionsRequired, t), this.json.extensionsUsed && this._removeStringFromArray(this.json.extensionsUsed, t);\n  }\n  setDefaultScene(t) {\n    this.json.scene = t;\n  }\n  addScene(t) {\n    const {\n      nodeIndices: n\n    } = t;\n    return this.json.scenes = this.json.scenes || [], this.json.scenes.push({\n      nodes: n\n    }), this.json.scenes.length - 1;\n  }\n  addNode(t) {\n    const {\n      meshIndex: n,\n      matrix: s\n    } = t;\n    this.json.nodes = this.json.nodes || [];\n    const r = {\n      mesh: n\n    };\n    return s && (r.matrix = s), this.json.nodes.push(r), this.json.nodes.length - 1;\n  }\n  addMesh(t) {\n    const {\n      attributes: n,\n      indices: s,\n      material: r,\n      mode: i = 4\n    } = t, a = {\n      primitives: [{\n        attributes: this._addAttributes(n),\n        mode: i\n      }]\n    };\n    if (s) {\n      const c = this._addIndices(s);\n      a.primitives[0].indices = c;\n    }\n    return Number.isFinite(r) && (a.primitives[0].material = r), this.json.meshes = this.json.meshes || [], this.json.meshes.push(a), this.json.meshes.length - 1;\n  }\n  addPointCloud(t) {\n    const s = {\n      primitives: [{\n        attributes: this._addAttributes(t),\n        mode: 0\n      }]\n    };\n    return this.json.meshes = this.json.meshes || [], this.json.meshes.push(s), this.json.meshes.length - 1;\n  }\n  addImage(t, n) {\n    const s = zs(t), r = n || (s == null ? void 0 : s.mimeType), o = {\n      bufferView: this.addBufferView(t),\n      mimeType: r\n    };\n    return this.json.images = this.json.images || [], this.json.images.push(o), this.json.images.length - 1;\n  }\n  addBufferView(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.byteLength;\n    const r = t.byteLength;\n    ft(Number.isFinite(r)), this.sourceBuffers = this.sourceBuffers || [], this.sourceBuffers.push(t);\n    const i = {\n      buffer: n,\n      byteOffset: s,\n      byteLength: r\n    };\n    return this.byteLength += Ie(r, 4), this.json.bufferViews = this.json.bufferViews || [], this.json.bufferViews.push(i), this.json.bufferViews.length - 1;\n  }\n  addAccessor(t, n) {\n    const s = {\n      bufferView: t,\n      type: Zo(n.size),\n      componentType: n.componentType,\n      count: n.count,\n      max: n.max,\n      min: n.min\n    };\n    return this.json.accessors = this.json.accessors || [], this.json.accessors.push(s), this.json.accessors.length - 1;\n  }\n  addBinaryBuffer(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n      size: 3\n    };\n    const s = this.addBufferView(t);\n    let r = {\n      min: n.min,\n      max: n.max\n    };\n    (!r.min || !r.max) && (r = this._getAccessorMinMax(t, n.size));\n    const i = {\n      size: n.size,\n      componentType: Ws(t),\n      count: Math.round(t.length / n.size),\n      min: r.min,\n      max: r.max\n    };\n    return this.addAccessor(s, Object.assign(i, n));\n  }\n  addTexture(t) {\n    const {\n      imageIndex: n\n    } = t, s = {\n      source: n\n    };\n    return this.json.textures = this.json.textures || [], this.json.textures.push(s), this.json.textures.length - 1;\n  }\n  addMaterial(t) {\n    return this.json.materials = this.json.materials || [], this.json.materials.push(t), this.json.materials.length - 1;\n  }\n  createBinaryChunk() {\n    var t, n;\n    this.gltf.buffers = [];\n    const s = this.byteLength, r = new ArrayBuffer(s), i = new Uint8Array(r);\n    let o = 0;\n    for (const a of this.sourceBuffers || [])\n      o = Dc(a, i, o);\n    (t = this.json) !== null && t !== void 0 && (n = t.buffers) !== null && n !== void 0 && n[0] ? this.json.buffers[0].byteLength = s : this.json.buffers = [{\n      byteLength: s\n    }], this.gltf.binary = r, this.sourceBuffers = [r];\n  }\n  _removeStringFromArray(t, n) {\n    let s = !0;\n    for (; s; ) {\n      const r = t.indexOf(n);\n      r > -1 ? t.splice(r, 1) : s = !1;\n    }\n  }\n  _addAttributes() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const n = {};\n    for (const s in t) {\n      const r = t[s], i = this._getGltfAttributeName(s), o = this.addBinaryBuffer(r.value, r);\n      n[i] = o;\n    }\n    return n;\n  }\n  _addIndices(t) {\n    return this.addBinaryBuffer(t, {\n      size: 1\n    });\n  }\n  _getGltfAttributeName(t) {\n    switch (t.toLowerCase()) {\n      case \"position\":\n      case \"positions\":\n      case \"vertices\":\n        return \"POSITION\";\n      case \"normal\":\n      case \"normals\":\n        return \"NORMAL\";\n      case \"color\":\n      case \"colors\":\n        return \"COLOR_0\";\n      case \"texcoord\":\n      case \"texcoords\":\n        return \"TEXCOORD_0\";\n      default:\n        return t;\n    }\n  }\n  _getAccessorMinMax(t, n) {\n    const s = {\n      min: null,\n      max: null\n    };\n    if (t.length < n)\n      return s;\n    s.min = [], s.max = [];\n    const r = t.subarray(0, n);\n    for (const i of r)\n      s.min.push(i), s.max.push(i);\n    for (let i = n; i < t.length; i += n)\n      for (let o = 0; o < n; o++)\n        s.min[0 + o] = Math.min(s.min[0 + o], t[i + o]), s.max[0 + o] = Math.max(s.max[0 + o], t[i + o]);\n    return s;\n  }\n}\nfunction pi(e) {\n  return (e % 1 + 1) % 1;\n}\nconst ea = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16,\n  BOOLEAN: 1,\n  STRING: 1,\n  ENUM: 1\n}, jm = {\n  INT8: Int8Array,\n  UINT8: Uint8Array,\n  INT16: Int16Array,\n  UINT16: Uint16Array,\n  INT32: Int32Array,\n  UINT32: Uint32Array,\n  INT64: BigInt64Array,\n  UINT64: BigUint64Array,\n  FLOAT32: Float32Array,\n  FLOAT64: Float64Array\n}, na = {\n  INT8: 1,\n  UINT8: 1,\n  INT16: 2,\n  UINT16: 2,\n  INT32: 4,\n  UINT32: 4,\n  INT64: 8,\n  UINT64: 8,\n  FLOAT32: 4,\n  FLOAT64: 8\n};\nfunction Qs(e, t) {\n  return na[t] * ea[e];\n}\nfunction In(e, t, n, s) {\n  if (n !== \"UINT8\" && n !== \"UINT16\" && n !== \"UINT32\" && n !== \"UINT64\")\n    return null;\n  const r = e.getTypedArrayForBufferView(t), i = Sn(r, \"SCALAR\", n, s + 1);\n  return i instanceof BigInt64Array || i instanceof BigUint64Array ? null : i;\n}\nfunction Sn(e, t, n) {\n  let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n  const r = ea[t], i = jm[n], o = na[n], a = s * r, c = a * o;\n  let u = e.buffer, l = e.byteOffset;\n  return l % o !== 0 && (u = new Uint8Array(u).slice(l, l + c).buffer, l = 0), new i(u, l, a);\n}\nfunction qs(e, t, n) {\n  var s, r;\n  const i = `TEXCOORD_${t.texCoord || 0}`, o = n.attributes[i], a = e.getTypedArrayForAccessor(o), c = e.gltf.json, u = t.index, l = (s = c.textures) === null || s === void 0 || (r = s[u]) === null || r === void 0 ? void 0 : r.source;\n  if (typeof l < \"u\") {\n    var h, f, d;\n    const A = (h = c.images) === null || h === void 0 || (f = h[l]) === null || f === void 0 ? void 0 : f.mimeType, g = (d = e.gltf.images) === null || d === void 0 ? void 0 : d[l];\n    if (g && typeof g.width < \"u\") {\n      const p = [];\n      for (let y = 0; y < a.length; y += 2) {\n        const _ = Km(g, A, a, y, t.channels);\n        p.push(_);\n      }\n      return p;\n    }\n  }\n  return [];\n}\nfunction sa(e, t, n, s, r) {\n  if (!(n != null && n.length))\n    return;\n  const i = [];\n  for (const l of n) {\n    let h = s.findIndex((f) => f === l);\n    h === -1 && (h = s.push(l) - 1), i.push(h);\n  }\n  const o = new Uint32Array(i), a = e.gltf.buffers.push({\n    arrayBuffer: o.buffer,\n    byteOffset: o.byteOffset,\n    byteLength: o.byteLength\n  }) - 1, c = e.addBufferView(o, a, 0), u = e.addAccessor(c, {\n    size: 1,\n    componentType: Ws(o),\n    count: o.length\n  });\n  r.attributes[t] = u;\n}\nfunction Km(e, t, n, s) {\n  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [0];\n  const i = {\n    r: {\n      offset: 0,\n      shift: 0\n    },\n    g: {\n      offset: 1,\n      shift: 8\n    },\n    b: {\n      offset: 2,\n      shift: 16\n    },\n    a: {\n      offset: 3,\n      shift: 24\n    }\n  }, o = n[s], a = n[s + 1];\n  let c = 1;\n  t && (t.indexOf(\"image/jpeg\") !== -1 || t.indexOf(\"image/png\") !== -1) && (c = 4);\n  const u = zm(o, a, e, c);\n  let l = 0;\n  for (const h of r) {\n    const f = typeof h == \"number\" ? Object.values(i)[h] : i[h], d = u + f.offset, A = Xo(e);\n    if (A.data.length <= d)\n      throw new Error(`${A.data.length} <= ${d}`);\n    const g = A.data[d];\n    l |= g << f.shift;\n  }\n  return l;\n}\nfunction zm(e, t, n) {\n  let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n  const r = n.width, i = pi(e) * (r - 1), o = Math.round(i), a = n.height, c = pi(t) * (a - 1), u = Math.round(c), l = n.components ? n.components : s;\n  return (u * r + o) * l;\n}\nfunction ra(e, t, n, s, r) {\n  const i = [];\n  for (let o = 0; o < t; o++) {\n    const a = n[o], c = n[o + 1] - n[o];\n    if (c + a > s)\n      break;\n    const u = a / r, l = c / r;\n    i.push(e.slice(u, u + l));\n  }\n  return i;\n}\nfunction ia(e, t, n) {\n  const s = [];\n  for (let r = 0; r < t; r++) {\n    const i = r * n;\n    s.push(e.slice(i, i + n));\n  }\n  return s;\n}\nfunction oa(e, t, n, s) {\n  if (n)\n    throw new Error(\"Not implemented - arrayOffsets for strings is specified\");\n  if (s) {\n    const r = [], i = new TextDecoder(\"utf8\");\n    let o = 0;\n    for (let a = 0; a < e; a++) {\n      const c = s[a + 1] - s[a];\n      if (c + o <= t.length) {\n        const u = t.subarray(o, c + o), l = i.decode(u);\n        r.push(l), o += c;\n      }\n    }\n    return r;\n  }\n  return [];\n}\nconst aa = \"EXT_mesh_features\", Wm = aa;\nasync function Xm(e, t) {\n  const n = new Z(e);\n  Qm(n, t);\n}\nfunction Qm(e, t) {\n  const n = e.gltf.json;\n  if (n.meshes)\n    for (const s of n.meshes)\n      for (const r of s.primitives)\n        qm(e, r, t);\n}\nfunction qm(e, t, n) {\n  var s, r;\n  if (!(n != null && (s = n.gltf) !== null && s !== void 0 && s.loadBuffers))\n    return;\n  const i = (r = t.extensions) === null || r === void 0 ? void 0 : r[aa], o = i == null ? void 0 : i.featureIds;\n  if (o)\n    for (const c of o) {\n      var a;\n      let u;\n      if (typeof c.attribute < \"u\") {\n        const l = `_FEATURE_ID_${c.attribute}`, h = t.attributes[l];\n        u = e.getTypedArrayForAccessor(h);\n      } else\n        typeof c.texture < \"u\" && n !== null && n !== void 0 && (a = n.gltf) !== null && a !== void 0 && a.loadImages ? u = qs(e, c.texture, t) : u = [];\n      c.data = u;\n    }\n}\nconst Ym = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: Xm,\n  name: Wm\n}, Symbol.toStringTag, { value: \"Module\" })), Ys = \"EXT_structural_metadata\", $m = Ys;\nasync function Zm(e, t) {\n  const n = new Z(e);\n  tA(n, t);\n}\nfunction tA(e, t) {\n  var n, s;\n  if (!((n = t.gltf) !== null && n !== void 0 && n.loadBuffers))\n    return;\n  const r = e.getExtension(Ys);\n  r && ((s = t.gltf) !== null && s !== void 0 && s.loadImages && eA(e, r), nA(e, r));\n}\nfunction eA(e, t) {\n  const n = t.propertyTextures, s = e.gltf.json;\n  if (n && s.meshes)\n    for (const r of s.meshes)\n      for (const i of r.primitives)\n        rA(e, n, i, t);\n}\nfunction nA(e, t) {\n  const n = t.schema;\n  if (!n)\n    return;\n  const s = n.classes, r = t.propertyTables;\n  if (s && r)\n    for (const i in s) {\n      const o = sA(r, i);\n      o && oA(e, n, o);\n    }\n}\nfunction sA(e, t) {\n  for (const n of e)\n    if (n.class === t)\n      return n;\n  return null;\n}\nfunction rA(e, t, n, s) {\n  var r;\n  if (!t)\n    return;\n  const i = (r = n.extensions) === null || r === void 0 ? void 0 : r[Ys], o = i == null ? void 0 : i.propertyTextures;\n  if (o)\n    for (const a of o) {\n      const c = t[a];\n      iA(e, c, n, s);\n    }\n}\nfunction iA(e, t, n, s) {\n  if (!t.properties)\n    return;\n  s.dataAttributeNames || (s.dataAttributeNames = []);\n  const r = t.class;\n  for (const o in t.properties) {\n    var i;\n    const a = `${r}_${o}`, c = (i = t.properties) === null || i === void 0 ? void 0 : i[o];\n    if (!c)\n      continue;\n    c.data || (c.data = []);\n    const u = c.data, l = qs(e, c, n);\n    l !== null && (sa(e, a, l, u, n), c.data = u, s.dataAttributeNames.push(a));\n  }\n}\nfunction oA(e, t, n) {\n  var s;\n  const r = (s = t.classes) === null || s === void 0 ? void 0 : s[n.class];\n  if (!r)\n    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${n.class}`);\n  const i = n.count;\n  for (const a in r.properties) {\n    var o;\n    const c = r.properties[a], u = (o = n.properties) === null || o === void 0 ? void 0 : o[a];\n    if (u) {\n      const l = aA(e, t, c, i, u);\n      u.data = l;\n    }\n  }\n}\nfunction aA(e, t, n, s, r) {\n  let i = [];\n  const o = r.values, a = e.getTypedArrayForBufferView(o), c = cA(e, n, r, s), u = uA(e, r, s);\n  switch (n.type) {\n    case \"SCALAR\":\n    case \"VEC2\":\n    case \"VEC3\":\n    case \"VEC4\":\n    case \"MAT2\":\n    case \"MAT3\":\n    case \"MAT4\": {\n      i = lA(n, s, a, c);\n      break;\n    }\n    case \"BOOLEAN\":\n      throw new Error(`Not implemented - classProperty.type=${n.type}`);\n    case \"STRING\": {\n      i = oa(s, a, c, u);\n      break;\n    }\n    case \"ENUM\": {\n      i = hA(t, n, s, a, c);\n      break;\n    }\n    default:\n      throw new Error(`Unknown classProperty type ${n.type}`);\n  }\n  return i;\n}\nfunction cA(e, t, n, s) {\n  return t.array && typeof t.count > \"u\" && typeof n.arrayOffsets < \"u\" ? In(e, n.arrayOffsets, n.arrayOffsetType || \"UINT32\", s) : null;\n}\nfunction uA(e, t, n) {\n  return typeof t.stringOffsets < \"u\" ? In(e, t.stringOffsets, t.stringOffsetType || \"UINT32\", n) : null;\n}\nfunction lA(e, t, n, s) {\n  const r = e.array, i = e.count, o = Qs(e.type, e.componentType), a = n.byteLength / o;\n  let c;\n  return e.componentType ? c = Sn(n, e.type, e.componentType, a) : c = n, r ? s ? ra(c, t, s, n.length, o) : i ? ia(c, t, i) : [] : c;\n}\nfunction hA(e, t, n, s, r) {\n  var i;\n  const o = t.enumType;\n  if (!o)\n    throw new Error(\"Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM\");\n  const a = (i = e.enums) === null || i === void 0 ? void 0 : i[o];\n  if (!a)\n    throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${o}`);\n  const c = a.valueType || \"UINT16\", u = Qs(t.type, c), l = s.byteLength / u;\n  let h = Sn(s, t.type, c, l);\n  if (h || (h = s), t.array) {\n    if (r)\n      return fA({\n        valuesData: h,\n        numberOfElements: n,\n        arrayOffsets: r,\n        valuesDataBytesLength: s.length,\n        elementSize: u,\n        enumEntry: a\n      });\n    const f = t.count;\n    return f ? dA(h, n, f, a) : [];\n  }\n  return $s(h, 0, n, a);\n}\nfunction fA(e) {\n  const {\n    valuesData: t,\n    numberOfElements: n,\n    arrayOffsets: s,\n    valuesDataBytesLength: r,\n    elementSize: i,\n    enumEntry: o\n  } = e, a = [];\n  for (let c = 0; c < n; c++) {\n    const u = s[c], l = s[c + 1] - s[c];\n    if (l + u > r)\n      break;\n    const h = u / i, f = l / i, d = $s(t, h, f, o);\n    a.push(d);\n  }\n  return a;\n}\nfunction dA(e, t, n, s) {\n  const r = [];\n  for (let i = 0; i < t; i++) {\n    const o = n * i, a = $s(e, o, n, s);\n    r.push(a);\n  }\n  return r;\n}\nfunction $s(e, t, n, s) {\n  const r = [];\n  for (let i = 0; i < n; i++)\n    if (e instanceof BigInt64Array || e instanceof BigUint64Array)\n      r.push(\"\");\n    else {\n      const o = e[t + i], a = mA(s, o);\n      a ? r.push(a.name) : r.push(\"\");\n    }\n  return r;\n}\nfunction mA(e, t) {\n  for (const n of e.values)\n    if (n.value === t)\n      return n;\n  return null;\n}\nconst AA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: Zm,\n  name: $m\n}, Symbol.toStringTag, { value: \"Module\" })), ca = \"EXT_feature_metadata\", gA = ca;\nasync function pA(e, t) {\n  const n = new Z(e);\n  BA(n, t);\n}\nfunction BA(e, t) {\n  var n, s;\n  if (!((n = t.gltf) !== null && n !== void 0 && n.loadBuffers))\n    return;\n  const r = e.getExtension(ca);\n  r && ((s = t.gltf) !== null && s !== void 0 && s.loadImages && yA(e, r), CA(e, r));\n}\nfunction yA(e, t) {\n  const n = t.schema;\n  if (!n)\n    return;\n  const s = n.classes, {\n    featureTextures: r\n  } = t;\n  if (s && r)\n    for (const i in s) {\n      const o = s[i], a = EA(r, i);\n      a && _A(e, a, o);\n    }\n}\nfunction CA(e, t) {\n  const n = t.schema;\n  if (!n)\n    return;\n  const s = n.classes, r = t.featureTables;\n  if (s && r)\n    for (const i in s) {\n      const o = TA(r, i);\n      o && bA(e, n, o);\n    }\n}\nfunction TA(e, t) {\n  for (const n in e) {\n    const s = e[n];\n    if (s.class === t)\n      return s;\n  }\n  return null;\n}\nfunction EA(e, t) {\n  for (const n in e) {\n    const s = e[n];\n    if (s.class === t)\n      return s;\n  }\n  return null;\n}\nfunction bA(e, t, n) {\n  var s;\n  if (!n.class)\n    return;\n  const r = (s = t.classes) === null || s === void 0 ? void 0 : s[n.class];\n  if (!r)\n    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${n.class}`);\n  const i = n.count;\n  for (const a in r.properties) {\n    var o;\n    const c = r.properties[a], u = (o = n.properties) === null || o === void 0 ? void 0 : o[a];\n    if (u) {\n      const l = wA(e, t, c, i, u);\n      u.data = l;\n    }\n  }\n}\nfunction _A(e, t, n) {\n  const s = t.class;\n  for (const i in n.properties) {\n    var r;\n    const o = t == null || (r = t.properties) === null || r === void 0 ? void 0 : r[i];\n    if (o) {\n      const a = DA(e, o, s);\n      o.data = a;\n    }\n  }\n}\nfunction wA(e, t, n, s, r) {\n  let i = [];\n  const o = r.bufferView, a = e.getTypedArrayForBufferView(o), c = MA(e, n, r, s), u = RA(e, n, r, s);\n  return n.type === \"STRING\" || n.componentType === \"STRING\" ? i = oa(s, a, c, u) : IA(n) && (i = SA(n, s, a, c)), i;\n}\nfunction MA(e, t, n, s) {\n  return t.type === \"ARRAY\" && typeof t.componentCount > \"u\" && typeof n.arrayOffsetBufferView < \"u\" ? In(e, n.arrayOffsetBufferView, n.offsetType || \"UINT32\", s) : null;\n}\nfunction RA(e, t, n, s) {\n  return typeof n.stringOffsetBufferView < \"u\" ? In(e, n.stringOffsetBufferView, n.offsetType || \"UINT32\", s) : null;\n}\nfunction IA(e) {\n  const t = [\"UINT8\", \"INT16\", \"UINT16\", \"INT32\", \"UINT32\", \"INT64\", \"UINT64\", \"FLOAT32\", \"FLOAT64\"];\n  return t.includes(e.type) || typeof e.componentType < \"u\" && t.includes(e.componentType);\n}\nfunction SA(e, t, n, s) {\n  const r = e.type === \"ARRAY\", i = e.componentCount, o = \"SCALAR\", a = e.componentType || e.type, c = Qs(o, a), u = n.byteLength / c, l = Sn(n, o, a, u);\n  return r ? s ? ra(l, t, s, n.length, c) : i ? ia(l, t, i) : [] : l;\n}\nfunction DA(e, t, n) {\n  const s = e.gltf.json;\n  if (!s.meshes)\n    return [];\n  const r = [];\n  for (const i of s.meshes)\n    for (const o of i.primitives)\n      FA(e, n, t, r, o);\n  return r;\n}\nfunction FA(e, t, n, s, r) {\n  const i = {\n    channels: n.channels,\n    ...n.texture\n  }, o = qs(e, i, r);\n  o && sa(e, t, o, s, r);\n}\nconst OA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: pA,\n  name: gA\n}, Symbol.toStringTag, { value: \"Module\" })), vA = \"4.1.1\", xA = \"4.1.1\", mn = {\n  TRANSCODER: \"basis_transcoder.js\",\n  TRANSCODER_WASM: \"basis_transcoder.wasm\",\n  ENCODER: \"basis_encoder.js\",\n  ENCODER_WASM: \"basis_encoder.wasm\"\n};\nlet rs;\nasync function Bi(e) {\n  const t = e.modules || {};\n  return t.basis ? t.basis : (rs = rs || LA(e), await rs);\n}\nasync function LA(e) {\n  let t = null, n = null;\n  return [t, n] = await Promise.all([await zt(mn.TRANSCODER, \"textures\", e), await zt(mn.TRANSCODER_WASM, \"textures\", e)]), t = t || globalThis.BASIS, await GA(t, n);\n}\nfunction GA(e, t) {\n  const n = {};\n  return t && (n.wasmBinary = t), new Promise((s) => {\n    e(n).then((r) => {\n      const {\n        BasisFile: i,\n        initializeBasis: o\n      } = r;\n      o(), s({\n        BasisFile: i\n      });\n    });\n  });\n}\nlet is;\nasync function yi(e) {\n  const t = e.modules || {};\n  return t.basisEncoder ? t.basisEncoder : (is = is || UA(e), await is);\n}\nasync function UA(e) {\n  let t = null, n = null;\n  return [t, n] = await Promise.all([await zt(mn.ENCODER, \"textures\", e), await zt(mn.ENCODER_WASM, \"textures\", e)]), t = t || globalThis.BASIS, await PA(t, n);\n}\nfunction PA(e, t) {\n  const n = {};\n  return t && (n.wasmBinary = t), new Promise((s) => {\n    e(n).then((r) => {\n      const {\n        BasisFile: i,\n        KTX2File: o,\n        initializeBasis: a,\n        BasisEncoder: c\n      } = r;\n      a(), s({\n        BasisFile: i,\n        KTX2File: o,\n        BasisEncoder: c\n      });\n    });\n  });\n}\nconst se = {\n  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,\n  COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,\n  COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,\n  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,\n  COMPRESSED_R11_EAC: 37488,\n  COMPRESSED_SIGNED_R11_EAC: 37489,\n  COMPRESSED_RG11_EAC: 37490,\n  COMPRESSED_SIGNED_RG11_EAC: 37491,\n  COMPRESSED_RGB8_ETC2: 37492,\n  COMPRESSED_RGBA8_ETC2_EAC: 37493,\n  COMPRESSED_SRGB8_ETC2: 37494,\n  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,\n  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,\n  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,\n  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,\n  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,\n  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,\n  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,\n  COMPRESSED_RGB_ETC1_WEBGL: 36196,\n  COMPRESSED_RGB_ATC_WEBGL: 35986,\n  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,\n  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,\n  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,\n  COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,\n  COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,\n  COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,\n  COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,\n  COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,\n  COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,\n  COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,\n  COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,\n  COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,\n  COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,\n  COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,\n  COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,\n  COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,\n  COMPRESSED_RED_RGTC1_EXT: 36283,\n  COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,\n  COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,\n  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,\n  COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919\n}, NA = [\"\", \"WEBKIT_\", \"MOZ_\"], Ci = {\n  WEBGL_compressed_texture_s3tc: \"dxt\",\n  WEBGL_compressed_texture_s3tc_srgb: \"dxt-srgb\",\n  WEBGL_compressed_texture_etc1: \"etc1\",\n  WEBGL_compressed_texture_etc: \"etc2\",\n  WEBGL_compressed_texture_pvrtc: \"pvrtc\",\n  WEBGL_compressed_texture_atc: \"atc\",\n  WEBGL_compressed_texture_astc: \"astc\",\n  EXT_texture_compression_rgtc: \"rgtc\"\n};\nlet $e = null;\nfunction HA(e) {\n  if (!$e) {\n    e = e || JA() || void 0, $e = /* @__PURE__ */ new Set();\n    for (const t of NA)\n      for (const n in Ci)\n        if (e && e.getExtension(`${t}${n}`)) {\n          const s = Ci[n];\n          $e.add(s);\n        }\n  }\n  return $e;\n}\nfunction JA() {\n  try {\n    return document.createElement(\"canvas\").getContext(\"webgl\");\n  } catch {\n    return null;\n  }\n}\nvar Ti, Ei, bi, _i, wi, Mi, Ri, Ii;\n(function(e) {\n  e[e.NONE = 0] = \"NONE\", e[e.BASISLZ = 1] = \"BASISLZ\", e[e.ZSTD = 2] = \"ZSTD\", e[e.ZLIB = 3] = \"ZLIB\";\n})(Ti || (Ti = {})), function(e) {\n  e[e.BASICFORMAT = 0] = \"BASICFORMAT\";\n}(Ei || (Ei = {})), function(e) {\n  e[e.UNSPECIFIED = 0] = \"UNSPECIFIED\", e[e.ETC1S = 163] = \"ETC1S\", e[e.UASTC = 166] = \"UASTC\";\n}(bi || (bi = {})), function(e) {\n  e[e.UNSPECIFIED = 0] = \"UNSPECIFIED\", e[e.SRGB = 1] = \"SRGB\";\n}(_i || (_i = {})), function(e) {\n  e[e.UNSPECIFIED = 0] = \"UNSPECIFIED\", e[e.LINEAR = 1] = \"LINEAR\", e[e.SRGB = 2] = \"SRGB\", e[e.ITU = 3] = \"ITU\", e[e.NTSC = 4] = \"NTSC\", e[e.SLOG = 5] = \"SLOG\", e[e.SLOG2 = 6] = \"SLOG2\";\n}(wi || (wi = {})), function(e) {\n  e[e.ALPHA_STRAIGHT = 0] = \"ALPHA_STRAIGHT\", e[e.ALPHA_PREMULTIPLIED = 1] = \"ALPHA_PREMULTIPLIED\";\n}(Mi || (Mi = {})), function(e) {\n  e[e.RGB = 0] = \"RGB\", e[e.RRR = 3] = \"RRR\", e[e.GGG = 4] = \"GGG\", e[e.AAA = 15] = \"AAA\";\n}(Ri || (Ri = {})), function(e) {\n  e[e.RGB = 0] = \"RGB\", e[e.RGBA = 3] = \"RGBA\", e[e.RRR = 4] = \"RRR\", e[e.RRRG = 5] = \"RRRG\";\n}(Ii || (Ii = {}));\nconst lt = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];\nfunction VA(e) {\n  const t = new Uint8Array(e);\n  return !(t.byteLength < lt.length || t[0] !== lt[0] || t[1] !== lt[1] || t[2] !== lt[2] || t[3] !== lt[3] || t[4] !== lt[4] || t[5] !== lt[5] || t[6] !== lt[6] || t[7] !== lt[7] || t[8] !== lt[8] || t[9] !== lt[9] || t[10] !== lt[10] || t[11] !== lt[11]);\n}\nconst kA = {\n  etc1: {\n    basisFormat: 0,\n    compressed: !0,\n    format: se.COMPRESSED_RGB_ETC1_WEBGL\n  },\n  etc2: {\n    basisFormat: 1,\n    compressed: !0\n  },\n  bc1: {\n    basisFormat: 2,\n    compressed: !0,\n    format: se.COMPRESSED_RGB_S3TC_DXT1_EXT\n  },\n  bc3: {\n    basisFormat: 3,\n    compressed: !0,\n    format: se.COMPRESSED_RGBA_S3TC_DXT5_EXT\n  },\n  bc4: {\n    basisFormat: 4,\n    compressed: !0\n  },\n  bc5: {\n    basisFormat: 5,\n    compressed: !0\n  },\n  \"bc7-m6-opaque-only\": {\n    basisFormat: 6,\n    compressed: !0\n  },\n  \"bc7-m5\": {\n    basisFormat: 7,\n    compressed: !0\n  },\n  \"pvrtc1-4-rgb\": {\n    basisFormat: 8,\n    compressed: !0,\n    format: se.COMPRESSED_RGB_PVRTC_4BPPV1_IMG\n  },\n  \"pvrtc1-4-rgba\": {\n    basisFormat: 9,\n    compressed: !0,\n    format: se.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\n  },\n  \"astc-4x4\": {\n    basisFormat: 10,\n    compressed: !0,\n    format: se.COMPRESSED_RGBA_ASTC_4X4_KHR\n  },\n  \"atc-rgb\": {\n    basisFormat: 11,\n    compressed: !0\n  },\n  \"atc-rgba-interpolated-alpha\": {\n    basisFormat: 12,\n    compressed: !0\n  },\n  rgba32: {\n    basisFormat: 13,\n    compressed: !1\n  },\n  rgb565: {\n    basisFormat: 14,\n    compressed: !1\n  },\n  bgr565: {\n    basisFormat: 15,\n    compressed: !1\n  },\n  rgba4444: {\n    basisFormat: 16,\n    compressed: !1\n  }\n};\nasync function jA(e, t) {\n  if (t.basis.containerFormat === \"auto\") {\n    if (VA(e)) {\n      const s = await yi(t);\n      return Si(s.KTX2File, e, t);\n    }\n    const {\n      BasisFile: n\n    } = await Bi(t);\n    return os(n, e, t);\n  }\n  switch (t.basis.module) {\n    case \"encoder\":\n      const n = await yi(t);\n      switch (t.basis.containerFormat) {\n        case \"ktx2\":\n          return Si(n.KTX2File, e, t);\n        case \"basis\":\n        default:\n          return os(n.BasisFile, e, t);\n      }\n    case \"transcoder\":\n    default:\n      const {\n        BasisFile: s\n      } = await Bi(t);\n      return os(s, e, t);\n  }\n}\nfunction os(e, t, n) {\n  const s = new e(new Uint8Array(t));\n  try {\n    if (!s.startTranscoding())\n      throw new Error(\"Failed to start basis transcoding\");\n    const r = s.getNumImages(), i = [];\n    for (let o = 0; o < r; o++) {\n      const a = s.getNumLevels(o), c = [];\n      for (let u = 0; u < a; u++)\n        c.push(KA(s, o, u, n));\n      i.push(c);\n    }\n    return i;\n  } finally {\n    s.close(), s.delete();\n  }\n}\nfunction KA(e, t, n, s) {\n  const r = e.getImageWidth(t, n), i = e.getImageHeight(t, n), o = e.getHasAlpha(), {\n    compressed: a,\n    format: c,\n    basisFormat: u\n  } = ua(s, o), l = e.getImageTranscodedSizeInBytes(t, n, u), h = new Uint8Array(l);\n  if (!e.transcodeImage(h, t, n, u, 0, 0))\n    throw new Error(\"failed to start Basis transcoding\");\n  return {\n    width: r,\n    height: i,\n    data: h,\n    compressed: a,\n    format: c,\n    hasAlpha: o\n  };\n}\nfunction Si(e, t, n) {\n  const s = new e(new Uint8Array(t));\n  try {\n    if (!s.startTranscoding())\n      throw new Error(\"failed to start KTX2 transcoding\");\n    const r = s.getLevels(), i = [];\n    for (let o = 0; o < r; o++) {\n      i.push(zA(s, o, n));\n      break;\n    }\n    return [i];\n  } finally {\n    s.close(), s.delete();\n  }\n}\nfunction zA(e, t, n) {\n  const {\n    alphaFlag: s,\n    height: r,\n    width: i\n  } = e.getImageLevelInfo(t, 0, 0), {\n    compressed: o,\n    format: a,\n    basisFormat: c\n  } = ua(n, s), u = e.getImageTranscodedSizeInBytes(t, 0, 0, c), l = new Uint8Array(u);\n  if (!e.transcodeImage(l, t, 0, 0, c, 0, -1, -1))\n    throw new Error(\"Failed to transcode KTX2 image\");\n  return {\n    width: i,\n    height: r,\n    data: l,\n    compressed: o,\n    levelSize: u,\n    hasAlpha: s,\n    format: a\n  };\n}\nfunction ua(e, t) {\n  let n = e && e.basis && e.basis.format;\n  return n === \"auto\" && (n = la()), typeof n == \"object\" && (n = t ? n.alpha : n.noAlpha), n = n.toLowerCase(), kA[n];\n}\nfunction la() {\n  const e = HA();\n  return e.has(\"astc\") ? \"astc-4x4\" : e.has(\"dxt\") ? {\n    alpha: \"bc3\",\n    noAlpha: \"bc1\"\n  } : e.has(\"pvrtc\") ? {\n    alpha: \"pvrtc1-4-rgba\",\n    noAlpha: \"pvrtc1-4-rgb\"\n  } : e.has(\"etc1\") ? \"etc1\" : e.has(\"etc2\") ? \"etc2\" : \"rgb565\";\n}\nconst WA = {\n  name: \"Basis\",\n  id: \"basis\",\n  module: \"textures\",\n  version: xA,\n  worker: !0,\n  extensions: [\"basis\", \"ktx2\"],\n  mimeTypes: [\"application/octet-stream\", \"image/ktx2\"],\n  tests: [\"sB\"],\n  binary: !0,\n  options: {\n    basis: {\n      format: \"auto\",\n      libraryPath: \"libs/\",\n      containerFormat: \"auto\",\n      module: \"transcoder\"\n    }\n  }\n}, XA = {\n  ...WA,\n  parse: jA\n}, ae = !0, Di = 1735152710, Zs = 12, An = 8, QA = 1313821514, qA = 5130562, YA = 0, $A = 0, ZA = 1;\nfunction t0(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n  return `${String.fromCharCode(e.getUint8(t + 0))}${String.fromCharCode(e.getUint8(t + 1))}${String.fromCharCode(e.getUint8(t + 2))}${String.fromCharCode(e.getUint8(t + 3))}`;\n}\nfunction e0(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n  const s = new DataView(e), {\n    magic: r = Di\n  } = n, i = s.getUint32(t, !1);\n  return i === r || i === Di;\n}\nfunction n0(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  const s = new DataView(t), r = t0(s, n + 0), i = s.getUint32(n + 4, ae), o = s.getUint32(n + 8, ae);\n  switch (Object.assign(e, {\n    header: {\n      byteOffset: n,\n      byteLength: o,\n      hasBinChunk: !1\n    },\n    type: r,\n    version: i,\n    json: {},\n    binChunks: []\n  }), n += Zs, e.version) {\n    case 1:\n      return s0(e, s, n);\n    case 2:\n      return r0(e, s, n, {});\n    default:\n      throw new Error(`Invalid GLB version ${e.version}. Only supports version 1 and 2.`);\n  }\n}\nfunction s0(e, t, n) {\n  U(e.header.byteLength > Zs + An);\n  const s = t.getUint32(n + 0, ae), r = t.getUint32(n + 4, ae);\n  return n += An, U(r === YA), _s(e, t, n, s), n += s, n += ws(e, t, n, e.header.byteLength), n;\n}\nfunction r0(e, t, n, s) {\n  return U(e.header.byteLength > Zs + An), i0(e, t, n, s), n + e.header.byteLength;\n}\nfunction i0(e, t, n, s) {\n  for (; n + 8 <= e.header.byteLength; ) {\n    const r = t.getUint32(n + 0, ae), i = t.getUint32(n + 4, ae);\n    switch (n += An, i) {\n      case QA:\n        _s(e, t, n, r);\n        break;\n      case qA:\n        ws(e, t, n, r);\n        break;\n      case $A:\n        s.strict || _s(e, t, n, r);\n        break;\n      case ZA:\n        s.strict || ws(e, t, n, r);\n        break;\n    }\n    n += Ie(r, 4);\n  }\n  return n;\n}\nfunction _s(e, t, n, s) {\n  const r = new Uint8Array(t.buffer, n, s), o = new TextDecoder(\"utf8\").decode(r);\n  return e.json = JSON.parse(o), Ie(s, 4);\n}\nfunction ws(e, t, n, s) {\n  return e.header.hasBinChunk = !0, e.binChunks.push({\n    byteOffset: n,\n    byteLength: s,\n    arrayBuffer: t.buffer\n  }), Ie(s, 4);\n}\nfunction ha(e, t) {\n  if (e.startsWith(\"data:\") || e.startsWith(\"http:\") || e.startsWith(\"https:\"))\n    return e;\n  const s = t.baseUri || t.uri;\n  if (!s)\n    throw new Error(`'baseUri' must be provided to resolve relative url ${e}`);\n  return s.substr(0, s.lastIndexOf(\"/\") + 1) + e;\n}\nconst o0 = \"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\", a0 = \"B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB\", c0 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), u0 = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]), l0 = {\n  0: \"\",\n  1: \"meshopt_decodeFilterOct\",\n  2: \"meshopt_decodeFilterQuat\",\n  3: \"meshopt_decodeFilterExp\",\n  NONE: \"\",\n  OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n  QUATERNION: \"meshopt_decodeFilterQuat\",\n  EXPONENTIAL: \"meshopt_decodeFilterExp\"\n}, h0 = {\n  0: \"meshopt_decodeVertexBuffer\",\n  1: \"meshopt_decodeIndexBuffer\",\n  2: \"meshopt_decodeIndexSequence\",\n  ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n  TRIANGLES: \"meshopt_decodeIndexBuffer\",\n  INDICES: \"meshopt_decodeIndexSequence\"\n};\nasync function f0(e, t, n, s, r) {\n  let i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"NONE\";\n  const o = await d0();\n  g0(o, o.exports[h0[r]], e, t, n, s, o.exports[l0[i || \"NONE\"]]);\n}\nlet as;\nasync function d0() {\n  return as || (as = m0()), as;\n}\nasync function m0() {\n  let e = o0;\n  WebAssembly.validate(c0) && (e = a0, console.log(\"Warning: meshopt_decoder is using experimental SIMD support\"));\n  const t = await WebAssembly.instantiate(A0(e), {});\n  return await t.instance.exports.__wasm_call_ctors(), t.instance;\n}\nfunction A0(e) {\n  const t = new Uint8Array(e.length);\n  for (let s = 0; s < e.length; ++s) {\n    const r = e.charCodeAt(s);\n    t[s] = r > 96 ? r - 71 : r > 64 ? r - 65 : r > 47 ? r + 4 : r > 46 ? 63 : 62;\n  }\n  let n = 0;\n  for (let s = 0; s < e.length; ++s)\n    t[n++] = t[s] < 60 ? u0[t[s]] : (t[s] - 60) * 64 + t[++s];\n  return t.buffer.slice(0, n);\n}\nfunction g0(e, t, n, s, r, i, o) {\n  const a = e.exports.sbrk, c = s + 3 & -4, u = a(c * r), l = a(i.length), h = new Uint8Array(e.exports.memory.buffer);\n  h.set(i, l);\n  const f = t(u, s, r, l, i.length);\n  if (f === 0 && o && o(u, c, r), n.set(h.subarray(u, u + s * r)), a(u - a(0)), f !== 0)\n    throw new Error(`Malformed buffer data: ${f}`);\n}\nconst gn = \"EXT_meshopt_compression\", p0 = gn;\nasync function B0(e, t) {\n  var n, s;\n  const r = new Z(e);\n  if (!(t != null && (n = t.gltf) !== null && n !== void 0 && n.decompressMeshes) || !((s = t.gltf) !== null && s !== void 0 && s.loadBuffers))\n    return;\n  const i = [];\n  for (const o of e.json.bufferViews || [])\n    i.push(y0(r, o));\n  await Promise.all(i), r.removeExtension(gn);\n}\nasync function y0(e, t) {\n  const n = e.getObjectExtension(t, gn);\n  if (n) {\n    const {\n      byteOffset: s = 0,\n      byteLength: r = 0,\n      byteStride: i,\n      count: o,\n      mode: a,\n      filter: c = \"NONE\",\n      buffer: u\n    } = n, l = e.gltf.buffers[u], h = new Uint8Array(l.arrayBuffer, l.byteOffset + s, r), f = new Uint8Array(e.gltf.buffers[t.buffer].arrayBuffer, t.byteOffset, t.byteLength);\n    await f0(f, o, i, h, a, c), e.removeObjectExtension(t, gn);\n  }\n}\nconst C0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: B0,\n  name: p0\n}, Symbol.toStringTag, { value: \"Module\" })), re = \"EXT_texture_webp\", T0 = re;\nfunction E0(e, t) {\n  const n = new Z(e);\n  if (!Fm(\"image/webp\")) {\n    if (n.getRequiredExtensions().includes(re))\n      throw new Error(`gltf: Required extension ${re} not supported by browser`);\n    return;\n  }\n  const {\n    json: s\n  } = n;\n  for (const r of s.textures || []) {\n    const i = n.getObjectExtension(r, re);\n    i && (r.source = i.source), n.removeObjectExtension(r, re);\n  }\n  n.removeExtension(re);\n}\nconst b0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  name: T0,\n  preprocess: E0\n}, Symbol.toStringTag, { value: \"Module\" })), an = \"KHR_texture_basisu\", _0 = an;\nfunction w0(e, t) {\n  const n = new Z(e), {\n    json: s\n  } = n;\n  for (const r of s.textures || []) {\n    const i = n.getObjectExtension(r, an);\n    i && (r.source = i.source, n.removeObjectExtension(r, an));\n  }\n  n.removeExtension(an);\n}\nconst M0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  name: _0,\n  preprocess: w0\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction R0(e) {\n  const t = {};\n  for (const n in e) {\n    const s = e[n];\n    if (n !== \"indices\") {\n      const r = fa(s);\n      t[n] = r;\n    }\n  }\n  return t;\n}\nfunction fa(e) {\n  const {\n    buffer: t,\n    size: n,\n    count: s\n  } = I0(e);\n  return {\n    value: t,\n    size: n,\n    byteOffset: 0,\n    count: s,\n    type: Zo(n),\n    componentType: Ws(t)\n  };\n}\nfunction I0(e) {\n  let t = e, n = 1, s = 0;\n  return e && e.value && (t = e.value, n = e.size || 1), t && (ArrayBuffer.isView(t) || (t = S0(t, Float32Array)), s = t.length / n), {\n    buffer: t,\n    size: n,\n    count: s\n  };\n}\nfunction S0(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n  return e ? Array.isArray(e) ? new t(e) : n && !(e instanceof t) ? new t(e) : e : null;\n}\nconst Ht = \"KHR_draco_mesh_compression\", D0 = Ht;\nfunction F0(e, t, n) {\n  const s = new Z(e);\n  for (const r of da(s))\n    s.getObjectExtension(r, Ht);\n}\nasync function O0(e, t, n) {\n  var s;\n  if (!(t != null && (s = t.gltf) !== null && s !== void 0 && s.decompressMeshes))\n    return;\n  const r = new Z(e), i = [];\n  for (const o of da(r))\n    r.getObjectExtension(o, Ht) && i.push(x0(r, o, t, n));\n  await Promise.all(i), r.removeExtension(Ht);\n}\nfunction v0(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  const n = new Z(e);\n  for (const s of n.json.meshes || [])\n    L0(s, t), n.addRequiredExtension(Ht);\n}\nasync function x0(e, t, n, s) {\n  const r = e.getObjectExtension(t, Ht);\n  if (!r)\n    return;\n  const i = e.getTypedArrayForBufferView(r.bufferView), o = Fs(i.buffer, i.byteOffset), a = {\n    ...n\n  };\n  delete a[\"3d-tiles\"];\n  const c = await Re(o, jo, a, s), u = R0(c.attributes);\n  for (const [l, h] of Object.entries(u))\n    if (l in t.attributes) {\n      const f = t.attributes[l], d = e.getAccessor(f);\n      d != null && d.min && d !== null && d !== void 0 && d.max && (h.min = d.min, h.max = d.max);\n    }\n  t.attributes = u, c.indices && (t.indices = fa(c.indices)), e.removeObjectExtension(t, Ht), G0(t);\n}\nfunction L0(e, t) {\n  var n;\n  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 4, r = arguments.length > 3 ? arguments[3] : void 0, i = arguments.length > 4 ? arguments[4] : void 0;\n  if (!r.DracoWriter)\n    throw new Error(\"options.gltf.DracoWriter not provided\");\n  const o = r.DracoWriter.encodeSync({\n    attributes: e\n  }), a = i == null || (n = i.parseSync) === null || n === void 0 ? void 0 : n.call(i, {\n    attributes: e\n  }), c = r._addFauxAttributes(a.attributes), u = r.addBufferView(o);\n  return {\n    primitives: [{\n      attributes: c,\n      mode: s,\n      extensions: {\n        [Ht]: {\n          bufferView: u,\n          attributes: c\n        }\n      }\n    }]\n  };\n}\nfunction G0(e) {\n  if (!e.attributes && Object.keys(e.attributes).length > 0)\n    throw new Error(\"glTF: Empty primitive detected: Draco decompression failure?\");\n}\nfunction* da(e) {\n  for (const t of e.json.meshes || [])\n    for (const n of t.primitives)\n      yield n;\n}\nconst U0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: O0,\n  encode: v0,\n  name: D0,\n  preprocess: F0\n}, Symbol.toStringTag, { value: \"Module\" })), tr = \"KHR_texture_transform\", P0 = tr, Ze = new m(), N0 = new j(), H0 = new j();\nasync function J0(e, t) {\n  var n;\n  if (!new Z(e).hasExtension(tr) || !((n = t.gltf) !== null && n !== void 0 && n.loadBuffers))\n    return;\n  const i = e.json.materials || [];\n  for (let o = 0; o < i.length; o++)\n    V0(o, e);\n}\nfunction V0(e, t) {\n  var n, s, r;\n  const i = [], o = (n = t.json.materials) === null || n === void 0 ? void 0 : n[e], a = o == null || (s = o.pbrMetallicRoughness) === null || s === void 0 ? void 0 : s.baseColorTexture;\n  a && ge(t, e, a, i);\n  const c = o == null ? void 0 : o.emissiveTexture;\n  c && ge(t, e, c, i);\n  const u = o == null ? void 0 : o.normalTexture;\n  u && ge(t, e, u, i);\n  const l = o == null ? void 0 : o.occlusionTexture;\n  l && ge(t, e, l, i);\n  const h = o == null || (r = o.pbrMetallicRoughness) === null || r === void 0 ? void 0 : r.metallicRoughnessTexture;\n  h && ge(t, e, h, i);\n}\nfunction ge(e, t, n, s) {\n  const r = k0(n, s);\n  if (!r)\n    return;\n  const i = e.json.meshes || [];\n  for (const o of i)\n    for (const a of o.primitives) {\n      const c = a.material;\n      Number.isFinite(c) && t === c && j0(e, a, r);\n    }\n}\nfunction k0(e, t) {\n  var n;\n  const s = (n = e.extensions) === null || n === void 0 ? void 0 : n[tr], {\n    texCoord: r = 0\n  } = e, {\n    texCoord: i = r\n  } = s;\n  if (!(t.findIndex((a) => {\n    let [c, u] = a;\n    return c === r && u === i;\n  }) !== -1)) {\n    const a = W0(s);\n    return r !== i && (e.texCoord = i), t.push([r, i]), {\n      originalTexCoord: r,\n      texCoord: i,\n      matrix: a\n    };\n  }\n  return null;\n}\nfunction j0(e, t, n) {\n  const {\n    originalTexCoord: s,\n    texCoord: r,\n    matrix: i\n  } = n, o = t.attributes[`TEXCOORD_${s}`];\n  if (Number.isFinite(o)) {\n    var a;\n    const u = (a = e.json.accessors) === null || a === void 0 ? void 0 : a[o];\n    if (u && u.bufferView) {\n      var c;\n      const l = (c = e.json.bufferViews) === null || c === void 0 ? void 0 : c[u.bufferView];\n      if (l) {\n        const {\n          arrayBuffer: h,\n          byteOffset: f\n        } = e.buffers[l.buffer], d = (f || 0) + (u.byteOffset || 0) + (l.byteOffset || 0), {\n          ArrayType: A,\n          length: g\n        } = Xs(u, l), p = $o[u.componentType], y = Yo[u.type], _ = l.byteStride || p * y, b = new Float32Array(g);\n        for (let w = 0; w < u.count; w++) {\n          const M = new A(h, d + w * _, 2);\n          Ze.set(M[0], M[1], 1), Ze.transformByMatrix3(i), b.set([Ze[0], Ze[1]], w * y);\n        }\n        s === r ? K0(u, l, e.buffers, b) : z0(r, u, t, e, b);\n      }\n    }\n  }\n}\nfunction K0(e, t, n, s) {\n  e.componentType = 5126, n.push({\n    arrayBuffer: s.buffer,\n    byteOffset: 0,\n    byteLength: s.buffer.byteLength\n  }), t.buffer = n.length - 1, t.byteLength = s.buffer.byteLength, t.byteOffset = 0, delete t.byteStride;\n}\nfunction z0(e, t, n, s, r) {\n  s.buffers.push({\n    arrayBuffer: r.buffer,\n    byteOffset: 0,\n    byteLength: r.buffer.byteLength\n  });\n  const i = s.json.bufferViews;\n  if (!i)\n    return;\n  i.push({\n    buffer: s.buffers.length - 1,\n    byteLength: r.buffer.byteLength,\n    byteOffset: 0\n  });\n  const o = s.json.accessors;\n  o && (o.push({\n    bufferView: (i == null ? void 0 : i.length) - 1,\n    byteOffset: 0,\n    componentType: 5126,\n    count: t.count,\n    type: \"VEC2\"\n  }), n.attributes[`TEXCOORD_${e}`] = o.length - 1);\n}\nfunction W0(e) {\n  const {\n    offset: t = [0, 0],\n    rotation: n = 0,\n    scale: s = [1, 1]\n  } = e, r = new j().set(1, 0, 0, 0, 1, 0, t[0], t[1], 1), i = N0.set(Math.cos(n), Math.sin(n), 0, -Math.sin(n), Math.cos(n), 0, 0, 0, 1), o = H0.set(s[0], 0, 0, 0, s[1], 0, 0, 0, 1);\n  return r.multiplyRight(i).multiplyRight(o);\n}\nconst X0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: J0,\n  name: P0\n}, Symbol.toStringTag, { value: \"Module\" })), Kt = \"KHR_lights_punctual\", Q0 = Kt;\nasync function q0(e) {\n  const t = new Z(e), {\n    json: n\n  } = t, s = t.getExtension(Kt);\n  s && (t.json.lights = s.lights, t.removeExtension(Kt));\n  for (const r of n.nodes || []) {\n    const i = t.getObjectExtension(r, Kt);\n    i && (r.light = i.light), t.removeObjectExtension(r, Kt);\n  }\n}\nasync function Y0(e) {\n  const t = new Z(e), {\n    json: n\n  } = t;\n  if (n.lights) {\n    const s = t.addExtension(Kt);\n    ft(!s.lights), s.lights = n.lights, delete n.lights;\n  }\n  if (t.json.lights) {\n    for (const s of t.json.lights) {\n      const r = s.node;\n      t.addObjectExtension(r, Kt, s);\n    }\n    delete t.json.lights;\n  }\n}\nconst $0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: q0,\n  encode: Y0,\n  name: Q0\n}, Symbol.toStringTag, { value: \"Module\" })), Me = \"KHR_materials_unlit\", Z0 = Me;\nasync function tg(e) {\n  const t = new Z(e), {\n    json: n\n  } = t;\n  for (const s of n.materials || [])\n    s.extensions && s.extensions.KHR_materials_unlit && (s.unlit = !0), t.removeObjectExtension(s, Me);\n  t.removeExtension(Me);\n}\nfunction eg(e) {\n  const t = new Z(e), {\n    json: n\n  } = t;\n  if (t.materials)\n    for (const s of n.materials || [])\n      s.unlit && (delete s.unlit, t.addObjectExtension(s, Me, {}), t.addExtension(Me));\n}\nconst ng = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: tg,\n  encode: eg,\n  name: Z0\n}, Symbol.toStringTag, { value: \"Module\" })), Be = \"KHR_techniques_webgl\", sg = Be;\nasync function rg(e) {\n  const t = new Z(e), {\n    json: n\n  } = t, s = t.getExtension(Be);\n  if (s) {\n    const r = og(s, t);\n    for (const i of n.materials || []) {\n      const o = t.getObjectExtension(i, Be);\n      o && (i.technique = Object.assign({}, o, r[o.technique]), i.technique.values = ag(i.technique, t)), t.removeObjectExtension(i, Be);\n    }\n    t.removeExtension(Be);\n  }\n}\nasync function ig(e, t) {\n}\nfunction og(e, t) {\n  const {\n    programs: n = [],\n    shaders: s = [],\n    techniques: r = []\n  } = e, i = new TextDecoder();\n  return s.forEach((o) => {\n    if (Number.isFinite(o.bufferView))\n      o.code = i.decode(t.getTypedArrayForBufferView(o.bufferView));\n    else\n      throw new Error(\"KHR_techniques_webgl: no shader code\");\n  }), n.forEach((o) => {\n    o.fragmentShader = s[o.fragmentShader], o.vertexShader = s[o.vertexShader];\n  }), r.forEach((o) => {\n    o.program = n[o.program];\n  }), r;\n}\nfunction ag(e, t) {\n  const n = Object.assign({}, e.values);\n  return Object.keys(e.uniforms || {}).forEach((s) => {\n    e.uniforms[s].value && !(s in n) && (n[s] = e.uniforms[s].value);\n  }), Object.keys(n).forEach((s) => {\n    typeof n[s] == \"object\" && n[s].index !== void 0 && (n[s].texture = t.getTexture(n[s].index));\n  }), n;\n}\nconst cg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: rg,\n  encode: ig,\n  name: sg\n}, Symbol.toStringTag, { value: \"Module\" })), ma = [AA, Ym, C0, b0, M0, U0, $0, ng, cg, X0, OA];\nfunction ug(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = ma.filter((i) => Aa(i.name, t));\n  for (const i of s) {\n    var r;\n    (r = i.preprocess) === null || r === void 0 || r.call(i, e, t, n);\n  }\n}\nasync function lg(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = ma.filter((i) => Aa(i.name, t));\n  for (const i of s) {\n    var r;\n    await ((r = i.decode) === null || r === void 0 ? void 0 : r.call(i, e, t, n));\n  }\n}\nfunction Aa(e, t) {\n  var n;\n  const s = (t == null || (n = t.gltf) === null || n === void 0 ? void 0 : n.excludeExtensions) || {};\n  return !(e in s && !s[e]);\n}\nconst cs = \"KHR_binary_glTF\";\nfunction hg(e) {\n  const t = new Z(e), {\n    json: n\n  } = t;\n  for (const s of n.images || []) {\n    const r = t.getObjectExtension(s, cs);\n    r && Object.assign(s, r), t.removeObjectExtension(s, cs);\n  }\n  n.buffers && n.buffers[0] && delete n.buffers[0].uri, t.removeExtension(cs);\n}\nconst Fi = {\n  accessors: \"accessor\",\n  animations: \"animation\",\n  buffers: \"buffer\",\n  bufferViews: \"bufferView\",\n  images: \"image\",\n  materials: \"material\",\n  meshes: \"mesh\",\n  nodes: \"node\",\n  samplers: \"sampler\",\n  scenes: \"scene\",\n  skins: \"skin\",\n  textures: \"texture\"\n}, fg = {\n  accessor: \"accessors\",\n  animations: \"animation\",\n  buffer: \"buffers\",\n  bufferView: \"bufferViews\",\n  image: \"images\",\n  material: \"materials\",\n  mesh: \"meshes\",\n  node: \"nodes\",\n  sampler: \"samplers\",\n  scene: \"scenes\",\n  skin: \"skins\",\n  texture: \"textures\"\n};\nclass dg {\n  constructor() {\n    this.idToIndexMap = {\n      animations: {},\n      accessors: {},\n      buffers: {},\n      bufferViews: {},\n      images: {},\n      materials: {},\n      meshes: {},\n      nodes: {},\n      samplers: {},\n      scenes: {},\n      skins: {},\n      textures: {}\n    }, this.json = void 0;\n  }\n  normalize(t, n) {\n    this.json = t.json;\n    const s = t.json;\n    switch (s.asset && s.asset.version) {\n      case \"2.0\":\n        return;\n      case void 0:\n      case \"1.0\":\n        break;\n      default:\n        console.warn(`glTF: Unknown version ${s.asset.version}`);\n        return;\n    }\n    if (!n.normalize)\n      throw new Error(\"glTF v1 is not supported.\");\n    console.warn(\"Converting glTF v1 to glTF v2 format. This is experimental and may fail.\"), this._addAsset(s), this._convertTopLevelObjectsToArrays(s), hg(t), this._convertObjectIdsToArrayIndices(s), this._updateObjects(s), this._updateMaterial(s);\n  }\n  _addAsset(t) {\n    t.asset = t.asset || {}, t.asset.version = \"2.0\", t.asset.generator = t.asset.generator || \"Normalized to glTF 2.0 by loaders.gl\";\n  }\n  _convertTopLevelObjectsToArrays(t) {\n    for (const n in Fi)\n      this._convertTopLevelObjectToArray(t, n);\n  }\n  _convertTopLevelObjectToArray(t, n) {\n    const s = t[n];\n    if (!(!s || Array.isArray(s))) {\n      t[n] = [];\n      for (const r in s) {\n        const i = s[r];\n        i.id = i.id || r;\n        const o = t[n].length;\n        t[n].push(i), this.idToIndexMap[n][r] = o;\n      }\n    }\n  }\n  _convertObjectIdsToArrayIndices(t) {\n    for (const n in Fi)\n      this._convertIdsToIndices(t, n);\n    \"scene\" in t && (t.scene = this._convertIdToIndex(t.scene, \"scene\"));\n    for (const n of t.textures)\n      this._convertTextureIds(n);\n    for (const n of t.meshes)\n      this._convertMeshIds(n);\n    for (const n of t.nodes)\n      this._convertNodeIds(n);\n    for (const n of t.scenes)\n      this._convertSceneIds(n);\n  }\n  _convertTextureIds(t) {\n    t.source && (t.source = this._convertIdToIndex(t.source, \"image\"));\n  }\n  _convertMeshIds(t) {\n    for (const n of t.primitives) {\n      const {\n        attributes: s,\n        indices: r,\n        material: i\n      } = n;\n      for (const o in s)\n        s[o] = this._convertIdToIndex(s[o], \"accessor\");\n      r && (n.indices = this._convertIdToIndex(r, \"accessor\")), i && (n.material = this._convertIdToIndex(i, \"material\"));\n    }\n  }\n  _convertNodeIds(t) {\n    t.children && (t.children = t.children.map((n) => this._convertIdToIndex(n, \"node\"))), t.meshes && (t.meshes = t.meshes.map((n) => this._convertIdToIndex(n, \"mesh\")));\n  }\n  _convertSceneIds(t) {\n    t.nodes && (t.nodes = t.nodes.map((n) => this._convertIdToIndex(n, \"node\")));\n  }\n  _convertIdsToIndices(t, n) {\n    t[n] || (console.warn(`gltf v1: json doesn't contain attribute ${n}`), t[n] = []);\n    for (const s of t[n])\n      for (const r in s) {\n        const i = s[r], o = this._convertIdToIndex(i, r);\n        s[r] = o;\n      }\n  }\n  _convertIdToIndex(t, n) {\n    const s = fg[n];\n    if (s in this.idToIndexMap) {\n      const r = this.idToIndexMap[s][t];\n      if (!Number.isFinite(r))\n        throw new Error(`gltf v1: failed to resolve ${n} with id ${t}`);\n      return r;\n    }\n    return t;\n  }\n  _updateObjects(t) {\n    for (const n of this.json.buffers)\n      delete n.type;\n  }\n  _updateMaterial(t) {\n    for (const i of t.materials) {\n      var n, s, r;\n      i.pbrMetallicRoughness = {\n        baseColorFactor: [1, 1, 1, 1],\n        metallicFactor: 1,\n        roughnessFactor: 1\n      };\n      const o = ((n = i.values) === null || n === void 0 ? void 0 : n.tex) || ((s = i.values) === null || s === void 0 ? void 0 : s.texture2d_0) || ((r = i.values) === null || r === void 0 ? void 0 : r.diffuseTex), a = t.textures.findIndex((c) => c.id === o);\n      a !== -1 && (i.pbrMetallicRoughness.baseColorTexture = {\n        index: a\n      });\n    }\n  }\n}\nfunction mg(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  return new dg().normalize(e, t);\n}\nasync function Ag(e, t) {\n  var n, s, r;\n  let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, o = arguments.length > 3 ? arguments[3] : void 0, a = arguments.length > 4 ? arguments[4] : void 0;\n  return gg(e, t, i, o), mg(e, {\n    normalize: o == null || (n = o.gltf) === null || n === void 0 ? void 0 : n.normalize\n  }), ug(e, o, a), o != null && (s = o.gltf) !== null && s !== void 0 && s.loadBuffers && e.json.buffers && await pg(e, o, a), o != null && (r = o.gltf) !== null && r !== void 0 && r.loadImages && await Bg(e, o, a), await lg(e, o, a), e;\n}\nfunction gg(e, t, n, s) {\n  if (s.uri && (e.baseUri = s.uri), t instanceof ArrayBuffer && !e0(t, n, s) && (t = new TextDecoder().decode(t)), typeof t == \"string\")\n    e.json = Mc(t);\n  else if (t instanceof ArrayBuffer) {\n    const o = {};\n    n = n0(o, t, n, s.glb), ft(o.type === \"glTF\", `Invalid GLB magic string ${o.type}`), e._glb = o, e.json = o.json;\n  } else\n    ft(!1, \"GLTF: must be ArrayBuffer or string\");\n  const r = e.json.buffers || [];\n  if (e.buffers = new Array(r.length).fill(null), e._glb && e._glb.header.hasBinChunk) {\n    const {\n      binChunks: o\n    } = e._glb;\n    e.buffers[0] = {\n      arrayBuffer: o[0].arrayBuffer,\n      byteOffset: o[0].byteOffset,\n      byteLength: o[0].byteLength\n    };\n  }\n  const i = e.json.images || [];\n  e.images = new Array(i.length).fill({});\n}\nasync function pg(e, t, n) {\n  const s = e.json.buffers || [];\n  for (let o = 0; o < s.length; ++o) {\n    const a = s[o];\n    if (a.uri) {\n      var r, i;\n      const {\n        fetch: c\n      } = n;\n      ft(c);\n      const u = ha(a.uri, t), l = await (n == null || (r = n.fetch) === null || r === void 0 ? void 0 : r.call(n, u)), h = await (l == null || (i = l.arrayBuffer) === null || i === void 0 ? void 0 : i.call(l));\n      e.buffers[o] = {\n        arrayBuffer: h,\n        byteOffset: 0,\n        byteLength: h.byteLength\n      }, delete a.uri;\n    } else\n      e.buffers[o] === null && (e.buffers[o] = {\n        arrayBuffer: new ArrayBuffer(a.byteLength),\n        byteOffset: 0,\n        byteLength: a.byteLength\n      });\n  }\n}\nasync function Bg(e, t, n) {\n  const s = yg(e), r = e.json.images || [], i = [];\n  for (const o of s)\n    i.push(Cg(e, r[o], o, t, n));\n  return await Promise.all(i);\n}\nfunction yg(e) {\n  const t = /* @__PURE__ */ new Set(), n = e.json.textures || [];\n  for (const s of n)\n    s.source !== void 0 && t.add(s.source);\n  return Array.from(t).sort();\n}\nasync function Cg(e, t, n, s, r) {\n  let i;\n  if (t.uri && !t.hasOwnProperty(\"bufferView\")) {\n    const a = ha(t.uri, s), {\n      fetch: c\n    } = r;\n    i = await (await c(a)).arrayBuffer(), t.bufferView = {\n      data: i\n    };\n  }\n  if (Number.isFinite(t.bufferView)) {\n    const a = Jm(e.json, e.buffers, t.bufferView);\n    i = Fs(a.buffer, a.byteOffset, a.byteLength);\n  }\n  ft(i, \"glTF image has no data\");\n  let o = await Re(i, [Dm, XA], {\n    ...s,\n    mimeType: t.mimeType,\n    basis: s.basis || {\n      format: la()\n    }\n  }, r);\n  o && o[0] && (o = {\n    compressed: !0,\n    mipmaps: !1,\n    width: o[0].width,\n    height: o[0].height,\n    data: o[0]\n  }), e.images = e.images || [], e.images[n] = o;\n}\nconst pn = {\n  name: \"glTF\",\n  id: \"gltf\",\n  module: \"gltf\",\n  version: vA,\n  extensions: [\"gltf\", \"glb\"],\n  mimeTypes: [\"model/gltf+json\", \"model/gltf-binary\"],\n  text: !0,\n  binary: !0,\n  tests: [\"glTF\"],\n  parse: Tg,\n  options: {\n    gltf: {\n      normalize: !0,\n      loadBuffers: !0,\n      loadImages: !0,\n      decompressMeshes: !0\n    },\n    log: console\n  }\n};\nasync function Tg(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;\n  t = {\n    ...pn.options,\n    ...t\n  }, t.gltf = {\n    ...pn.options.gltf,\n    ...t.gltf\n  };\n  const {\n    byteOffset: s = 0\n  } = t;\n  return await Ag({}, e, s, t, n);\n}\nconst Eg = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n}, bg = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n}, mt = {\n  TEXTURE_MAG_FILTER: 10240,\n  TEXTURE_MIN_FILTER: 10241,\n  TEXTURE_WRAP_S: 10242,\n  TEXTURE_WRAP_T: 10243,\n  REPEAT: 10497,\n  LINEAR: 9729,\n  NEAREST_MIPMAP_LINEAR: 9986\n}, _g = {\n  magFilter: mt.TEXTURE_MAG_FILTER,\n  minFilter: mt.TEXTURE_MIN_FILTER,\n  wrapS: mt.TEXTURE_WRAP_S,\n  wrapT: mt.TEXTURE_WRAP_T\n}, wg = {\n  [mt.TEXTURE_MAG_FILTER]: mt.LINEAR,\n  [mt.TEXTURE_MIN_FILTER]: mt.NEAREST_MIPMAP_LINEAR,\n  [mt.TEXTURE_WRAP_S]: mt.REPEAT,\n  [mt.TEXTURE_WRAP_T]: mt.REPEAT\n};\nfunction Mg() {\n  return {\n    id: \"default-sampler\",\n    parameters: wg\n  };\n}\nfunction Rg(e) {\n  return bg[e];\n}\nfunction Ig(e) {\n  return Eg[e];\n}\nclass Sg {\n  constructor() {\n    this.baseUri = \"\", this.jsonUnprocessed = void 0, this.json = void 0, this.buffers = [], this.images = [];\n  }\n  postProcess(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const {\n      json: s,\n      buffers: r = [],\n      images: i = []\n    } = t, {\n      baseUri: o = \"\"\n    } = t;\n    return ft(s), this.baseUri = o, this.buffers = r, this.images = i, this.jsonUnprocessed = s, this.json = this._resolveTree(t.json, n), this.json;\n  }\n  _resolveTree(t) {\n    const n = {\n      ...t\n    };\n    return this.json = n, t.bufferViews && (n.bufferViews = t.bufferViews.map((s, r) => this._resolveBufferView(s, r))), t.images && (n.images = t.images.map((s, r) => this._resolveImage(s, r))), t.samplers && (n.samplers = t.samplers.map((s, r) => this._resolveSampler(s, r))), t.textures && (n.textures = t.textures.map((s, r) => this._resolveTexture(s, r))), t.accessors && (n.accessors = t.accessors.map((s, r) => this._resolveAccessor(s, r))), t.materials && (n.materials = t.materials.map((s, r) => this._resolveMaterial(s, r))), t.meshes && (n.meshes = t.meshes.map((s, r) => this._resolveMesh(s, r))), t.nodes && (n.nodes = t.nodes.map((s, r) => this._resolveNode(s, r)), n.nodes = n.nodes.map((s, r) => this._resolveNodeChildren(s))), t.skins && (n.skins = t.skins.map((s, r) => this._resolveSkin(s, r))), t.scenes && (n.scenes = t.scenes.map((s, r) => this._resolveScene(s, r))), typeof this.json.scene == \"number\" && n.scenes && (n.scene = n.scenes[this.json.scene]), n;\n  }\n  getScene(t) {\n    return this._get(this.json.scenes, t);\n  }\n  getNode(t) {\n    return this._get(this.json.nodes, t);\n  }\n  getSkin(t) {\n    return this._get(this.json.skins, t);\n  }\n  getMesh(t) {\n    return this._get(this.json.meshes, t);\n  }\n  getMaterial(t) {\n    return this._get(this.json.materials, t);\n  }\n  getAccessor(t) {\n    return this._get(this.json.accessors, t);\n  }\n  getCamera(t) {\n    return this._get(this.json.cameras, t);\n  }\n  getTexture(t) {\n    return this._get(this.json.textures, t);\n  }\n  getSampler(t) {\n    return this._get(this.json.samplers, t);\n  }\n  getImage(t) {\n    return this._get(this.json.images, t);\n  }\n  getBufferView(t) {\n    return this._get(this.json.bufferViews, t);\n  }\n  getBuffer(t) {\n    return this._get(this.json.buffers, t);\n  }\n  _get(t, n) {\n    if (typeof n == \"object\")\n      return n;\n    const s = t && t[n];\n    return s || console.warn(`glTF file error: Could not find ${t}[${n}]`), s;\n  }\n  _resolveScene(t, n) {\n    return {\n      ...t,\n      id: t.id || `scene-${n}`,\n      nodes: (t.nodes || []).map((s) => this.getNode(s))\n    };\n  }\n  _resolveNode(t, n) {\n    const s = {\n      ...t,\n      id: (t == null ? void 0 : t.id) || `node-${n}`\n    };\n    return t.mesh !== void 0 && (s.mesh = this.getMesh(t.mesh)), t.camera !== void 0 && (s.camera = this.getCamera(t.camera)), t.skin !== void 0 && (s.skin = this.getSkin(t.skin)), t.meshes !== void 0 && t.meshes.length && (s.mesh = t.meshes.reduce((r, i) => {\n      const o = this.getMesh(i);\n      return r.id = o.id, r.primitives = r.primitives.concat(o.primitives), r;\n    }, {\n      primitives: []\n    })), s;\n  }\n  _resolveNodeChildren(t) {\n    return t.children && (t.children = t.children.map((n) => this.getNode(n))), t;\n  }\n  _resolveSkin(t, n) {\n    const s = typeof t.inverseBindMatrices == \"number\" ? this.getAccessor(t.inverseBindMatrices) : void 0;\n    return {\n      ...t,\n      id: t.id || `skin-${n}`,\n      inverseBindMatrices: s\n    };\n  }\n  _resolveMesh(t, n) {\n    const s = {\n      ...t,\n      id: t.id || `mesh-${n}`,\n      primitives: []\n    };\n    return t.primitives && (s.primitives = t.primitives.map((r) => {\n      const i = {\n        ...r,\n        attributes: {},\n        indices: void 0,\n        material: void 0\n      }, o = r.attributes;\n      for (const a in o)\n        i.attributes[a] = this.getAccessor(o[a]);\n      return r.indices !== void 0 && (i.indices = this.getAccessor(r.indices)), r.material !== void 0 && (i.material = this.getMaterial(r.material)), i;\n    })), s;\n  }\n  _resolveMaterial(t, n) {\n    const s = {\n      ...t,\n      id: t.id || `material-${n}`\n    };\n    if (s.normalTexture && (s.normalTexture = {\n      ...s.normalTexture\n    }, s.normalTexture.texture = this.getTexture(s.normalTexture.index)), s.occlusionTexture && (s.occlusionTexture = {\n      ...s.occlusionTexture\n    }, s.occlusionTexture.texture = this.getTexture(s.occlusionTexture.index)), s.emissiveTexture && (s.emissiveTexture = {\n      ...s.emissiveTexture\n    }, s.emissiveTexture.texture = this.getTexture(s.emissiveTexture.index)), s.emissiveFactor || (s.emissiveFactor = s.emissiveTexture ? [1, 1, 1] : [0, 0, 0]), s.pbrMetallicRoughness) {\n      s.pbrMetallicRoughness = {\n        ...s.pbrMetallicRoughness\n      };\n      const r = s.pbrMetallicRoughness;\n      r.baseColorTexture && (r.baseColorTexture = {\n        ...r.baseColorTexture\n      }, r.baseColorTexture.texture = this.getTexture(r.baseColorTexture.index)), r.metallicRoughnessTexture && (r.metallicRoughnessTexture = {\n        ...r.metallicRoughnessTexture\n      }, r.metallicRoughnessTexture.texture = this.getTexture(r.metallicRoughnessTexture.index));\n    }\n    return s;\n  }\n  _resolveAccessor(t, n) {\n    const s = Rg(t.componentType), r = Ig(t.type), i = s * r, o = {\n      ...t,\n      id: t.id || `accessor-${n}`,\n      bytesPerComponent: s,\n      components: r,\n      bytesPerElement: i,\n      value: void 0,\n      bufferView: void 0,\n      sparse: void 0\n    };\n    if (t.bufferView !== void 0 && (o.bufferView = this.getBufferView(t.bufferView)), o.bufferView) {\n      const a = o.bufferView.buffer, {\n        ArrayType: c,\n        byteLength: u\n      } = Xs(o, o.bufferView), l = (o.bufferView.byteOffset || 0) + (o.byteOffset || 0) + a.byteOffset;\n      let h = a.arrayBuffer.slice(l, l + u);\n      o.bufferView.byteStride && (h = this._getValueFromInterleavedBuffer(a, l, o.bufferView.byteStride, o.bytesPerElement, o.count)), o.value = new c(h);\n    }\n    return o;\n  }\n  _getValueFromInterleavedBuffer(t, n, s, r, i) {\n    const o = new Uint8Array(i * r);\n    for (let a = 0; a < i; a++) {\n      const c = n + a * s;\n      o.set(new Uint8Array(t.arrayBuffer.slice(c, c + r)), a * r);\n    }\n    return o.buffer;\n  }\n  _resolveTexture(t, n) {\n    return {\n      ...t,\n      id: t.id || `texture-${n}`,\n      sampler: typeof t.sampler == \"number\" ? this.getSampler(t.sampler) : Mg(),\n      source: typeof t.source == \"number\" ? this.getImage(t.source) : void 0\n    };\n  }\n  _resolveSampler(t, n) {\n    const s = {\n      id: t.id || `sampler-${n}`,\n      ...t,\n      parameters: {}\n    };\n    for (const r in s) {\n      const i = this._enumSamplerParameter(r);\n      i !== void 0 && (s.parameters[i] = s[r]);\n    }\n    return s;\n  }\n  _enumSamplerParameter(t) {\n    return _g[t];\n  }\n  _resolveImage(t, n) {\n    const s = {\n      ...t,\n      id: t.id || `image-${n}`,\n      image: null,\n      bufferView: t.bufferView !== void 0 ? this.getBufferView(t.bufferView) : void 0\n    }, r = this.images[n];\n    return r && (s.image = r), s;\n  }\n  _resolveBufferView(t, n) {\n    const s = t.buffer, r = this.buffers[s].arrayBuffer;\n    let i = this.buffers[s].byteOffset || 0;\n    return t.byteOffset && (i += t.byteOffset), {\n      id: `bufferView-${n}`,\n      ...t,\n      buffer: this.buffers[s],\n      data: new Uint8Array(r, i, t.byteLength)\n    };\n  }\n  _resolveCamera(t, n) {\n    const s = {\n      ...t,\n      id: t.id || `camera-${n}`\n    };\n    return s.perspective, s.orthographic, s;\n  }\n}\nfunction ga(e, t) {\n  return new Sg().postProcess(e, t);\n}\nconst Ms = {\n  URI: 0,\n  EMBEDDED: 1\n};\nfunction pa(e, t, n, s) {\n  e.rotateYtoZ = !0;\n  const r = (e.byteOffset || 0) + (e.byteLength || 0) - n;\n  if (r === 0)\n    throw new Error(\"glTF byte length must be greater than 0.\");\n  return e.gltfUpAxis = s != null && s[\"3d-tiles\"] && s[\"3d-tiles\"].assetGltfUpAxis ? s[\"3d-tiles\"].assetGltfUpAxis : \"Y\", e.gltfArrayBuffer = Fs(t, n, r), e.gltfByteOffset = 0, e.gltfByteLength = r, n % 4 === 0 || console.warn(`${e.type}: embedded glb is not aligned to a 4-byte boundary.`), (e.byteOffset || 0) + (e.byteLength || 0);\n}\nasync function Ba(e, t, n, s) {\n  const r = (n == null ? void 0 : n[\"3d-tiles\"]) || {};\n  if (Dg(e, t), r.loadGLTF) {\n    if (!s)\n      return;\n    if (e.gltfUrl) {\n      const {\n        fetch: i\n      } = s, o = await i(e.gltfUrl, n);\n      e.gltfArrayBuffer = await o.arrayBuffer(), e.gltfByteOffset = 0;\n    }\n    if (e.gltfArrayBuffer) {\n      const i = await Re(e.gltfArrayBuffer, pn, n, s);\n      e.gltf = ga(i), e.gpuMemoryUsageInBytes = ta(e.gltf), delete e.gltfArrayBuffer, delete e.gltfByteOffset, delete e.gltfByteLength;\n    }\n  }\n}\nfunction Dg(e, t, n) {\n  switch (t) {\n    case Ms.URI:\n      if (e.gltfArrayBuffer) {\n        const s = new Uint8Array(e.gltfArrayBuffer, e.gltfByteOffset), i = new TextDecoder().decode(s);\n        e.gltfUrl = i.replace(/[\\s\\0]+$/, \"\");\n      }\n      delete e.gltfArrayBuffer, delete e.gltfByteOffset, delete e.gltfByteLength;\n      break;\n    case Ms.EMBEDDED:\n      break;\n    default:\n      throw new Error(\"b3dm: Illegal glTF format field\");\n  }\n}\nasync function Fg(e, t, n, s, r) {\n  var i;\n  n = Og(e, t, n, s), await Ba(e, Ms.EMBEDDED, s, r);\n  const o = e == null || (i = e.gltf) === null || i === void 0 ? void 0 : i.extensions;\n  return o && o.CESIUM_RTC && (e.rtcCenter = o.CESIUM_RTC.center), n;\n}\nfunction Og(e, t, n, s, r) {\n  n = Rn(e, t, n), n = ks(e, t, n), n = js(e, t, n), n = pa(e, t, n, s);\n  const i = new Vs(e.featureTableJson, e.featureTableBinary);\n  return e.rtcCenter = i.getGlobalProperty(\"RTC_CENTER\", x.FLOAT, 3), n;\n}\nasync function vg(e, t, n, s, r) {\n  return n = xg(e, t, n, s), await Ba(e, e.gltfFormat || 0, s, r), n;\n}\nfunction xg(e, t, n, s, r) {\n  var i;\n  if (n = Rn(e, t, n), e.version !== 1)\n    throw new Error(`Instanced 3D Model version ${e.version} is not supported`);\n  n = ks(e, t, n);\n  const o = new DataView(t);\n  if (e.gltfFormat = o.getUint32(n, !0), n += 4, n = js(e, t, n), n = pa(e, t, n, s), !(e != null && (i = e.header) !== null && i !== void 0 && i.featureTableJsonByteLength) || e.header.featureTableJsonByteLength === 0)\n    throw new Error(\"i3dm parser: featureTableJsonByteLength is zero.\");\n  const a = new Vs(e.featureTableJson, e.featureTableBinary), c = a.getGlobalProperty(\"INSTANCES_LENGTH\");\n  if (a.featuresLength = c, !Number.isFinite(c))\n    throw new Error(\"i3dm parser: INSTANCES_LENGTH must be defined\");\n  e.eastNorthUp = a.getGlobalProperty(\"EAST_NORTH_UP\"), e.rtcCenter = a.getGlobalProperty(\"RTC_CENTER\", x.FLOAT, 3);\n  const u = new zo(e.batchTableJson, e.batchTableBinary, c);\n  return Lg(e, a, u, c), n;\n}\nfunction Lg(e, t, n, s) {\n  const r = new Array(s), i = new m();\n  new m(), new m(), new m();\n  const o = new j(), a = new hn(), c = new m(), u = {}, l = new N(), h = [], f = [], d = [], A = [];\n  for (let g = 0; g < s; g++) {\n    let p;\n    if (t.hasProperty(\"POSITION\"))\n      p = t.getProperty(\"POSITION\", x.FLOAT, 3, g, i);\n    else if (t.hasProperty(\"POSITION_QUANTIZED\")) {\n      p = t.getProperty(\"POSITION_QUANTIZED\", x.UNSIGNED_SHORT, 3, g, i);\n      const C = t.getGlobalProperty(\"QUANTIZED_VOLUME_OFFSET\", x.FLOAT, 3);\n      if (!C)\n        throw new Error(\"i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\");\n      const D = t.getGlobalProperty(\"QUANTIZED_VOLUME_SCALE\", x.FLOAT, 3);\n      if (!D)\n        throw new Error(\"i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\");\n      const F = 65535;\n      for (let I = 0; I < 3; I++)\n        p[I] = p[I] / F * D[I] + C[I];\n    }\n    if (!p)\n      throw new Error(\"i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.\");\n    if (i.copy(p), u.translation = i, e.normalUp = t.getProperty(\"NORMAL_UP\", x.FLOAT, 3, g, h), e.normalRight = t.getProperty(\"NORMAL_RIGHT\", x.FLOAT, 3, g, f), e.normalUp) {\n      if (!e.normalRight)\n        throw new Error(\"i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.\");\n      e.hasCustomOrientation = !0;\n    } else {\n      if (e.octNormalUp = t.getProperty(\"NORMAL_UP_OCT32P\", x.UNSIGNED_SHORT, 2, g, h), e.octNormalRight = t.getProperty(\"NORMAL_RIGHT_OCT32P\", x.UNSIGNED_SHORT, 2, g, f), e.octNormalUp)\n        throw e.octNormalRight ? new Error(\"i3dm: oct-encoded orientation not implemented\") : new Error(\"i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P\");\n      e.eastNorthUp ? (H.WGS84.eastNorthUpToFixedFrame(i, l), l.getRotationMatrix3(o)) : o.identity();\n    }\n    a.fromMatrix3(o), u.rotation = a, c.set(1, 1, 1);\n    const y = t.getProperty(\"SCALE\", x.FLOAT, 1, g, d);\n    Number.isFinite(y) && c.multiplyByScalar(y);\n    const _ = t.getProperty(\"SCALE_NON_UNIFORM\", x.FLOAT, 3, g, h);\n    _ && c.scale(_), u.scale = c;\n    let b = t.getProperty(\"BATCH_ID\", x.UNSIGNED_SHORT, 1, g, A);\n    b === void 0 && (b = g);\n    const w = new N().fromQuaternion(u.rotation);\n    l.identity(), l.translate(u.translation), l.multiplyRight(w), l.scale(u.scale);\n    const M = l.clone();\n    r[g] = {\n      modelMatrix: M,\n      batchId: b\n    };\n  }\n  e.instances = r;\n}\nasync function Gg(e, t, n, s, r, i) {\n  n = Rn(e, t, n);\n  const o = new DataView(t);\n  for (e.tilesLength = o.getUint32(n, !0), n += 4, e.tiles = []; e.tiles.length < e.tilesLength && (e.byteLength || 0) - n > 12; ) {\n    const a = {\n      shape: \"tile3d\"\n    };\n    e.tiles.push(a), n = await i(t, n, s, r, a);\n  }\n  return n;\n}\nasync function Ug(e, t, n, s) {\n  var r, i;\n  if (e.rotateYtoZ = !0, e.gltfUpAxis = n != null && (r = n[\"3d-tiles\"]) !== null && r !== void 0 && r.assetGltfUpAxis ? n[\"3d-tiles\"].assetGltfUpAxis : \"Y\", n != null && (i = n[\"3d-tiles\"]) !== null && i !== void 0 && i.loadGLTF) {\n    if (!s)\n      return t.byteLength;\n    const o = await Re(t, pn, n, s);\n    e.gltf = ga(o), e.gpuMemoryUsageInBytes = ta(e.gltf);\n  } else\n    e.gltfArrayBuffer = t;\n  return t.byteLength;\n}\nasync function ya(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 ? arguments[2] : void 0, s = arguments.length > 3 ? arguments[3] : void 0, r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {\n    shape: \"tile3d\"\n  };\n  switch (r.byteOffset = t, r.type = id(e, t), r.type) {\n    case de.COMPOSITE:\n      return await Gg(r, e, t, n, s, ya);\n    case de.BATCHED_3D_MODEL:\n      return await Fg(r, e, t, n, s);\n    case de.GLTF:\n      return await Ug(r, e, n, s);\n    case de.INSTANCED_3D_MODEL:\n      return await vg(r, e, t, n, s);\n    case de.POINT_CLOUD:\n      return await kd(r, e, t, n, s);\n    default:\n      throw new Error(`3DTileLoader: unknown type ${r.type}`);\n  }\n}\nconst Pg = 1952609651, Ng = 1;\nasync function Hg(e, t, n) {\n  if (new Uint32Array(e.slice(0, 4))[0] !== Pg)\n    throw new Error(\"Wrong subtree file magic number\");\n  if (new Uint32Array(e.slice(4, 8))[0] !== Ng)\n    throw new Error(\"Wrong subtree file verson, must be 1\");\n  const i = Oi(e.slice(8, 16)), o = new Uint8Array(e, 24, i), c = new TextDecoder(\"utf8\").decode(o), u = JSON.parse(c), l = Oi(e.slice(16, 24));\n  let h = new ArrayBuffer(0);\n  if (l && (h = e.slice(24 + i)), await tn(u, u.tileAvailability, h, n), Array.isArray(u.contentAvailability))\n    for (const f of u.contentAvailability)\n      await tn(u, f, h, n);\n  else\n    await tn(u, u.contentAvailability, h, n);\n  return await tn(u, u.childSubtreeAvailability, h, n), u;\n}\nasync function tn(e, t, n, s) {\n  const r = Number.isFinite(t.bitstream) ? t.bitstream : t.bufferView;\n  if (typeof r != \"number\")\n    return;\n  const i = e.bufferViews[r], o = e.buffers[i.buffer];\n  if (!(s != null && s.baseUrl))\n    throw new Error(\"Url is not provided\");\n  if (!s.fetch)\n    throw new Error(\"fetch is not provided\");\n  if (o.uri) {\n    const c = `${(s == null ? void 0 : s.baseUrl) || \"\"}/${o.uri}`, l = await (await s.fetch(c)).arrayBuffer();\n    t.explicitBitstream = new Uint8Array(l, i.byteOffset, i.byteLength);\n    return;\n  }\n  const a = e.buffers.slice(0, i.buffer).reduce((c, u) => c + u.byteLength, 0);\n  t.explicitBitstream = new Uint8Array(n.slice(a, a + o.byteLength), i.byteOffset, i.byteLength);\n}\nfunction Oi(e) {\n  const t = new DataView(e), n = t.getUint32(0, !0), s = t.getUint32(4, !0);\n  return n + 2 ** 32 * s;\n}\nconst Ca = {\n  id: \"3d-tiles-subtree\",\n  name: \"3D Tiles Subtree\",\n  module: \"3d-tiles\",\n  version: Jo,\n  extensions: [\"subtree\"],\n  mimeTypes: [\"application/octet-stream\"],\n  tests: [\"subtree\"],\n  parse: Hg,\n  options: {}\n};\n/**\n * @license\n * Copyright 2009 The Closure Library Authors\n * Copyright 2020 Daniel Wirtz / The long.js Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nvar gt = null;\ntry {\n  gt = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n    0,\n    97,\n    115,\n    109,\n    1,\n    0,\n    0,\n    0,\n    1,\n    13,\n    2,\n    96,\n    0,\n    1,\n    127,\n    96,\n    4,\n    127,\n    127,\n    127,\n    127,\n    1,\n    127,\n    3,\n    7,\n    6,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    6,\n    6,\n    1,\n    127,\n    1,\n    65,\n    0,\n    11,\n    7,\n    50,\n    6,\n    3,\n    109,\n    117,\n    108,\n    0,\n    1,\n    5,\n    100,\n    105,\n    118,\n    95,\n    115,\n    0,\n    2,\n    5,\n    100,\n    105,\n    118,\n    95,\n    117,\n    0,\n    3,\n    5,\n    114,\n    101,\n    109,\n    95,\n    115,\n    0,\n    4,\n    5,\n    114,\n    101,\n    109,\n    95,\n    117,\n    0,\n    5,\n    8,\n    103,\n    101,\n    116,\n    95,\n    104,\n    105,\n    103,\n    104,\n    0,\n    0,\n    10,\n    191,\n    1,\n    6,\n    4,\n    0,\n    35,\n    0,\n    11,\n    36,\n    1,\n    1,\n    126,\n    32,\n    0,\n    173,\n    32,\n    1,\n    173,\n    66,\n    32,\n    134,\n    132,\n    32,\n    2,\n    173,\n    32,\n    3,\n    173,\n    66,\n    32,\n    134,\n    132,\n    126,\n    34,\n    4,\n    66,\n    32,\n    135,\n    167,\n    36,\n    0,\n    32,\n    4,\n    167,\n    11,\n    36,\n    1,\n    1,\n    126,\n    32,\n    0,\n    173,\n    32,\n    1,\n    173,\n    66,\n    32,\n    134,\n    132,\n    32,\n    2,\n    173,\n    32,\n    3,\n    173,\n    66,\n    32,\n    134,\n    132,\n    127,\n    34,\n    4,\n    66,\n    32,\n    135,\n    167,\n    36,\n    0,\n    32,\n    4,\n    167,\n    11,\n    36,\n    1,\n    1,\n    126,\n    32,\n    0,\n    173,\n    32,\n    1,\n    173,\n    66,\n    32,\n    134,\n    132,\n    32,\n    2,\n    173,\n    32,\n    3,\n    173,\n    66,\n    32,\n    134,\n    132,\n    128,\n    34,\n    4,\n    66,\n    32,\n    135,\n    167,\n    36,\n    0,\n    32,\n    4,\n    167,\n    11,\n    36,\n    1,\n    1,\n    126,\n    32,\n    0,\n    173,\n    32,\n    1,\n    173,\n    66,\n    32,\n    134,\n    132,\n    32,\n    2,\n    173,\n    32,\n    3,\n    173,\n    66,\n    32,\n    134,\n    132,\n    129,\n    34,\n    4,\n    66,\n    32,\n    135,\n    167,\n    36,\n    0,\n    32,\n    4,\n    167,\n    11,\n    36,\n    1,\n    1,\n    126,\n    32,\n    0,\n    173,\n    32,\n    1,\n    173,\n    66,\n    32,\n    134,\n    132,\n    32,\n    2,\n    173,\n    32,\n    3,\n    173,\n    66,\n    32,\n    134,\n    132,\n    130,\n    34,\n    4,\n    66,\n    32,\n    135,\n    167,\n    36,\n    0,\n    32,\n    4,\n    167,\n    11\n  ])), {}).exports;\n} catch {\n}\nfunction P(e, t, n) {\n  this.low = e | 0, this.high = t | 0, this.unsigned = !!n;\n}\nP.prototype.__isLong__;\nObject.defineProperty(P.prototype, \"__isLong__\", { value: !0 });\nfunction tt(e) {\n  return (e && e.__isLong__) === !0;\n}\nfunction vi(e) {\n  var t = Math.clz32(e & -e);\n  return e ? 31 - t : t;\n}\nP.isLong = tt;\nvar xi = {}, Li = {};\nfunction qt(e, t) {\n  var n, s, r;\n  return t ? (e >>>= 0, (r = 0 <= e && e < 256) && (s = Li[e], s) ? s : (n = L(e, 0, !0), r && (Li[e] = n), n)) : (e |= 0, (r = -128 <= e && e < 128) && (s = xi[e], s) ? s : (n = L(e, e < 0 ? -1 : 0, !1), r && (xi[e] = n), n));\n}\nP.fromInt = qt;\nfunction pt(e, t) {\n  if (isNaN(e))\n    return t ? vt : bt;\n  if (t) {\n    if (e < 0)\n      return vt;\n    if (e >= Ta)\n      return _a;\n  } else {\n    if (e <= -Ui)\n      return ct;\n    if (e + 1 >= Ui)\n      return ba;\n  }\n  return e < 0 ? pt(-e, t).neg() : L(e % ce | 0, e / ce | 0, t);\n}\nP.fromNumber = pt;\nfunction L(e, t, n) {\n  return new P(e, t, n);\n}\nP.fromBits = L;\nvar Bn = Math.pow;\nfunction er(e, t, n) {\n  if (e.length === 0)\n    throw Error(\"empty string\");\n  if (typeof t == \"number\" ? (n = t, t = !1) : t = !!t, e === \"NaN\" || e === \"Infinity\" || e === \"+Infinity\" || e === \"-Infinity\")\n    return t ? vt : bt;\n  if (n = n || 10, n < 2 || 36 < n)\n    throw RangeError(\"radix\");\n  var s;\n  if ((s = e.indexOf(\"-\")) > 0)\n    throw Error(\"interior hyphen\");\n  if (s === 0)\n    return er(e.substring(1), t, n).neg();\n  for (var r = pt(Bn(n, 8)), i = bt, o = 0; o < e.length; o += 8) {\n    var a = Math.min(8, e.length - o), c = parseInt(e.substring(o, o + a), n);\n    if (a < 8) {\n      var u = pt(Bn(n, a));\n      i = i.mul(u).add(pt(c));\n    } else\n      i = i.mul(r), i = i.add(pt(c));\n  }\n  return i.unsigned = t, i;\n}\nP.fromString = er;\nfunction wt(e, t) {\n  return typeof e == \"number\" ? pt(e, t) : typeof e == \"string\" ? er(e, t) : L(e.low, e.high, typeof t == \"boolean\" ? t : e.unsigned);\n}\nP.fromValue = wt;\nvar Gi = 65536, Jg = 1 << 24, ce = Gi * Gi, Ta = ce * ce, Ui = Ta / 2, Pi = qt(Jg), bt = qt(0);\nP.ZERO = bt;\nvar vt = qt(0, !0);\nP.UZERO = vt;\nvar oe = qt(1);\nP.ONE = oe;\nvar Ea = qt(1, !0);\nP.UONE = Ea;\nvar Rs = qt(-1);\nP.NEG_ONE = Rs;\nvar ba = L(-1, 2147483647, !1);\nP.MAX_VALUE = ba;\nvar _a = L(-1, -1, !0);\nP.MAX_UNSIGNED_VALUE = _a;\nvar ct = L(0, -2147483648, !1);\nP.MIN_VALUE = ct;\nvar B = P.prototype;\nB.toInt = function() {\n  return this.unsigned ? this.low >>> 0 : this.low;\n};\nB.toNumber = function() {\n  return this.unsigned ? (this.high >>> 0) * ce + (this.low >>> 0) : this.high * ce + (this.low >>> 0);\n};\nB.toString = function(t) {\n  if (t = t || 10, t < 2 || 36 < t)\n    throw RangeError(\"radix\");\n  if (this.isZero())\n    return \"0\";\n  if (this.isNegative())\n    if (this.eq(ct)) {\n      var n = pt(t), s = this.div(n), r = s.mul(n).sub(this);\n      return s.toString(t) + r.toInt().toString(t);\n    } else\n      return \"-\" + this.neg().toString(t);\n  for (var i = pt(Bn(t, 6), this.unsigned), o = this, a = \"\"; ; ) {\n    var c = o.div(i), u = o.sub(c.mul(i)).toInt() >>> 0, l = u.toString(t);\n    if (o = c, o.isZero())\n      return l + a;\n    for (; l.length < 6; )\n      l = \"0\" + l;\n    a = \"\" + l + a;\n  }\n};\nB.getHighBits = function() {\n  return this.high;\n};\nB.getHighBitsUnsigned = function() {\n  return this.high >>> 0;\n};\nB.getLowBits = function() {\n  return this.low;\n};\nB.getLowBitsUnsigned = function() {\n  return this.low >>> 0;\n};\nB.getNumBitsAbs = function() {\n  if (this.isNegative())\n    return this.eq(ct) ? 64 : this.neg().getNumBitsAbs();\n  for (var t = this.high != 0 ? this.high : this.low, n = 31; n > 0 && !(t & 1 << n); n--)\n    ;\n  return this.high != 0 ? n + 33 : n + 1;\n};\nB.isZero = function() {\n  return this.high === 0 && this.low === 0;\n};\nB.eqz = B.isZero;\nB.isNegative = function() {\n  return !this.unsigned && this.high < 0;\n};\nB.isPositive = function() {\n  return this.unsigned || this.high >= 0;\n};\nB.isOdd = function() {\n  return (this.low & 1) === 1;\n};\nB.isEven = function() {\n  return (this.low & 1) === 0;\n};\nB.equals = function(t) {\n  return tt(t) || (t = wt(t)), this.unsigned !== t.unsigned && this.high >>> 31 === 1 && t.high >>> 31 === 1 ? !1 : this.high === t.high && this.low === t.low;\n};\nB.eq = B.equals;\nB.notEquals = function(t) {\n  return !this.eq(\n    /* validates */\n    t\n  );\n};\nB.neq = B.notEquals;\nB.ne = B.notEquals;\nB.lessThan = function(t) {\n  return this.comp(\n    /* validates */\n    t\n  ) < 0;\n};\nB.lt = B.lessThan;\nB.lessThanOrEqual = function(t) {\n  return this.comp(\n    /* validates */\n    t\n  ) <= 0;\n};\nB.lte = B.lessThanOrEqual;\nB.le = B.lessThanOrEqual;\nB.greaterThan = function(t) {\n  return this.comp(\n    /* validates */\n    t\n  ) > 0;\n};\nB.gt = B.greaterThan;\nB.greaterThanOrEqual = function(t) {\n  return this.comp(\n    /* validates */\n    t\n  ) >= 0;\n};\nB.gte = B.greaterThanOrEqual;\nB.ge = B.greaterThanOrEqual;\nB.compare = function(t) {\n  if (tt(t) || (t = wt(t)), this.eq(t))\n    return 0;\n  var n = this.isNegative(), s = t.isNegative();\n  return n && !s ? -1 : !n && s ? 1 : this.unsigned ? t.high >>> 0 > this.high >>> 0 || t.high === this.high && t.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t).isNegative() ? -1 : 1;\n};\nB.comp = B.compare;\nB.negate = function() {\n  return !this.unsigned && this.eq(ct) ? ct : this.not().add(oe);\n};\nB.neg = B.negate;\nB.add = function(t) {\n  tt(t) || (t = wt(t));\n  var n = this.high >>> 16, s = this.high & 65535, r = this.low >>> 16, i = this.low & 65535, o = t.high >>> 16, a = t.high & 65535, c = t.low >>> 16, u = t.low & 65535, l = 0, h = 0, f = 0, d = 0;\n  return d += i + u, f += d >>> 16, d &= 65535, f += r + c, h += f >>> 16, f &= 65535, h += s + a, l += h >>> 16, h &= 65535, l += n + o, l &= 65535, L(f << 16 | d, l << 16 | h, this.unsigned);\n};\nB.subtract = function(t) {\n  return tt(t) || (t = wt(t)), this.add(t.neg());\n};\nB.sub = B.subtract;\nB.multiply = function(t) {\n  if (this.isZero())\n    return this;\n  if (tt(t) || (t = wt(t)), gt) {\n    var n = gt.mul(\n      this.low,\n      this.high,\n      t.low,\n      t.high\n    );\n    return L(n, gt.get_high(), this.unsigned);\n  }\n  if (t.isZero())\n    return this.unsigned ? vt : bt;\n  if (this.eq(ct))\n    return t.isOdd() ? ct : bt;\n  if (t.eq(ct))\n    return this.isOdd() ? ct : bt;\n  if (this.isNegative())\n    return t.isNegative() ? this.neg().mul(t.neg()) : this.neg().mul(t).neg();\n  if (t.isNegative())\n    return this.mul(t.neg()).neg();\n  if (this.lt(Pi) && t.lt(Pi))\n    return pt(this.toNumber() * t.toNumber(), this.unsigned);\n  var s = this.high >>> 16, r = this.high & 65535, i = this.low >>> 16, o = this.low & 65535, a = t.high >>> 16, c = t.high & 65535, u = t.low >>> 16, l = t.low & 65535, h = 0, f = 0, d = 0, A = 0;\n  return A += o * l, d += A >>> 16, A &= 65535, d += i * l, f += d >>> 16, d &= 65535, d += o * u, f += d >>> 16, d &= 65535, f += r * l, h += f >>> 16, f &= 65535, f += i * u, h += f >>> 16, f &= 65535, f += o * c, h += f >>> 16, f &= 65535, h += s * l + r * u + i * c + o * a, h &= 65535, L(d << 16 | A, h << 16 | f, this.unsigned);\n};\nB.mul = B.multiply;\nB.divide = function(t) {\n  if (tt(t) || (t = wt(t)), t.isZero())\n    throw Error(\"division by zero\");\n  if (gt) {\n    if (!this.unsigned && this.high === -2147483648 && t.low === -1 && t.high === -1)\n      return this;\n    var n = (this.unsigned ? gt.div_u : gt.div_s)(\n      this.low,\n      this.high,\n      t.low,\n      t.high\n    );\n    return L(n, gt.get_high(), this.unsigned);\n  }\n  if (this.isZero())\n    return this.unsigned ? vt : bt;\n  var s, r, i;\n  if (this.unsigned) {\n    if (t.unsigned || (t = t.toUnsigned()), t.gt(this))\n      return vt;\n    if (t.gt(this.shru(1)))\n      return Ea;\n    i = vt;\n  } else {\n    if (this.eq(ct)) {\n      if (t.eq(oe) || t.eq(Rs))\n        return ct;\n      if (t.eq(ct))\n        return oe;\n      var o = this.shr(1);\n      return s = o.div(t).shl(1), s.eq(bt) ? t.isNegative() ? oe : Rs : (r = this.sub(t.mul(s)), i = s.add(r.div(t)), i);\n    } else if (t.eq(ct))\n      return this.unsigned ? vt : bt;\n    if (this.isNegative())\n      return t.isNegative() ? this.neg().div(t.neg()) : this.neg().div(t).neg();\n    if (t.isNegative())\n      return this.div(t.neg()).neg();\n    i = bt;\n  }\n  for (r = this; r.gte(t); ) {\n    s = Math.max(1, Math.floor(r.toNumber() / t.toNumber()));\n    for (var a = Math.ceil(Math.log(s) / Math.LN2), c = a <= 48 ? 1 : Bn(2, a - 48), u = pt(s), l = u.mul(t); l.isNegative() || l.gt(r); )\n      s -= c, u = pt(s, this.unsigned), l = u.mul(t);\n    u.isZero() && (u = oe), i = i.add(u), r = r.sub(l);\n  }\n  return i;\n};\nB.div = B.divide;\nB.modulo = function(t) {\n  if (tt(t) || (t = wt(t)), gt) {\n    var n = (this.unsigned ? gt.rem_u : gt.rem_s)(\n      this.low,\n      this.high,\n      t.low,\n      t.high\n    );\n    return L(n, gt.get_high(), this.unsigned);\n  }\n  return this.sub(this.div(t).mul(t));\n};\nB.mod = B.modulo;\nB.rem = B.modulo;\nB.not = function() {\n  return L(~this.low, ~this.high, this.unsigned);\n};\nB.countLeadingZeros = function() {\n  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n};\nB.clz = B.countLeadingZeros;\nB.countTrailingZeros = function() {\n  return this.low ? vi(this.low) : vi(this.high) + 32;\n};\nB.ctz = B.countTrailingZeros;\nB.and = function(t) {\n  return tt(t) || (t = wt(t)), L(this.low & t.low, this.high & t.high, this.unsigned);\n};\nB.or = function(t) {\n  return tt(t) || (t = wt(t)), L(this.low | t.low, this.high | t.high, this.unsigned);\n};\nB.xor = function(t) {\n  return tt(t) || (t = wt(t)), L(this.low ^ t.low, this.high ^ t.high, this.unsigned);\n};\nB.shiftLeft = function(t) {\n  return tt(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? L(this.low << t, this.high << t | this.low >>> 32 - t, this.unsigned) : L(0, this.low << t - 32, this.unsigned);\n};\nB.shl = B.shiftLeft;\nB.shiftRight = function(t) {\n  return tt(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? L(this.low >>> t | this.high << 32 - t, this.high >> t, this.unsigned) : L(this.high >> t - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n};\nB.shr = B.shiftRight;\nB.shiftRightUnsigned = function(t) {\n  return tt(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? L(this.low >>> t | this.high << 32 - t, this.high >>> t, this.unsigned) : t === 32 ? L(this.high, 0, this.unsigned) : L(this.high >>> t - 32, 0, this.unsigned);\n};\nB.shru = B.shiftRightUnsigned;\nB.shr_u = B.shiftRightUnsigned;\nB.rotateLeft = function(t) {\n  var n;\n  return tt(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t === 32 ? L(this.high, this.low, this.unsigned) : t < 32 ? (n = 32 - t, L(this.low << t | this.high >>> n, this.high << t | this.low >>> n, this.unsigned)) : (t -= 32, n = 32 - t, L(this.high << t | this.low >>> n, this.low << t | this.high >>> n, this.unsigned));\n};\nB.rotl = B.rotateLeft;\nB.rotateRight = function(t) {\n  var n;\n  return tt(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t === 32 ? L(this.high, this.low, this.unsigned) : t < 32 ? (n = 32 - t, L(this.high << n | this.low >>> t, this.low << n | this.high >>> t, this.unsigned)) : (t -= 32, n = 32 - t, L(this.low << n | this.high >>> t, this.high << n | this.low >>> t, this.unsigned));\n};\nB.rotr = B.rotateRight;\nB.toSigned = function() {\n  return this.unsigned ? L(this.low, this.high, !1) : this;\n};\nB.toUnsigned = function() {\n  return this.unsigned ? this : L(this.low, this.high, !0);\n};\nB.toBytes = function(t) {\n  return t ? this.toBytesLE() : this.toBytesBE();\n};\nB.toBytesLE = function() {\n  var t = this.high, n = this.low;\n  return [\n    n & 255,\n    n >>> 8 & 255,\n    n >>> 16 & 255,\n    n >>> 24,\n    t & 255,\n    t >>> 8 & 255,\n    t >>> 16 & 255,\n    t >>> 24\n  ];\n};\nB.toBytesBE = function() {\n  var t = this.high, n = this.low;\n  return [\n    t >>> 24,\n    t >>> 16 & 255,\n    t >>> 8 & 255,\n    t & 255,\n    n >>> 24,\n    n >>> 16 & 255,\n    n >>> 8 & 255,\n    n & 255\n  ];\n};\nP.fromBytes = function(t, n, s) {\n  return s ? P.fromBytesLE(t, n) : P.fromBytesBE(t, n);\n};\nP.fromBytesLE = function(t, n) {\n  return new P(\n    t[0] | t[1] << 8 | t[2] << 16 | t[3] << 24,\n    t[4] | t[5] << 8 | t[6] << 16 | t[7] << 24,\n    n\n  );\n};\nP.fromBytesBE = function(t, n) {\n  return new P(\n    t[4] << 24 | t[5] << 16 | t[6] << 8 | t[7],\n    t[0] << 24 | t[1] << 16 | t[2] << 8 | t[3],\n    n\n  );\n};\nconst Vg = 16;\nfunction wa(e) {\n  e === \"X\" && (e = \"\");\n  const t = e.padEnd(Vg, \"0\");\n  return P.fromString(t, !0, 16);\n}\nfunction kg(e) {\n  if (e.isZero())\n    return \"X\";\n  let t = e.countTrailingZeros();\n  const n = t % 4;\n  t = (t - n) / 4;\n  const s = t;\n  t *= 4;\n  const i = e.shiftRightUnsigned(t).toString(16).replace(/0+$/, \"\");\n  return Array(17 - s - i.length).join(\"0\") + i;\n}\nfunction jg(e, t) {\n  const n = Kg(e).shiftRightUnsigned(2);\n  return e.add(P.fromNumber(2 * t + 1 - 4).multiply(n));\n}\nfunction Kg(e) {\n  return e.and(e.not().add(1));\n}\nconst zg = 3, Wg = 30, Xg = 2 * Wg + 1, Ni = 180 / Math.PI;\nfunction Qg(e) {\n  if (e.length === 0)\n    throw new Error(`Invalid Hilbert quad key ${e}`);\n  const t = e.split(\"/\"), n = parseInt(t[0], 10), s = t[1], r = s.length;\n  let i = 0;\n  const o = [0, 0];\n  for (let a = r - 1; a >= 0; a--) {\n    i = r - a;\n    const c = s[a];\n    let u = 0, l = 0;\n    c === \"1\" ? l = 1 : c === \"2\" ? (u = 1, l = 1) : c === \"3\" && (u = 1);\n    const h = Math.pow(2, i - 1);\n    Yg(h, o, u, l), o[0] += h * u, o[1] += h * l;\n  }\n  if (n % 2 === 1) {\n    const a = o[0];\n    o[0] = o[1], o[1] = a;\n  }\n  return {\n    face: n,\n    ij: o,\n    level: i\n  };\n}\nfunction qg(e) {\n  if (e.isZero())\n    return \"\";\n  let t = e.toString(2);\n  for (; t.length < zg + Xg; )\n    t = \"0\" + t;\n  const n = t.lastIndexOf(\"1\"), s = t.substring(0, 3), r = t.substring(3, n), i = r.length / 2, o = P.fromString(s, !0, 2).toString(10);\n  let a = \"\";\n  if (i !== 0)\n    for (a = P.fromString(r, !0, 2).toString(4); a.length < i; )\n      a = \"0\" + a;\n  return `${o}/${a}`;\n}\nfunction Ma(e, t, n) {\n  const s = 1 << t;\n  return [(e[0] + n[0]) / s, (e[1] + n[1]) / s];\n}\nfunction Hi(e) {\n  return e >= 0.5 ? 1 / 3 * (4 * e * e - 1) : 1 / 3 * (1 - 4 * (1 - e) * (1 - e));\n}\nfunction Ra(e) {\n  return [Hi(e[0]), Hi(e[1])];\n}\nfunction Ia(e, t) {\n  let [n, s] = t;\n  switch (e) {\n    case 0:\n      return [1, n, s];\n    case 1:\n      return [-n, 1, s];\n    case 2:\n      return [-n, -s, 1];\n    case 3:\n      return [-1, -s, -n];\n    case 4:\n      return [s, -1, -n];\n    case 5:\n      return [s, n, -1];\n    default:\n      throw new Error(\"Invalid face\");\n  }\n}\nfunction Sa(e) {\n  let [t, n, s] = e;\n  const r = Math.atan2(s, Math.sqrt(t * t + n * n));\n  return [Math.atan2(n, t) * Ni, r * Ni];\n}\nfunction Yg(e, t, n, s) {\n  if (s === 0) {\n    n === 1 && (t[0] = e - 1 - t[0], t[1] = e - 1 - t[1]);\n    const r = t[0];\n    t[0] = t[1], t[1] = r;\n  }\n}\nfunction $g(e) {\n  const t = Ma(e.ij, e.level, [0.5, 0.5]), n = Ra(t), s = Ia(e.face, n);\n  return Sa(s);\n}\nconst Zg = 100;\nfunction Ji(e) {\n  const {\n    face: t,\n    ij: n,\n    level: s\n  } = e, r = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]], i = Math.max(1, Math.ceil(Zg * Math.pow(2, -s))), o = new Float64Array(4 * i * 2 + 2);\n  let a = 0, c = 0;\n  for (let u = 0; u < 4; u++) {\n    const l = r[u].slice(0), h = r[u + 1], f = (h[0] - l[0]) / i, d = (h[1] - l[1]) / i;\n    for (let A = 0; A < i; A++) {\n      l[0] += f, l[1] += d;\n      const g = Ma(n, s, l), p = Ra(g), y = Ia(t, p), _ = Sa(y);\n      Math.abs(_[1]) > 89.999 && (_[0] = c);\n      const b = _[0] - c;\n      _[0] += b > 180 ? -360 : b < -180 ? 360 : 0, o[a++] = _[0], o[a++] = _[1], c = _[0];\n    }\n  }\n  return o[a++] = o[0], o[a++] = o[1], o;\n}\nfunction nr(e) {\n  const t = tp(e);\n  return Qg(t);\n}\nfunction tp(e) {\n  if (e.indexOf(\"/\") > 0)\n    return e;\n  const t = wa(e);\n  return qg(t);\n}\nfunction ep(e) {\n  const t = nr(e);\n  return $g(t);\n}\nfunction np(e) {\n  let t;\n  if (e.face === 2 || e.face === 5) {\n    let n = null, s = 0;\n    for (let r = 0; r < 4; r++) {\n      const i = `${e.face}/${r}`, o = nr(i), a = Ji(o);\n      (typeof n > \"u\" || n === null) && (n = new Float64Array(4 * a.length)), n.set(a, s), s += a.length;\n    }\n    t = Vi(n);\n  } else {\n    const n = Ji(e);\n    t = Vi(n);\n  }\n  return t;\n}\nfunction Vi(e) {\n  if (e.length % 2 !== 0)\n    throw new Error(\"Invalid corners\");\n  const t = [], n = [];\n  for (let s = 0; s < e.length; s += 2)\n    t.push(e[s]), n.push(e[s + 1]);\n  return t.sort((s, r) => s - r), n.sort((s, r) => s - r), {\n    west: t[0],\n    east: t[t.length - 1],\n    north: n[n.length - 1],\n    south: n[0]\n  };\n}\nfunction sp(e, t) {\n  const n = (t == null ? void 0 : t.minimumHeight) || 0, s = (t == null ? void 0 : t.maximumHeight) || 0, r = nr(e), i = np(r), o = i.west, a = i.south, c = i.east, u = i.north, l = [];\n  return l.push(new m(o, u, n)), l.push(new m(c, u, n)), l.push(new m(c, a, n)), l.push(new m(o, a, n)), l.push(new m(o, u, s)), l.push(new m(c, u, s)), l.push(new m(c, a, s)), l.push(new m(o, a, s)), l;\n}\nfunction Da(e) {\n  const t = e.token, n = {\n    minimumHeight: e.minimumHeight,\n    maximumHeight: e.maximumHeight\n  }, s = sp(t, n), r = ep(t), i = r[0], o = r[1], a = H.WGS84.cartographicToCartesian([i, o, n.maximumHeight]), c = new m(a[0], a[1], a[2]);\n  s.push(c);\n  const u = If(s);\n  return [...u.center, ...u.halfAxes];\n}\nconst rp = 4, ip = 8, op = {\n  QUADTREE: rp,\n  OCTREE: ip\n};\nfunction ap(e, t, n) {\n  if (e != null && e.box) {\n    const s = wa(e.s2VolumeInfo.token), r = jg(s, t), i = kg(r), o = {\n      ...e.s2VolumeInfo\n    };\n    switch (o.token = i, n) {\n      case \"OCTREE\":\n        const u = e.s2VolumeInfo, l = u.maximumHeight - u.minimumHeight, h = l / 2, f = u.minimumHeight + l / 2;\n        u.minimumHeight = f - h, u.maximumHeight = f + h;\n        break;\n    }\n    return {\n      box: Da(o),\n      s2VolumeInfo: o\n    };\n  }\n}\nasync function Fa(e) {\n  const {\n    implicitOptions: t,\n    parentData: n = {\n      mortonIndex: 0,\n      x: 0,\n      y: 0,\n      z: 0\n    },\n    childIndex: s = 0,\n    s2VolumeBox: r,\n    loaderOptions: i\n  } = e;\n  let {\n    subtree: o,\n    level: a = 0,\n    globalData: c = {\n      level: 0,\n      mortonIndex: 0,\n      x: 0,\n      y: 0,\n      z: 0\n    }\n  } = e;\n  const {\n    subdivisionScheme: u,\n    subtreeLevels: l,\n    maximumLevel: h,\n    contentUrlTemplate: f,\n    subtreesUriTemplate: d,\n    basePath: A\n  } = t, g = {\n    children: [],\n    lodMetricValue: 0,\n    contentUrl: \"\"\n  };\n  if (!h)\n    return lo.once(`Missing 'maximumLevel' or 'availableLevels' property. The subtree ${f} won't be loaded...`), g;\n  const p = a + c.level;\n  if (p > h)\n    return g;\n  const y = op[u], _ = Math.log2(y), b = s & 1, w = s >> 1 & 1, M = s >> 2 & 1, C = (y ** a - 1) / (y - 1);\n  let D = kt(n.mortonIndex, s, _), F = C + D, I = kt(n.x, b, 1), S = kt(n.y, w, 1), V = kt(n.z, M, 1), K = !1;\n  a >= l && (K = us(o.childSubtreeAvailability, D));\n  const k = kt(c.x, I, a), O = kt(c.y, S, a), st = kt(c.z, V, a);\n  if (K) {\n    const yt = `${A}/${d}`, $t = Is(yt, p, k, O, st);\n    o = await Fe($t, Ca, i), c = {\n      mortonIndex: D,\n      x: I,\n      y: S,\n      z: V,\n      level: a\n    }, D = 0, F = 0, I = 0, S = 0, V = 0, a = 0;\n  }\n  if (!us(o.tileAvailability, F))\n    return g;\n  us(o.contentAvailability, F) && (g.contentUrl = Is(f, p, k, O, st));\n  const Jt = a + 1, ut = {\n    mortonIndex: D,\n    x: I,\n    y: S,\n    z: V\n  };\n  for (let yt = 0; yt < y; yt++) {\n    const $t = ap(r, yt, u), Gt = await Fa({\n      subtree: o,\n      implicitOptions: t,\n      loaderOptions: i,\n      parentData: ut,\n      childIndex: yt,\n      level: Jt,\n      globalData: {\n        ...c\n      },\n      s2VolumeBox: $t\n    });\n    if (Gt.contentUrl || Gt.children.length) {\n      const Le = p + 1, v = cp(Gt, Le, {\n        childTileX: I,\n        childTileY: S,\n        childTileZ: V\n      }, t, r);\n      g.children.push(v);\n    }\n  }\n  return g;\n}\nfunction us(e, t) {\n  let n;\n  return Array.isArray(e) ? (n = e[0], e.length > 1 && lo.once('Not supported extension \"3DTILES_multiple_contents\" has been detected')) : n = e, \"constant\" in n ? !!n.constant : n.explicitBitstream ? hp(t, n.explicitBitstream) : !1;\n}\nfunction cp(e, t, n, s, r) {\n  const {\n    basePath: i,\n    refine: o,\n    getRefine: a,\n    lodMetricType: c,\n    getTileType: u,\n    rootLodMetricValue: l,\n    rootBoundingVolume: h\n  } = s, f = e.contentUrl && e.contentUrl.replace(`${i}/`, \"\"), d = l / 2 ** t, A = r != null && r.box ? {\n    box: r.box\n  } : h, g = up(t, A, n);\n  return {\n    children: e.children,\n    contentUrl: e.contentUrl,\n    content: {\n      uri: f\n    },\n    id: e.contentUrl,\n    refine: a(o),\n    type: u(e),\n    lodMetricType: c,\n    lodMetricValue: d,\n    geometricError: d,\n    transform: e.transform,\n    boundingVolume: g\n  };\n}\nfunction up(e, t, n) {\n  if (t.region) {\n    const {\n      childTileX: s,\n      childTileY: r,\n      childTileZ: i\n    } = n, [o, a, c, u, l, h] = t.region, f = 2 ** e, d = (c - o) / f, A = (u - a) / f, g = (h - l) / f, [p, y] = [o + d * s, o + d * (s + 1)], [_, b] = [a + A * r, a + A * (r + 1)], [w, M] = [l + g * i, l + g * (i + 1)];\n    return {\n      region: [p, _, y, b, w, M]\n    };\n  }\n  if (t.box)\n    return t;\n  throw new Error(`Unsupported bounding volume type ${t}`);\n}\nfunction kt(e, t, n) {\n  return (e << n) + t;\n}\nfunction Is(e, t, n, s, r) {\n  const i = lp({\n    level: t,\n    x: n,\n    y: s,\n    z: r\n  });\n  return e.replace(/{level}|{x}|{y}|{z}/gi, (o) => i[o]);\n}\nfunction lp(e) {\n  const t = {};\n  for (const n in e)\n    t[`{${n}}`] = e[n];\n  return t;\n}\nfunction hp(e, t) {\n  const n = Math.floor(e / 8), s = e % 8;\n  return (t[n] >> s & 1) === 1;\n}\nfunction sr(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n  if (!t)\n    return jt.EMPTY;\n  const s = t.split(\"?\")[0].split(\".\").pop();\n  switch (s) {\n    case \"pnts\":\n      return jt.POINTCLOUD;\n    case \"i3dm\":\n    case \"b3dm\":\n    case \"glb\":\n    case \"gltf\":\n      return jt.SCENEGRAPH;\n    default:\n      return s || jt.EMPTY;\n  }\n}\nfunction rr(e) {\n  switch (e) {\n    case \"REPLACE\":\n    case \"replace\":\n      return xt.REPLACE;\n    case \"ADD\":\n    case \"add\":\n      return xt.ADD;\n    default:\n      return e;\n  }\n}\nfunction Ss(e, t) {\n  if (/^[a-z][0-9a-z+.-]*:/i.test(t)) {\n    const s = new URL(e, `${t}/`);\n    return decodeURI(s.toString());\n  } else if (e.startsWith(\"/\"))\n    return e;\n  return kc(t, e);\n}\nfunction ki(e, t) {\n  if (!e)\n    return null;\n  let n;\n  if (e.content) {\n    var s;\n    const i = e.content.uri || ((s = e.content) === null || s === void 0 ? void 0 : s.url);\n    typeof i < \"u\" && (n = Ss(i, t));\n  }\n  return {\n    ...e,\n    id: n,\n    contentUrl: n,\n    lodMetricType: wn.GEOMETRIC_ERROR,\n    lodMetricValue: e.geometricError,\n    transformMatrix: e.transform,\n    type: sr(e, n),\n    refine: rr(e.refine)\n  };\n}\nasync function fp(e, t, n) {\n  let s = null;\n  const r = Ki(e.root);\n  r && e.root ? s = await ji(e.root, e, t, r, n) : s = ki(e.root, t);\n  const i = [];\n  for (i.push(s); i.length > 0; ) {\n    const o = i.pop() || {}, a = o.children || [], c = [];\n    for (const u of a) {\n      const l = Ki(u);\n      let h;\n      l ? h = await ji(u, e, t, l, n) : h = ki(u, t), h && (c.push(h), i.push(h));\n    }\n    o.children = c;\n  }\n  return s;\n}\nasync function ji(e, t, n, s, r) {\n  var i, o, a;\n  const {\n    subdivisionScheme: c,\n    maximumLevel: u,\n    availableLevels: l,\n    subtreeLevels: h,\n    subtrees: {\n      uri: f\n    }\n  } = s, d = Is(f, 0, 0, 0, 0), A = Ss(d, n), g = await Fe(A, Ca, r), p = (i = e.content) === null || i === void 0 ? void 0 : i.uri, y = p ? Ss(p, n) : \"\", _ = t == null || (o = t.root) === null || o === void 0 ? void 0 : o.refine, b = e.geometricError, w = (a = e.boundingVolume.extensions) === null || a === void 0 ? void 0 : a[\"3DTILES_bounding_volume_S2\"];\n  if (w) {\n    const F = {\n      box: Da(w),\n      s2VolumeInfo: w\n    };\n    e.boundingVolume = F;\n  }\n  const M = e.boundingVolume, C = {\n    contentUrlTemplate: y,\n    subtreesUriTemplate: f,\n    subdivisionScheme: c,\n    subtreeLevels: h,\n    maximumLevel: Number.isFinite(l) ? l - 1 : u,\n    refine: _,\n    basePath: n,\n    lodMetricType: wn.GEOMETRIC_ERROR,\n    rootLodMetricValue: b,\n    rootBoundingVolume: M,\n    getTileType: sr,\n    getRefine: rr\n  };\n  return await dp(e, n, g, C, r);\n}\nasync function dp(e, t, n, s, r) {\n  if (!e)\n    return null;\n  const {\n    children: i,\n    contentUrl: o\n  } = await Fa({\n    subtree: n,\n    implicitOptions: s,\n    loaderOptions: r\n  });\n  let a, c = null;\n  return o && (a = o, c = {\n    uri: o.replace(`${t}/`, \"\")\n  }), {\n    ...e,\n    id: a,\n    contentUrl: a,\n    lodMetricType: wn.GEOMETRIC_ERROR,\n    lodMetricValue: e.geometricError,\n    transformMatrix: e.transform,\n    type: sr(e, a),\n    refine: rr(e.refine),\n    content: c || e.content,\n    children: i\n  };\n}\nfunction Ki(e) {\n  var t;\n  return (e == null || (t = e.extensions) === null || t === void 0 ? void 0 : t[\"3DTILES_implicit_tiling\"]) || (e == null ? void 0 : e.implicitTiling);\n}\nconst be = {\n  id: \"3d-tiles\",\n  name: \"3D Tiles\",\n  module: \"3d-tiles\",\n  version: Jo,\n  extensions: [\"cmpt\", \"pnts\", \"b3dm\", \"i3dm\"],\n  mimeTypes: [\"application/octet-stream\"],\n  tests: [\"cmpt\", \"pnts\", \"b3dm\", \"i3dm\"],\n  parse: mp,\n  options: {\n    \"3d-tiles\": {\n      loadGLTF: !0,\n      decodeQuantizedPositions: !1,\n      isTileset: \"auto\",\n      assetGltfUpAxis: null\n    }\n  }\n};\nasync function mp(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = t[\"3d-tiles\"] || {};\n  let r;\n  return s.isTileset === \"auto\" ? r = (n == null ? void 0 : n.url) && n.url.indexOf(\".json\") !== -1 : r = s.isTileset, r ? Ap(e, t, n) : gp(e, t, n);\n}\nasync function Ap(e, t, n) {\n  var s;\n  const r = JSON.parse(new TextDecoder().decode(e)), i = (n == null ? void 0 : n.url) || \"\", o = pp(i), a = await fp(r, o, t || {});\n  return {\n    ...r,\n    shape: \"tileset3d\",\n    loader: be,\n    url: i,\n    queryString: (n == null ? void 0 : n.queryString) || \"\",\n    basePath: o,\n    root: a || r.root,\n    type: dt.TILES3D,\n    lodMetricType: wn.GEOMETRIC_ERROR,\n    lodMetricValue: ((s = r.root) === null || s === void 0 ? void 0 : s.geometricError) || 0\n  };\n}\nasync function gp(e, t, n) {\n  const s = {\n    content: {\n      shape: \"tile3d\",\n      featureIds: null\n    }\n  };\n  return await ya(e, 0, t, n, s.content), s.content;\n}\nfunction pp(e) {\n  return Os(e);\n}\nconst Oa = \"https://api.cesium.com/v1/assets\";\nasync function Bp(e, t) {\n  if (!t) {\n    const i = await yp(e);\n    for (const o of i.items)\n      o.type === \"3DTILES\" && (t = o.id);\n  }\n  const n = await Cp(e, t), {\n    type: s,\n    url: r\n  } = n;\n  return U(s === \"3DTILES\" && r), n.headers = {\n    Authorization: `Bearer ${n.accessToken}`\n  }, n;\n}\nasync function yp(e) {\n  U(e);\n  const t = Oa, n = {\n    Authorization: `Bearer ${e}`\n  }, s = await _e(t, {\n    headers: n\n  });\n  if (!s.ok)\n    throw new Error(s.statusText);\n  return await s.json();\n}\nasync function Cp(e, t) {\n  U(e, t);\n  const n = {\n    Authorization: `Bearer ${e}`\n  }, s = `${Oa}/${t}`;\n  let r = await _e(`${s}`, {\n    headers: n\n  });\n  if (!r.ok)\n    throw new Error(r.statusText);\n  let i = await r.json();\n  if (r = await _e(`${s}/endpoint`, {\n    headers: n\n  }), !r.ok)\n    throw new Error(r.statusText);\n  const o = await r.json();\n  return i = {\n    ...i,\n    ...o\n  }, i;\n}\nasync function Tp(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  t = t[\"cesium-ion\"] || {};\n  const {\n    accessToken: n\n  } = t;\n  let s = t.assetId;\n  if (!Number.isFinite(s)) {\n    const r = e.match(/\\/([0-9]+)\\/tileset.json/);\n    s = r && r[1];\n  }\n  return Bp(n, s);\n}\nconst va = {\n  ...be,\n  id: \"cesium-ion\",\n  name: \"Cesium Ion\",\n  preload: Tp,\n  parse: async (e, t, n) => (t = {\n    ...t\n  }, t[\"3d-tiles\"] = t[\"cesium-ion\"], t.loader = va, be.parse(e, t, n)),\n  options: {\n    \"cesium-ion\": {\n      ...be.options[\"3d-tiles\"],\n      accessToken: null\n    }\n  }\n};\nfunction Ep(e) {\n  let t = 0;\n  for (const s in e.attributes) {\n    const r = e.getAttribute(s);\n    t += r.count * r.itemSize * r.array.BYTES_PER_ELEMENT;\n  }\n  const n = e.getIndex();\n  return t += n ? n.count * n.itemSize * n.array.BYTES_PER_ELEMENT : 0, t;\n}\nfunction xa(e) {\n  const n = document.createElement(\"canvas\");\n  n.width = 64, n.height = 64;\n  const s = n.getContext(\"2d\");\n  s.rect(0, 0, 64, 64);\n  const r = s.createLinearGradient(0, 0, 64, 64);\n  for (let o = 0; o < e.length; o++) {\n    const a = e[o];\n    r.addColorStop(a[0], \"#\" + a[1].getHexString());\n  }\n  s.fillStyle = r, s.fill();\n  const i = new three__WEBPACK_IMPORTED_MODULE_0__.CanvasTexture(n);\n  return i.needsUpdate = !0, i.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, i.wrapS = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping, i.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping, i.repeat.set(2, 2), i;\n}\nfunction zi(e) {\n  e.updateMatrix(), e.updateMatrixWorld(), e.matrixWorldInverse.copy(e.matrixWorld).invert();\n  const t = new three__WEBPACK_IMPORTED_MODULE_0__.Frustum();\n  return t.setFromProjectionMatrix(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse)), t;\n}\nfunction bp(e) {\n  const t = new three__WEBPACK_IMPORTED_MODULE_0__.Group(), n = new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(10, 5), s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(...e.projectPointOntoPlane([0, 0, 0])), r = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(e.normal.x, e.normal.y, e.normal.z), i = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(s).add(r);\n  n.lookAt(i), n.translate(s.x, s.y, s.z);\n  const o = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({ color: 65535, side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide }), a = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(n, o), c = new three__WEBPACK_IMPORTED_MODULE_0__.ArrowHelper(r, s, 5, 16776960);\n  return t.add(c), t.add(a), t;\n}\nfunction Wi(e) {\n  const { boundingVolume: t } = e;\n  let n = 0;\n  e.content && (n = Math.min(e.content.byteLength / 5e5, 1));\n  const s = new three__WEBPACK_IMPORTED_MODULE_0__.Color(n, 1, 0), r = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(1, 1, 1), i = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n  t.halfAxes ? i.copy(La(t.halfAxes)) : t.radius && r.scale(t.radius * 2, t.radius * 2, t.radius * 2), r.applyMatrix4(i);\n  const o = new three__WEBPACK_IMPORTED_MODULE_0__.EdgesGeometry(r), a = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(o, new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({ color: s }));\n  return a.position.copy(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(...t.center)), a;\n}\nfunction La(e) {\n  const t = e;\n  return new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray([\n    t[0] * 2,\n    t[1] * 2,\n    t[2] * 2,\n    0,\n    t[3] * 2,\n    t[4] * 2,\n    t[5] * 2,\n    0,\n    t[6] * 2,\n    t[7] * 2,\n    t[8] * 2,\n    0,\n    0,\n    0,\n    0,\n    1\n  ]);\n}\nfunction _p(e, t) {\n  const r = 2 * Math.PI * 6378137 / 2, i = t * r / 180;\n  let o = Math.log(Math.tan((90 + e) * Math.PI / 360)) / (Math.PI / 180);\n  return o = o * r / 180, new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(i, o);\n}\nfunction wp(e) {\n  let t = 0;\n  if (e.userData.mimeType == \"image/ktx2\" && e.mipmaps) {\n    for (let n = 0; n < e.mipmaps.length; n++)\n      t += e.mipmaps[n].data.byteLength;\n    return t;\n  } else if (e.image) {\n    const { image: n } = e, s = 4;\n    let r = [n.width, n.height];\n    for (; r[0] > 1 || r[1] > 1; )\n      t += r[0] * r[1] * s, r[0] = Math.max(Math.floor(r[0] / 2), 1), r[1] = Math.max(Math.floor(r[1] / 2), 1);\n    return t += 1 * 1 * s, t;\n  } else\n    return;\n}\nfunction Ga(e) {\n  return Ep(e);\n}\nconst Ua = {\n  // From chroma spectral http://gka.github.io/chroma.js/\n  SPECTRAL: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.3686, 0.3098, 0.6353)],\n    [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.1961, 0.5333, 0.7412)],\n    [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.4, 0.7608, 0.6471)],\n    [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.6706, 0.8667, 0.6431)],\n    [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.902, 0.9608, 0.5961)],\n    [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 0.749)],\n    [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9961, 0.8784, 0.5451)],\n    [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9922, 0.6824, 0.3804)],\n    [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9569, 0.4275, 0.2627)],\n    [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.8353, 0.2431, 0.3098)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.6196, 39e-4, 0.2588)]\n  ],\n  PLASMA: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.241, 0.015, 0.61)],\n    [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.387, 1e-3, 0.654)],\n    [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.524, 0.025, 0.653)],\n    [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.651, 0.125, 0.596)],\n    [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.752, 0.227, 0.513)],\n    [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.837, 0.329, 0.431)],\n    [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.907, 0.435, 0.353)],\n    [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.963, 0.554, 0.272)],\n    [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.992, 0.681, 0.195)],\n    [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.987, 0.822, 0.144)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.94, 0.975, 0.131)]\n  ],\n  YELLOW_GREEN: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.1647, 0.2824, 0.3451)],\n    [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.1338, 0.3555, 0.4227)],\n    [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.061, 0.4319, 0.4864)],\n    [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0.5099, 0.5319)],\n    [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0.5881, 0.5569)],\n    [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.137, 0.665, 0.5614)],\n    [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.2906, 0.7395, 0.5477)],\n    [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.4453, 0.8099, 0.5201)],\n    [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.6102, 0.8748, 0.485)],\n    [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.7883, 0.9323, 0.4514)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9804, 0.9804, 0.4314)]\n  ],\n  VIRIDIS: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.267, 5e-3, 0.329)],\n    [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.283, 0.141, 0.458)],\n    [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.254, 0.265, 0.53)],\n    [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.207, 0.372, 0.553)],\n    [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.164, 0.471, 0.558)],\n    [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.128, 0.567, 0.551)],\n    [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.135, 0.659, 0.518)],\n    [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.267, 0.749, 0.441)],\n    [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.478, 0.821, 0.318)],\n    [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.741, 0.873, 0.15)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.993, 0.906, 0.144)]\n  ],\n  INFERNO: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.077, 0.042, 0.206)],\n    [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.225, 0.036, 0.388)],\n    [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.373, 0.074, 0.432)],\n    [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.522, 0.128, 0.42)],\n    [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.665, 0.182, 0.37)],\n    [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.797, 0.255, 0.287)],\n    [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.902, 0.364, 0.184)],\n    [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.969, 0.516, 0.063)],\n    [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.988, 0.683, 0.072)],\n    [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.961, 0.859, 0.298)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.988, 0.998, 0.645)]\n  ],\n  GRAYSCALE: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1)]\n  ],\n  // 16 samples of the TURBU color scheme\n  // values taken from: https://gist.github.com/mikhailov-work/ee72ba4191942acecc03fe6da94fc73f\n  // original file licensed under Apache-2.0\n  TURBO: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.18995, 0.07176, 0.23217)],\n    [0.07, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.25107, 0.25237, 0.63374)],\n    [0.13, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.27628, 0.42118, 0.89123)],\n    [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.25862, 0.57958, 0.99876)],\n    [0.27, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.15844, 0.73551, 0.92305)],\n    [0.33, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.09267, 0.86554, 0.7623)],\n    [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.19659, 0.94901, 0.59466)],\n    [0.47, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.42778, 0.99419, 0.38575)],\n    [0.53, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.64362, 0.98999, 0.23356)],\n    [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.80473, 0.92452, 0.20459)],\n    [0.67, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.93301, 0.81236, 0.22667)],\n    [0.73, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.99314, 0.67408, 0.20348)],\n    [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9836, 0.49291, 0.12849)],\n    [0.87, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.92105, 0.31489, 0.05475)],\n    [0.93, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.81608, 0.18462, 0.01809)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.66449, 0.08436, 424e-5)]\n  ],\n  RAINBOW: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.278, 0, 0.714)],\n    [1 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 1)],\n    [2 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 1, 1)],\n    [3 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 1, 0)],\n    [4 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 0)],\n    [5 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 0.64, 0)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 0, 0)]\n  ],\n  CONTOUR: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0)],\n    [0.03, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0)],\n    [0.04, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1)]\n  ]\n}, Mp = `\n  varying vec3 vColor;\n  uniform float alpha;\n\n  void main() {\n    if (vColor == vec3(0.0, 0.0, 0.0)) {\n      discard;\n    } else {\n      gl_FragColor = vec4( vColor, alpha);\n    }\n  }\n`, Rp = `\n  varying vec3 vColor;\n  uniform sampler2D gradient;\n  uniform sampler2D grayscale;\n  attribute float intensity;\n  attribute float classification;\n  uniform vec3 rootCenter;\n  uniform vec3 rootNormal;\n  uniform vec2 elevationRange;\n  uniform int coloring;\n  uniform bool hideGround;\n  uniform float maxIntensity;\n  uniform float intensityContrast;\n  uniform float pointSize;\n\n  #ifdef USE_COLOR\n  vec3 getRGB() {\n      vec3 rgb = color;\n      return rgb;\n  }\n  #endif\n\n  vec3 getElevation(){\n    vec4 world = modelMatrix * vec4( position, 1.0 );\n    float diff = abs(dot(rootNormal, (vec3(world) - rootCenter)));\n    float w = max(diff - elevationRange.x,0.0) / max(elevationRange.y - elevationRange.x,1.0);\n    vec3 cElevation = texture2D(gradient, vec2(w,1.0-w)).rgb;\n\n    return cElevation;\n  }\n\n  vec3 getIntensity(){\n    // TODO: real contrast enhancement. Check https://github.com/yuki-koyama/enhancer/blob/master/shaders/enhancer.fs\n    float intmod = pow(intensity, intensityContrast);\n    vec3 cIntensity = texture2D(grayscale, vec2(intmod / maxIntensity ,1.0-(intmod / maxIntensity))).rgb;\n    return cIntensity;\n  }\n\n  vec3 getClassification(){\n    float classNormalized = classification / 255.0;\n    vec3 cClassification = texture2D(gradient, vec2(classNormalized * 5.0,1.0-classNormalized * 5.0)).rgb;\n    return cClassification;\n  }\n\n  vec3 getColor(){\n      vec3 color;\n      if (hideGround && classification == 2.0) {\n         return vec3(0.0, 0.0, 0.0);               \n      }\n\n      if (coloring == 1) {\n        color = getIntensity();\n      }\n      else if (coloring == 2) {\n        color = getClassification();\n      } else if (coloring == 3) {\n        color = getElevation();\n      } \n      #ifdef USE_COLOR\n      else if (coloring == 4) {\n        color = getRGB();\n      }\n      #endif\n      else {\n        color = vec3(1.0, 1.0, 1.0);\n      }\n      return color;\n  }\n\n  void main() {\n      vColor = getColor();\n\n      gl_PointSize = pointSize;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  }\n`;\nvar Pa = /* @__PURE__ */ ((e) => (e[e.Intensity = 1] = \"Intensity\", e[e.Classification = 2] = \"Classification\", e[e.Elevation = 3] = \"Elevation\", e[e.RGB = 4] = \"RGB\", e[e.White = 5] = \"White\", e))(Pa || {}), yn = /* @__PURE__ */ ((e) => (e[e.FlatTexture = 1] = \"FlatTexture\", e[e.ShadedTexture = 2] = \"ShadedTexture\", e[e.ShadedNoTexture = 3] = \"ShadedNoTexture\", e))(yn || {}), Rt = /* @__PURE__ */ ((e) => (e[e.Reset = 1] = \"Reset\", e[e.Mercator = 2] = \"Mercator\", e[e.WGS84Cartesian = 3] = \"WGS84Cartesian\", e))(Rt || {});\nconst Ip = Ua.RAINBOW, Sp = typeof document < \"u\" ? xa(Ip) : null, Dp = Ua.GRAYSCALE, Fp = typeof document < \"u\" ? xa(Dp) : null, Op = {\n  throttleRequests: !0,\n  maxRequests: 64,\n  updateInterval: 0.1,\n  maxConcurrency: 1,\n  maximumScreenSpaceError: 16,\n  memoryAdjustedScreenSpaceError: !0,\n  maximumMemoryUsage: 400,\n  memoryCacheOverflow: 128,\n  viewDistanceScale: 1,\n  skipLevelOfDetail: !1,\n  updateTransforms: !0,\n  shading: yn.FlatTexture,\n  transparent: !1,\n  pointCloudColoring: Pa.White,\n  pointSize: 1,\n  worker: !0,\n  wireframe: !1,\n  debug: !1,\n  gltfLoader: null,\n  basisTranscoderPath: null,\n  dracoDecoderPath: null,\n  material: null,\n  computeNormals: !1,\n  shaderCallback: null,\n  geoTransform: Rt.Reset,\n  preloadTilesCount: null\n};\nclass Hp {\n  /**\n  * Loads a tileset of 3D Tiles according to the given {@link LoaderProps}\n  * @public\n  *\n  * @param props - Properties for this load call {@link LoaderProps}.\n  * @returns An object containing the 3D Model to be added to the scene\n  * and a runtime engine to be updated every frame.\n  */\n  static async load(t) {\n    const n = { ...Op, ...t.options }, { url: s } = t, r = n.updateInterval, i = 5, o = {};\n    if (n.cesiumIONToken) {\n      o[\"cesium-ion\"] = {\n        accessToken: n.cesiumIONToken\n      };\n      const E = await va.preload(s, o);\n      o.fetch = { headers: E.headers };\n    }\n    n.googleApiKey && (o.fetch = { headers: { \"X-GOOG-API-KEY\": n.googleApiKey } }), t.loadingManager && t.loadingManager.itemStart(s);\n    const a = await Fe(s, be, {\n      ...o\n    }), c = {}, u = {}, l = [], h = new three__WEBPACK_IMPORTED_MODULE_0__.Group(), f = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n    n.debug || (f.visible = !1);\n    const d = {\n      pointSize: { type: \"f\", value: n.pointSize },\n      gradient: { type: \"t\", value: Sp },\n      grayscale: { type: \"t\", value: Fp },\n      rootCenter: { type: \"vec3\", value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3() },\n      rootNormal: { type: \"vec3\", value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3() },\n      coloring: { type: \"i\", value: n.pointCloudColoring },\n      hideGround: { type: \"b\", value: !0 },\n      elevationRange: { type: \"vec2\", value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 400) },\n      maxIntensity: { type: \"f\", value: 1 },\n      intensityContrast: { type: \"f\", value: 1 },\n      alpha: { type: \"f\", value: 1 }\n    }, A = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n      uniforms: d,\n      vertexShader: Rp,\n      fragmentShader: Mp,\n      transparent: n.transparent,\n      vertexColors: !0\n    });\n    let g = null, p = 0, y, _, b;\n    n.gltfLoader ? y = n.gltfLoader : (y = new three__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader(), n.basisTranscoderPath && (_ = new three__WEBPACK_IMPORTED_MODULE_0__.KTX2Loader(), _.detectSupport(t.renderer), _.setTranscoderPath(n.basisTranscoderPath + \"/\"), _.setWorkerLimit(1), y.setKTX2Loader(_)), n.dracoDecoderPath && (b = new three__WEBPACK_IMPORTED_MODULE_0__.DRACOLoader(), b.setDecoderPath(n.dracoDecoderPath + \"/\"), b.setWorkerLimit(n.maxConcurrency), y.setDRACOLoader(b)));\n    const w = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({ transparent: n.transparent }), M = {\n      maximumMemoryUsage: n.maximumMemoryUsage,\n      maximumScreenSpaceError: n.maximumScreenSpaceError,\n      memoryAdjustedScreenSpaceError: n.memoryAdjustedScreenSpaceError,\n      memoryCacheOverflow: n.memoryCacheOverflow,\n      viewDistanceScale: n.viewDistanceScale,\n      skipLevelOfDetail: n.skipLevelOfDetail,\n      updateTransforms: n.updateTransforms,\n      throttleRequests: n.throttleRequests,\n      maxRequests: n.maxRequests,\n      contentLoader: async (E) => {\n        let v = null;\n        switch (E.type) {\n          case jt.POINTCLOUD: {\n            v = xp(E, A, n, yt);\n            break;\n          }\n          case jt.SCENEGRAPH:\n          case jt.MESH: {\n            v = await vp(y, E, w, n, yt);\n            break;\n          }\n        }\n        if (v && (v.visible = !1, c[E.id] = v, h.add(c[E.id]), n.debug)) {\n          const q = Wi(E);\n          f.add(q), u[E.id] = q;\n        }\n      },\n      onTileLoad: async (E) => {\n        C && (n.geoTransform == Rt.Reset && !S && (E == null ? void 0 : E.depth) <= i && $t(E), Yt = !0);\n      },\n      onTileUnload: (E) => {\n        l.push(E);\n      },\n      onTileError: (E, v) => {\n        console.error(\"Tile error\", E.id, v);\n      }\n    }, C = new rd(a, {\n      ...M,\n      loadOptions: {\n        ...o,\n        maxConcurrency: n.maxConcurrency,\n        worker: n.worker,\n        gltf: {\n          loadImages: !1\n        },\n        \"3d-tiles\": {\n          loadGLTF: !1\n        }\n      }\n    }), D = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), F = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), I = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    let S = !1;\n    if (C.root.boundingVolume ? (C.root.header.boundingVolume.region && (console.warn(\"Cannot apply a model matrix to bounding volumes of type region. Tileset stays in original geo-coordinates.\"), n.geoTransform = Rt.WGS84Cartesian), F.setPosition(\n      C.root.boundingVolume.center[0],\n      C.root.boundingVolume.center[1],\n      C.root.boundingVolume.center[2]\n    )) : console.warn(\"Bounding volume not found, no transformations applied\"), n.debug) {\n      const E = Wi(C.root);\n      f.add(E), u[C.root.id] = E;\n    }\n    let V = !1, K = !1;\n    d.rootCenter.value.copy(I), d.rootNormal.value.copy(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1).normalize()), C.stats.get(\"Loader concurrency\").count = n.maxConcurrency, C.stats.get(\"Maximum mem usage\").count = n.maximumMemoryUsage;\n    let k = 0, O = null, st = null, Yt = !1;\n    const ue = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1 / 0, 1 / 0, 1 / 0);\n    let Jt = null;\n    h.updateMatrixWorld(!0);\n    const ut = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(h.matrixWorld), yt = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(ut).invert();\n    if ((n.geoTransform == Rt.Reset || n.geoTransform == Rt.Mercator) && ($t(C.root), Gt()), n.debug && (u[C.root.id].applyMatrix4(D), f.matrixWorld.copy(h.matrixWorld)), n.geoTransform == Rt.Mercator) {\n      const E = _p(\n        C.cartographicCenter[1],\n        C.cartographicCenter[0]\n      );\n      I.set(\n        E.x,\n        0,\n        -E.y\n      ), h.position.copy(I), h.updateMatrixWorld(!0);\n    } else\n      n.geoTransform == Rt.WGS84Cartesian && (h.applyMatrix4(F), h.updateMatrixWorld(!0), I.copy(h.position));\n    function $t(E) {\n      if (!E.boundingVolume.halfAxes)\n        return;\n      const v = E.boundingVolume.halfAxes, q = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().extractRotation(La(v)).premultiply(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().extractRotation(yt));\n      if (!new three__WEBPACK_IMPORTED_MODULE_0__.Euler().setFromRotationMatrix(q).equals(new three__WEBPACK_IMPORTED_MODULE_0__.Euler())) {\n        S = !0;\n        const Ct = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(\n          F.elements[12],\n          F.elements[13],\n          F.elements[14]\n        );\n        F.extractRotation(q), F.setPosition(Ct), Gt();\n      }\n    }\n    function Gt() {\n      D.copy(F).invert(), D.premultiply(ut), D.copy(ut).multiply(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(F).invert()), C.modelMatrix = new N(D.toArray());\n    }\n    function Le(E, v, q, et) {\n      if (V)\n        return;\n      (!Jt || et.aspect != st) && (Jt = new dn({\n        fov: et.fov / 180 * Math.PI,\n        aspectRatio: et.aspect,\n        near: et.near,\n        far: et.far\n      }).sseDenominator, st = et.aspect, n.debug && console.log(\"Updated sse denonimator:\", Jt));\n      const Ge = zi(et).planes.map((z) => new Y(z.normal.toArray(), z.constant)), Na = new at(Ge), ir = {\n        camera: {\n          position: ue.toArray()\n        },\n        height: q,\n        frameNumber: E._frameNumber,\n        sseDenominator: Jt,\n        cullingVolume: Na,\n        viewport: {\n          id: 0\n        }\n      };\n      E._cache.reset(), E._traverser.traverse(E.root, ir, E.options);\n      for (const z of E.tiles)\n        z.selected ? v[z.id] ? v[z.id].visible = !0 : console.error(\"TILE SELECTED BUT NOT LOADED!!\", z.id) : v[z.id] && (v[z.id].visible = !1);\n      for (; l.length > 0; ) {\n        const z = l.pop();\n        v[z.id] && z.contentState == it.UNLOADED && (h.remove(v[z.id]), ls(v[z.id]), delete v[z.id]), u[z.id] && (ls(u[z.id]), f.remove(u[z.id]), delete u[z.id]);\n      }\n      const Dn = E.stats.get(\"Tiles Loaded\").count, or = E.stats.get(\"Tiles Loading\").count;\n      return t.onProgress && t.onProgress(\n        Dn,\n        Dn + or\n      ), t.loadingManager && !K && or == 0 && (n.preloadTilesCount == null || Dn >= n.preloadTilesCount) && (K = !0, t.loadingManager.itemEnd(t.url)), ir;\n    }\n    return {\n      model: h,\n      runtime: {\n        getTileset: () => C,\n        getStats: () => C.stats,\n        showTiles: (E) => {\n          f.visible = E;\n        },\n        setWireframe: (E) => {\n          n.wireframe = E, h.traverse((v) => {\n            v instanceof three__WEBPACK_IMPORTED_MODULE_0__.Mesh && (v.material.wireframe = E);\n          });\n        },\n        setDebug: (E) => {\n          n.debug = E, f.visible = E;\n        },\n        setShading: (E) => {\n          n.shading = E;\n        },\n        getTileBoxes: () => f,\n        setViewDistanceScale: (E) => {\n          C.options.viewDistanceScale = E, C._frameNumber++, Le(C, c, p, g);\n        },\n        setHideGround: (E) => {\n          d.hideGround.value = E;\n        },\n        setPointCloudColoring: (E) => {\n          d.coloring.value = E;\n        },\n        setElevationRange: (E) => {\n          d.elevationRange.value.set(E[0], E[1]);\n        },\n        setMaxIntensity: (E) => {\n          d.maxIntensity.value = E;\n        },\n        setIntensityContrast: (E) => {\n          d.intensityContrast.value = E;\n        },\n        setPointAlpha: (E) => {\n          d.alpha.value = E;\n        },\n        getLatLongHeightFromPosition: (E) => {\n          const v = C.ellipsoid.cartesianToCartographic(\n            new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(E).applyMatrix4(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(D).invert()).toArray()\n          );\n          return {\n            lat: v[1],\n            long: v[0],\n            height: v[2]\n          };\n        },\n        getPositionFromLatLongHeight: (E) => {\n          const v = C.ellipsoid.cartographicToCartesian([\n            ds(E.long),\n            ds(E.lat),\n            E.height\n          ]);\n          return new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(...v).applyMatrix4(D);\n        },\n        orientToGeocoord: (E) => {\n          const v = [E.long, E.lat, E.height], q = C.ellipsoid.cartographicToCartesian(v), et = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray(C.ellipsoid.eastNorthUpToFixedFrame(q)), Ct = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeRotationFromEuler(\n            new three__WEBPACK_IMPORTED_MODULE_0__.Euler(Math.PI / 2, Math.PI / 2, 0)\n          ), Ge = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(et).multiply(Ct).invert();\n          C.modelMatrix = new N(Ge.toArray()), h.applyMatrix4(Ge), h.updateMatrixWorld(!0);\n        },\n        getCameraFrustum: (E) => {\n          const q = zi(E).planes.map((Ct) => new Y(Ct.normal.toArray(), Ct.constant)).map((Ct) => bp(Ct)), et = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n          for (const Ct of q)\n            et.add(Ct);\n          return et;\n        },\n        update: function(E, v, q) {\n          if (g = q, p = v, k += E, C && k >= r) {\n            if (!ut.equals(h.matrixWorld)) {\n              k = 0, ut.copy(h.matrixWorld), (n.geoTransform == Rt.Reset || n.geoTransform == Rt.Mercator) && Gt();\n              const et = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().setFromMatrixPosition(ut);\n              d.rootCenter.value.copy(et), d.rootNormal.value.copy(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1).applyMatrix4(ut).normalize()), yt.copy(ut).invert(), n.debug && (u[C.root.id].matrixWorld.copy(D), u[C.root.id].applyMatrix4(ut));\n            }\n            O == null ? O = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(q.matrixWorld) : (Yt || Lp(q, O, st)) && (k = 0, Yt = !1, C._frameNumber++, q.getWorldPosition(ue), O.copy(q.matrixWorld), Le(C, c, p, q));\n          }\n        },\n        dispose: function() {\n          for (V = !0, C._destroy(); h.children.length > 0; ) {\n            const E = h.children[0];\n            ls(E), h.remove(E);\n          }\n          for (; f.children.length > 0; ) {\n            const E = f.children[0];\n            f.remove(E), E.geometry.dispose(), E.material.dispose();\n          }\n          _ && _.dispose(), b && b.dispose();\n        }\n      }\n    };\n  }\n}\nasync function vp(e, t, n, s, r) {\n  return new Promise((i, o) => {\n    const a = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeRotationAxis(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0), Math.PI / 2), c = t.content.gltfUpAxis !== \"Z\", u = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray(t.computedTransform).premultiply(r);\n    c && u.multiply(a), t.content.byteLength || (t.content.byteLength = t.content.gltfArrayBuffer.byteLength), e.parse(\n      t.content.gltfArrayBuffer,\n      t.contentUrl ? t.contentUrl.substr(0, t.contentUrl.lastIndexOf(\"/\") + 1) : \"\",\n      (l) => {\n        const h = l.scenes[0];\n        h.applyMatrix4(u), t.content.texturesByteLength = 0, t.content.geometriesByteLength = 0, h.traverse((f) => {\n          if (f.type == \"Mesh\") {\n            const d = f;\n            t.content.geometriesByteLength += Ga(d.geometry);\n            const A = d.material, g = A.map, p = wp(g);\n            p && (t.content.texturesByteLength += p), s.material ? (d.material = s.material.clone(), A.dispose()) : s.shading == yn.FlatTexture && (d.material = n.clone(), A.dispose()), s.shading != yn.ShadedNoTexture ? d.material.type == \"ShaderMaterial\" ? d.material.uniforms.map = { value: g } : d.material.map = g : (g && g.dispose(), d.material.map = null), s.shaderCallback && (d.onBeforeRender = (y, _, b, w, M, C) => {\n              s.shaderCallback(y, M);\n            }), d.material.wireframe = s.wireframe, s.computeNormals && d.geometry.computeVertexNormals();\n          }\n        }), t.content.gpuMemoryUsageInBytes = t.content.texturesByteLength + t.content.geometriesByteLength, i(h);\n      },\n      (l) => {\n        o(new Error(`error parsing gltf in tile ${t.id}: ${l}`));\n      }\n    );\n  });\n}\nfunction xp(e, t, n, s) {\n  const r = {\n    rtc_center: e.content.rtcCenter,\n    // eslint-disable-line camelcase\n    points: e.content.attributes.positions,\n    intensities: e.content.attributes.intensity,\n    classifications: e.content.attributes.classification,\n    rgb: null,\n    rgba: null\n  }, { colors: i } = e.content.attributes;\n  i && i.size === 3 && (r.rgb = i.value), i && i.size === 4 && (r.rgba = i.value);\n  const o = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n  o.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(r.points, 3));\n  const a = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray(e.computedTransform).premultiply(s);\n  r.rgba ? o.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(r.rgba, 4)) : r.rgb && o.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_0__.Uint8BufferAttribute(r.rgb, 3, !0)), r.intensities && o.setAttribute(\n    \"intensity\",\n    // Handles both 16bit or 8bit intensity values\n    new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(r.intensities, 1, !0)\n  ), r.classifications && o.setAttribute(\"classification\", new three__WEBPACK_IMPORTED_MODULE_0__.Uint8BufferAttribute(r.classifications, 1, !1)), e.content.geometriesByteLength = Ga(o), e.content.gpuMemoryUsageInBytes = e.content.geometriesByteLength;\n  const c = new three__WEBPACK_IMPORTED_MODULE_0__.Points(o, n.material || t);\n  if (r.rtc_center) {\n    const u = r.rtc_center;\n    a.multiply(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeTranslation(u[0], u[1], u[2]));\n  }\n  return c.applyMatrix4(a), c;\n}\nfunction Xi(e) {\n  var t, n, s, r;\n  (t = e == null ? void 0 : e.uniforms) != null && t.map ? (s = (n = e == null ? void 0 : e.uniforms) == null ? void 0 : n.map.value) == null || s.dispose() : e.map && ((r = e.map) == null || r.dispose()), e.dispose();\n}\nfunction ls(e) {\n  e.traverse((t) => {\n    if (t.isMesh)\n      if (t.geometry.dispose(), t.material.isMaterial)\n        Xi(t.material);\n      else\n        for (const n of t.material)\n          Xi(n);\n  });\n  for (let t = e.children.length - 1; t >= 0; t--) {\n    const n = e.children[t];\n    e.remove(n);\n  }\n}\nfunction Lp(e, t, n) {\n  return !e.matrixWorld.equals(t) || e.aspect != n;\n}\n\n\n\n//# sourceURL=webpack://aframe-loader-3dtiles-component/./node_modules/three-loader-3dtiles/dist/lib/three-loader-3dtiles.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});