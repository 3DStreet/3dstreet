/*! For license information please see aframe-loader-3dtiles-component.min.js.LICENSE.txt */
!(function (t, e) {
  if ('object' == typeof exports && 'object' == typeof module)
    module.exports = e(require('THREE'));
  else if ('function' == typeof define && define.amd) define(['THREE'], e);
  else {
    var n = 'object' == typeof exports ? e(require('THREE')) : e(t.THREE);
    for (var r in n) ('object' == typeof exports ? exports : t)[r] = n[r];
  }
})(this, (t) =>
  (() => {
    var e = {
        384: () => {
          if ('undefined' == typeof AFRAME)
            throw new Error(
              'Component attempted to register before AFRAME was available.'
            );
          AFRAME.registerComponent('textarea', {
            schema: {
              transparentBG: { type: 'boolean', default: !1 },
              cols: { type: 'int', default: 40 },
              rows: { type: 'int', default: 20 },
              color: { type: 'color', default: 'black' },
              backgroundColor: { type: 'color', default: 'white' },
              disabledBackgroundColor: { type: 'color', default: 'lightgrey' },
              disabled: { type: 'boolean', default: !1 },
              text: { type: 'string', default: '' }
            },
            init: function () {
              (this.text = null),
                (this.lines = []),
                (this.lastBlink = 0),
                (this.blinkEnabled = !this.data.disabled),
                (this.charWidth = this.charHeight = null),
                (this.selectionStart = this.selectionEnd = 0),
                (this.endIndexInfo = this.startIndexInfo = null),
                (this.origin = { x: 0, y: 0 }),
                (this.background = document.createElement('a-plane')),
                this.background.setAttribute(
                  'color',
                  this.data.disabled
                    ? this.data.disabledBackgroundColor
                    : this.data.backgroundColor
                ),
                this.el.appendChild(this.background),
                this.data.transparentBG &&
                  this.background.setAttribute('material', {
                    opacity: 0,
                    transparent: !0
                  }),
                (this.textAnchor = document.createElement('a-entity')),
                this.el.appendChild(this.textAnchor),
                this.textAnchor.setAttribute('text', {
                  mode: 'pre',
                  baseline: 'top',
                  anchor: 'center',
                  font: 'dejavu',
                  wrapCount: this.data.cols,
                  height: this.data.rows,
                  color: this.data.color
                }),
                this._initTextarea(),
                this.el.addEventListener(
                  'textfontset',
                  this._updateCharMetrics.bind(this)
                ),
                this.el.addEventListener(
                  'char-metrics-changed',
                  this._updateIndexInfo.bind(this)
                ),
                this.el.addEventListener(
                  'text-changed',
                  this._updateLines.bind(this)
                ),
                this.el.addEventListener(
                  'text-changed',
                  this._updateDisplayText.bind(this)
                ),
                this.el.addEventListener(
                  'selection-changed',
                  this._updateIndexInfo.bind(this)
                ),
                this.el.addEventListener(
                  'selection-changed',
                  this._updateHorizontalOrigin.bind(this)
                ),
                this.el.addEventListener(
                  'lines-changed',
                  this._updateIndexInfo.bind(this)
                ),
                this.el.addEventListener(
                  'index-info-changed',
                  this._updateOrigin.bind(this)
                ),
                this.el.addEventListener(
                  'index-info-changed',
                  this._updateHorizontalOrigin.bind(this)
                ),
                this.el.addEventListener(
                  'origin-changed',
                  this._updateDisplayText.bind(this)
                ),
                this.el.addEventListener('click', this.focus.bind(this));
            },
            update: function (t) {
              this.data.text !== t.text && this._updateTextarea(),
                (this.data.backgroundColor === t.backgroundColor &&
                  this.data.disabledBackgroundColor ===
                    t.disabledBackgroundColor) ||
                  this.background.setAttribute(
                    'color',
                    this.data.disabled
                      ? this.data.disabledBackgroundColor
                      : this.data.backgroundColor
                  ),
                this.data.disabled !== t.disabled &&
                  ((this.blinkEnabled = !this.data.disabled),
                  (this.textarea.disabled = this.data.disabled),
                  this.background.setAttribute(
                    'color',
                    this.data.disabled
                      ? this.data.disabledBackgroundColor
                      : this.data.backgroundColor
                  ));
            },
            focus: function () {
              this.textarea.focus();
            },
            _initTextarea: function () {
              (this.textarea = document.createElement('textarea')),
                document.body.appendChild(this.textarea),
                this._updateTextarea();
            },
            _updateTextarea: function () {
              (this.textarea.style.whiteSpace = 'pre'),
                (this.textarea.style.overflow = 'hidden'),
                (this.textarea.style.opacity = '0'),
                (this.textarea.cols = this.data.cols),
                (this.textarea.rows = this.data.rows),
                (this.textarea.value = this.data.text),
                (this.textarea.selectionStart = 0),
                (this.textarea.selectionEnd = 0),
                this._updateIndexInfo();
            },
            _emit: function (t, e) {
              this.el.emit(t, e);
            },
            _updateCharMetrics: function (t) {
              const e = this.textAnchor.components.text.geometry.layout,
                n = t.detail.fontObj.widthFactor;
              (this.charWidth = n * this.textAnchor.object3DMap.text.scale.x),
                (this.charHeight = (this.charWidth * e.lineHeight) / n),
                this.textAnchor.setAttribute('position', {
                  x: 0,
                  y: (this.charHeight * this.data.rows) / 2,
                  z: 0
                }),
                this.data.transparentBG ||
                  (this.background.setAttribute('scale', {
                    x: 1.05,
                    y: this.charHeight * this.data.rows * 1.05,
                    z: 1
                  }),
                  this.background.setAttribute('position', {
                    x: 0,
                    y: 0,
                    z: 0
                  })),
                this._emit('char-metrics-changed');
            },
            _checkAndUpdateSelection: function () {
              if (
                this.selectionStart === this.textarea.selectionStart &&
                this.selectionEnd === this.textarea.selectionEnd
              )
                return;
              const t = this.selectionStart,
                e = this.selectionEnd;
              (this.selectionStart = this.textarea.selectionStart),
                (this.selectionEnd = this.textarea.selectionEnd),
                this._emit('selection-changed', {
                  start: {
                    old: t,
                    new: this.selectionStart,
                    changed: this.selectionStart !== t
                  },
                  end: {
                    old: e,
                    new: this.selectionEnd,
                    changed: this.selectionEnd !== e
                  }
                });
            },
            tick: function (t) {
              t - this.lastBlink > 500 &&
                this.blinkEnabled &&
                (this.lastBlink = t),
                this._checkAndUpdateSelection(),
                this._checkAndUpdateText();
            },
            _getIndexInfo: function (t, e) {
              const n = Math.max(0, t),
                r = this.lines[n];
              return {
                line: r,
                x: (e - r.start) * this.charWidth,
                y: -this.charHeight * n + -this.charHeight / 2
              };
            },
            _updateIndexInfo: function () {
              if (!this.lines.length) return;
              const t = this.startIndexInfo && this.startIndexInfo.line.index,
                e = this.endIndexInfo && this.endIndexInfo.line.index;
              let n;
              (this.startIndexInfo = null), (this.endIndexInfo = null);
              let r = !1,
                s = !1;
              for (n = 0; n <= this.lines.length; n++) {
                const i = this.lines[n - 1],
                  o =
                    n === this.lines.length
                      ? i.start + i.length + 1
                      : this.lines[n].start;
                if (
                  (o > this.selectionStart &&
                    !this.startIndexInfo &&
                    ((this.startIndexInfo = this._getIndexInfo(
                      n - 1,
                      this.selectionStart
                    )),
                    this.startIndexInfo.line.index !== t && (r = !0)),
                  o > this.selectionEnd)
                ) {
                  (this.endIndexInfo = this._getIndexInfo(
                    n - 1,
                    this.selectionEnd
                  )),
                    this.endIndexInfo.line.index !== e && (s = !0);
                  break;
                }
              }
              (r || s) &&
                this._emit('index-info-changed', {
                  start: { changed: r },
                  end: { changed: s }
                });
            },
            _updateOrigin: function (t) {
              let e = !1;
              if (t.detail.end.changed) {
                const t = this.origin.y + this.data.rows - 1;
                this.endIndexInfo.line.index > t
                  ? ((this.origin.y =
                      this.endIndexInfo.line.index + 1 - this.data.rows),
                    (e = !0))
                  : this.endIndexInfo.line.index < this.origin.y &&
                    ((this.origin.y = this.endIndexInfo.line.index), (e = !0));
              }
              t.detail.start.changed &&
                this.startIndexInfo.line.index < this.origin.y &&
                ((this.origin.y = this.startIndexInfo.line.index), (e = !0)),
                e && this._emit('origin-changed');
            },
            _updateHorizontalOrigin: function (t) {
              if (!this.endIndexInfo) return;
              let e = !0;
              if (t.detail.end.changed) {
                const t = this.selectionEnd - this.endIndexInfo.line.start;
                t > this.origin.x + this.data.cols
                  ? ((this.origin.x = t - this.data.cols), (e = !0))
                  : t < this.origin.x && ((this.origin.x = t), (e = !0));
              }
              const n = this.selectionStart - this.startIndexInfo.line.start;
              t.detail.start.changed &&
                (n > this.origin.x + this.data.cols
                  ? ((this.origin.x = n - this.data.cols), (e = !0))
                  : n < this.origin.x && ((this.origin.x = n), (e = !0))),
                e && this._emit('origin-changed');
            },
            _updateLines: function () {
              this.lines = [];
              const t = this.text.split('\n');
              let e = 0;
              for (let n = 0; n < t.length; n++)
                (this.lines[n] = { index: n, length: t[n].length, start: e }),
                  (e += t[n].length + 1);
              this._emit('lines-changed');
            },
            _getViewportText: function () {
              return this.text
                .split('\n')
                .slice(this.origin.y, this.origin.y + this.data.rows)
                .map(
                  function (t) {
                    return t.substr(this.origin.x, this.data.cols) || ' ';
                  }.bind(this)
                )
                .join('\n');
            },
            _updateDisplayText: function () {
              this.textAnchor.setAttribute('text', {
                value: this._getViewportText()
              });
            },
            _checkAndUpdateText: function () {
              const t = this.textarea.value;
              t !== this.text && ((this.text = t), this._emit('text-changed'));
            }
          });
        },
        824: (e) => {
          'use strict';
          e.exports = t;
        }
      },
      n = {};
    function r(t) {
      var s = n[t];
      if (void 0 !== s) return s.exports;
      var i = (n[t] = { exports: {} });
      return e[t](i, i.exports, r), i.exports;
    }
    r.r = (t) => {
      'undefined' != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }),
        Object.defineProperty(t, '__esModule', { value: !0 });
    };
    var s = {};
    return (
      (() => {
        'use strict';
        r.r(s);
        var t = r(824);
        async function e(t, e, n, r) {
          return r._parse(t, e, n, r);
        }
        function n(t, e) {
          if (!t) throw new Error(e || 'loader assertion failed.');
        }
        const i = !(
            'object' == typeof process &&
            '[object process]' === String(process) &&
            !process.browser
          ),
          o =
            typeof process < 'u' &&
            process.version &&
            /v([0-9]*)/.exec(process.version);
        function a(t, e) {
          return c(t || {}, e);
        }
        function c(t, e) {
          let n =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
          if (n > 3) return e;
          const r = { ...t };
          for (const [t, s] of Object.entries(e))
            s && 'object' == typeof s && !Array.isArray(s)
              ? (r[t] = c(r[t] || {}, e[t], n + 1))
              : (r[t] = e[t]);
          return r;
        }
        o && parseFloat(o[1]);
        const l = 'latest',
          h =
            ((null !== (u = globalThis._loadersgl_) &&
              void 0 !== u &&
              u.version) ||
              ((globalThis._loadersgl_ = globalThis._loadersgl_ || {}),
              (globalThis._loadersgl_.version = '4.1.1')),
            globalThis._loadersgl_.version);
        var u;
        function d(t, e) {
          if (!t) throw new Error(e || 'loaders.gl assertion failed.');
        }
        const f =
            'object' != typeof process ||
            '[object process]' !== String(process) ||
            process.browser,
          m = 'function' == typeof importScripts,
          g = typeof window < 'u' && typeof window.orientation < 'u',
          A =
            typeof process < 'u' &&
            process.version &&
            /v([0-9]*)/.exec(process.version);
        A && parseFloat(A[1]);
        class p {
          constructor(t, e) {
            (this.name = void 0),
              (this.workerThread = void 0),
              (this.isRunning = !0),
              (this.result = void 0),
              (this._resolve = () => {}),
              (this._reject = () => {}),
              (this.name = t),
              (this.workerThread = e),
              (this.result = new Promise((t, e) => {
                (this._resolve = t), (this._reject = e);
              }));
          }
          postMessage(t, e) {
            this.workerThread.postMessage({
              source: 'loaders.gl',
              type: t,
              payload: e
            });
          }
          done(t) {
            d(this.isRunning), (this.isRunning = !1), this._resolve(t);
          }
          error(t) {
            d(this.isRunning), (this.isRunning = !1), this._reject(t);
          }
        }
        class y {
          terminate() {}
        }
        const B = new Map();
        function b(t) {
          const e = new Blob([t], { type: 'application/javascript' });
          return URL.createObjectURL(e);
        }
        function C(t) {
          let e =
              !(arguments.length > 1 && void 0 !== arguments[1]) ||
              arguments[1],
            n = arguments.length > 2 ? arguments[2] : void 0;
          const r = n || new Set();
          if (t)
            if (w(t)) r.add(t);
            else if (w(t.buffer)) r.add(t.buffer);
            else if (!ArrayBuffer.isView(t) && e && 'object' == typeof t)
              for (const n in t) C(t[n], e, r);
          return void 0 === n ? Array.from(r) : [];
        }
        function w(t) {
          return (
            !!t &&
            (t instanceof ArrayBuffer ||
              (typeof MessagePort < 'u' && t instanceof MessagePort) ||
              (typeof ImageBitmap < 'u' && t instanceof ImageBitmap) ||
              (typeof OffscreenCanvas < 'u' && t instanceof OffscreenCanvas))
          );
        }
        const E = () => {};
        class T {
          static isSupported() {
            return (typeof Worker < 'u' && f) || (typeof y < 'u' && !f);
          }
          constructor(t) {
            (this.name = void 0),
              (this.source = void 0),
              (this.url = void 0),
              (this.terminated = !1),
              (this.worker = void 0),
              (this.onMessage = void 0),
              (this.onError = void 0),
              (this._loadableURL = '');
            const { name: e, source: n, url: r } = t;
            d(n || r),
              (this.name = e),
              (this.source = n),
              (this.url = r),
              (this.onMessage = E),
              (this.onError = (t) => console.log(t)),
              (this.worker = f
                ? this._createBrowserWorker()
                : this._createNodeWorker());
          }
          destroy() {
            (this.onMessage = E),
              (this.onError = E),
              this.worker.terminate(),
              (this.terminated = !0);
          }
          get isRunning() {
            return !!this.onMessage;
          }
          postMessage(t, e) {
            (e = e || C(t)), this.worker.postMessage(t, e);
          }
          _getErrorFromErrorEvent(t) {
            let e = 'Failed to load ';
            return (
              (e += `worker ${this.name} from ${this.url}. `),
              t.message && (e += `${t.message} in `),
              t.lineno && (e += `:${t.lineno}:${t.colno}`),
              new Error(e)
            );
          }
          _createBrowserWorker() {
            this._loadableURL = (function (t) {
              d((t.source && !t.url) || (!t.source && t.url));
              let e = B.get(t.source || t.url);
              return (
                e ||
                  (t.url &&
                    ((e = (function (t) {
                      return t.startsWith('http')
                        ? b(
                            (function (t) {
                              return `try {\n  importScripts('${t}');\n} catch (error) {\n  console.error(error);\n  throw error;\n}`;
                            })(t)
                          )
                        : t;
                    })(t.url)),
                    B.set(t.url, e)),
                  t.source && ((e = b(t.source)), B.set(t.source, e))),
                d(e),
                e
              );
            })({ source: this.source, url: this.url });
            const t = new Worker(this._loadableURL, { name: this.name });
            return (
              (t.onmessage = (t) => {
                t.data
                  ? this.onMessage(t.data)
                  : this.onError(new Error('No data received'));
              }),
              (t.onerror = (t) => {
                this.onError(this._getErrorFromErrorEvent(t)),
                  (this.terminated = !0);
              }),
              (t.onmessageerror = (t) => console.error(t)),
              t
            );
          }
          _createNodeWorker() {
            let t;
            if (this.url) {
              const e =
                this.url.includes(':/') || this.url.startsWith('/')
                  ? this.url
                  : `./${this.url}`;
              t = new y(e, { eval: !1 });
            } else {
              if (!this.source) throw new Error('no worker');
              t = new y(this.source, { eval: !0 });
            }
            return (
              t.on('message', (t) => {
                this.onMessage(t);
              }),
              t.on('error', (t) => {
                this.onError(t);
              }),
              t.on('exit', (t) => {}),
              t
            );
          }
        }
        class v {
          static isSupported() {
            return T.isSupported();
          }
          constructor(t) {
            (this.name = 'unnamed'),
              (this.source = void 0),
              (this.url = void 0),
              (this.maxConcurrency = 1),
              (this.maxMobileConcurrency = 1),
              (this.onDebug = () => {}),
              (this.reuseWorkers = !0),
              (this.props = {}),
              (this.jobQueue = []),
              (this.idleQueue = []),
              (this.count = 0),
              (this.isDestroyed = !1),
              (this.source = t.source),
              (this.url = t.url),
              this.setProps(t);
          }
          destroy() {
            this.idleQueue.forEach((t) => t.destroy()), (this.isDestroyed = !0);
          }
          setProps(t) {
            (this.props = { ...this.props, ...t }),
              void 0 !== t.name && (this.name = t.name),
              void 0 !== t.maxConcurrency &&
                (this.maxConcurrency = t.maxConcurrency),
              void 0 !== t.maxMobileConcurrency &&
                (this.maxMobileConcurrency = t.maxMobileConcurrency),
              void 0 !== t.reuseWorkers && (this.reuseWorkers = t.reuseWorkers),
              void 0 !== t.onDebug && (this.onDebug = t.onDebug);
          }
          async startJob(t) {
            let e =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : (t, e, n) => t.done(n),
              n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : (t, e) => t.error(e);
            const r = new Promise(
              (r) => (
                this.jobQueue.push({
                  name: t,
                  onMessage: e,
                  onError: n,
                  onStart: r
                }),
                this
              )
            );
            return this._startQueuedJob(), await r;
          }
          async _startQueuedJob() {
            if (!this.jobQueue.length) return;
            const t = this._getAvailableWorker();
            if (!t) return;
            const e = this.jobQueue.shift();
            if (e) {
              this.onDebug({
                message: 'Starting job',
                name: e.name,
                workerThread: t,
                backlog: this.jobQueue.length
              });
              const n = new p(e.name, t);
              (t.onMessage = (t) => e.onMessage(n, t.type, t.payload)),
                (t.onError = (t) => e.onError(n, t)),
                e.onStart(n);
              try {
                await n.result;
              } catch (t) {
                console.error(`Worker exception: ${t}`);
              } finally {
                this.returnWorkerToQueue(t);
              }
            }
          }
          returnWorkerToQueue(t) {
            !f ||
            this.isDestroyed ||
            !this.reuseWorkers ||
            this.count > this._getMaxConcurrency()
              ? (t.destroy(), this.count--)
              : this.idleQueue.push(t),
              this.isDestroyed || this._startQueuedJob();
          }
          _getAvailableWorker() {
            if (this.idleQueue.length > 0)
              return this.idleQueue.shift() || null;
            if (this.count < this._getMaxConcurrency()) {
              this.count++;
              const t = `${this.name.toLowerCase()} (#${this.count} of ${
                this.maxConcurrency
              })`;
              return new T({ name: t, source: this.source, url: this.url });
            }
            return null;
          }
          _getMaxConcurrency() {
            return g ? this.maxMobileConcurrency : this.maxConcurrency;
          }
        }
        const _ = {
          maxConcurrency: 3,
          maxMobileConcurrency: 1,
          reuseWorkers: !0,
          onDebug: () => {}
        };
        class M {
          static isSupported() {
            return T.isSupported();
          }
          static getWorkerFarm() {
            let t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {};
            return (
              (M._workerFarm = M._workerFarm || new M({})),
              M._workerFarm.setProps(t),
              M._workerFarm
            );
          }
          constructor(t) {
            (this.props = void 0),
              (this.workerPools = new Map()),
              (this.props = { ..._ }),
              this.setProps(t),
              (this.workerPools = new Map());
          }
          destroy() {
            for (const t of this.workerPools.values()) t.destroy();
            this.workerPools = new Map();
          }
          setProps(t) {
            this.props = { ...this.props, ...t };
            for (const t of this.workerPools.values())
              t.setProps(this._getWorkerPoolProps());
          }
          getWorkerPool(t) {
            const { name: e, source: n, url: r } = t;
            let s = this.workerPools.get(e);
            return (
              s ||
                ((s = new v({ name: e, source: n, url: r })),
                s.setProps(this._getWorkerPoolProps()),
                this.workerPools.set(e, s)),
              s
            );
          }
          _getWorkerPoolProps() {
            return {
              maxConcurrency: this.props.maxConcurrency,
              maxMobileConcurrency: this.props.maxMobileConcurrency,
              reuseWorkers: this.props.reuseWorkers,
              onDebug: this.props.onDebug
            };
          }
        }
        M._workerFarm = void 0;
        const I = Object.freeze(
            Object.defineProperty(
              { __proto__: null, default: {} },
              Symbol.toStringTag,
              { value: 'Module' }
            )
          ),
          x = {};
        async function F(t) {
          let e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : null,
            n =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {},
            r =
              arguments.length > 3 && void 0 !== arguments[3]
                ? arguments[3]
                : null;
          return e && (t = O(t, e, n, r)), (x[t] = x[t] || R(t)), await x[t];
        }
        function O(t, e) {
          let n =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {},
            r =
              arguments.length > 3 && void 0 !== arguments[3]
                ? arguments[3]
                : null;
          if (!n.useLocalLibraries && t.startsWith('http')) return t;
          r = r || t;
          const s = n.modules || {};
          return s[r]
            ? s[r]
            : f
            ? n.CDN
              ? (d(n.CDN.startsWith('http')),
                `${n.CDN}/${e}@${h}/dist/libs/${r}`)
              : m
              ? `../src/libs/${r}`
              : `modules/${e}/src/libs/${r}`
            : `modules/${e}/dist/libs/${r}`;
        }
        async function R(t) {
          if (t.endsWith('wasm'))
            return await (async function (t) {
              return await (await fetch(t)).arrayBuffer();
            })(t);
          if (!f)
            try {
              return I && void 0;
            } catch (t) {
              return console.error(t), null;
            }
          if (m) return importScripts(t);
          const e = await (async function (t) {
            return await (await fetch(t)).text();
          })(t);
          return (function (t, e) {
            if (!f) return;
            if (m) return eval.call(globalThis, t), null;
            const n = document.createElement('script');
            n.id = e;
            try {
              n.appendChild(document.createTextNode(t));
            } catch {
              n.text = t;
            }
            return document.body.appendChild(n), null;
          })(e, t);
        }
        async function S(t, e, n, r, s) {
          const i = t.id,
            o = (function (t) {
              let e =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : {};
              const n = e[t.id] || {},
                r = f ? `${t.id}-worker.js` : `${t.id}-worker-node.js`;
              let s = n.workerUrl;
              if (
                (!s && 'compression' === t.id && (s = e.workerUrl),
                'test' === e._workerType &&
                  (s = f
                    ? `modules/${t.module}/dist/${r}`
                    : `modules/${t.module}/src/workers/${t.id}-worker-node.ts`),
                !s)
              ) {
                let e = t.version;
                'latest' === e && (e = l);
                const n = e ? `@${e}` : '';
                s = `https://unpkg.com/@loaders.gl/${t.module}${n}/dist/${r}`;
              }
              return d(s), s;
            })(t, n),
            a = M.getWorkerFarm(n).getWorkerPool({ name: i, url: o });
          (n = JSON.parse(JSON.stringify(n))),
            (r = JSON.parse(JSON.stringify(r || {})));
          const c = await a.startJob('process-on-worker', D.bind(null, s));
          return (
            c.postMessage('process', { input: e, options: n, context: r }),
            await (
              await c.result
            ).result
          );
        }
        async function D(t, e, n, r) {
          switch (n) {
            case 'done':
              e.done(r);
              break;
            case 'error':
              e.error(new Error(r.error));
              break;
            case 'process':
              const { id: s, input: i, options: o } = r;
              try {
                const n = await t(i, o);
                e.postMessage('done', { id: s, result: n });
              } catch (t) {
                const n = t instanceof Error ? t.message : 'unknown error';
                e.postMessage('error', { id: s, error: n });
              }
              break;
            default:
              console.warn(`parse-with-worker unknown message ${n}`);
          }
        }
        function G(t, e, n) {
          if (t.byteLength <= e + n) return '';
          const r = new DataView(t);
          let s = '';
          for (let t = 0; t < n; t++)
            s += String.fromCharCode(r.getUint8(e + t));
          return s;
        }
        function L(t) {
          const e = t.map((t) =>
              t instanceof ArrayBuffer ? new Uint8Array(t) : t
            ),
            n = e.reduce((t, e) => t + e.byteLength, 0),
            r = new Uint8Array(n);
          let s = 0;
          for (const t of e) r.set(t, s), (s += t.byteLength);
          return r.buffer;
        }
        function U(t, e, n) {
          const r =
            void 0 !== n
              ? new Uint8Array(t).subarray(e, e + n)
              : new Uint8Array(t).subarray(e);
          return new Uint8Array(r).buffer;
        }
        function N(t, e) {
          return n(t >= 0), n(e > 0), (t + (e - 1)) & ~(e - 1);
        }
        function H(t, e, n) {
          let r;
          if (t instanceof ArrayBuffer) r = new Uint8Array(t);
          else {
            const e = t.byteOffset,
              n = t.byteLength;
            r = new Uint8Array(t.buffer || t.arrayBuffer, e, n);
          }
          return e.set(r, n), n + N(r.byteLength, 4);
        }
        function P() {
          let t;
          if (typeof window < 'u' && window.performance)
            t = window.performance.now();
          else if (typeof process < 'u' && process.hrtime) {
            const e = process.hrtime();
            t = 1e3 * e[0] + e[1] / 1e6;
          } else t = Date.now();
          return t;
        }
        class J {
          constructor(t, e) {
            (this.name = void 0),
              (this.type = void 0),
              (this.sampleSize = 1),
              (this.time = 0),
              (this.count = 0),
              (this.samples = 0),
              (this.lastTiming = 0),
              (this.lastSampleTime = 0),
              (this.lastSampleCount = 0),
              (this._count = 0),
              (this._time = 0),
              (this._samples = 0),
              (this._startTime = 0),
              (this._timerPending = !1),
              (this.name = t),
              (this.type = e),
              this.reset();
          }
          reset() {
            return (
              (this.time = 0),
              (this.count = 0),
              (this.samples = 0),
              (this.lastTiming = 0),
              (this.lastSampleTime = 0),
              (this.lastSampleCount = 0),
              (this._count = 0),
              (this._time = 0),
              (this._samples = 0),
              (this._startTime = 0),
              (this._timerPending = !1),
              this
            );
          }
          setSampleSize(t) {
            return (this.sampleSize = t), this;
          }
          incrementCount() {
            return this.addCount(1), this;
          }
          decrementCount() {
            return this.subtractCount(1), this;
          }
          addCount(t) {
            return (
              (this._count += t), this._samples++, this._checkSampling(), this
            );
          }
          subtractCount(t) {
            return (
              (this._count -= t), this._samples++, this._checkSampling(), this
            );
          }
          addTime(t) {
            return (
              (this._time += t),
              (this.lastTiming = t),
              this._samples++,
              this._checkSampling(),
              this
            );
          }
          timeStart() {
            return (this._startTime = P()), (this._timerPending = !0), this;
          }
          timeEnd() {
            return this._timerPending
              ? (this.addTime(P() - this._startTime),
                (this._timerPending = !1),
                this._checkSampling(),
                this)
              : this;
          }
          getSampleAverageCount() {
            return this.sampleSize > 0
              ? this.lastSampleCount / this.sampleSize
              : 0;
          }
          getSampleAverageTime() {
            return this.sampleSize > 0
              ? this.lastSampleTime / this.sampleSize
              : 0;
          }
          getSampleHz() {
            return this.lastSampleTime > 0
              ? this.sampleSize / (this.lastSampleTime / 1e3)
              : 0;
          }
          getAverageCount() {
            return this.samples > 0 ? this.count / this.samples : 0;
          }
          getAverageTime() {
            return this.samples > 0 ? this.time / this.samples : 0;
          }
          getHz() {
            return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
          }
          _checkSampling() {
            this._samples === this.sampleSize &&
              ((this.lastSampleTime = this._time),
              (this.lastSampleCount = this._count),
              (this.count += this._count),
              (this.time += this._time),
              (this.samples += this._samples),
              (this._time = 0),
              (this._count = 0),
              (this._samples = 0));
          }
        }
        class j {
          constructor(t) {
            (this.id = void 0),
              (this.stats = {}),
              (this.id = t.id),
              (this.stats = {}),
              this._initializeStats(t.stats),
              Object.seal(this);
          }
          get(t) {
            let e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 'count';
            return this._getOrCreate({ name: t, type: e });
          }
          get size() {
            return Object.keys(this.stats).length;
          }
          reset() {
            for (const t of Object.values(this.stats)) t.reset();
            return this;
          }
          forEach(t) {
            for (const e of Object.values(this.stats)) t(e);
          }
          getTable() {
            const t = {};
            return (
              this.forEach((e) => {
                t[e.name] = {
                  time: e.time || 0,
                  count: e.count || 0,
                  average: e.getAverageTime() || 0,
                  hz: e.getHz() || 0
                };
              }),
              t
            );
          }
          _initializeStats() {
            (arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : []
            ).forEach((t) => this._getOrCreate(t));
          }
          _getOrCreate(t) {
            const { name: e, type: n } = t;
            let r = this.stats[e];
            return (
              r ||
                ((r = t instanceof J ? t : new J(e, n)), (this.stats[e] = r)),
              r
            );
          }
        }
        const k = {
          id: 'request-scheduler',
          throttleRequests: !0,
          maxRequests: 6
        };
        class V {
          constructor() {
            let t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {};
            (this.props = void 0),
              (this.stats = void 0),
              (this.activeRequestCount = 0),
              (this.requestQueue = []),
              (this.requestMap = new Map()),
              (this.deferredUpdate = null),
              (this.props = { ...k, ...t }),
              (this.stats = new j({ id: this.props.id })),
              this.stats.get('Queued Requests'),
              this.stats.get('Active Requests'),
              this.stats.get('Cancelled Requests'),
              this.stats.get('Queued Requests Ever'),
              this.stats.get('Active Requests Ever');
          }
          scheduleRequest(t) {
            let e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : () => 0;
            if (!this.props.throttleRequests)
              return Promise.resolve({ done: () => {} });
            if (this.requestMap.has(t)) return this.requestMap.get(t);
            const n = { handle: t, priority: 0, getPriority: e },
              r = new Promise((t) => ((n.resolve = t), n));
            return (
              this.requestQueue.push(n),
              this.requestMap.set(t, r),
              this._issueNewRequests(),
              r
            );
          }
          _issueRequest(t) {
            const { handle: e, resolve: n } = t;
            let r = !1;
            const s = () => {
              r ||
                ((r = !0),
                this.requestMap.delete(e),
                this.activeRequestCount--,
                this._issueNewRequests());
            };
            return (
              this.activeRequestCount++,
              n ? n({ done: s }) : Promise.resolve({ done: s })
            );
          }
          _issueNewRequests() {
            this.deferredUpdate ||
              (this.deferredUpdate = setTimeout(
                () => this._issueNewRequestsAsync(),
                0
              ));
          }
          _issueNewRequestsAsync() {
            this.deferredUpdate = null;
            const t = Math.max(
              this.props.maxRequests - this.activeRequestCount,
              0
            );
            if (0 !== t) {
              this._updateAllRequests();
              for (let e = 0; e < t; ++e) {
                const t = this.requestQueue.shift();
                t && this._issueRequest(t);
              }
            }
          }
          _updateAllRequests() {
            const t = this.requestQueue;
            for (let e = 0; e < t.length; ++e) {
              const n = t[e];
              this._updateRequest(n) ||
                (t.splice(e, 1), this.requestMap.delete(n.handle), e--);
            }
            t.sort((t, e) => t.priority - e.priority);
          }
          _updateRequest(t) {
            return (
              (t.priority = t.getPriority(t.handle)),
              !(t.priority < 0 && (t.resolve(null), 1))
            );
          }
        }
        const K = {};
        function Q(t) {
          if (
            (function (t) {
              return t && 'object' == typeof t && t.isBuffer;
            })(t)
          )
            return t;
          if (t instanceof ArrayBuffer) return t;
          if (ArrayBuffer.isView(t))
            return 0 === t.byteOffset && t.byteLength === t.buffer.byteLength
              ? t.buffer
              : t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);
          if ('string' == typeof t) {
            const e = t;
            return new TextEncoder().encode(e).buffer;
          }
          if (t && 'object' == typeof t && t._toArrayBuffer)
            return t._toArrayBuffer();
          throw new Error('toArrayBuffer');
        }
        function q() {
          var t;
          if (typeof process < 'u' && typeof process.cwd < 'u')
            return process.cwd();
          const e =
            null === (t = window.location) || void 0 === t
              ? void 0
              : t.pathname;
          return (
            (null == e ? void 0 : e.slice(0, e.lastIndexOf('/') + 1)) || ''
          );
        }
        function W(t) {
          const e = t ? t.lastIndexOf('/') : -1;
          return e >= 0 ? t.substr(e + 1) : '';
        }
        function z(t) {
          const e = t ? t.lastIndexOf('/') : -1;
          return e >= 0 ? t.substr(0, e) : '';
        }
        const X = 47;
        function Y(t, e) {
          let n,
            r = '',
            s = -1,
            i = 0,
            o = !1;
          for (let a = 0; a <= t.length; ++a) {
            if (a < t.length) n = t.charCodeAt(a);
            else {
              if (n === X) break;
              n = X;
            }
            if (n === X) {
              if (s !== a - 1 && 1 !== i)
                if (s !== a - 1 && 2 === i) {
                  if (
                    r.length < 2 ||
                    !o ||
                    46 !== r.charCodeAt(r.length - 1) ||
                    46 !== r.charCodeAt(r.length - 2)
                  )
                    if (r.length > 2) {
                      const t = r.length - 1;
                      let e = t;
                      for (; e >= 0 && r.charCodeAt(e) !== X; --e);
                      if (e !== t) {
                        (r = -1 === e ? '' : r.slice(0, e)),
                          (s = a),
                          (i = 0),
                          (o = !1);
                        continue;
                      }
                    } else if (2 === r.length || 1 === r.length) {
                      (r = ''), (s = a), (i = 0), (o = !1);
                      continue;
                    }
                  e && (r.length > 0 ? (r += '/..') : (r = '..'), (o = !0));
                } else {
                  const e = t.slice(s + 1, a);
                  r.length > 0 ? (r += `/${e}`) : (r = e), (o = !1);
                }
              (s = a), (i = 0);
            } else 46 === n && -1 !== i ? ++i : (i = -1);
          }
          return r;
        }
        const Z = (t) => 'function' == typeof t,
          $ = (t) => null !== t && 'object' == typeof t,
          tt = (t) => $(t) && t.constructor === {}.constructor,
          et = (t) =>
            (typeof Response < 'u' && t instanceof Response) ||
            (t && t.arrayBuffer && t.text && t.json),
          nt = (t) => typeof Blob < 'u' && t instanceof Blob,
          rt = (t) =>
            ((t) =>
              (typeof ReadableStream < 'u' && t instanceof ReadableStream) ||
              ($(t) && Z(t.tee) && Z(t.cancel) && Z(t.getReader)))(t) ||
            ((t) =>
              $(t) &&
              Z(t.read) &&
              Z(t.pipe) &&
              ((t) => 'boolean' == typeof t)(t.readable))(t),
          st = /^data:([-\w.]+\/[-\w.+]+)(;|,)/,
          it = /^([-\w.]+\/[-\w.+]+)/;
        function ot(t) {
          const e = st.exec(t);
          return e ? e[1] : '';
        }
        const at = /\?.*/;
        function ct(t) {
          return t.replace(at, '');
        }
        function lt(t) {
          return et(t)
            ? t.url
            : nt(t)
            ? t.name || ''
            : 'string' == typeof t
            ? t
            : '';
        }
        function ht(t) {
          if (et(t)) {
            const e = t,
              n = e.headers.get('content-type') || '',
              r = ct(e.url);
            return (
              (function (t) {
                const e = it.exec(t);
                return e ? e[1] : t;
              })(n) || ot(r)
            );
          }
          return nt(t) ? t.type || '' : 'string' == typeof t ? ot(t) : '';
        }
        async function ut(t) {
          if (et(t)) return t;
          const e = {},
            n = (function (t) {
              return et(t)
                ? t.headers['content-length'] || -1
                : nt(t)
                ? t.size
                : 'string' == typeof t
                ? t.length
                : t instanceof ArrayBuffer || ArrayBuffer.isView(t)
                ? t.byteLength
                : -1;
            })(t);
          n >= 0 && (e['content-length'] = String(n));
          const r = lt(t),
            s = ht(t);
          s && (e['content-type'] = s);
          const i = await (async function (t) {
            if ('string' == typeof t) return `data:,${t.slice(0, 5)}`;
            if (t instanceof Blob) {
              const e = t.slice(0, 5);
              return await new Promise((t) => {
                const n = new FileReader();
                (n.onload = (e) => {
                  var n;
                  return t(
                    null == e || null === (n = e.target) || void 0 === n
                      ? void 0
                      : n.result
                  );
                }),
                  n.readAsDataURL(e);
              });
            }
            return t instanceof ArrayBuffer
              ? `data:base64,${(function (t) {
                  let e = '';
                  const n = new Uint8Array(t);
                  for (let t = 0; t < n.byteLength; t++)
                    e += String.fromCharCode(n[t]);
                  return btoa(e);
                })(t.slice(0, 5))}`
              : null;
          })(t);
          i && (e['x-first-bytes'] = i),
            'string' == typeof t && (t = new TextEncoder().encode(t));
          const o = new Response(t, { headers: e });
          return Object.defineProperty(o, 'url', { value: r }), o;
        }
        async function dt(t, e) {
          if ('string' == typeof t) {
            const s = (function (t) {
              for (const e in K)
                if (t.startsWith(e)) {
                  const n = K[e];
                  t = t.replace(e, n);
                }
              return (
                !t.startsWith('http://') &&
                  !t.startsWith('https://') &&
                  (t = `${t}`),
                t
              );
            })(t);
            var n, r;
            return (function (t) {
              return (
                !(function (t) {
                  return t.startsWith('http:') || t.startsWith('https:');
                })(t) &&
                !(function (t) {
                  return t.startsWith('data:');
                })(t)
              );
            })(s) &&
              null !== (n = globalThis.loaders) &&
              void 0 !== n &&
              n.fetchNode
              ? null === (r = globalThis.loaders) || void 0 === r
                ? void 0
                : r.fetchNode(s, e)
              : await fetch(s, e);
          }
          return await ut(t);
        }
        function ft() {
          return (
            !(
              'object' == typeof process &&
              '[object process]' === String(process) &&
              !process.browser
            ) ||
            (function (t) {
              if (
                (typeof window < 'u' &&
                  'object' == typeof window.process &&
                  'renderer' === window.process.type) ||
                (typeof process < 'u' &&
                  'object' == typeof process.versions &&
                  process.versions.electron)
              )
                return !0;
              const e =
                'object' == typeof navigator &&
                'string' == typeof navigator.userAgent &&
                navigator.userAgent;
              return !!(e && e.indexOf('Electron') >= 0);
            })()
          );
        }
        const mt = globalThis.window || globalThis.self || globalThis.global,
          gt = globalThis.process || {},
          At = typeof __VERSION__ < 'u' ? __VERSION__ : 'untranspiled source';
        ft();
        class pt {
          constructor(t, e) {
            let n =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : 'sessionStorage';
            (this.storage = void 0),
              (this.id = void 0),
              (this.config = void 0),
              (this.storage = (function (t) {
                try {
                  const e = window[t],
                    n = '__storage_test__';
                  return e.setItem(n, n), e.removeItem(n), e;
                } catch {
                  return null;
                }
              })(n)),
              (this.id = t),
              (this.config = e),
              this._loadConfiguration();
          }
          getConfiguration() {
            return this.config;
          }
          setConfiguration(t) {
            if ((Object.assign(this.config, t), this.storage)) {
              const t = JSON.stringify(this.config);
              this.storage.setItem(this.id, t);
            }
          }
          _loadConfiguration() {
            let t = {};
            if (this.storage) {
              const e = this.storage.getItem(this.id);
              t = e ? JSON.parse(e) : {};
            }
            return Object.assign(this.config, t), this;
          }
        }
        function yt(t, e, n) {
          let r =
            arguments.length > 3 && void 0 !== arguments[3]
              ? arguments[3]
              : 600;
          const s = t.src.replace(/\(/g, '%28').replace(/\)/g, '%29');
          t.width > r && (n = Math.min(n, r / t.width));
          const i = t.width * n,
            o = t.height * n,
            a = [
              'font-size:1px;',
              'padding:'
                .concat(Math.floor(o / 2), 'px ')
                .concat(Math.floor(i / 2), 'px;'),
              'line-height:'.concat(o, 'px;'),
              'background:url('.concat(s, ');'),
              'background-size:'.concat(i, 'px ').concat(o, 'px;'),
              'color:transparent;'
            ].join('');
          return [''.concat(e, ' %c+'), a];
        }
        let Bt;
        function bt(t) {
          return 'string' != typeof t
            ? t
            : ((t = t.toUpperCase()), Bt[t] || Bt.WHITE);
        }
        function Ct(t, e) {
          if (!t) throw new Error(e || 'Assertion failed');
        }
        function wt() {
          let t;
          var e, n;
          if (ft() && mt.performance)
            t =
              null == mt ||
              null === (e = mt.performance) ||
              void 0 === e ||
              null === (n = e.now) ||
              void 0 === n
                ? void 0
                : n.call(e);
          else if ('hrtime' in gt) {
            var r;
            const e =
              null == gt || null === (r = gt.hrtime) || void 0 === r
                ? void 0
                : r.call(gt);
            t = 1e3 * e[0] + e[1] / 1e6;
          } else t = Date.now();
          return t;
        }
        !(function (t) {
          (t[(t.BLACK = 30)] = 'BLACK'),
            (t[(t.RED = 31)] = 'RED'),
            (t[(t.GREEN = 32)] = 'GREEN'),
            (t[(t.YELLOW = 33)] = 'YELLOW'),
            (t[(t.BLUE = 34)] = 'BLUE'),
            (t[(t.MAGENTA = 35)] = 'MAGENTA'),
            (t[(t.CYAN = 36)] = 'CYAN'),
            (t[(t.WHITE = 37)] = 'WHITE'),
            (t[(t.BRIGHT_BLACK = 90)] = 'BRIGHT_BLACK'),
            (t[(t.BRIGHT_RED = 91)] = 'BRIGHT_RED'),
            (t[(t.BRIGHT_GREEN = 92)] = 'BRIGHT_GREEN'),
            (t[(t.BRIGHT_YELLOW = 93)] = 'BRIGHT_YELLOW'),
            (t[(t.BRIGHT_BLUE = 94)] = 'BRIGHT_BLUE'),
            (t[(t.BRIGHT_MAGENTA = 95)] = 'BRIGHT_MAGENTA'),
            (t[(t.BRIGHT_CYAN = 96)] = 'BRIGHT_CYAN'),
            (t[(t.BRIGHT_WHITE = 97)] = 'BRIGHT_WHITE');
        })(Bt || (Bt = {}));
        const Et = {
            debug: (ft() && console.debug) || console.log,
            log: console.log,
            info: console.info,
            warn: console.warn,
            error: console.error
          },
          Tt = { enabled: !0, level: 0 };
        function vt() {}
        const _t = {},
          Mt = { once: !0 };
        class It {
          constructor() {
            let { id: t } =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : { id: '' };
            (this.id = void 0),
              (this.VERSION = At),
              (this._startTs = wt()),
              (this._deltaTs = wt()),
              (this._storage = void 0),
              (this.userData = {}),
              (this.LOG_THROTTLE_TIMEOUT = 0),
              (this.id = t),
              (this.userData = {}),
              (this._storage = new pt('__probe-'.concat(this.id, '__'), Tt)),
              this.timeStamp(''.concat(this.id, ' started')),
              (function (t) {
                let e =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : ['constructor'];
                const n = Object.getPrototypeOf(t),
                  r = Object.getOwnPropertyNames(n),
                  s = t;
                for (const n of r) {
                  const r = s[n];
                  'function' == typeof r &&
                    (e.find((t) => n === t) || (s[n] = r.bind(t)));
                }
              })(this),
              Object.seal(this);
          }
          set level(t) {
            this.setLevel(t);
          }
          get level() {
            return this.getLevel();
          }
          isEnabled() {
            return this._storage.config.enabled;
          }
          getLevel() {
            return this._storage.config.level;
          }
          getTotal() {
            return Number((wt() - this._startTs).toPrecision(10));
          }
          getDelta() {
            return Number((wt() - this._deltaTs).toPrecision(10));
          }
          set priority(t) {
            this.level = t;
          }
          get priority() {
            return this.level;
          }
          getPriority() {
            return this.level;
          }
          enable() {
            let t =
              !(arguments.length > 0 && void 0 !== arguments[0]) ||
              arguments[0];
            return this._storage.setConfiguration({ enabled: t }), this;
          }
          setLevel(t) {
            return this._storage.setConfiguration({ level: t }), this;
          }
          get(t) {
            return this._storage.config[t];
          }
          set(t, e) {
            this._storage.setConfiguration({ [t]: e });
          }
          settings() {
            console.table
              ? console.table(this._storage.config)
              : console.log(this._storage.config);
          }
          assert(t, e) {
            Ct(t, e);
          }
          warn(t) {
            return this._getLogFunction(0, t, Et.warn, arguments, Mt);
          }
          error(t) {
            return this._getLogFunction(0, t, Et.error, arguments);
          }
          deprecated(t, e) {
            return this.warn(
              '`'
                .concat(
                  t,
                  '` is deprecated and will be removed in a later version. Use `'
                )
                .concat(e, '` instead')
            );
          }
          removed(t, e) {
            return this.error(
              '`'.concat(t, '` has been removed. Use `').concat(e, '` instead')
            );
          }
          probe(t, e) {
            return this._getLogFunction(t, e, Et.log, arguments, {
              time: !0,
              once: !0
            });
          }
          log(t, e) {
            return this._getLogFunction(t, e, Et.debug, arguments);
          }
          info(t, e) {
            return this._getLogFunction(t, e, console.info, arguments);
          }
          once(t, e) {
            return this._getLogFunction(
              t,
              e,
              Et.debug || Et.info,
              arguments,
              Mt
            );
          }
          table(t, e, n) {
            return e
              ? this._getLogFunction(t, e, console.table || vt, n && [n], {
                  tag: Ot(e)
                })
              : vt;
          }
          image(t) {
            let {
              logLevel: e,
              priority: n,
              image: r,
              message: s = '',
              scale: i = 1
            } = t;
            return this._shouldLog(e || n)
              ? ft()
                ? (function (t) {
                    let { image: e, message: n = '', scale: r = 1 } = t;
                    if ('string' == typeof e) {
                      const t = new Image();
                      return (
                        (t.onload = () => {
                          const e = yt(t, n, r);
                          console.log(...e);
                        }),
                        (t.src = e),
                        vt
                      );
                    }
                    const s = e.nodeName || '';
                    if ('img' === s.toLowerCase())
                      return console.log(...yt(e, n, r)), vt;
                    if ('canvas' === s.toLowerCase()) {
                      const t = new Image();
                      return (
                        (t.onload = () => console.log(...yt(t, n, r))),
                        (t.src = e.toDataURL()),
                        vt
                      );
                    }
                    return vt;
                  })({ image: r, message: s, scale: i })
                : (console.warn('removed'), vt)
              : vt;
          }
          time(t, e) {
            return this._getLogFunction(
              t,
              e,
              console.time ? console.time : console.info
            );
          }
          timeEnd(t, e) {
            return this._getLogFunction(
              t,
              e,
              console.timeEnd ? console.timeEnd : console.info
            );
          }
          timeStamp(t, e) {
            return this._getLogFunction(t, e, console.timeStamp || vt);
          }
          group(t, e) {
            let n =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : { collapsed: !1 };
            const r = Ft({ logLevel: t, message: e, opts: n }),
              { collapsed: s } = n;
            return (
              (r.method =
                (s ? console.groupCollapsed : console.group) || console.info),
              this._getLogFunction(r)
            );
          }
          groupCollapsed(t, e) {
            let n =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {};
            return this.group(t, e, Object.assign({}, n, { collapsed: !0 }));
          }
          groupEnd(t) {
            return this._getLogFunction(t, '', console.groupEnd || vt);
          }
          withGroup(t, e, n) {
            this.group(t, e)();
            try {
              n();
            } finally {
              this.groupEnd(t)();
            }
          }
          trace() {
            console.trace && console.trace();
          }
          _shouldLog(t) {
            return this.isEnabled() && this.getLevel() >= xt(t);
          }
          _getLogFunction(t, e, n, r, s) {
            if (this._shouldLog(t)) {
              (s = Ft({ logLevel: t, message: e, args: r, opts: s })),
                Ct((n = n || s.method)),
                (s.total = this.getTotal()),
                (s.delta = this.getDelta()),
                (this._deltaTs = wt());
              const i = s.tag || s.message;
              if (s.once && i) {
                if (_t[i]) return vt;
                _t[i] = wt();
              }
              return (
                (e = (function (t, e, n) {
                  if ('string' == typeof e) {
                    const r = n.time
                      ? (function (t) {
                          let e =
                            arguments.length > 1 && void 0 !== arguments[1]
                              ? arguments[1]
                              : 8;
                          const n = Math.max(e - t.length, 0);
                          return ''.concat(' '.repeat(n)).concat(t);
                        })(
                          (function (t) {
                            let e;
                            return (
                              (e =
                                t < 10
                                  ? ''.concat(t.toFixed(2), 'ms')
                                  : t < 100
                                  ? ''.concat(t.toFixed(1), 'ms')
                                  : t < 1e3
                                  ? ''.concat(t.toFixed(0), 'ms')
                                  : ''.concat((t / 1e3).toFixed(2), 's')),
                              e
                            );
                          })(n.total)
                        )
                      : '';
                    (e = n.time
                      ? ''.concat(t, ': ').concat(r, '  ').concat(e)
                      : ''.concat(t, ': ').concat(e)),
                      (e = (function (t, e, n) {
                        if (!ft && 'string' == typeof t) {
                          if (e) {
                            const n = bt(e);
                            t = '['.concat(n, 'm').concat(t, '[39m');
                          }
                          if (n) {
                            const e = bt(n);
                            t = '['.concat(e + 10, 'm').concat(t, '[49m');
                          }
                        }
                        return t;
                      })(e, n.color, n.background));
                  }
                  return e;
                })(this.id, s.message, s)),
                n.bind(console, e, ...s.args)
              );
            }
            return vt;
          }
        }
        function xt(t) {
          if (!t) return 0;
          let e;
          switch (typeof t) {
            case 'number':
              e = t;
              break;
            case 'object':
              e = t.logLevel || t.priority || 0;
              break;
            default:
              return 0;
          }
          return Ct(Number.isFinite(e) && e >= 0), e;
        }
        function Ft(t) {
          const { logLevel: e, message: n } = t;
          t.logLevel = xt(e);
          const r = t.args ? Array.from(t.args) : [];
          for (; r.length && r.shift() !== n; );
          switch (typeof e) {
            case 'string':
            case 'function':
              void 0 !== n && r.unshift(n), (t.message = e);
              break;
            case 'object':
              Object.assign(t, e);
          }
          'function' == typeof t.message && (t.message = t.message());
          const s = typeof t.message;
          return (
            Ct('string' === s || 'object' === s),
            Object.assign(t, { args: r }, t.opts)
          );
        }
        function Ot(t) {
          for (const e in t) for (const n in t[e]) return n || 'untitled';
          return 'empty';
        }
        It.VERSION = At;
        const Rt = new It({ id: '@probe.gl/log' }),
          St = new It({ id: 'loaders.gl' });
        class Dt {
          log() {
            return () => {};
          }
          info() {
            return () => {};
          }
          warn() {
            return () => {};
          }
          error() {
            return () => {};
          }
        }
        const Gt = {
            fetch: null,
            mimeType: void 0,
            nothrow: !1,
            log: new (class {
              constructor() {
                (this.console = void 0), (this.console = console);
              }
              log() {
                for (
                  var t = arguments.length, e = new Array(t), n = 0;
                  n < t;
                  n++
                )
                  e[n] = arguments[n];
                return this.console.log.bind(this.console, ...e);
              }
              info() {
                for (
                  var t = arguments.length, e = new Array(t), n = 0;
                  n < t;
                  n++
                )
                  e[n] = arguments[n];
                return this.console.info.bind(this.console, ...e);
              }
              warn() {
                for (
                  var t = arguments.length, e = new Array(t), n = 0;
                  n < t;
                  n++
                )
                  e[n] = arguments[n];
                return this.console.warn.bind(this.console, ...e);
              }
              error() {
                for (
                  var t = arguments.length, e = new Array(t), n = 0;
                  n < t;
                  n++
                )
                  e[n] = arguments[n];
                return this.console.error.bind(this.console, ...e);
              }
            })(),
            useLocalLibraries: !1,
            CDN: 'https://unpkg.com/@loaders.gl',
            worker: !0,
            maxConcurrency: 3,
            maxMobileConcurrency: 1,
            reuseWorkers: i,
            _nodeWorkers: !1,
            _workerType: '',
            limit: 0,
            _limitMB: 0,
            batchSize: 'auto',
            batchDebounceMs: 0,
            metadata: !1,
            transforms: []
          },
          Lt = {
            throws: 'nothrow',
            dataType: '(no longer used)',
            uri: 'baseUri',
            method: 'fetch.method',
            headers: 'fetch.headers',
            body: 'fetch.body',
            mode: 'fetch.mode',
            credentials: 'fetch.credentials',
            cache: 'fetch.cache',
            redirect: 'fetch.redirect',
            referrer: 'fetch.referrer',
            referrerPolicy: 'fetch.referrerPolicy',
            integrity: 'fetch.integrity',
            keepalive: 'fetch.keepalive',
            signal: 'fetch.signal'
          };
        function Ut() {
          globalThis.loaders = globalThis.loaders || {};
          const { loaders: t } = globalThis;
          return (t._state = t._state || {}), t._state;
        }
        function Nt() {
          const t = Ut();
          return (
            (t.globalOptions = t.globalOptions || { ...Gt }), t.globalOptions
          );
        }
        function Ht(t, e, n, r, s) {
          const i = e || 'Top level',
            o = e ? `${e}.` : '';
          for (const a in t) {
            const c = !e && $(t[a]),
              l = 'baseUri' === a && !e,
              h = 'workerUrl' === a && e;
            if (!(a in n) && !l && !h)
              if (a in r)
                St.warn(
                  `${i} loader option '${o}${a}' no longer supported, use '${r[a]}'`
                )();
              else if (!c) {
                const t = Pt(a, s);
                St.warn(`${i} loader option '${o}${a}' not recognized. ${t}`)();
              }
          }
        }
        function Pt(t, e) {
          const n = t.toLowerCase();
          let r = '';
          for (const s of e)
            for (const e in s.options) {
              if (t === e) return `Did you mean '${s.id}.${e}'?`;
              const i = e.toLowerCase();
              (n.startsWith(i) || i.startsWith(n)) &&
                (r = r || `Did you mean '${s.id}.${e}'?`);
            }
          return r;
        }
        function Jt(t, e) {
          for (const n in e)
            if (n in e) {
              const r = e[n];
              tt(r) && tt(t[n]) ? (t[n] = { ...t[n], ...e[n] }) : (t[n] = e[n]);
            }
        }
        function jt(t) {
          var e;
          return (
            !!t &&
            (Array.isArray(t) && (t = t[0]),
            Array.isArray(
              null === (e = t) || void 0 === e ? void 0 : e.extensions
            ))
          );
        }
        function kt(t) {
          var e, r;
          let s;
          return (
            n(t, 'null loader'),
            n(jt(t), 'invalid loader'),
            Array.isArray(t) &&
              ((s = t[1]),
              (t = t[0]),
              (t = { ...t, options: { ...t.options, ...s } })),
            ((null !== (e = t) && void 0 !== e && e.parseTextSync) ||
              (null !== (r = t) && void 0 !== r && r.parseText)) &&
              (t.text = !0),
            t.text || (t.binary = !0),
            t
          );
        }
        function Vt() {
          return (() => {
            const t = Ut();
            return (
              (t.loaderRegistry = t.loaderRegistry || []), t.loaderRegistry
            );
          })();
        }
        const Kt = new It({ id: 'loaders.gl' }),
          Qt = /\.([^.]+)$/;
        function qt(t) {
          let e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : [],
            n = arguments.length > 2 ? arguments[2] : void 0,
            r = arguments.length > 3 ? arguments[3] : void 0;
          if (!zt(t)) return null;
          if (e && !Array.isArray(e)) return kt(e);
          let s = [];
          e && (s = s.concat(e)),
            (null != n && n.ignoreRegisteredLoaders) || s.push(...Vt()),
            Yt(s);
          const i = Wt(t, s, n, r);
          if (!(i || (null != n && n.nothrow))) throw new Error(Xt(t));
          return i;
        }
        function Wt(t, e, n, r) {
          const s = lt(t),
            i = ht(t),
            o = ct(s) || (null == r ? void 0 : r.url);
          let a = null,
            c = '';
          var l;
          return (
            null != n &&
              n.mimeType &&
              ((a = Zt(e, null == n ? void 0 : n.mimeType)),
              (c = `match forced by supplied MIME type ${
                null == n ? void 0 : n.mimeType
              }`)),
            (a =
              a ||
              (function (t, e) {
                const n = e && Qt.exec(e),
                  r = n && n[1];
                return r
                  ? (function (t, e) {
                      e = e.toLowerCase();
                      for (const n of t)
                        for (const t of n.extensions)
                          if (t.toLowerCase() === e) return n;
                      return null;
                    })(t, r)
                  : null;
              })(e, o)),
            (c = c || (a ? `matched url ${o}` : '')),
            (a = a || Zt(e, i)),
            (c = c || (a ? `matched MIME type ${i}` : '')),
            (a =
              a ||
              (function (t, e) {
                if (!e) return null;
                for (const n of t)
                  if ('string' == typeof e) {
                    if ($t(e, n)) return n;
                  } else if (ArrayBuffer.isView(e)) {
                    if (te(e.buffer, e.byteOffset, n)) return n;
                  } else if (e instanceof ArrayBuffer && te(e, 0, n)) return n;
                return null;
              })(e, t)),
            (c = c || (a ? `matched initial data ${ee(t)}` : '')),
            null != n &&
              n.fallbackMimeType &&
              ((a = a || Zt(e, null == n ? void 0 : n.fallbackMimeType)),
              (c = c || (a ? `matched fallback MIME type ${i}` : ''))),
            c &&
              Kt.log(
                1,
                `selectLoader selected ${
                  null === (l = a) || void 0 === l ? void 0 : l.name
                }: ${c}.`
              ),
            a
          );
        }
        function zt(t) {
          return !(t instanceof Response && 204 === t.status);
        }
        function Xt(t) {
          const e = lt(t),
            n = ht(t);
          let r = 'No valid loader found (';
          (r += e ? `${W(e)}, ` : 'no url provided, '),
            (r += `MIME type: ${n ? `"${n}"` : 'not provided'}, `);
          const s = t ? ee(t) : '';
          return (
            (r += s ? ` first bytes: "${s}"` : 'first bytes: not available'),
            (r += ')'),
            r
          );
        }
        function Yt(t) {
          for (const e of t) kt(e);
        }
        function Zt(t, e) {
          for (const n of t)
            if (
              (n.mimeTypes && n.mimeTypes.includes(e)) ||
              e === `application/x.${n.id}`
            )
              return n;
          return null;
        }
        function $t(t, e) {
          return e.testText
            ? e.testText(t)
            : (Array.isArray(e.tests) ? e.tests : [e.tests]).some((e) =>
                t.startsWith(e)
              );
        }
        function te(t, e, n) {
          return (Array.isArray(n.tests) ? n.tests : [n.tests]).some((n) =>
            (function (t, e, n, r) {
              if (r instanceof ArrayBuffer)
                return (function (t, e, n) {
                  if (
                    ((n = n || t.byteLength),
                    t.byteLength < n || e.byteLength < n)
                  )
                    return !1;
                  const r = new Uint8Array(t),
                    s = new Uint8Array(e);
                  for (let t = 0; t < r.length; ++t)
                    if (r[t] !== s[t]) return !1;
                  return !0;
                })(r, t, r.byteLength);
              switch (typeof r) {
                case 'function':
                  return r(t);
                case 'string':
                  return r === ne(t, e, r.length);
                default:
                  return !1;
              }
            })(t, e, 0, n)
          );
        }
        function ee(t) {
          let e =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5;
          return 'string' == typeof t
            ? t.slice(0, e)
            : ArrayBuffer.isView(t)
            ? ne(t.buffer, t.byteOffset, e)
            : t instanceof ArrayBuffer
            ? ne(t, 0, e)
            : '';
        }
        function ne(t, e, n) {
          if (t.byteLength < e + n) return '';
          const r = new DataView(t);
          let s = '';
          for (let t = 0; t < n; t++)
            s += String.fromCharCode(r.getUint8(e + t));
          return s;
        }
        const re = 262144;
        function se(t, e) {
          return i
            ? (async function* (t, e) {
                const n = t.getReader();
                let r;
                try {
                  for (;;) {
                    const t = r || n.read();
                    null != e && e._streamReadAhead && (r = n.read());
                    const { done: s, value: i } = await t;
                    if (s) return;
                    yield Q(i);
                  }
                } catch {
                  n.releaseLock();
                }
              })(t, e)
            : (async function* (t, e) {
                for await (const e of t) yield Q(e);
              })(t);
        }
        const ie = 'Cannot convert supplied data type';
        async function oe(t, e, n) {
          const r = t instanceof ArrayBuffer || ArrayBuffer.isView(t);
          if ('string' == typeof t || r)
            return (function (t, e, n) {
              if (e.text && 'string' == typeof t) return t;
              if (
                (((t) => t && 'object' == typeof t && t.isBuffer)(t) &&
                  (t = t.buffer),
                t instanceof ArrayBuffer)
              ) {
                const n = t;
                return e.text && !e.binary
                  ? new TextDecoder('utf8').decode(n)
                  : n;
              }
              if (ArrayBuffer.isView(t)) {
                if (e.text && !e.binary)
                  return new TextDecoder('utf8').decode(t);
                let n = t.buffer;
                const r = t.byteLength || t.length;
                return (
                  (0 !== t.byteOffset || r !== n.byteLength) &&
                    (n = n.slice(t.byteOffset, t.byteOffset + r)),
                  n
                );
              }
              throw new Error(ie);
            })(t, e);
          if ((nt(t) && (t = await ut(t)), et(t))) {
            const n = t;
            return (
              await (async function (t) {
                if (!t.ok) {
                  const e = await (async function (t) {
                    let e = `Failed to fetch resource ${t.url} (${t.status}): `;
                    try {
                      const n = t.headers.get('Content-Type');
                      let r = t.statusText;
                      null != n &&
                        n.includes('application/json') &&
                        (r += ` ${await t.text()}`),
                        (e += r),
                        (e = e.length > 60 ? `${e.slice(0, 60)}...` : e);
                    } catch {}
                    return e;
                  })(t);
                  throw new Error(e);
                }
              })(n),
              e.binary ? await n.arrayBuffer() : await n.text()
            );
          }
          if (
            (rt(t) &&
              (t = (function (t, e) {
                if ('string' == typeof t)
                  return (function* (t, e) {
                    const n = (null == e ? void 0 : e.chunkSize) || 262144;
                    let r = 0;
                    const s = new TextEncoder();
                    for (; r < t.length; ) {
                      const e = Math.min(t.length - r, n),
                        i = t.slice(r, r + e);
                      (r += e), yield s.encode(i);
                    }
                  })(t, e);
                if (t instanceof ArrayBuffer)
                  return (function (t) {
                    let e =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : {};
                    return (function* () {
                      const { chunkSize: n = re } = e;
                      let r = 0;
                      for (; r < t.byteLength; ) {
                        const e = Math.min(t.byteLength - r, n),
                          s = new ArrayBuffer(e),
                          i = new Uint8Array(t, r, e);
                        new Uint8Array(s).set(i), (r += e), yield s;
                      }
                    })();
                  })(t, e);
                if (nt(t))
                  return (async function* (t, e) {
                    const n = (null == e ? void 0 : e.chunkSize) || 1048576;
                    let r = 0;
                    for (; r < t.size; ) {
                      const e = r + n,
                        s = await t.slice(r, e).arrayBuffer();
                      (r = e), yield s;
                    }
                  })(t, e);
                if (rt(t)) return se(t, e);
                if (et(t)) return se(t.body, e);
                throw new Error('makeIterator');
              })(t, n)),
            ((t) => !!t && 'function' == typeof t[Symbol.iterator])(t) ||
              ((t) => t && 'function' == typeof t[Symbol.asyncIterator])(t))
          )
            return (async function (t) {
              const e = [];
              for await (const n of t) e.push(n);
              return (function () {
                for (
                  var t = arguments.length, e = new Array(t), n = 0;
                  n < t;
                  n++
                )
                  e[n] = arguments[n];
                return L(e);
              })(...e);
            })(t);
          throw new Error(ie);
        }
        function ae(t, e) {
          const n = Nt(),
            r = t || n;
          return 'function' == typeof r.fetch
            ? r.fetch
            : $(r.fetch)
            ? (t) => dt(t, r.fetch)
            : null != e && e.fetch
            ? null == e
              ? void 0
              : e.fetch
            : dt;
        }
        async function ce(t, e, n, r) {
          e &&
            !Array.isArray(e) &&
            !jt(e) &&
            ((r = void 0), (n = e), (e = void 0)),
            (n = n || {});
          const s = lt((t = await t)),
            i = (function (t, e) {
              if (t && !Array.isArray(t)) return t;
              let n;
              if ((t && (n = Array.isArray(t) ? t : [t]), e && e.loaders)) {
                const t = Array.isArray(e.loaders) ? e.loaders : [e.loaders];
                n = n ? [...n, ...t] : t;
              }
              return n && n.length ? n : void 0;
            })(e, r),
            o = await (async function (t) {
              let e =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : [],
                n = arguments.length > 2 ? arguments[2] : void 0,
                r = arguments.length > 3 ? arguments[3] : void 0;
              if (!zt(t)) return null;
              let s = qt(t, e, { ...n, nothrow: !0 }, r);
              if (s) return s;
              if (
                (nt(t) &&
                  (s = qt((t = await t.slice(0, 10).arrayBuffer()), e, n, r)),
                !(s || (null != n && n.nothrow)))
              )
                throw new Error(Xt(t));
              return s;
            })(t, i, n);
          return o
            ? ((r = (function (t, e, n) {
                if (n) return n;
                const r = { fetch: ae(e, t), ...t };
                if (r.url) {
                  const t = ct(r.url);
                  (r.baseUrl = t),
                    (r.queryString = (function (t) {
                      const e = t.match(at);
                      return e && e[0];
                    })(r.url)),
                    (r.filename = W(t)),
                    (r.baseUrl = z(t));
                }
                return Array.isArray(r.loaders) || (r.loaders = null), r;
              })(
                { url: s, _parse: ce, loaders: i },
                (n = (function (t, e, n, r) {
                  return (
                    (n = n || []),
                    (function (t, e) {
                      Ht(t, null, Gt, Lt, e);
                      for (const n of e) {
                        const r = (t && t[n.id]) || {},
                          s = (n.options && n.options[n.id]) || {},
                          i =
                            (n.deprecatedOptions &&
                              n.deprecatedOptions[n.id]) ||
                            {};
                        Ht(r, n.id, s, i, e);
                      }
                    })(t, (n = Array.isArray(n) ? n : [n])),
                    (function (t, e, n) {
                      const r = { ...(t.options || {}) };
                      return (
                        (function (t, e) {
                          e && !('baseUri' in t) && (t.baseUri = e);
                        })(r, n),
                        null === r.log && (r.log = new Dt()),
                        Jt(r, Nt()),
                        Jt(r, e),
                        r
                      );
                    })(e, t, r)
                  );
                })(n, o, i, s)),
                r || null
              )),
              await (async function (t, e, n, r) {
                if (
                  ((function (t) {
                    d(t, 'no worker provided');
                    t.version;
                  })(t),
                  (n = a(t.options, n)),
                  et(e))
                ) {
                  const t = e,
                    {
                      ok: n,
                      redirected: s,
                      status: i,
                      statusText: o,
                      type: a,
                      url: c
                    } = t,
                    l = Object.fromEntries(t.headers.entries());
                  r.response = {
                    headers: l,
                    ok: n,
                    redirected: s,
                    status: i,
                    statusText: o,
                    type: a,
                    url: c
                  };
                }
                e = await oe(e, t, n);
                const s = t;
                if (s.parseTextSync && 'string' == typeof e)
                  return s.parseTextSync(e, n, r);
                if (
                  (function (t, e) {
                    return (
                      !(
                        !M.isSupported() ||
                        !(f || (null != e && e._nodeWorkers))
                      ) &&
                      t.worker &&
                      (null == e ? void 0 : e.worker)
                    );
                  })(t, n)
                )
                  return await S(t, e, n, r, ce);
                if (s.parseText && 'string' == typeof e)
                  return await s.parseText(e, n, r);
                if (s.parse) return await s.parse(e, n, r);
                throw (
                  (d(!s.parseSync),
                  new Error(
                    `${t.id} loader - no parser found and worker is disabled`
                  ))
                );
              })(o, t, n, r))
            : null;
        }
        async function le(t, e, n, r) {
          let s, i;
          Array.isArray(e) || jt(e) ? ((s = e), (i = n)) : ((s = []), (i = e));
          const o = ae(i);
          let a = t;
          return (
            'string' == typeof t && (a = await o(t)),
            nt(t) && (a = await o(t)),
            Array.isArray(s),
            await ce(a, s, i)
          );
        }
        const he = (1 / Math.PI) * 180,
          ue = (1 / 180) * Math.PI;
        globalThis.mathgl = globalThis.mathgl || {
          config: {
            EPSILON: 1e-12,
            debug: !1,
            precision: 4,
            printTypes: !1,
            printDegrees: !1,
            printRowMajor: !0,
            _cartographicRadians: !1
          }
        };
        const de = globalThis.mathgl.config;
        function fe(t, { precision: e = de.precision } = {}) {
          return (
            (t = (function (t) {
              return Math.round(t / de.EPSILON) * de.EPSILON;
            })(t)),
            ''.concat(parseFloat(t.toPrecision(e)))
          );
        }
        function me(t) {
          return (
            Array.isArray(t) ||
            (ArrayBuffer.isView(t) && !(t instanceof DataView))
          );
        }
        function ge(t) {
          return (function (t, e) {
            return be(t, (t) => t * ue, void 0);
          })(t);
        }
        function Ae(t) {
          return pe(t);
        }
        function pe(t, e) {
          return be(t, (t) => t * he, e);
        }
        function ye(t, e, n) {
          return be(t, (t) => Math.max(e, Math.min(n, t)));
        }
        function Be(t, e, n) {
          const r = de.EPSILON;
          n && (de.EPSILON = n);
          try {
            if (t === e) return !0;
            if (me(t) && me(e)) {
              if (t.length !== e.length) return !1;
              for (let n = 0; n < t.length; ++n) if (!Be(t[n], e[n])) return !1;
              return !0;
            }
            return t && t.equals
              ? t.equals(e)
              : e && e.equals
              ? e.equals(t)
              : 'number' == typeof t &&
                'number' == typeof e &&
                Math.abs(t - e) <=
                  de.EPSILON * Math.max(1, Math.abs(t), Math.abs(e));
          } finally {
            de.EPSILON = r;
          }
        }
        function be(t, e, n) {
          if (me(t)) {
            const r = t;
            n =
              n ||
              (function (t) {
                return t.clone ? t.clone() : new Array(t.length);
              })(r);
            for (let s = 0; s < n.length && s < r.length; ++s) {
              const r = 'number' == typeof t ? t : t[s];
              n[s] = e(r, s, n);
            }
            return n;
          }
          return e(t);
        }
        class Ce extends (function (t) {
          function e() {
            var e = Reflect.construct(t, Array.from(arguments));
            return Object.setPrototypeOf(e, Object.getPrototypeOf(this)), e;
          }
          return (
            (e.prototype = Object.create(t.prototype, {
              constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0
              }
            })),
            Object.setPrototypeOf
              ? Object.setPrototypeOf(e, t)
              : (e.__proto__ = t),
            e
          );
        })(Array) {
          clone() {
            return new this.constructor().copy(this);
          }
          fromArray(t, e = 0) {
            for (let n = 0; n < this.ELEMENTS; ++n) this[n] = t[n + e];
            return this.check();
          }
          toArray(t = [], e = 0) {
            for (let n = 0; n < this.ELEMENTS; ++n) t[e + n] = this[n];
            return t;
          }
          toObject(t) {
            return t;
          }
          from(t) {
            return Array.isArray(t) ? this.copy(t) : this.fromObject(t);
          }
          to(t) {
            return t === this
              ? this
              : me(t)
              ? this.toArray(t)
              : this.toObject(t);
          }
          toTarget(t) {
            return t ? this.to(t) : this;
          }
          toFloat32Array() {
            return new Float32Array(this);
          }
          toString() {
            return this.formatString(de);
          }
          formatString(t) {
            let e = '';
            for (let n = 0; n < this.ELEMENTS; ++n)
              e += (n > 0 ? ', ' : '') + fe(this[n], t);
            return ''
              .concat(t.printTypes ? this.constructor.name : '', '[')
              .concat(e, ']');
          }
          equals(t) {
            if (!t || this.length !== t.length) return !1;
            for (let e = 0; e < this.ELEMENTS; ++e)
              if (!Be(this[e], t[e])) return !1;
            return !0;
          }
          exactEquals(t) {
            if (!t || this.length !== t.length) return !1;
            for (let e = 0; e < this.ELEMENTS; ++e)
              if (this[e] !== t[e]) return !1;
            return !0;
          }
          negate() {
            for (let t = 0; t < this.ELEMENTS; ++t) this[t] = -this[t];
            return this.check();
          }
          lerp(t, e, n) {
            if (void 0 === n) return this.lerp(this, t, e);
            for (let r = 0; r < this.ELEMENTS; ++r) {
              const s = t[r],
                i = 'number' == typeof e ? e : e[r];
              this[r] = s + n * (i - s);
            }
            return this.check();
          }
          min(t) {
            for (let e = 0; e < this.ELEMENTS; ++e)
              this[e] = Math.min(t[e], this[e]);
            return this.check();
          }
          max(t) {
            for (let e = 0; e < this.ELEMENTS; ++e)
              this[e] = Math.max(t[e], this[e]);
            return this.check();
          }
          clamp(t, e) {
            for (let n = 0; n < this.ELEMENTS; ++n)
              this[n] = Math.min(Math.max(this[n], t[n]), e[n]);
            return this.check();
          }
          add(...t) {
            for (const e of t)
              for (let t = 0; t < this.ELEMENTS; ++t) this[t] += e[t];
            return this.check();
          }
          subtract(...t) {
            for (const e of t)
              for (let t = 0; t < this.ELEMENTS; ++t) this[t] -= e[t];
            return this.check();
          }
          scale(t) {
            if ('number' == typeof t)
              for (let e = 0; e < this.ELEMENTS; ++e) this[e] *= t;
            else
              for (let e = 0; e < this.ELEMENTS && e < t.length; ++e)
                this[e] *= t[e];
            return this.check();
          }
          multiplyByScalar(t) {
            for (let e = 0; e < this.ELEMENTS; ++e) this[e] *= t;
            return this.check();
          }
          check() {
            if (de.debug && !this.validate())
              throw new Error(
                'math.gl: '.concat(
                  this.constructor.name,
                  " some fields set to invalid numbers'"
                )
              );
            return this;
          }
          validate() {
            let t = this.length === this.ELEMENTS;
            for (let e = 0; e < this.ELEMENTS; ++e)
              t = t && Number.isFinite(this[e]);
            return t;
          }
          sub(t) {
            return this.subtract(t);
          }
          setScalar(t) {
            for (let e = 0; e < this.ELEMENTS; ++e) this[e] = t;
            return this.check();
          }
          addScalar(t) {
            for (let e = 0; e < this.ELEMENTS; ++e) this[e] += t;
            return this.check();
          }
          subScalar(t) {
            return this.addScalar(-t);
          }
          multiplyScalar(t) {
            for (let e = 0; e < this.ELEMENTS; ++e) this[e] *= t;
            return this.check();
          }
          divideScalar(t) {
            return this.multiplyByScalar(1 / t);
          }
          clampScalar(t, e) {
            for (let n = 0; n < this.ELEMENTS; ++n)
              this[n] = Math.min(Math.max(this[n], t), e);
            return this.check();
          }
          get elements() {
            return this;
          }
        }
        function we(t) {
          if (!Number.isFinite(t))
            throw new Error('Invalid number '.concat(JSON.stringify(t)));
          return t;
        }
        function Ee(t, e, n = '') {
          if (
            de.debug &&
            !(function (t, e) {
              if (t.length !== e) return !1;
              for (let e = 0; e < t.length; ++e)
                if (!Number.isFinite(t[e])) return !1;
              return !0;
            })(t, e)
          )
            throw new Error(
              'math.gl: '.concat(n, " some fields set to invalid numbers'")
            );
          return t;
        }
        function Te(t, e) {
          if (!t) throw new Error('math.gl assertion '.concat(e));
        }
        class ve extends Ce {
          get x() {
            return this[0];
          }
          set x(t) {
            this[0] = we(t);
          }
          get y() {
            return this[1];
          }
          set y(t) {
            this[1] = we(t);
          }
          len() {
            return Math.sqrt(this.lengthSquared());
          }
          magnitude() {
            return this.len();
          }
          lengthSquared() {
            let t = 0;
            for (let e = 0; e < this.ELEMENTS; ++e) t += this[e] * this[e];
            return t;
          }
          magnitudeSquared() {
            return this.lengthSquared();
          }
          distance(t) {
            return Math.sqrt(this.distanceSquared(t));
          }
          distanceSquared(t) {
            let e = 0;
            for (let n = 0; n < this.ELEMENTS; ++n) {
              const r = this[n] - t[n];
              e += r * r;
            }
            return we(e);
          }
          dot(t) {
            let e = 0;
            for (let n = 0; n < this.ELEMENTS; ++n) e += this[n] * t[n];
            return we(e);
          }
          normalize() {
            const t = this.magnitude();
            if (0 !== t) for (let e = 0; e < this.ELEMENTS; ++e) this[e] /= t;
            return this.check();
          }
          multiply(...t) {
            for (const e of t)
              for (let t = 0; t < this.ELEMENTS; ++t) this[t] *= e[t];
            return this.check();
          }
          divide(...t) {
            for (const e of t)
              for (let t = 0; t < this.ELEMENTS; ++t) this[t] /= e[t];
            return this.check();
          }
          lengthSq() {
            return this.lengthSquared();
          }
          distanceTo(t) {
            return this.distance(t);
          }
          distanceToSquared(t) {
            return this.distanceSquared(t);
          }
          getComponent(t) {
            return (
              Te(t >= 0 && t < this.ELEMENTS, 'index is out of range'),
              we(this[t])
            );
          }
          setComponent(t, e) {
            return (
              Te(t >= 0 && t < this.ELEMENTS, 'index is out of range'),
              (this[t] = e),
              this.check()
            );
          }
          addVectors(t, e) {
            return this.copy(t).add(e);
          }
          subVectors(t, e) {
            return this.copy(t).subtract(e);
          }
          multiplyVectors(t, e) {
            return this.copy(t).multiply(e);
          }
          addScaledVector(t, e) {
            return this.add(new this.constructor(t).multiplyScalar(e));
          }
        }
        const _e = 1e-6;
        let Me = typeof Float32Array < 'u' ? Float32Array : Array;
        function Ie(t, e, n) {
          const r = e[0],
            s = e[1];
          return (
            (t[0] = n[0] * r + n[3] * s + n[6]),
            (t[1] = n[1] * r + n[4] * s + n[7]),
            t
          );
        }
        function xe(t, e, n) {
          const r = e[0],
            s = e[1];
          return (
            (t[0] = n[0] * r + n[4] * s + n[12]),
            (t[1] = n[1] * r + n[5] * s + n[13]),
            t
          );
        }
        function Fe(t, e, n) {
          const r = e[0],
            s = e[1],
            i = n[3] * r + n[7] * s || 1;
          return (
            (t[0] = (n[0] * r + n[4] * s) / i),
            (t[1] = (n[1] * r + n[5] * s) / i),
            t
          );
        }
        function Oe(t, e, n) {
          const r = e[0],
            s = e[1],
            i = e[2],
            o = n[3] * r + n[7] * s + n[11] * i || 1;
          return (
            (t[0] = (n[0] * r + n[4] * s + n[8] * i) / o),
            (t[1] = (n[1] * r + n[5] * s + n[9] * i) / o),
            (t[2] = (n[2] * r + n[6] * s + n[10] * i) / o),
            t
          );
        }
        function Re(t, e, n) {
          const r = e[0],
            s = e[1],
            i = e[2];
          return (
            (t[0] = n[0] * r + n[3] * s + n[6] * i),
            (t[1] = n[1] * r + n[4] * s + n[7] * i),
            (t[2] = n[2] * r + n[5] * s + n[8] * i),
            (t[3] = e[3]),
            t
          );
        }
        !(function () {
          const t = new Me(2);
          Me != Float32Array && ((t[0] = 0), (t[1] = 0));
        })();
        class Se extends ve {
          constructor(t = 0, e = 0) {
            super(2),
              me(t) && 1 === arguments.length
                ? this.copy(t)
                : (de.debug && (we(t), we(e)), (this[0] = t), (this[1] = e));
          }
          set(t, e) {
            return (this[0] = t), (this[1] = e), this.check();
          }
          copy(t) {
            return (this[0] = t[0]), (this[1] = t[1]), this.check();
          }
          fromObject(t) {
            return (
              de.debug && (we(t.x), we(t.y)),
              (this[0] = t.x),
              (this[1] = t.y),
              this.check()
            );
          }
          toObject(t) {
            return (t.x = this[0]), (t.y = this[1]), t;
          }
          get ELEMENTS() {
            return 2;
          }
          horizontalAngle() {
            return Math.atan2(this.y, this.x);
          }
          verticalAngle() {
            return Math.atan2(this.x, this.y);
          }
          transform(t) {
            return this.transformAsPoint(t);
          }
          transformAsPoint(t) {
            return xe(this, this, t), this.check();
          }
          transformAsVector(t) {
            return Fe(this, this, t), this.check();
          }
          transformByMatrix3(t) {
            return Ie(this, this, t), this.check();
          }
          transformByMatrix2x3(t) {
            return (
              (function (t, e, n) {
                const r = e[0],
                  s = e[1];
                (t[0] = n[0] * r + n[2] * s + n[4]),
                  (t[1] = n[1] * r + n[3] * s + n[5]);
              })(this, this, t),
              this.check()
            );
          }
          transformByMatrix2(t) {
            return (
              (function (t, e, n) {
                const r = e[0],
                  s = e[1];
                (t[0] = n[0] * r + n[2] * s), (t[1] = n[1] * r + n[3] * s);
              })(this, this, t),
              this.check()
            );
          }
        }
        function De() {
          const t = new Me(3);
          return Me != Float32Array && ((t[0] = 0), (t[1] = 0), (t[2] = 0)), t;
        }
        function Ge(t) {
          const e = t[0],
            n = t[1],
            r = t[2];
          return Math.sqrt(e * e + n * n + r * r);
        }
        function Le(t, e, n) {
          const r = new Me(3);
          return (r[0] = t), (r[1] = e), (r[2] = n), r;
        }
        function Ue(t, e) {
          return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
        }
        function Ne(t, e, n) {
          const r = e[0],
            s = e[1],
            i = e[2],
            o = n[0],
            a = n[1],
            c = n[2];
          return (
            (t[0] = s * c - i * a),
            (t[1] = i * o - r * c),
            (t[2] = r * a - s * o),
            t
          );
        }
        function He(t, e, n) {
          const r = e[0],
            s = e[1],
            i = e[2];
          let o = n[3] * r + n[7] * s + n[11] * i + n[15];
          return (
            (o = o || 1),
            (t[0] = (n[0] * r + n[4] * s + n[8] * i + n[12]) / o),
            (t[1] = (n[1] * r + n[5] * s + n[9] * i + n[13]) / o),
            (t[2] = (n[2] * r + n[6] * s + n[10] * i + n[14]) / o),
            t
          );
        }
        function Pe(t, e, n) {
          const r = e[0],
            s = e[1],
            i = e[2];
          return (
            (t[0] = r * n[0] + s * n[3] + i * n[6]),
            (t[1] = r * n[1] + s * n[4] + i * n[7]),
            (t[2] = r * n[2] + s * n[5] + i * n[8]),
            t
          );
        }
        function Je(t, e, n) {
          const r = n[0],
            s = n[1],
            i = n[2],
            o = n[3],
            a = e[0],
            c = e[1],
            l = e[2];
          let h = s * l - i * c,
            u = i * a - r * l,
            d = r * c - s * a,
            f = s * d - i * u,
            m = i * h - r * d,
            g = r * u - s * h;
          const A = 2 * o;
          return (
            (h *= A),
            (u *= A),
            (d *= A),
            (f *= 2),
            (m *= 2),
            (g *= 2),
            (t[0] = a + h + f),
            (t[1] = c + u + m),
            (t[2] = l + d + g),
            t
          );
        }
        const je = Ge;
        De();
        const ke = [0, 0, 0];
        let Ve, Ke;
        class Qe extends ve {
          static get ZERO() {
            return Ve || ((Ve = new Qe(0, 0, 0)), Object.freeze(Ve)), Ve;
          }
          constructor(t = 0, e = 0, n = 0) {
            super(-0, -0, -0),
              1 === arguments.length && me(t)
                ? this.copy(t)
                : (de.debug && (we(t), we(e), we(n)),
                  (this[0] = t),
                  (this[1] = e),
                  (this[2] = n));
          }
          set(t, e, n) {
            return (this[0] = t), (this[1] = e), (this[2] = n), this.check();
          }
          copy(t) {
            return (
              (this[0] = t[0]), (this[1] = t[1]), (this[2] = t[2]), this.check()
            );
          }
          fromObject(t) {
            return (
              de.debug && (we(t.x), we(t.y), we(t.z)),
              (this[0] = t.x),
              (this[1] = t.y),
              (this[2] = t.z),
              this.check()
            );
          }
          toObject(t) {
            return (t.x = this[0]), (t.y = this[1]), (t.z = this[2]), t;
          }
          get ELEMENTS() {
            return 3;
          }
          get z() {
            return this[2];
          }
          set z(t) {
            this[2] = we(t);
          }
          angle(t) {
            return (function (t, e) {
              const n = t[0],
                r = t[1],
                s = t[2],
                i = e[0],
                o = e[1],
                a = e[2],
                c = Math.sqrt(
                  (n * n + r * r + s * s) * (i * i + o * o + a * a)
                ),
                l = c && Ue(t, e) / c;
              return Math.acos(Math.min(Math.max(l, -1), 1));
            })(this, t);
          }
          cross(t) {
            return Ne(this, this, t), this.check();
          }
          rotateX({ radians: t, origin: e = ke }) {
            return (
              (function (t, e, n, r) {
                const s = [],
                  i = [];
                (s[0] = e[0] - n[0]),
                  (s[1] = e[1] - n[1]),
                  (s[2] = e[2] - n[2]),
                  (i[0] = s[0]),
                  (i[1] = s[1] * Math.cos(r) - s[2] * Math.sin(r)),
                  (i[2] = s[1] * Math.sin(r) + s[2] * Math.cos(r)),
                  (t[0] = i[0] + n[0]),
                  (t[1] = i[1] + n[1]),
                  (t[2] = i[2] + n[2]);
              })(this, this, e, t),
              this.check()
            );
          }
          rotateY({ radians: t, origin: e = ke }) {
            return (
              (function (t, e, n, r) {
                const s = [],
                  i = [];
                (s[0] = e[0] - n[0]),
                  (s[1] = e[1] - n[1]),
                  (s[2] = e[2] - n[2]),
                  (i[0] = s[2] * Math.sin(r) + s[0] * Math.cos(r)),
                  (i[1] = s[1]),
                  (i[2] = s[2] * Math.cos(r) - s[0] * Math.sin(r)),
                  (t[0] = i[0] + n[0]),
                  (t[1] = i[1] + n[1]),
                  (t[2] = i[2] + n[2]);
              })(this, this, e, t),
              this.check()
            );
          }
          rotateZ({ radians: t, origin: e = ke }) {
            return (
              (function (t, e, n, r) {
                const s = [],
                  i = [];
                (s[0] = e[0] - n[0]),
                  (s[1] = e[1] - n[1]),
                  (s[2] = e[2] - n[2]),
                  (i[0] = s[0] * Math.cos(r) - s[1] * Math.sin(r)),
                  (i[1] = s[0] * Math.sin(r) + s[1] * Math.cos(r)),
                  (i[2] = s[2]),
                  (t[0] = i[0] + n[0]),
                  (t[1] = i[1] + n[1]),
                  (t[2] = i[2] + n[2]);
              })(this, this, e, t),
              this.check()
            );
          }
          transform(t) {
            return this.transformAsPoint(t);
          }
          transformAsPoint(t) {
            return He(this, this, t), this.check();
          }
          transformAsVector(t) {
            return Oe(this, this, t), this.check();
          }
          transformByMatrix3(t) {
            return Pe(this, this, t), this.check();
          }
          transformByMatrix2(t) {
            return (
              (function (t, e, n) {
                const r = e[0],
                  s = e[1];
                (t[0] = n[0] * r + n[2] * s),
                  (t[1] = n[1] * r + n[3] * s),
                  (t[2] = e[2]);
              })(this, this, t),
              this.check()
            );
          }
          transformByQuaternion(t) {
            return Je(this, this, t), this.check();
          }
        }
        class qe extends ve {
          static get ZERO() {
            return Ke || ((Ke = new qe(0, 0, 0, 0)), Object.freeze(Ke)), Ke;
          }
          constructor(t = 0, e = 0, n = 0, r = 0) {
            super(-0, -0, -0, -0),
              me(t) && 1 === arguments.length
                ? this.copy(t)
                : (de.debug && (we(t), we(e), we(n), we(r)),
                  (this[0] = t),
                  (this[1] = e),
                  (this[2] = n),
                  (this[3] = r));
          }
          set(t, e, n, r) {
            return (
              (this[0] = t),
              (this[1] = e),
              (this[2] = n),
              (this[3] = r),
              this.check()
            );
          }
          copy(t) {
            return (
              (this[0] = t[0]),
              (this[1] = t[1]),
              (this[2] = t[2]),
              (this[3] = t[3]),
              this.check()
            );
          }
          fromObject(t) {
            return (
              de.debug && (we(t.x), we(t.y), we(t.z), we(t.w)),
              (this[0] = t.x),
              (this[1] = t.y),
              (this[2] = t.z),
              (this[3] = t.w),
              this
            );
          }
          toObject(t) {
            return (
              (t.x = this[0]),
              (t.y = this[1]),
              (t.z = this[2]),
              (t.w = this[3]),
              t
            );
          }
          get ELEMENTS() {
            return 4;
          }
          get z() {
            return this[2];
          }
          set z(t) {
            this[2] = we(t);
          }
          get w() {
            return this[3];
          }
          set w(t) {
            this[3] = we(t);
          }
          transform(t) {
            return He(this, this, t), this.check();
          }
          transformByMatrix3(t) {
            return Re(this, this, t), this.check();
          }
          transformByMatrix2(t) {
            return (
              (function (t, e, n) {
                const r = e[0],
                  s = e[1];
                (t[0] = n[0] * r + n[2] * s),
                  (t[1] = n[1] * r + n[3] * s),
                  (t[2] = e[2]),
                  (t[3] = e[3]);
              })(this, this, t),
              this.check()
            );
          }
          transformByQuaternion(t) {
            return Je(this, this, t), this.check();
          }
          applyMatrix4(t) {
            return t.transform(this, this), this;
          }
        }
        class We extends Ce {
          toString() {
            let t = '[';
            if (de.printRowMajor) {
              t += 'row-major:';
              for (let e = 0; e < this.RANK; ++e)
                for (let n = 0; n < this.RANK; ++n)
                  t += ' '.concat(this[n * this.RANK + e]);
            } else {
              t += 'column-major:';
              for (let e = 0; e < this.ELEMENTS; ++e) t += ' '.concat(this[e]);
            }
            return (t += ']'), t;
          }
          getElementIndex(t, e) {
            return e * this.RANK + t;
          }
          getElement(t, e) {
            return this[e * this.RANK + t];
          }
          setElement(t, e, n) {
            return (this[e * this.RANK + t] = we(n)), this;
          }
          getColumn(t, e = new Array(this.RANK).fill(-0)) {
            const n = t * this.RANK;
            for (let t = 0; t < this.RANK; ++t) e[t] = this[n + t];
            return e;
          }
          setColumn(t, e) {
            const n = t * this.RANK;
            for (let t = 0; t < this.RANK; ++t) this[n + t] = e[t];
            return this;
          }
        }
        function ze(t, e, n) {
          const r = e[0],
            s = e[1],
            i = e[2],
            o = e[3],
            a = e[4],
            c = e[5],
            l = e[6],
            h = e[7],
            u = e[8],
            d = n[0],
            f = n[1],
            m = n[2],
            g = n[3],
            A = n[4],
            p = n[5],
            y = n[6],
            B = n[7],
            b = n[8];
          return (
            (t[0] = d * r + f * o + m * l),
            (t[1] = d * s + f * a + m * h),
            (t[2] = d * i + f * c + m * u),
            (t[3] = g * r + A * o + p * l),
            (t[4] = g * s + A * a + p * h),
            (t[5] = g * i + A * c + p * u),
            (t[6] = y * r + B * o + b * l),
            (t[7] = y * s + B * a + b * h),
            (t[8] = y * i + B * c + b * u),
            t
          );
        }
        function Xe(t, e, n) {
          const r = n[0],
            s = n[1];
          return (
            (t[0] = r * e[0]),
            (t[1] = r * e[1]),
            (t[2] = r * e[2]),
            (t[3] = s * e[3]),
            (t[4] = s * e[4]),
            (t[5] = s * e[5]),
            (t[6] = e[6]),
            (t[7] = e[7]),
            (t[8] = e[8]),
            t
          );
        }
        var Ye;
        !(function (t) {
          (t[(t.COL0ROW0 = 0)] = 'COL0ROW0'),
            (t[(t.COL0ROW1 = 1)] = 'COL0ROW1'),
            (t[(t.COL0ROW2 = 2)] = 'COL0ROW2'),
            (t[(t.COL1ROW0 = 3)] = 'COL1ROW0'),
            (t[(t.COL1ROW1 = 4)] = 'COL1ROW1'),
            (t[(t.COL1ROW2 = 5)] = 'COL1ROW2'),
            (t[(t.COL2ROW0 = 6)] = 'COL2ROW0'),
            (t[(t.COL2ROW1 = 7)] = 'COL2ROW1'),
            (t[(t.COL2ROW2 = 8)] = 'COL2ROW2');
        })(Ye || (Ye = {}));
        const Ze = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        class $e extends We {
          static get IDENTITY() {
            return en || ((en = new $e()), Object.freeze(en)), en;
          }
          static get ZERO() {
            return (
              tn ||
                ((tn = new $e([0, 0, 0, 0, 0, 0, 0, 0, 0])), Object.freeze(tn)),
              tn
            );
          }
          get ELEMENTS() {
            return 9;
          }
          get RANK() {
            return 3;
          }
          get INDICES() {
            return Ye;
          }
          constructor(t, ...e) {
            super(-0, -0, -0, -0, -0, -0, -0, -0, -0),
              1 === arguments.length && Array.isArray(t)
                ? this.copy(t)
                : e.length > 0
                ? this.copy([t, ...e])
                : this.identity();
          }
          copy(t) {
            return (
              (this[0] = t[0]),
              (this[1] = t[1]),
              (this[2] = t[2]),
              (this[3] = t[3]),
              (this[4] = t[4]),
              (this[5] = t[5]),
              (this[6] = t[6]),
              (this[7] = t[7]),
              (this[8] = t[8]),
              this.check()
            );
          }
          identity() {
            return this.copy(Ze);
          }
          fromObject(t) {
            return this.check();
          }
          fromQuaternion(t) {
            return (
              (function (t, e) {
                const n = e[0],
                  r = e[1],
                  s = e[2],
                  i = e[3],
                  o = n + n,
                  a = r + r,
                  c = s + s,
                  l = n * o,
                  h = r * o,
                  u = r * a,
                  d = s * o,
                  f = s * a,
                  m = s * c,
                  g = i * o,
                  A = i * a,
                  p = i * c;
                (t[0] = 1 - u - m),
                  (t[3] = h - p),
                  (t[6] = d + A),
                  (t[1] = h + p),
                  (t[4] = 1 - l - m),
                  (t[7] = f - g),
                  (t[2] = d - A),
                  (t[5] = f + g),
                  (t[8] = 1 - l - u);
              })(this, t),
              this.check()
            );
          }
          set(t, e, n, r, s, i, o, a, c) {
            return (
              (this[0] = t),
              (this[1] = e),
              (this[2] = n),
              (this[3] = r),
              (this[4] = s),
              (this[5] = i),
              (this[6] = o),
              (this[7] = a),
              (this[8] = c),
              this.check()
            );
          }
          setRowMajor(t, e, n, r, s, i, o, a, c) {
            return (
              (this[0] = t),
              (this[1] = r),
              (this[2] = o),
              (this[3] = e),
              (this[4] = s),
              (this[5] = a),
              (this[6] = n),
              (this[7] = i),
              (this[8] = c),
              this.check()
            );
          }
          determinant() {
            return (function (t) {
              const e = t[0],
                n = t[1],
                r = t[2],
                s = t[3],
                i = t[4],
                o = t[5],
                a = t[6],
                c = t[7],
                l = t[8];
              return (
                e * (l * i - o * c) + n * (-l * s + o * a) + r * (c * s - i * a)
              );
            })(this);
          }
          transpose() {
            return (
              (function (t, e) {
                if (t === e) {
                  const n = e[1],
                    r = e[2],
                    s = e[5];
                  (t[1] = e[3]),
                    (t[2] = e[6]),
                    (t[3] = n),
                    (t[5] = e[7]),
                    (t[6] = r),
                    (t[7] = s);
                } else
                  (t[0] = e[0]),
                    (t[1] = e[3]),
                    (t[2] = e[6]),
                    (t[3] = e[1]),
                    (t[4] = e[4]),
                    (t[5] = e[7]),
                    (t[6] = e[2]),
                    (t[7] = e[5]),
                    (t[8] = e[8]);
              })(this, this),
              this.check()
            );
          }
          invert() {
            return (
              (function (t, e) {
                const n = e[0],
                  r = e[1],
                  s = e[2],
                  i = e[3],
                  o = e[4],
                  a = e[5],
                  c = e[6],
                  l = e[7],
                  h = e[8],
                  u = h * o - a * l,
                  d = -h * i + a * c,
                  f = l * i - o * c;
                let m = n * u + r * d + s * f;
                m &&
                  ((m = 1 / m),
                  (t[0] = u * m),
                  (t[1] = (-h * r + s * l) * m),
                  (t[2] = (a * r - s * o) * m),
                  (t[3] = d * m),
                  (t[4] = (h * n - s * c) * m),
                  (t[5] = (-a * n + s * i) * m),
                  (t[6] = f * m),
                  (t[7] = (-l * n + r * c) * m),
                  (t[8] = (o * n - r * i) * m));
              })(this, this),
              this.check()
            );
          }
          multiplyLeft(t) {
            return ze(this, t, this), this.check();
          }
          multiplyRight(t) {
            return ze(this, this, t), this.check();
          }
          rotate(t) {
            return (
              (function (t, e, n) {
                const r = e[0],
                  s = e[1],
                  i = e[2],
                  o = e[3],
                  a = e[4],
                  c = e[5],
                  l = e[6],
                  h = e[7],
                  u = e[8],
                  d = Math.sin(n),
                  f = Math.cos(n);
                (t[0] = f * r + d * o),
                  (t[1] = f * s + d * a),
                  (t[2] = f * i + d * c),
                  (t[3] = f * o - d * r),
                  (t[4] = f * a - d * s),
                  (t[5] = f * c - d * i),
                  (t[6] = l),
                  (t[7] = h),
                  (t[8] = u);
              })(this, this, t),
              this.check()
            );
          }
          scale(t) {
            return (
              Array.isArray(t) ? Xe(this, this, t) : Xe(this, this, [t, t]),
              this.check()
            );
          }
          translate(t) {
            return (
              (function (t, e, n) {
                const r = e[0],
                  s = e[1],
                  i = e[2],
                  o = e[3],
                  a = e[4],
                  c = e[5],
                  l = e[6],
                  h = e[7],
                  u = e[8],
                  d = n[0],
                  f = n[1];
                (t[0] = r),
                  (t[1] = s),
                  (t[2] = i),
                  (t[3] = o),
                  (t[4] = a),
                  (t[5] = c),
                  (t[6] = d * r + f * o + l),
                  (t[7] = d * s + f * a + h),
                  (t[8] = d * i + f * c + u);
              })(this, this, t),
              this.check()
            );
          }
          transform(t, e) {
            let n;
            switch (t.length) {
              case 2:
                n = Ie(e || [-0, -0], t, this);
                break;
              case 3:
                n = Pe(e || [-0, -0, -0], t, this);
                break;
              case 4:
                n = Re(e || [-0, -0, -0, -0], t, this);
                break;
              default:
                throw new Error('Illegal vector');
            }
            return Ee(n, t.length), n;
          }
          transformVector(t, e) {
            return this.transform(t, e);
          }
          transformVector2(t, e) {
            return this.transform(t, e);
          }
          transformVector3(t, e) {
            return this.transform(t, e);
          }
        }
        let tn,
          en = null;
        function nn(t, e, n) {
          const r = e[0],
            s = e[1],
            i = e[2],
            o = e[3],
            a = e[4],
            c = e[5],
            l = e[6],
            h = e[7],
            u = e[8],
            d = e[9],
            f = e[10],
            m = e[11],
            g = e[12],
            A = e[13],
            p = e[14],
            y = e[15];
          let B = n[0],
            b = n[1],
            C = n[2],
            w = n[3];
          return (
            (t[0] = B * r + b * a + C * u + w * g),
            (t[1] = B * s + b * c + C * d + w * A),
            (t[2] = B * i + b * l + C * f + w * p),
            (t[3] = B * o + b * h + C * m + w * y),
            (B = n[4]),
            (b = n[5]),
            (C = n[6]),
            (w = n[7]),
            (t[4] = B * r + b * a + C * u + w * g),
            (t[5] = B * s + b * c + C * d + w * A),
            (t[6] = B * i + b * l + C * f + w * p),
            (t[7] = B * o + b * h + C * m + w * y),
            (B = n[8]),
            (b = n[9]),
            (C = n[10]),
            (w = n[11]),
            (t[8] = B * r + b * a + C * u + w * g),
            (t[9] = B * s + b * c + C * d + w * A),
            (t[10] = B * i + b * l + C * f + w * p),
            (t[11] = B * o + b * h + C * m + w * y),
            (B = n[12]),
            (b = n[13]),
            (C = n[14]),
            (w = n[15]),
            (t[12] = B * r + b * a + C * u + w * g),
            (t[13] = B * s + b * c + C * d + w * A),
            (t[14] = B * i + b * l + C * f + w * p),
            (t[15] = B * o + b * h + C * m + w * y),
            t
          );
        }
        var rn;
        !(function () {
          const t = new Me(4);
          Me != Float32Array &&
            ((t[0] = 0), (t[1] = 0), (t[2] = 0), (t[3] = 0));
        })(),
          (function (t) {
            (t[(t.COL0ROW0 = 0)] = 'COL0ROW0'),
              (t[(t.COL0ROW1 = 1)] = 'COL0ROW1'),
              (t[(t.COL0ROW2 = 2)] = 'COL0ROW2'),
              (t[(t.COL0ROW3 = 3)] = 'COL0ROW3'),
              (t[(t.COL1ROW0 = 4)] = 'COL1ROW0'),
              (t[(t.COL1ROW1 = 5)] = 'COL1ROW1'),
              (t[(t.COL1ROW2 = 6)] = 'COL1ROW2'),
              (t[(t.COL1ROW3 = 7)] = 'COL1ROW3'),
              (t[(t.COL2ROW0 = 8)] = 'COL2ROW0'),
              (t[(t.COL2ROW1 = 9)] = 'COL2ROW1'),
              (t[(t.COL2ROW2 = 10)] = 'COL2ROW2'),
              (t[(t.COL2ROW3 = 11)] = 'COL2ROW3'),
              (t[(t.COL3ROW0 = 12)] = 'COL3ROW0'),
              (t[(t.COL3ROW1 = 13)] = 'COL3ROW1'),
              (t[(t.COL3ROW2 = 14)] = 'COL3ROW2'),
              (t[(t.COL3ROW3 = 15)] = 'COL3ROW3');
          })(rn || (rn = {}));
        const sn = (45 * Math.PI) / 180,
          on = 1,
          an = 0.1,
          cn = 500,
          ln = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        class hn extends We {
          static get IDENTITY() {
            return dn || ((dn = new hn()), Object.freeze(dn)), dn;
          }
          static get ZERO() {
            return (
              un ||
                ((un = new hn([
                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                ])),
                Object.freeze(un)),
              un
            );
          }
          get ELEMENTS() {
            return 16;
          }
          get RANK() {
            return 4;
          }
          get INDICES() {
            return rn;
          }
          constructor(t) {
            super(
              -0,
              -0,
              -0,
              -0,
              -0,
              -0,
              -0,
              -0,
              -0,
              -0,
              -0,
              -0,
              -0,
              -0,
              -0,
              -0
            ),
              1 === arguments.length && Array.isArray(t)
                ? this.copy(t)
                : this.identity();
          }
          copy(t) {
            return (
              (this[0] = t[0]),
              (this[1] = t[1]),
              (this[2] = t[2]),
              (this[3] = t[3]),
              (this[4] = t[4]),
              (this[5] = t[5]),
              (this[6] = t[6]),
              (this[7] = t[7]),
              (this[8] = t[8]),
              (this[9] = t[9]),
              (this[10] = t[10]),
              (this[11] = t[11]),
              (this[12] = t[12]),
              (this[13] = t[13]),
              (this[14] = t[14]),
              (this[15] = t[15]),
              this.check()
            );
          }
          set(t, e, n, r, s, i, o, a, c, l, h, u, d, f, m, g) {
            return (
              (this[0] = t),
              (this[1] = e),
              (this[2] = n),
              (this[3] = r),
              (this[4] = s),
              (this[5] = i),
              (this[6] = o),
              (this[7] = a),
              (this[8] = c),
              (this[9] = l),
              (this[10] = h),
              (this[11] = u),
              (this[12] = d),
              (this[13] = f),
              (this[14] = m),
              (this[15] = g),
              this.check()
            );
          }
          setRowMajor(t, e, n, r, s, i, o, a, c, l, h, u, d, f, m, g) {
            return (
              (this[0] = t),
              (this[1] = s),
              (this[2] = c),
              (this[3] = d),
              (this[4] = e),
              (this[5] = i),
              (this[6] = l),
              (this[7] = f),
              (this[8] = n),
              (this[9] = o),
              (this[10] = h),
              (this[11] = m),
              (this[12] = r),
              (this[13] = a),
              (this[14] = u),
              (this[15] = g),
              this.check()
            );
          }
          toRowMajor(t) {
            return (
              (t[0] = this[0]),
              (t[1] = this[4]),
              (t[2] = this[8]),
              (t[3] = this[12]),
              (t[4] = this[1]),
              (t[5] = this[5]),
              (t[6] = this[9]),
              (t[7] = this[13]),
              (t[8] = this[2]),
              (t[9] = this[6]),
              (t[10] = this[10]),
              (t[11] = this[14]),
              (t[12] = this[3]),
              (t[13] = this[7]),
              (t[14] = this[11]),
              (t[15] = this[15]),
              t
            );
          }
          identity() {
            return this.copy(ln);
          }
          fromObject(t) {
            return this.check();
          }
          fromQuaternion(t) {
            return (
              (function (t, e) {
                const n = e[0],
                  r = e[1],
                  s = e[2],
                  i = e[3],
                  o = n + n,
                  a = r + r,
                  c = s + s,
                  l = n * o,
                  h = r * o,
                  u = r * a,
                  d = s * o,
                  f = s * a,
                  m = s * c,
                  g = i * o,
                  A = i * a,
                  p = i * c;
                (t[0] = 1 - u - m),
                  (t[1] = h + p),
                  (t[2] = d - A),
                  (t[3] = 0),
                  (t[4] = h - p),
                  (t[5] = 1 - l - m),
                  (t[6] = f + g),
                  (t[7] = 0),
                  (t[8] = d + A),
                  (t[9] = f - g),
                  (t[10] = 1 - l - u),
                  (t[11] = 0),
                  (t[12] = 0),
                  (t[13] = 0),
                  (t[14] = 0),
                  (t[15] = 1);
              })(this, t),
              this.check()
            );
          }
          frustum(t) {
            const {
              left: e,
              right: n,
              bottom: r,
              top: s,
              near: i = an,
              far: o = cn
            } = t;
            return (
              o === 1 / 0
                ? (function (t, e, n, r, s, i) {
                    const o = (2 * i) / (n - e),
                      a = (2 * i) / (s - r),
                      c = (n + e) / (n - e),
                      l = (s + r) / (s - r),
                      h = -2 * i;
                    (t[0] = o),
                      (t[1] = 0),
                      (t[2] = 0),
                      (t[3] = 0),
                      (t[4] = 0),
                      (t[5] = a),
                      (t[6] = 0),
                      (t[7] = 0),
                      (t[8] = c),
                      (t[9] = l),
                      (t[10] = -1),
                      (t[11] = -1),
                      (t[12] = 0),
                      (t[13] = 0),
                      (t[14] = h),
                      (t[15] = 0);
                  })(this, e, n, r, s, i)
                : (function (t, e, n, r, s, i, o) {
                    const a = 1 / (n - e),
                      c = 1 / (s - r),
                      l = 1 / (i - o);
                    (t[0] = 2 * i * a),
                      (t[1] = 0),
                      (t[2] = 0),
                      (t[3] = 0),
                      (t[4] = 0),
                      (t[5] = 2 * i * c),
                      (t[6] = 0),
                      (t[7] = 0),
                      (t[8] = (n + e) * a),
                      (t[9] = (s + r) * c),
                      (t[10] = (o + i) * l),
                      (t[11] = -1),
                      (t[12] = 0),
                      (t[13] = 0),
                      (t[14] = o * i * 2 * l),
                      (t[15] = 0);
                  })(this, e, n, r, s, i, o),
              this.check()
            );
          }
          lookAt(t) {
            const { eye: e, center: n = [0, 0, 0], up: r = [0, 1, 0] } = t;
            return (
              (function (t, e, n, r) {
                let s, i, o, a, c, l, h, u, d, f;
                const m = e[0],
                  g = e[1],
                  A = e[2],
                  p = r[0],
                  y = r[1],
                  B = r[2],
                  b = n[0],
                  C = n[1],
                  w = n[2];
                Math.abs(m - b) < _e &&
                Math.abs(g - C) < _e &&
                Math.abs(A - w) < _e
                  ? (function (t) {
                      (t[0] = 1),
                        (t[1] = 0),
                        (t[2] = 0),
                        (t[3] = 0),
                        (t[4] = 0),
                        (t[5] = 1),
                        (t[6] = 0),
                        (t[7] = 0),
                        (t[8] = 0),
                        (t[9] = 0),
                        (t[10] = 1),
                        (t[11] = 0),
                        (t[12] = 0),
                        (t[13] = 0),
                        (t[14] = 0),
                        (t[15] = 1);
                    })(t)
                  : ((u = m - b),
                    (d = g - C),
                    (f = A - w),
                    (s = 1 / Math.sqrt(u * u + d * d + f * f)),
                    (u *= s),
                    (d *= s),
                    (f *= s),
                    (i = y * f - B * d),
                    (o = B * u - p * f),
                    (a = p * d - y * u),
                    (s = Math.sqrt(i * i + o * o + a * a)),
                    s
                      ? ((s = 1 / s), (i *= s), (o *= s), (a *= s))
                      : ((i = 0), (o = 0), (a = 0)),
                    (c = d * a - f * o),
                    (l = f * i - u * a),
                    (h = u * o - d * i),
                    (s = Math.sqrt(c * c + l * l + h * h)),
                    s
                      ? ((s = 1 / s), (c *= s), (l *= s), (h *= s))
                      : ((c = 0), (l = 0), (h = 0)),
                    (t[0] = i),
                    (t[1] = c),
                    (t[2] = u),
                    (t[3] = 0),
                    (t[4] = o),
                    (t[5] = l),
                    (t[6] = d),
                    (t[7] = 0),
                    (t[8] = a),
                    (t[9] = h),
                    (t[10] = f),
                    (t[11] = 0),
                    (t[12] = -(i * m + o * g + a * A)),
                    (t[13] = -(c * m + l * g + h * A)),
                    (t[14] = -(u * m + d * g + f * A)),
                    (t[15] = 1));
              })(this, e, n, r),
              this.check()
            );
          }
          ortho(t) {
            const {
              left: e,
              right: n,
              bottom: r,
              top: s,
              near: i = an,
              far: o = cn
            } = t;
            return (
              (function (t, e, n, r, s, i, o) {
                const a = 1 / (e - n),
                  c = 1 / (r - s),
                  l = 1 / (i - o);
                (t[0] = -2 * a),
                  (t[1] = 0),
                  (t[2] = 0),
                  (t[3] = 0),
                  (t[4] = 0),
                  (t[5] = -2 * c),
                  (t[6] = 0),
                  (t[7] = 0),
                  (t[8] = 0),
                  (t[9] = 0),
                  (t[10] = 2 * l),
                  (t[11] = 0),
                  (t[12] = (e + n) * a),
                  (t[13] = (s + r) * c),
                  (t[14] = (o + i) * l),
                  (t[15] = 1);
              })(this, e, n, r, s, i, o),
              this.check()
            );
          }
          orthographic(t) {
            const {
              fovy: e = sn,
              aspect: n = on,
              focalDistance: r = 1,
              near: s = an,
              far: i = cn
            } = t;
            fn(e);
            const o = e / 2,
              a = r * Math.tan(o),
              c = a * n;
            return this.ortho({
              left: -c,
              right: c,
              bottom: -a,
              top: a,
              near: s,
              far: i
            });
          }
          perspective(t) {
            const {
              fovy: e = (45 * Math.PI) / 180,
              aspect: n = 1,
              near: r = 0.1,
              far: s = 500
            } = t;
            return (
              fn(e),
              (function (t, e, n, r, s) {
                const i = 1 / Math.tan(e / 2);
                if (
                  ((t[0] = i / n),
                  (t[1] = 0),
                  (t[2] = 0),
                  (t[3] = 0),
                  (t[4] = 0),
                  (t[5] = i),
                  (t[6] = 0),
                  (t[7] = 0),
                  (t[8] = 0),
                  (t[9] = 0),
                  (t[11] = -1),
                  (t[12] = 0),
                  (t[13] = 0),
                  (t[15] = 0),
                  null != s && s !== 1 / 0)
                ) {
                  const e = 1 / (r - s);
                  (t[10] = (s + r) * e), (t[14] = 2 * s * r * e);
                } else (t[10] = -1), (t[14] = -2 * r);
              })(this, e, n, r, s),
              this.check()
            );
          }
          determinant() {
            return (function (t) {
              const e = t[0],
                n = t[1],
                r = t[2],
                s = t[3],
                i = t[4],
                o = t[5],
                a = t[6],
                c = t[7],
                l = t[8],
                h = t[9],
                u = t[10],
                d = t[11],
                f = t[12],
                m = t[13],
                g = t[14],
                A = e * o - n * i,
                p = e * a - r * i,
                y = n * a - r * o,
                B = l * m - h * f,
                b = l * g - u * f,
                C = h * g - u * m;
              return (
                c * (e * C - n * b + r * B) -
                s * (i * C - o * b + a * B) +
                t[15] * (l * y - h * p + u * A) -
                d * (f * y - m * p + g * A)
              );
            })(this);
          }
          getScale(t = [-0, -0, -0]) {
            return (
              (t[0] = Math.sqrt(
                this[0] * this[0] + this[1] * this[1] + this[2] * this[2]
              )),
              (t[1] = Math.sqrt(
                this[4] * this[4] + this[5] * this[5] + this[6] * this[6]
              )),
              (t[2] = Math.sqrt(
                this[8] * this[8] + this[9] * this[9] + this[10] * this[10]
              )),
              t
            );
          }
          getTranslation(t = [-0, -0, -0]) {
            return (t[0] = this[12]), (t[1] = this[13]), (t[2] = this[14]), t;
          }
          getRotation(t, e) {
            (t = t || [
              -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0
            ]),
              (e = e || [-0, -0, -0]);
            const n = this.getScale(e),
              r = 1 / n[0],
              s = 1 / n[1],
              i = 1 / n[2];
            return (
              (t[0] = this[0] * r),
              (t[1] = this[1] * s),
              (t[2] = this[2] * i),
              (t[3] = 0),
              (t[4] = this[4] * r),
              (t[5] = this[5] * s),
              (t[6] = this[6] * i),
              (t[7] = 0),
              (t[8] = this[8] * r),
              (t[9] = this[9] * s),
              (t[10] = this[10] * i),
              (t[11] = 0),
              (t[12] = 0),
              (t[13] = 0),
              (t[14] = 0),
              (t[15] = 1),
              t
            );
          }
          getRotationMatrix3(t, e) {
            (t = t || [-0, -0, -0, -0, -0, -0, -0, -0, -0]),
              (e = e || [-0, -0, -0]);
            const n = this.getScale(e),
              r = 1 / n[0],
              s = 1 / n[1],
              i = 1 / n[2];
            return (
              (t[0] = this[0] * r),
              (t[1] = this[1] * s),
              (t[2] = this[2] * i),
              (t[3] = this[4] * r),
              (t[4] = this[5] * s),
              (t[5] = this[6] * i),
              (t[6] = this[8] * r),
              (t[7] = this[9] * s),
              (t[8] = this[10] * i),
              t
            );
          }
          transpose() {
            return (
              (function (t, e) {
                if (t === e) {
                  const n = e[1],
                    r = e[2],
                    s = e[3],
                    i = e[6],
                    o = e[7],
                    a = e[11];
                  (t[1] = e[4]),
                    (t[2] = e[8]),
                    (t[3] = e[12]),
                    (t[4] = n),
                    (t[6] = e[9]),
                    (t[7] = e[13]),
                    (t[8] = r),
                    (t[9] = i),
                    (t[11] = e[14]),
                    (t[12] = s),
                    (t[13] = o),
                    (t[14] = a);
                } else
                  (t[0] = e[0]),
                    (t[1] = e[4]),
                    (t[2] = e[8]),
                    (t[3] = e[12]),
                    (t[4] = e[1]),
                    (t[5] = e[5]),
                    (t[6] = e[9]),
                    (t[7] = e[13]),
                    (t[8] = e[2]),
                    (t[9] = e[6]),
                    (t[10] = e[10]),
                    (t[11] = e[14]),
                    (t[12] = e[3]),
                    (t[13] = e[7]),
                    (t[14] = e[11]),
                    (t[15] = e[15]);
              })(this, this),
              this.check()
            );
          }
          invert() {
            return (
              (function (t, e) {
                const n = e[0],
                  r = e[1],
                  s = e[2],
                  i = e[3],
                  o = e[4],
                  a = e[5],
                  c = e[6],
                  l = e[7],
                  h = e[8],
                  u = e[9],
                  d = e[10],
                  f = e[11],
                  m = e[12],
                  g = e[13],
                  A = e[14],
                  p = e[15],
                  y = n * a - r * o,
                  B = n * c - s * o,
                  b = n * l - i * o,
                  C = r * c - s * a,
                  w = r * l - i * a,
                  E = s * l - i * c,
                  T = h * g - u * m,
                  v = h * A - d * m,
                  _ = h * p - f * m,
                  M = u * A - d * g,
                  I = u * p - f * g,
                  x = d * p - f * A;
                let F = y * x - B * I + b * M + C * _ - w * v + E * T;
                F &&
                  ((F = 1 / F),
                  (t[0] = (a * x - c * I + l * M) * F),
                  (t[1] = (s * I - r * x - i * M) * F),
                  (t[2] = (g * E - A * w + p * C) * F),
                  (t[3] = (d * w - u * E - f * C) * F),
                  (t[4] = (c * _ - o * x - l * v) * F),
                  (t[5] = (n * x - s * _ + i * v) * F),
                  (t[6] = (A * b - m * E - p * B) * F),
                  (t[7] = (h * E - d * b + f * B) * F),
                  (t[8] = (o * I - a * _ + l * T) * F),
                  (t[9] = (r * _ - n * I - i * T) * F),
                  (t[10] = (m * w - g * b + p * y) * F),
                  (t[11] = (u * b - h * w - f * y) * F),
                  (t[12] = (a * v - o * M - c * T) * F),
                  (t[13] = (n * M - r * v + s * T) * F),
                  (t[14] = (g * B - m * C - A * y) * F),
                  (t[15] = (h * C - u * B + d * y) * F));
              })(this, this),
              this.check()
            );
          }
          multiplyLeft(t) {
            return nn(this, t, this), this.check();
          }
          multiplyRight(t) {
            return nn(this, this, t), this.check();
          }
          rotateX(t) {
            return (
              (function (t, e, n) {
                const r = Math.sin(n),
                  s = Math.cos(n),
                  i = e[4],
                  o = e[5],
                  a = e[6],
                  c = e[7],
                  l = e[8],
                  h = e[9],
                  u = e[10],
                  d = e[11];
                e !== t &&
                  ((t[0] = e[0]),
                  (t[1] = e[1]),
                  (t[2] = e[2]),
                  (t[3] = e[3]),
                  (t[12] = e[12]),
                  (t[13] = e[13]),
                  (t[14] = e[14]),
                  (t[15] = e[15])),
                  (t[4] = i * s + l * r),
                  (t[5] = o * s + h * r),
                  (t[6] = a * s + u * r),
                  (t[7] = c * s + d * r),
                  (t[8] = l * s - i * r),
                  (t[9] = h * s - o * r),
                  (t[10] = u * s - a * r),
                  (t[11] = d * s - c * r);
              })(this, this, t),
              this.check()
            );
          }
          rotateY(t) {
            return (
              (function (t, e, n) {
                const r = Math.sin(n),
                  s = Math.cos(n),
                  i = e[0],
                  o = e[1],
                  a = e[2],
                  c = e[3],
                  l = e[8],
                  h = e[9],
                  u = e[10],
                  d = e[11];
                e !== t &&
                  ((t[4] = e[4]),
                  (t[5] = e[5]),
                  (t[6] = e[6]),
                  (t[7] = e[7]),
                  (t[12] = e[12]),
                  (t[13] = e[13]),
                  (t[14] = e[14]),
                  (t[15] = e[15])),
                  (t[0] = i * s - l * r),
                  (t[1] = o * s - h * r),
                  (t[2] = a * s - u * r),
                  (t[3] = c * s - d * r),
                  (t[8] = i * r + l * s),
                  (t[9] = o * r + h * s),
                  (t[10] = a * r + u * s),
                  (t[11] = c * r + d * s);
              })(this, this, t),
              this.check()
            );
          }
          rotateZ(t) {
            return (
              (function (t, e, n) {
                const r = Math.sin(n),
                  s = Math.cos(n),
                  i = e[0],
                  o = e[1],
                  a = e[2],
                  c = e[3],
                  l = e[4],
                  h = e[5],
                  u = e[6],
                  d = e[7];
                e !== t &&
                  ((t[8] = e[8]),
                  (t[9] = e[9]),
                  (t[10] = e[10]),
                  (t[11] = e[11]),
                  (t[12] = e[12]),
                  (t[13] = e[13]),
                  (t[14] = e[14]),
                  (t[15] = e[15])),
                  (t[0] = i * s + l * r),
                  (t[1] = o * s + h * r),
                  (t[2] = a * s + u * r),
                  (t[3] = c * s + d * r),
                  (t[4] = l * s - i * r),
                  (t[5] = h * s - o * r),
                  (t[6] = u * s - a * r),
                  (t[7] = d * s - c * r);
              })(this, this, t),
              this.check()
            );
          }
          rotateXYZ(t) {
            return this.rotateX(t[0]).rotateY(t[1]).rotateZ(t[2]);
          }
          rotateAxis(t, e) {
            return (
              (function (t, e, n, r) {
                let s,
                  i,
                  o,
                  a,
                  c,
                  l,
                  h,
                  u,
                  d,
                  f,
                  m,
                  g,
                  A,
                  p,
                  y,
                  B,
                  b,
                  C,
                  w,
                  E,
                  T,
                  v,
                  _,
                  M,
                  I = r[0],
                  x = r[1],
                  F = r[2],
                  O = Math.sqrt(I * I + x * x + F * F);
                O < _e ||
                  ((O = 1 / O),
                  (I *= O),
                  (x *= O),
                  (F *= O),
                  (i = Math.sin(n)),
                  (s = Math.cos(n)),
                  (o = 1 - s),
                  (a = e[0]),
                  (c = e[1]),
                  (l = e[2]),
                  (h = e[3]),
                  (u = e[4]),
                  (d = e[5]),
                  (f = e[6]),
                  (m = e[7]),
                  (g = e[8]),
                  (A = e[9]),
                  (p = e[10]),
                  (y = e[11]),
                  (B = I * I * o + s),
                  (b = x * I * o + F * i),
                  (C = F * I * o - x * i),
                  (w = I * x * o - F * i),
                  (E = x * x * o + s),
                  (T = F * x * o + I * i),
                  (v = I * F * o + x * i),
                  (_ = x * F * o - I * i),
                  (M = F * F * o + s),
                  (t[0] = a * B + u * b + g * C),
                  (t[1] = c * B + d * b + A * C),
                  (t[2] = l * B + f * b + p * C),
                  (t[3] = h * B + m * b + y * C),
                  (t[4] = a * w + u * E + g * T),
                  (t[5] = c * w + d * E + A * T),
                  (t[6] = l * w + f * E + p * T),
                  (t[7] = h * w + m * E + y * T),
                  (t[8] = a * v + u * _ + g * M),
                  (t[9] = c * v + d * _ + A * M),
                  (t[10] = l * v + f * _ + p * M),
                  (t[11] = h * v + m * _ + y * M),
                  e !== t &&
                    ((t[12] = e[12]),
                    (t[13] = e[13]),
                    (t[14] = e[14]),
                    (t[15] = e[15])));
              })(this, this, t, e),
              this.check()
            );
          }
          scale(t) {
            return (
              (function (t, e, n) {
                const r = n[0],
                  s = n[1],
                  i = n[2];
                (t[0] = e[0] * r),
                  (t[1] = e[1] * r),
                  (t[2] = e[2] * r),
                  (t[3] = e[3] * r),
                  (t[4] = e[4] * s),
                  (t[5] = e[5] * s),
                  (t[6] = e[6] * s),
                  (t[7] = e[7] * s),
                  (t[8] = e[8] * i),
                  (t[9] = e[9] * i),
                  (t[10] = e[10] * i),
                  (t[11] = e[11] * i),
                  (t[12] = e[12]),
                  (t[13] = e[13]),
                  (t[14] = e[14]),
                  (t[15] = e[15]);
              })(this, this, Array.isArray(t) ? t : [t, t, t]),
              this.check()
            );
          }
          translate(t) {
            return (
              (function (t, e, n) {
                const r = n[0],
                  s = n[1],
                  i = n[2];
                let o, a, c, l, h, u, d, f, m, g, A, p;
                e === t
                  ? ((t[12] = e[0] * r + e[4] * s + e[8] * i + e[12]),
                    (t[13] = e[1] * r + e[5] * s + e[9] * i + e[13]),
                    (t[14] = e[2] * r + e[6] * s + e[10] * i + e[14]),
                    (t[15] = e[3] * r + e[7] * s + e[11] * i + e[15]))
                  : ((o = e[0]),
                    (a = e[1]),
                    (c = e[2]),
                    (l = e[3]),
                    (h = e[4]),
                    (u = e[5]),
                    (d = e[6]),
                    (f = e[7]),
                    (m = e[8]),
                    (g = e[9]),
                    (A = e[10]),
                    (p = e[11]),
                    (t[0] = o),
                    (t[1] = a),
                    (t[2] = c),
                    (t[3] = l),
                    (t[4] = h),
                    (t[5] = u),
                    (t[6] = d),
                    (t[7] = f),
                    (t[8] = m),
                    (t[9] = g),
                    (t[10] = A),
                    (t[11] = p),
                    (t[12] = o * r + h * s + m * i + e[12]),
                    (t[13] = a * r + u * s + g * i + e[13]),
                    (t[14] = c * r + d * s + A * i + e[14]),
                    (t[15] = l * r + f * s + p * i + e[15]));
              })(this, this, t),
              this.check()
            );
          }
          transform(t, e) {
            return 4 === t.length
              ? ((e = (function (t, e, n) {
                  const r = e[0],
                    s = e[1],
                    i = e[2],
                    o = e[3];
                  return (
                    (t[0] = n[0] * r + n[4] * s + n[8] * i + n[12] * o),
                    (t[1] = n[1] * r + n[5] * s + n[9] * i + n[13] * o),
                    (t[2] = n[2] * r + n[6] * s + n[10] * i + n[14] * o),
                    (t[3] = n[3] * r + n[7] * s + n[11] * i + n[15] * o),
                    t
                  );
                })(e || [-0, -0, -0, -0], t, this)),
                Ee(e, 4),
                e)
              : this.transformAsPoint(t, e);
          }
          transformAsPoint(t, e) {
            const { length: n } = t;
            let r;
            switch (n) {
              case 2:
                r = xe(e || [-0, -0], t, this);
                break;
              case 3:
                r = He(e || [-0, -0, -0], t, this);
                break;
              default:
                throw new Error('Illegal vector');
            }
            return Ee(r, t.length), r;
          }
          transformAsVector(t, e) {
            let n;
            switch (t.length) {
              case 2:
                n = Fe(e || [-0, -0], t, this);
                break;
              case 3:
                n = Oe(e || [-0, -0, -0], t, this);
                break;
              default:
                throw new Error('Illegal vector');
            }
            return Ee(n, t.length), n;
          }
          transformPoint(t, e) {
            return this.transformAsPoint(t, e);
          }
          transformVector(t, e) {
            return this.transformAsPoint(t, e);
          }
          transformDirection(t, e) {
            return this.transformAsVector(t, e);
          }
          makeRotationX(t) {
            return this.identity().rotateX(t);
          }
          makeTranslation(t, e, n) {
            return this.identity().translate([t, e, n]);
          }
        }
        let un, dn;
        function fn(t) {
          if (t > 2 * Math.PI) throw Error('expected radians');
        }
        function mn() {
          const t = new Me(4);
          return (
            Me != Float32Array && ((t[0] = 0), (t[1] = 0), (t[2] = 0)),
            (t[3] = 1),
            t
          );
        }
        function gn(t, e, n) {
          n *= 0.5;
          const r = Math.sin(n);
          return (
            (t[0] = r * e[0]),
            (t[1] = r * e[1]),
            (t[2] = r * e[2]),
            (t[3] = Math.cos(n)),
            t
          );
        }
        function An(t, e, n) {
          const r = e[0],
            s = e[1],
            i = e[2],
            o = e[3],
            a = n[0],
            c = n[1],
            l = n[2],
            h = n[3];
          return (
            (t[0] = r * h + o * a + s * l - i * c),
            (t[1] = s * h + o * c + i * a - r * l),
            (t[2] = i * h + o * l + r * c - s * a),
            (t[3] = o * h - r * a - s * c - i * l),
            t
          );
        }
        const pn = (function () {
          const t = De(),
            e = Le(1, 0, 0),
            n = Le(0, 1, 0);
          return function (r, s, i) {
            const o = Ue(s, i);
            return o < -0.999999
              ? (Ne(t, e, s),
                je(t) < 1e-6 && Ne(t, n, s),
                (function (t, e) {
                  const n = e[0],
                    r = e[1],
                    s = e[2];
                  let i = n * n + r * r + s * s;
                  i > 0 && (i = 1 / Math.sqrt(i)),
                    (t[0] = e[0] * i),
                    (t[1] = e[1] * i),
                    (t[2] = e[2] * i);
                })(t, t),
                gn(r, t, Math.PI),
                r)
              : o > 0.999999
              ? ((r[0] = 0), (r[1] = 0), (r[2] = 0), (r[3] = 1), r)
              : (Ne(t, s, i),
                (r[0] = t[0]),
                (r[1] = t[1]),
                (r[2] = t[2]),
                (r[3] = 1 + o),
                (function (t, e) {
                  const n = e[0],
                    r = e[1],
                    s = e[2],
                    i = e[3];
                  let o = n * n + r * r + s * s + i * i;
                  return (
                    o > 0 && (o = 1 / Math.sqrt(o)),
                    (t[0] = n * o),
                    (t[1] = r * o),
                    (t[2] = s * o),
                    (t[3] = i * o),
                    t
                  );
                })(r, r));
          };
        })();
        mn(),
          mn(),
          (function () {
            const t = new Me(9);
            Me != Float32Array &&
              ((t[1] = 0),
              (t[2] = 0),
              (t[3] = 0),
              (t[5] = 0),
              (t[6] = 0),
              (t[7] = 0)),
              (t[0] = 1),
              (t[4] = 1),
              (t[8] = 1);
          })();
        const yn = [0, 0, 0, 1];
        class Bn extends Ce {
          constructor(t = 0, e = 0, n = 0, r = 1) {
            super(-0, -0, -0, -0),
              Array.isArray(t) && 1 === arguments.length
                ? this.copy(t)
                : this.set(t, e, n, r);
          }
          copy(t) {
            return (
              (this[0] = t[0]),
              (this[1] = t[1]),
              (this[2] = t[2]),
              (this[3] = t[3]),
              this.check()
            );
          }
          set(t, e, n, r) {
            return (
              (this[0] = t),
              (this[1] = e),
              (this[2] = n),
              (this[3] = r),
              this.check()
            );
          }
          fromObject(t) {
            return (
              (this[0] = t.x),
              (this[1] = t.y),
              (this[2] = t.z),
              (this[3] = t.w),
              this.check()
            );
          }
          fromMatrix3(t) {
            return (
              (function (t, e) {
                const n = e[0] + e[4] + e[8];
                let r;
                if (n > 0)
                  (r = Math.sqrt(n + 1)),
                    (t[3] = 0.5 * r),
                    (r = 0.5 / r),
                    (t[0] = (e[5] - e[7]) * r),
                    (t[1] = (e[6] - e[2]) * r),
                    (t[2] = (e[1] - e[3]) * r);
                else {
                  let n = 0;
                  e[4] > e[0] && (n = 1), e[8] > e[3 * n + n] && (n = 2);
                  const s = (n + 1) % 3,
                    i = (n + 2) % 3;
                  (r = Math.sqrt(
                    e[3 * n + n] - e[3 * s + s] - e[3 * i + i] + 1
                  )),
                    (t[n] = 0.5 * r),
                    (r = 0.5 / r),
                    (t[3] = (e[3 * s + i] - e[3 * i + s]) * r),
                    (t[s] = (e[3 * s + n] + e[3 * n + s]) * r),
                    (t[i] = (e[3 * i + n] + e[3 * n + i]) * r);
                }
              })(this, t),
              this.check()
            );
          }
          fromAxisRotation(t, e) {
            return gn(this, t, e), this.check();
          }
          identity() {
            return (
              (function (t) {
                (t[0] = 0), (t[1] = 0), (t[2] = 0), (t[3] = 1);
              })(this),
              this.check()
            );
          }
          setAxisAngle(t, e) {
            return this.fromAxisRotation(t, e);
          }
          get ELEMENTS() {
            return 4;
          }
          get x() {
            return this[0];
          }
          set x(t) {
            this[0] = we(t);
          }
          get y() {
            return this[1];
          }
          set y(t) {
            this[1] = we(t);
          }
          get z() {
            return this[2];
          }
          set z(t) {
            this[2] = we(t);
          }
          get w() {
            return this[3];
          }
          set w(t) {
            this[3] = we(t);
          }
          len() {
            return (function (t) {
              const e = t[0],
                n = t[1],
                r = t[2],
                s = t[3];
              return Math.sqrt(e * e + n * n + r * r + s * s);
            })(this);
          }
          lengthSquared() {
            return (function (t) {
              const e = t[0],
                n = t[1],
                r = t[2],
                s = t[3];
              return e * e + n * n + r * r + s * s;
            })(this);
          }
          dot(t) {
            return (function (t, e) {
              return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3];
            })(this, t);
          }
          rotationTo(t, e) {
            return pn(this, t, e), this.check();
          }
          add(t) {
            return (
              (function (t, e, n) {
                (t[0] = e[0] + n[0]),
                  (t[1] = e[1] + n[1]),
                  (t[2] = e[2] + n[2]),
                  (t[3] = e[3] + n[3]);
              })(this, this, t),
              this.check()
            );
          }
          calculateW() {
            return (
              (function (t, e) {
                const n = e[0],
                  r = e[1],
                  s = e[2];
                (t[0] = n),
                  (t[1] = r),
                  (t[2] = s),
                  (t[3] = Math.sqrt(Math.abs(1 - n * n - r * r - s * s)));
              })(this, this),
              this.check()
            );
          }
          conjugate() {
            return (
              (function (t, e) {
                (t[0] = -e[0]), (t[1] = -e[1]), (t[2] = -e[2]), (t[3] = e[3]);
              })(this, this),
              this.check()
            );
          }
          invert() {
            return (
              (function (t, e) {
                const n = e[0],
                  r = e[1],
                  s = e[2],
                  i = e[3],
                  o = n * n + r * r + s * s + i * i,
                  a = o ? 1 / o : 0;
                (t[0] = -n * a),
                  (t[1] = -r * a),
                  (t[2] = -s * a),
                  (t[3] = i * a);
              })(this, this),
              this.check()
            );
          }
          lerp(t, e, n) {
            return void 0 === n
              ? this.lerp(this, t, e)
              : ((function (t, e, n, r) {
                  const s = e[0],
                    i = e[1],
                    o = e[2],
                    a = e[3];
                  (t[0] = s + r * (n[0] - s)),
                    (t[1] = i + r * (n[1] - i)),
                    (t[2] = o + r * (n[2] - o)),
                    (t[3] = a + r * (n[3] - a));
                })(this, t, e, n),
                this.check());
          }
          multiplyRight(t) {
            return An(this, this, t), this.check();
          }
          multiplyLeft(t) {
            return An(this, t, this), this.check();
          }
          normalize() {
            const t = this.len(),
              e = t > 0 ? 1 / t : 0;
            return (
              (this[0] = this[0] * e),
              (this[1] = this[1] * e),
              (this[2] = this[2] * e),
              (this[3] = this[3] * e),
              0 === t && (this[3] = 1),
              this.check()
            );
          }
          rotateX(t) {
            return (
              (function (t, e, n) {
                n *= 0.5;
                const r = e[0],
                  s = e[1],
                  i = e[2],
                  o = e[3],
                  a = Math.sin(n),
                  c = Math.cos(n);
                (t[0] = r * c + o * a),
                  (t[1] = s * c + i * a),
                  (t[2] = i * c - s * a),
                  (t[3] = o * c - r * a);
              })(this, this, t),
              this.check()
            );
          }
          rotateY(t) {
            return (
              (function (t, e, n) {
                n *= 0.5;
                const r = e[0],
                  s = e[1],
                  i = e[2],
                  o = e[3],
                  a = Math.sin(n),
                  c = Math.cos(n);
                (t[0] = r * c - i * a),
                  (t[1] = s * c + o * a),
                  (t[2] = i * c + r * a),
                  (t[3] = o * c - s * a);
              })(this, this, t),
              this.check()
            );
          }
          rotateZ(t) {
            return (
              (function (t, e, n) {
                n *= 0.5;
                const r = e[0],
                  s = e[1],
                  i = e[2],
                  o = e[3],
                  a = Math.sin(n),
                  c = Math.cos(n);
                (t[0] = r * c + s * a),
                  (t[1] = s * c - r * a),
                  (t[2] = i * c + o * a),
                  (t[3] = o * c - i * a);
              })(this, this, t),
              this.check()
            );
          }
          scale(t) {
            return (
              (function (t, e, n) {
                (t[0] = e[0] * n),
                  (t[1] = e[1] * n),
                  (t[2] = e[2] * n),
                  (t[3] = e[3] * n);
              })(this, this, t),
              this.check()
            );
          }
          slerp(t, e, n) {
            let r, s, i;
            switch (arguments.length) {
              case 1:
                ({ start: r = yn, target: s, ratio: i } = t);
                break;
              case 2:
                (r = this), (s = t), (i = e);
                break;
              default:
                (r = t), (s = e), (i = n);
            }
            return (
              (function (t, e, n, r) {
                const s = e[0],
                  i = e[1],
                  o = e[2],
                  a = e[3];
                let c,
                  l,
                  h,
                  u,
                  d,
                  f = n[0],
                  m = n[1],
                  g = n[2],
                  A = n[3];
                (c = s * f + i * m + o * g + a * A),
                  c < 0 && ((c = -c), (f = -f), (m = -m), (g = -g), (A = -A)),
                  1 - c > _e
                    ? ((l = Math.acos(c)),
                      (d = Math.sin(l)),
                      (h = Math.sin((1 - r) * l) / d),
                      (u = Math.sin(r * l) / d))
                    : ((h = 1 - r), (u = r)),
                  (t[0] = h * s + u * f),
                  (t[1] = h * i + u * m),
                  (t[2] = h * o + u * g),
                  (t[3] = h * a + u * A);
              })(this, r, s, i),
              this.check()
            );
          }
          transformVector4(t, e = new qe()) {
            return (
              (function (t, e, n) {
                const r = e[0],
                  s = e[1],
                  i = e[2],
                  o = n[0],
                  a = n[1],
                  c = n[2],
                  l = n[3],
                  h = l * r + a * i - c * s,
                  u = l * s + c * r - o * i,
                  d = l * i + o * s - a * r,
                  f = -o * r - a * s - c * i;
                (t[0] = h * l + f * -o + u * -c - d * -a),
                  (t[1] = u * l + f * -a + d * -o - h * -c),
                  (t[2] = d * l + f * -c + h * -a - u * -o),
                  (t[3] = e[3]);
              })(e, t, this),
              Ee(e, 4)
            );
          }
          lengthSq() {
            return this.lengthSquared();
          }
          setFromAxisAngle(t, e) {
            return this.setAxisAngle(t, e);
          }
          premultiply(t) {
            return this.multiplyLeft(t);
          }
          multiply(t) {
            return this.multiplyRight(t);
          }
        }
        function bn(t) {
          return (bn =
            'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t &&
                    'function' == typeof Symbol &&
                    t.constructor === Symbol &&
                    t !== Symbol.prototype
                    ? 'symbol'
                    : typeof t;
                })(t);
        }
        function Cn(t, e, n) {
          return (
            (e = (function (t) {
              var e = (function (t, e) {
                if ('object' != bn(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                  var r = n.call(t, e);
                  if ('object' != bn(r)) return r;
                  throw new TypeError(
                    '@@toPrimitive must return a primitive value.'
                  );
                }
                return String(t);
              })(t, 'string');
              return 'symbol' == bn(e) ? e : String(e);
            })(e)) in t
              ? Object.defineProperty(t, e, {
                  value: n,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0
                })
              : (t[e] = n),
            t
          );
        }
        function wn(t) {
          return t;
        }
        new Qe();
        const En = new Qe(),
          Tn = {
            up: { south: 'east', north: 'west', west: 'south', east: 'north' },
            down: {
              south: 'west',
              north: 'east',
              west: 'north',
              east: 'south'
            },
            south: { up: 'west', down: 'east', west: 'down', east: 'up' },
            north: { up: 'east', down: 'west', west: 'up', east: 'down' },
            west: { up: 'north', down: 'south', north: 'down', south: 'up' },
            east: { up: 'south', down: 'north', north: 'up', south: 'down' }
          },
          vn = {
            north: [-1, 0, 0],
            east: [0, 1, 0],
            up: [0, 0, 1],
            south: [1, 0, 0],
            west: [0, -1, 0],
            down: [0, 0, -1]
          },
          _n = {
            east: new Qe(),
            north: new Qe(),
            up: new Qe(),
            west: new Qe(),
            south: new Qe(),
            down: new Qe()
          },
          Mn = new Qe(),
          In = new Qe(),
          xn = new Qe();
        function Fn(t, e, n, r, s, i) {
          const o = Tn[e] && Tn[e][n];
          let a, c, l;
          Te(o && (!r || r === o));
          const h = En.copy(s);
          if (Be(h.x, 0, 1e-14) && Be(h.y, 0, 1e-14)) {
            const t = Math.sign(h.z);
            (a = Mn.fromArray(vn[e])),
              'east' !== e && 'west' !== e && a.scale(t),
              (c = In.fromArray(vn[n])),
              'east' !== n && 'west' !== n && c.scale(t),
              (l = xn.fromArray(vn[r])),
              'east' !== r && 'west' !== r && l.scale(t);
          } else {
            const { up: s, east: i, north: o } = _n;
            i.set(-h.y, h.x, 0).normalize(),
              t.geodeticSurfaceNormal(h, s),
              o.copy(s).cross(i);
            const { down: u, west: d, south: f } = _n;
            u.copy(s).scale(-1),
              d.copy(i).scale(-1),
              f.copy(o).scale(-1),
              (a = _n[e]),
              (c = _n[n]),
              (l = _n[r]);
          }
          return (
            (i[0] = a.x),
            (i[1] = a.y),
            (i[2] = a.z),
            (i[3] = 0),
            (i[4] = c.x),
            (i[5] = c.y),
            (i[6] = c.z),
            (i[7] = 0),
            (i[8] = l.x),
            (i[9] = l.y),
            (i[10] = l.z),
            (i[11] = 0),
            (i[12] = h.x),
            (i[13] = h.y),
            (i[14] = h.z),
            (i[15] = 1),
            i
          );
        }
        const On = new Qe(),
          Rn = new Qe(),
          Sn = new Qe(),
          Dn = new Qe(),
          Gn = new Qe(),
          Ln = new Qe(),
          Un = new Qe(),
          Nn = new Qe(),
          Hn = new Qe();
        class Pn {
          constructor(t = 0, e = 0, n = 0) {
            Cn(this, 'radii', void 0),
              Cn(this, 'radiiSquared', void 0),
              Cn(this, 'radiiToTheFourth', void 0),
              Cn(this, 'oneOverRadii', void 0),
              Cn(this, 'oneOverRadiiSquared', void 0),
              Cn(this, 'minimumRadius', void 0),
              Cn(this, 'maximumRadius', void 0),
              Cn(this, 'centerToleranceSquared', 0.1),
              Cn(this, 'squaredXOverSquaredZ', void 0),
              Te(t >= 0),
              Te(e >= 0),
              Te(n >= 0),
              (this.radii = new Qe(t, e, n)),
              (this.radiiSquared = new Qe(t * t, e * e, n * n)),
              (this.radiiToTheFourth = new Qe(
                t * t * t * t,
                e * e * e * e,
                n * n * n * n
              )),
              (this.oneOverRadii = new Qe(
                0 === t ? 0 : 1 / t,
                0 === e ? 0 : 1 / e,
                0 === n ? 0 : 1 / n
              )),
              (this.oneOverRadiiSquared = new Qe(
                0 === t ? 0 : 1 / (t * t),
                0 === e ? 0 : 1 / (e * e),
                0 === n ? 0 : 1 / (n * n)
              )),
              (this.minimumRadius = Math.min(t, e, n)),
              (this.maximumRadius = Math.max(t, e, n)),
              0 !== this.radiiSquared.z &&
                (this.squaredXOverSquaredZ =
                  this.radiiSquared.x / this.radiiSquared.z),
              Object.freeze(this);
          }
          equals(t) {
            return this === t || !(!t || !this.radii.equals(t.radii));
          }
          toString() {
            return this.radii.toString();
          }
          cartographicToCartesian(t, e = [0, 0, 0]) {
            const n = Gn,
              r = Ln,
              [, , s] = t;
            this.geodeticSurfaceNormalCartographic(t, n),
              r.copy(this.radiiSquared).scale(n);
            const i = Math.sqrt(n.dot(r));
            return r.scale(1 / i), n.scale(s), r.add(n), r.to(e);
          }
          cartesianToCartographic(t, e = [0, 0, 0]) {
            Hn.from(t);
            const n = this.scaleToGeodeticSurface(Hn, Un);
            if (!n) return;
            const r = this.geodeticSurfaceNormal(n, Gn),
              s = Nn;
            return (
              s.copy(Hn).subtract(n),
              (function (t, e) {
                return (function (t, e, n = wn) {
                  return (
                    'longitude' in e
                      ? ((e.longitude = n(t[0])),
                        (e.latitude = n(t[1])),
                        (e.height = t[2]))
                      : 'x' in e
                      ? ((e.x = n(t[0])), (e.y = n(t[1])), (e.z = t[2]))
                      : ((e[0] = n(t[0])), (e[1] = n(t[1])), (e[2] = t[2])),
                    e
                  );
                })(t, e, de._cartographicRadians ? wn : Ae);
              })(
                [
                  Math.atan2(r.y, r.x),
                  Math.asin(r.z),
                  Math.sign(Ue(s, Hn)) * Ge(s)
                ],
                e
              )
            );
          }
          eastNorthUpToFixedFrame(t, e = new hn()) {
            return Fn(this, 'east', 'north', 'up', t, e);
          }
          localFrameToFixedFrame(t, e, n, r, s = new hn()) {
            return Fn(this, t, e, n, r, s);
          }
          geocentricSurfaceNormal(t, e = [0, 0, 0]) {
            return Dn.from(t).normalize().to(e);
          }
          geodeticSurfaceNormalCartographic(t, e = [0, 0, 0]) {
            const n = (function (t, e = []) {
                return (function (t, e = [], n = wn) {
                  return (
                    'longitude' in t
                      ? ((e[0] = n(t.longitude)),
                        (e[1] = n(t.latitude)),
                        (e[2] = t.height))
                      : 'x' in t
                      ? ((e[0] = n(t.x)), (e[1] = n(t.y)), (e[2] = t.z))
                      : ((e[0] = n(t[0])), (e[1] = n(t[1])), (e[2] = t[2])),
                    e
                  );
                })(t, e, de._cartographicRadians ? wn : ge);
              })(t),
              r = n[0],
              s = n[1],
              i = Math.cos(s);
            return (
              Dn.set(i * Math.cos(r), i * Math.sin(r), Math.sin(s)).normalize(),
              Dn.to(e)
            );
          }
          geodeticSurfaceNormal(t, e = [0, 0, 0]) {
            return Dn.from(t).scale(this.oneOverRadiiSquared).normalize().to(e);
          }
          scaleToGeodeticSurface(t, e) {
            return (function (t, e, n = []) {
              const {
                oneOverRadii: r,
                oneOverRadiiSquared: s,
                centerToleranceSquared: i
              } = e;
              On.from(t);
              const o = On.x,
                a = On.y,
                c = On.z,
                l = r.x,
                h = r.y,
                u = r.z,
                d = o * o * l * l,
                f = a * a * h * h,
                m = c * c * u * u,
                g = d + f + m,
                A = Math.sqrt(1 / g);
              if (!Number.isFinite(A)) return;
              const p = Rn;
              if ((p.copy(t).scale(A), g < i)) return p.to(n);
              const y = s.x,
                B = s.y,
                b = s.z,
                C = Sn;
              C.set(p.x * y * 2, p.y * B * 2, p.z * b * 2);
              let w,
                E,
                T,
                v,
                _ = ((1 - A) * On.len()) / (0.5 * C.len()),
                M = 0;
              do {
                (_ -= M),
                  (w = 1 / (1 + _ * y)),
                  (E = 1 / (1 + _ * B)),
                  (T = 1 / (1 + _ * b));
                const t = w * w,
                  e = E * E,
                  n = T * T;
                (v = d * t + f * e + m * n - 1),
                  (M =
                    v /
                    (-2 *
                      (d * (t * w) * y + f * (e * E) * B + m * (n * T) * b)));
              } while (Math.abs(v) > 1e-12);
              return On.scale([w, E, T]).to(n);
            })(t, this, e);
          }
          scaleToGeocentricSurface(t, e = [0, 0, 0]) {
            Un.from(t);
            const n = Un.x,
              r = Un.y,
              s = Un.z,
              i = this.oneOverRadiiSquared,
              o = 1 / Math.sqrt(n * n * i.x + r * r * i.y + s * s * i.z);
            return Un.multiplyScalar(o).to(e);
          }
          transformPositionToScaledSpace(t, e = [0, 0, 0]) {
            return Un.from(t).scale(this.oneOverRadii).to(e);
          }
          transformPositionFromScaledSpace(t, e = [0, 0, 0]) {
            return Un.from(t).scale(this.radii).to(e);
          }
          getSurfaceNormalIntersectionWithZAxis(t, e = 0, n = [0, 0, 0]) {
            Te(Be(this.radii.x, this.radii.y, 1e-15)),
              Te(this.radii.z > 0),
              Un.from(t);
            const r = Un.z * (1 - this.squaredXOverSquaredZ);
            if (!(Math.abs(r) >= this.radii.z - e))
              return Un.set(0, 0, r).to(n);
          }
        }
        Cn(Pn, 'WGS84', new Pn(6378137, 6378137, 6356752.314245179));
        class Jn {
          constructor(t, e, n) {
            (this.item = void 0),
              (this.previous = void 0),
              (this.next = void 0),
              (this.item = t),
              (this.previous = e),
              (this.next = n);
          }
        }
        class jn {
          constructor() {
            (this.head = null), (this.tail = null), (this._length = 0);
          }
          get length() {
            return this._length;
          }
          add(t) {
            const e = new Jn(t, this.tail, null);
            return (
              this.tail
                ? ((this.tail.next = e), (this.tail = e))
                : ((this.head = e), (this.tail = e)),
              ++this._length,
              e
            );
          }
          remove(t) {
            t &&
              (t.previous && t.next
                ? ((t.previous.next = t.next), (t.next.previous = t.previous))
                : t.previous
                ? ((t.previous.next = null), (this.tail = t.previous))
                : t.next
                ? ((t.next.previous = null), (this.head = t.next))
                : ((this.head = null), (this.tail = null)),
              (t.next = null),
              (t.previous = null),
              --this._length);
          }
          splice(t, e) {
            t !== e && (this.remove(e), this._insert(t, e));
          }
          _insert(t, e) {
            const n = t.next;
            (t.next = e),
              this.tail === t ? (this.tail = e) : (n.previous = e),
              (e.next = n),
              (e.previous = t),
              ++this._length;
          }
        }
        class kn {
          constructor() {
            (this._list = void 0),
              (this._sentinel = void 0),
              (this._trimTiles = void 0),
              (this._list = new jn()),
              (this._sentinel = this._list.add('sentinel')),
              (this._trimTiles = !1);
          }
          reset() {
            this._list.splice(this._list.tail, this._sentinel);
          }
          touch(t) {
            const e = t._cacheNode;
            e && this._list.splice(this._sentinel, e);
          }
          add(t, e, n) {
            e._cacheNode || ((e._cacheNode = this._list.add(e)), n && n(t, e));
          }
          unloadTile(t, e, n) {
            const r = e._cacheNode;
            r && (this._list.remove(r), (e._cacheNode = null), n && n(t, e));
          }
          unloadTiles(t, e) {
            const n = this._trimTiles;
            this._trimTiles = !1;
            const r = this._list,
              s = 1024 * t.maximumMemoryUsage * 1024,
              i = this._sentinel;
            let o = r.head;
            for (; o !== i && (t.gpuMemoryUsageInBytes > s || n); ) {
              const n = o.item;
              (o = o.next), this.unloadTile(t, n, e);
            }
          }
          trim() {
            this._trimTiles = !0;
          }
        }
        new Qe(), new Qe();
        const Vn = new Qe(),
          Kn = new Qe();
        class Qn {
          constructor(t = [0, 0, 0], e = 0) {
            Cn(this, 'center', void 0),
              Cn(this, 'radius', void 0),
              (this.radius = -0),
              (this.center = new Qe()),
              this.fromCenterRadius(t, e);
          }
          fromCenterRadius(t, e) {
            return this.center.from(t), (this.radius = e), this;
          }
          fromCornerPoints(t, e) {
            return (
              (e = Vn.from(e)),
              (this.center = new Qe().from(t).add(e).scale(0.5)),
              (this.radius = this.center.distance(e)),
              this
            );
          }
          equals(t) {
            return (
              this === t ||
              (!!t && this.center.equals(t.center) && this.radius === t.radius)
            );
          }
          clone() {
            return new Qn(this.center, this.radius);
          }
          union(t) {
            const e = this.center,
              n = this.radius,
              r = t.center,
              s = t.radius,
              i = Vn.copy(r).subtract(e),
              o = i.magnitude();
            if (n >= o + s) return this.clone();
            if (s >= o + n) return t.clone();
            const a = 0.5 * (n + o + s);
            return (
              Kn.copy(i)
                .scale((-n + a) / o)
                .add(e),
              this.center.copy(Kn),
              (this.radius = a),
              this
            );
          }
          expand(t) {
            const e = Vn.from(t).subtract(this.center).magnitude();
            return e > this.radius && (this.radius = e), this;
          }
          transform(t) {
            this.center.transform(t);
            const e = (function (t, e) {
              const n = e[0],
                r = e[1],
                s = e[2],
                i = e[4],
                o = e[5],
                a = e[6],
                c = e[8],
                l = e[9],
                h = e[10];
              return (
                (t[0] = Math.sqrt(n * n + r * r + s * s)),
                (t[1] = Math.sqrt(i * i + o * o + a * a)),
                (t[2] = Math.sqrt(c * c + l * l + h * h)),
                t
              );
            })(Vn, t);
            return (
              (this.radius =
                Math.max(e[0], Math.max(e[1], e[2])) * this.radius),
              this
            );
          }
          distanceSquaredTo(t) {
            const e = this.distanceTo(t);
            return e * e;
          }
          distanceTo(t) {
            const e = Vn.from(t).subtract(this.center);
            return Math.max(0, e.len() - this.radius);
          }
          intersectPlane(t) {
            const e = this.center,
              n = this.radius,
              r = t.normal.dot(e) + t.distance;
            return r < -n ? -1 : r < n ? 0 : 1;
          }
        }
        const qn = new Qe(),
          Wn = new Qe(),
          zn = new Qe(),
          Xn = new Qe(),
          Yn = new Qe(),
          Zn = new Qe(),
          $n = new Qe();
        class tr {
          constructor(t = [0, 0, 0], e = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
            Cn(this, 'center', void 0),
              Cn(this, 'halfAxes', void 0),
              (this.center = new Qe().from(t)),
              (this.halfAxes = new $e(e));
          }
          get halfSize() {
            const t = this.halfAxes.getColumn(0),
              e = this.halfAxes.getColumn(1),
              n = this.halfAxes.getColumn(2);
            return [new Qe(t).len(), new Qe(e).len(), new Qe(n).len()];
          }
          get quaternion() {
            const t = this.halfAxes.getColumn(0),
              e = this.halfAxes.getColumn(1),
              n = this.halfAxes.getColumn(2),
              r = new Qe(t).normalize(),
              s = new Qe(e).normalize(),
              i = new Qe(n).normalize();
            return new Bn().fromMatrix3(new $e([...r, ...s, ...i]));
          }
          fromCenterHalfSizeQuaternion(t, e, n) {
            const r = new Bn(n),
              s = new $e().fromQuaternion(r);
            return (
              (s[0] = s[0] * e[0]),
              (s[1] = s[1] * e[0]),
              (s[2] = s[2] * e[0]),
              (s[3] = s[3] * e[1]),
              (s[4] = s[4] * e[1]),
              (s[5] = s[5] * e[1]),
              (s[6] = s[6] * e[2]),
              (s[7] = s[7] * e[2]),
              (s[8] = s[8] * e[2]),
              (this.center = new Qe().from(t)),
              (this.halfAxes = s),
              this
            );
          }
          clone() {
            return new tr(this.center, this.halfAxes);
          }
          equals(t) {
            return (
              this === t ||
              (!!t &&
                this.center.equals(t.center) &&
                this.halfAxes.equals(t.halfAxes))
            );
          }
          getBoundingSphere(t = new Qn()) {
            const e = this.halfAxes,
              n = e.getColumn(0, zn),
              r = e.getColumn(1, Xn),
              s = e.getColumn(2, Yn),
              i = qn.copy(n).add(r).add(s);
            return t.center.copy(this.center), (t.radius = i.magnitude()), t;
          }
          intersectPlane(t) {
            const e = this.center,
              n = t.normal,
              r = this.halfAxes,
              s = n.x,
              i = n.y,
              o = n.z,
              a =
                Math.abs(s * r[0] + i * r[1] + o * r[2]) +
                Math.abs(s * r[3] + i * r[4] + o * r[5]) +
                Math.abs(s * r[6] + i * r[7] + o * r[8]),
              c = n.dot(e) + t.distance;
            return c <= -a ? -1 : c >= a ? 1 : 0;
          }
          distanceTo(t) {
            return Math.sqrt(this.distanceSquaredTo(t));
          }
          distanceSquaredTo(t) {
            const e = Wn.from(t).subtract(this.center),
              n = this.halfAxes,
              r = n.getColumn(0, zn),
              s = n.getColumn(1, Xn),
              i = n.getColumn(2, Yn),
              o = r.magnitude(),
              a = s.magnitude(),
              c = i.magnitude();
            r.normalize(), s.normalize(), i.normalize();
            let l,
              h = 0;
            return (
              (l = Math.abs(e.dot(r)) - o),
              l > 0 && (h += l * l),
              (l = Math.abs(e.dot(s)) - a),
              l > 0 && (h += l * l),
              (l = Math.abs(e.dot(i)) - c),
              l > 0 && (h += l * l),
              h
            );
          }
          computePlaneDistances(t, e, n = [-0, -0]) {
            let r = Number.POSITIVE_INFINITY,
              s = Number.NEGATIVE_INFINITY;
            const i = this.center,
              o = this.halfAxes,
              a = o.getColumn(0, zn),
              c = o.getColumn(1, Xn),
              l = o.getColumn(2, Yn),
              h = Zn.copy(a).add(c).add(l).add(i),
              u = $n.copy(h).subtract(t);
            let d = e.dot(u);
            return (
              (r = Math.min(d, r)),
              (s = Math.max(d, s)),
              h.copy(i).add(a).add(c).subtract(l),
              u.copy(h).subtract(t),
              (d = e.dot(u)),
              (r = Math.min(d, r)),
              (s = Math.max(d, s)),
              h.copy(i).add(a).subtract(c).add(l),
              u.copy(h).subtract(t),
              (d = e.dot(u)),
              (r = Math.min(d, r)),
              (s = Math.max(d, s)),
              h.copy(i).add(a).subtract(c).subtract(l),
              u.copy(h).subtract(t),
              (d = e.dot(u)),
              (r = Math.min(d, r)),
              (s = Math.max(d, s)),
              i.copy(h).subtract(a).add(c).add(l),
              u.copy(h).subtract(t),
              (d = e.dot(u)),
              (r = Math.min(d, r)),
              (s = Math.max(d, s)),
              i.copy(h).subtract(a).add(c).subtract(l),
              u.copy(h).subtract(t),
              (d = e.dot(u)),
              (r = Math.min(d, r)),
              (s = Math.max(d, s)),
              i.copy(h).subtract(a).subtract(c).add(l),
              u.copy(h).subtract(t),
              (d = e.dot(u)),
              (r = Math.min(d, r)),
              (s = Math.max(d, s)),
              i.copy(h).subtract(a).subtract(c).subtract(l),
              u.copy(h).subtract(t),
              (d = e.dot(u)),
              (r = Math.min(d, r)),
              (s = Math.max(d, s)),
              (n[0] = r),
              (n[1] = s),
              n
            );
          }
          transform(t) {
            this.center.transformAsPoint(t);
            const e = this.halfAxes.getColumn(0, zn);
            e.transformAsPoint(t);
            const n = this.halfAxes.getColumn(1, Xn);
            n.transformAsPoint(t);
            const r = this.halfAxes.getColumn(2, Yn);
            return (
              r.transformAsPoint(t),
              (this.halfAxes = new $e([...e, ...n, ...r])),
              this
            );
          }
          getTransform() {
            throw new Error('not implemented');
          }
        }
        const er = new Qe(),
          nr = new Qe();
        class rr {
          constructor(t = [0, 0, 1], e = 0) {
            Cn(this, 'normal', void 0),
              Cn(this, 'distance', void 0),
              (this.normal = new Qe()),
              (this.distance = -0),
              this.fromNormalDistance(t, e);
          }
          fromNormalDistance(t, e) {
            return (
              Te(Number.isFinite(e)),
              this.normal.from(t).normalize(),
              (this.distance = e),
              this
            );
          }
          fromPointNormal(t, e) {
            (t = er.from(t)), this.normal.from(e).normalize();
            const n = -this.normal.dot(t);
            return (this.distance = n), this;
          }
          fromCoefficients(t, e, n, r) {
            return (
              this.normal.set(t, e, n),
              Te(Be(this.normal.len(), 1)),
              (this.distance = r),
              this
            );
          }
          clone() {
            return new rr(this.normal, this.distance);
          }
          equals(t) {
            return Be(this.distance, t.distance) && Be(this.normal, t.normal);
          }
          getPointDistance(t) {
            return this.normal.dot(t) + this.distance;
          }
          transform(t) {
            const e = nr.copy(this.normal).transformAsVector(t).normalize(),
              n = this.normal.scale(-this.distance).transform(t);
            return this.fromPointNormal(n, e);
          }
          projectPointOntoPlane(t, e = [0, 0, 0]) {
            const n = er.from(t),
              r = this.getPointDistance(n),
              s = nr.copy(this.normal).scale(r);
            return n.subtract(s).to(e);
          }
        }
        const sr = [new Qe([1, 0, 0]), new Qe([0, 1, 0]), new Qe([0, 0, 1])],
          ir = new Qe(),
          or = new Qe();
        class ar {
          constructor(t = []) {
            Cn(this, 'planes', void 0), (this.planes = t);
          }
          fromBoundingSphere(t) {
            this.planes.length = 2 * sr.length;
            const e = t.center,
              n = t.radius;
            let r = 0;
            for (const t of sr) {
              let s = this.planes[r],
                i = this.planes[r + 1];
              s || (s = this.planes[r] = new rr()),
                i || (i = this.planes[r + 1] = new rr());
              const o = ir.copy(t).scale(-n).add(e);
              s.fromPointNormal(o, t);
              const a = ir.copy(t).scale(n).add(e),
                c = or.copy(t).negate();
              i.fromPointNormal(a, c), (r += 2);
            }
            return this;
          }
          computeVisibility(t) {
            let e = 1;
            for (const n of this.planes)
              switch (t.intersectPlane(n)) {
                case -1:
                  return -1;
                case 0:
                  e = 0;
              }
            return e;
          }
          computeVisibilityWithPlaneMask(t, e) {
            if (
              (Te(Number.isFinite(e), 'parentPlaneMask is required.'),
              e === ar.MASK_OUTSIDE || e === ar.MASK_INSIDE)
            )
              return e;
            let n = ar.MASK_INSIDE;
            const r = this.planes;
            for (let s = 0; s < this.planes.length; ++s) {
              const i = s < 31 ? 1 << s : 0;
              if (s < 31 && !(e & i)) continue;
              const o = r[s],
                a = t.intersectPlane(o);
              if (-1 === a) return ar.MASK_OUTSIDE;
              0 === a && (n |= i);
            }
            return n;
          }
        }
        Cn(ar, 'MASK_OUTSIDE', 4294967295),
          Cn(ar, 'MASK_INSIDE', 0),
          Cn(ar, 'MASK_INDETERMINATE', 2147483647);
        const cr = new Qe(),
          lr = new Qe(),
          hr = new Qe(),
          ur = new Qe(),
          dr = new Qe();
        class fr {
          constructor(t = {}) {
            Cn(this, 'left', void 0),
              Cn(this, '_left', void 0),
              Cn(this, 'right', void 0),
              Cn(this, '_right', void 0),
              Cn(this, 'top', void 0),
              Cn(this, '_top', void 0),
              Cn(this, 'bottom', void 0),
              Cn(this, '_bottom', void 0),
              Cn(this, 'near', void 0),
              Cn(this, '_near', void 0),
              Cn(this, 'far', void 0),
              Cn(this, '_far', void 0),
              Cn(
                this,
                '_cullingVolume',
                new ar([
                  new rr(),
                  new rr(),
                  new rr(),
                  new rr(),
                  new rr(),
                  new rr()
                ])
              ),
              Cn(this, '_perspectiveMatrix', new hn()),
              Cn(this, '_infinitePerspective', new hn());
            const { near: e = 1, far: n = 5e8 } = t;
            (this.left = t.left),
              (this._left = void 0),
              (this.right = t.right),
              (this._right = void 0),
              (this.top = t.top),
              (this._top = void 0),
              (this.bottom = t.bottom),
              (this._bottom = void 0),
              (this.near = e),
              (this._near = e),
              (this.far = n),
              (this._far = n);
          }
          clone() {
            return new fr({
              right: this.right,
              left: this.left,
              top: this.top,
              bottom: this.bottom,
              near: this.near,
              far: this.far
            });
          }
          equals(t) {
            return (
              t &&
              t instanceof fr &&
              this.right === t.right &&
              this.left === t.left &&
              this.top === t.top &&
              this.bottom === t.bottom &&
              this.near === t.near &&
              this.far === t.far
            );
          }
          get projectionMatrix() {
            return this._update(), this._perspectiveMatrix;
          }
          get infiniteProjectionMatrix() {
            return this._update(), this._infinitePerspective;
          }
          computeCullingVolume(t, e, n) {
            Te(t, 'position is required.'),
              Te(e, 'direction is required.'),
              Te(n, 'up is required.');
            const r = this._cullingVolume.planes;
            n = cr.copy(n).normalize();
            const s = lr.copy(e).cross(n).normalize(),
              i = hr.copy(e).multiplyByScalar(this.near).add(t),
              o = ur.copy(e).multiplyByScalar(this.far).add(t);
            let a = dr;
            return (
              a.copy(s).multiplyByScalar(this.left).add(i).subtract(t).cross(n),
              r[0].fromPointNormal(t, a),
              a
                .copy(s)
                .multiplyByScalar(this.right)
                .add(i)
                .subtract(t)
                .cross(n)
                .negate(),
              r[1].fromPointNormal(t, a),
              a
                .copy(n)
                .multiplyByScalar(this.bottom)
                .add(i)
                .subtract(t)
                .cross(s)
                .negate(),
              r[2].fromPointNormal(t, a),
              a.copy(n).multiplyByScalar(this.top).add(i).subtract(t).cross(s),
              r[3].fromPointNormal(t, a),
              (a = new Qe().copy(e)),
              r[4].fromPointNormal(i, a),
              a.negate(),
              r[5].fromPointNormal(o, a),
              this._cullingVolume
            );
          }
          getPixelDimensions(t, e, n, r) {
            this._update(),
              Te(Number.isFinite(t) && Number.isFinite(e)),
              Te(t > 0),
              Te(e > 0),
              Te(n > 0),
              Te(r);
            const s = 1 / this.near;
            let i = this.top * s;
            const o = (2 * n * i) / e;
            i = this.right * s;
            const a = (2 * n * i) / t;
            return (r.x = a), (r.y = o), r;
          }
          _update() {
            Te(
              Number.isFinite(this.right) &&
                Number.isFinite(this.left) &&
                Number.isFinite(this.top) &&
                Number.isFinite(this.bottom) &&
                Number.isFinite(this.near) &&
                Number.isFinite(this.far)
            );
            const {
              top: t,
              bottom: e,
              right: n,
              left: r,
              near: s,
              far: i
            } = this;
            (t !== this._top ||
              e !== this._bottom ||
              r !== this._left ||
              n !== this._right ||
              s !== this._near ||
              i !== this._far) &&
              (Te(
                this.near > 0 && this.near < this.far,
                'near must be greater than zero and less than far.'
              ),
              (this._left = r),
              (this._right = n),
              (this._top = t),
              (this._bottom = e),
              (this._near = s),
              (this._far = i),
              (this._perspectiveMatrix = new hn().frustum({
                left: r,
                right: n,
                bottom: e,
                top: t,
                near: s,
                far: i
              })),
              (this._infinitePerspective = new hn().frustum({
                left: r,
                right: n,
                bottom: e,
                top: t,
                near: s,
                far: 1 / 0
              })));
          }
        }
        class mr {
          constructor(t = {}) {
            Cn(this, '_offCenterFrustum', new fr()),
              Cn(this, 'fov', void 0),
              Cn(this, '_fov', void 0),
              Cn(this, '_fovy', void 0),
              Cn(this, '_sseDenominator', void 0),
              Cn(this, 'aspectRatio', void 0),
              Cn(this, '_aspectRatio', void 0),
              Cn(this, 'near', void 0),
              Cn(this, '_near', void 0),
              Cn(this, 'far', void 0),
              Cn(this, '_far', void 0),
              Cn(this, 'xOffset', void 0),
              Cn(this, '_xOffset', void 0),
              Cn(this, 'yOffset', void 0),
              Cn(this, '_yOffset', void 0);
            const {
              fov: e,
              aspectRatio: n,
              near: r = 1,
              far: s = 5e8,
              xOffset: i = 0,
              yOffset: o = 0
            } = t;
            (this.fov = e),
              (this.aspectRatio = n),
              (this.near = r),
              (this.far = s),
              (this.xOffset = i),
              (this.yOffset = o);
          }
          clone() {
            return new mr({
              aspectRatio: this.aspectRatio,
              fov: this.fov,
              near: this.near,
              far: this.far
            });
          }
          equals(t) {
            return (
              !!(((t) => null !== t && typeof t < 'u')(t) && t instanceof mr) &&
              (this._update(),
              t._update(),
              this.fov === t.fov &&
                this.aspectRatio === t.aspectRatio &&
                this.near === t.near &&
                this.far === t.far &&
                this._offCenterFrustum.equals(t._offCenterFrustum))
            );
          }
          get projectionMatrix() {
            return this._update(), this._offCenterFrustum.projectionMatrix;
          }
          get infiniteProjectionMatrix() {
            return (
              this._update(), this._offCenterFrustum.infiniteProjectionMatrix
            );
          }
          get fovy() {
            return this._update(), this._fovy;
          }
          get sseDenominator() {
            return this._update(), this._sseDenominator;
          }
          computeCullingVolume(t, e, n) {
            return (
              this._update(),
              this._offCenterFrustum.computeCullingVolume(t, e, n)
            );
          }
          getPixelDimensions(t, e, n, r) {
            return (
              this._update(),
              this._offCenterFrustum.getPixelDimensions(t, e, n, r || new Se())
            );
          }
          _update() {
            Te(
              Number.isFinite(this.fov) &&
                Number.isFinite(this.aspectRatio) &&
                Number.isFinite(this.near) &&
                Number.isFinite(this.far)
            );
            const t = this._offCenterFrustum;
            (this.fov !== this._fov ||
              this.aspectRatio !== this._aspectRatio ||
              this.near !== this._near ||
              this.far !== this._far ||
              this.xOffset !== this._xOffset ||
              this.yOffset !== this._yOffset) &&
              (Te(this.fov >= 0 && this.fov < Math.PI),
              Te(this.aspectRatio > 0),
              Te(this.near >= 0 && this.near < this.far),
              (this._aspectRatio = this.aspectRatio),
              (this._fov = this.fov),
              (this._fovy =
                this.aspectRatio <= 1
                  ? this.fov
                  : 2 * Math.atan(Math.tan(0.5 * this.fov) / this.aspectRatio)),
              (this._near = this.near),
              (this._far = this.far),
              (this._sseDenominator = 2 * Math.tan(0.5 * this._fovy)),
              (this._xOffset = this.xOffset),
              (this._yOffset = this.yOffset),
              (t.top = this.near * Math.tan(0.5 * this._fovy)),
              (t.bottom = -t.top),
              (t.right = this.aspectRatio * t.top),
              (t.left = -t.right),
              (t.near = this.near),
              (t.far = this.far),
              (t.right += this.xOffset),
              (t.left += this.xOffset),
              (t.top += this.yOffset),
              (t.bottom += this.yOffset));
          }
        }
        new Qe(),
          new Qe(),
          new Qe(),
          new Qe(),
          new Qe(),
          new Qe(),
          new Qe(),
          new Qe(),
          new Qe(),
          new Qe(),
          new Qe(),
          new Qe();
        const gr = new $e(),
          Ar = new $e(),
          pr = new $e(),
          yr = new $e(),
          Br = new $e();
        const br = [1, 0, 0],
          Cr = [2, 2, 1];
        function wr(t) {
          let e = 0;
          for (let n = 0; n < 3; ++n) {
            const r = t[gr.getElementIndex(Cr[n], br[n])];
            e += 2 * r * r;
          }
          return Math.sqrt(e);
        }
        function Er(t, e) {
          let n = 0,
            r = 1;
          for (let e = 0; e < 3; ++e) {
            const s = Math.abs(t[gr.getElementIndex(Cr[e], br[e])]);
            s > n && ((r = e), (n = s));
          }
          const s = br[r],
            i = Cr[r];
          let o = 1,
            a = 0;
          if (Math.abs(t[gr.getElementIndex(i, s)]) > 1e-15) {
            const e =
              (t[gr.getElementIndex(i, i)] - t[gr.getElementIndex(s, s)]) /
              2 /
              t[gr.getElementIndex(i, s)];
            let n;
            (n =
              e < 0
                ? -1 / (-e + Math.sqrt(1 + e * e))
                : 1 / (e + Math.sqrt(1 + e * e))),
              (o = 1 / Math.sqrt(1 + n * n)),
              (a = n * o);
          }
          return (
            $e.IDENTITY.to(e),
            (e[gr.getElementIndex(s, s)] = e[gr.getElementIndex(i, i)] = o),
            (e[gr.getElementIndex(i, s)] = a),
            (e[gr.getElementIndex(s, i)] = -a),
            e
          );
        }
        const Tr = new Qe(),
          vr = new Qe(),
          _r = new Qe(),
          Mr = new Qe(),
          Ir = new Qe(),
          xr = new $e(),
          Fr = { diagonal: new $e(), unitary: new $e() },
          Or = new Qe(),
          Rr = new Qe(),
          Sr = new ar([
            new rr(),
            new rr(),
            new rr(),
            new rr(),
            new rr(),
            new rr()
          ]);
        function Dr(t, e) {
          const { cameraDirection: n, cameraUp: r, height: s } = t,
            { metersPerUnit: i } = t.distanceScales,
            o = Lr(t, t.center),
            a = Pn.WGS84.eastNorthUpToFixedFrame(o),
            c = t.unprojectPosition(t.cameraPosition),
            l = Pn.WGS84.cartographicToCartesian(c, new Qe()),
            h = new Qe(a.transformAsVector(new Qe(n).scale(i))).normalize(),
            u = new Qe(a.transformAsVector(new Qe(r).scale(i))).normalize();
          !(function (t) {
            const e = t.getFrustumPlanes(),
              n = Gr(e.near, t.cameraPosition),
              r = Lr(t, n),
              s = Lr(t, t.cameraPosition, Rr);
            let i = 0;
            Sr.planes[i++].fromPointNormal(r, Or.copy(r).subtract(s));
            for (const s in e) {
              if ('near' === s) continue;
              const o = Lr(t, Gr(e[s], n, Rr), Rr);
              Sr.planes[i++].fromPointNormal(o, Or.copy(r).subtract(o));
            }
          })(t);
          const d = t.constructor,
            { longitude: f, latitude: m, width: g, bearing: A, zoom: p } = t;
          return {
            camera: { position: l, direction: h, up: u },
            viewport: t,
            topDownViewport: new d({
              longitude: f,
              latitude: m,
              height: s,
              width: g,
              bearing: A,
              zoom: p,
              pitch: 0
            }),
            height: s,
            cullingVolume: Sr,
            frameNumber: e,
            sseDenominator: 1.15
          };
        }
        function Gr(t, e) {
          let n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : new Qe();
          const r = t.normal.dot(e);
          return (
            n
              .copy(t.normal)
              .scale(t.distance - r)
              .add(e),
            n
          );
        }
        function Lr(t, e) {
          let n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : new Qe();
          const r = t.unprojectPosition(e);
          return Pn.WGS84.cartographicToCartesian(r, n);
        }
        const Ur = 6356752.314245179,
          Nr = new Qe();
        function Hr(t, e, n) {
          Pn.WGS84.cartographicToCartesian([t.xmax, t.ymax, t.zmax], Nr);
          const r = Math.sqrt(
            Math.pow(Nr[0] - n[0], 2) +
              Math.pow(Nr[1] - n[1], 2) +
              Math.pow(Nr[2] - n[2], 2)
          );
          return Math.log2(Ur / (r + e[2]));
        }
        let Pr = (function (t) {
            return (
              (t[(t.ADD = 1)] = 'ADD'), (t[(t.REPLACE = 2)] = 'REPLACE'), t
            );
          })({}),
          Jr = (function (t) {
            return (
              (t.EMPTY = 'empty'),
              (t.SCENEGRAPH = 'scenegraph'),
              (t.POINTCLOUD = 'pointcloud'),
              (t.MESH = 'mesh'),
              t
            );
          })({}),
          jr = (function (t) {
            return (t.I3S = 'I3S'), (t.TILES3D = 'TILES3D'), t;
          })({}),
          kr = (function (t) {
            return (
              (t.GEOMETRIC_ERROR = 'geometricError'),
              (t.MAX_SCREEN_THRESHOLD = 'maxScreenThreshold'),
              t
            );
          })({});
        function Vr(t) {
          return null != t;
        }
        const Kr = new Qe(),
          Qr = new Qe(),
          qr = new Qe(),
          Wr = new Qe(),
          zr = new Qe(),
          Xr = new Qe(),
          Yr = new Qe(),
          Zr = new Qe();
        function $r(t, e, r) {
          if ((n(t, '3D Tile: boundingVolume must be defined'), t.box))
            return ts(t.box, e, r);
          if (t.region)
            return (function (t) {
              const [e, n, r, s, i, o] = t,
                a = Pn.WGS84.cartographicToCartesian([pe(e), pe(s), i], qr),
                c = Pn.WGS84.cartographicToCartesian([pe(r), pe(n), o], Wr),
                l = new Qe().addVectors(a, c).multiplyByScalar(0.5);
              return (
                Pn.WGS84.cartesianToCartographic(l, zr),
                Pn.WGS84.cartographicToCartesian([pe(r), zr[1], zr[2]], Xr),
                Pn.WGS84.cartographicToCartesian([zr[0], pe(s), zr[2]], Yr),
                Pn.WGS84.cartographicToCartesian([zr[0], zr[1], o], Zr),
                ts(
                  [
                    ...l,
                    ...Xr.subtract(l),
                    ...Yr.subtract(l),
                    ...Zr.subtract(l)
                  ],
                  new hn()
                )
              );
            })(t.region);
          if (t.sphere)
            return (function (t, e, n) {
              const r = new Qe(t[0], t[1], t[2]);
              e.transform(r, r);
              const s = e.getScale(Qr),
                i = Math.max(Math.max(s[0], s[1]), s[2]),
                o = t[3] * i;
              return Vr(n) ? ((n.center = r), (n.radius = o), n) : new Qn(r, o);
            })(t.sphere, e, r);
          throw new Error(
            '3D Tile: boundingVolume must contain a sphere, region, or box'
          );
        }
        function ts(t, e, n) {
          const r = new Qe(t[0], t[1], t[2]);
          e.transform(r, r);
          let s = [];
          if (10 === t.length) {
            const e = t.slice(3, 6),
              n = new Bn();
            n.fromArray(t, 6);
            const r = new Qe([1, 0, 0]),
              i = new Qe([0, 1, 0]),
              o = new Qe([0, 0, 1]);
            r.transformByQuaternion(n),
              r.scale(e[0]),
              i.transformByQuaternion(n),
              i.scale(e[1]),
              o.transformByQuaternion(n),
              o.scale(e[2]),
              (s = [...r.toArray(), ...i.toArray(), ...o.toArray()]);
          } else s = [...t.slice(3, 6), ...t.slice(6, 9), ...t.slice(9, 12)];
          const i = e.transformAsVector(s.slice(0, 3)),
            o = e.transformAsVector(s.slice(3, 6)),
            a = e.transformAsVector(s.slice(6, 9)),
            c = new $e([i[0], i[1], i[2], o[0], o[1], o[2], a[0], a[1], a[2]]);
          return Vr(n) ? ((n.center = r), (n.halfAxes = c), n) : new tr(r, c);
        }
        function es(t, e) {
          Pn.WGS84.cartesianToCartographic(e, Kr),
            (t[0][0] = Math.min(t[0][0], Kr[0])),
            (t[0][1] = Math.min(t[0][1], Kr[1])),
            (t[0][2] = Math.min(t[0][2], Kr[2])),
            (t[1][0] = Math.max(t[1][0], Kr[0])),
            (t[1][1] = Math.max(t[1][1], Kr[1])),
            (t[1][2] = Math.max(t[1][2], Kr[2]));
        }
        new Qe(), new Qe(), new hn(), new Qe(), new Qe(), new Qe();
        const ns = new Qe(),
          rs = new Qe(),
          ss = new Qe(),
          is = new Qe(),
          os = new Qe(),
          as = new hn(),
          cs = new hn();
        function ls(t, e) {
          const { topDownViewport: n } = e,
            r = t.header.mbs[1],
            s = t.header.mbs[0],
            i = t.header.mbs[2],
            o = t.header.mbs[3],
            a = [...t.boundingVolume.center],
            c = n.unprojectPosition(n.cameraPosition);
          Pn.WGS84.cartographicToCartesian(c, ns),
            rs.copy(ns).subtract(a).normalize(),
            Pn.WGS84.eastNorthUpToFixedFrame(a, as),
            cs.copy(as).invert(),
            ss.copy(ns).transform(cs);
          const l = Math.sqrt(ss[0] * ss[0] + ss[1] * ss[1]),
            h = (l * l) / ss[2];
          is.copy([ss[0], ss[1], h]);
          const u = is.transform(as).subtract(a).normalize(),
            d = rs.cross(u).normalize().scale(o).add(a),
            f = Pn.WGS84.cartesianToCartographic(d),
            m = n.project([s, r, i]),
            g = n.project(f);
          return os.copy(m).subtract(g).magnitude();
        }
        class hs {
          constructor() {
            let t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : 0;
            (this._map = new Map()),
              (this._array = void 0),
              (this._length = void 0),
              (this._array = new Array(t)),
              (this._length = t);
          }
          get length() {
            return this._length;
          }
          set length(t) {
            (this._length = t),
              t > this._array.length && (this._array.length = t);
          }
          get values() {
            return this._array;
          }
          get(t) {
            return n(t < this._array.length), this._array[t];
          }
          set(t, e) {
            n(t >= 0),
              t >= this.length && (this.length = t + 1),
              this._map.has(this._array[t]) && this._map.delete(this._array[t]),
              (this._array[t] = e),
              this._map.set(e, t);
          }
          delete(t) {
            const e = this._map.get(t);
            e >= 0 &&
              (this._array.splice(e, 1), this._map.delete(t), this.length--);
          }
          peek() {
            return this._array[this._length - 1];
          }
          push(t) {
            if (!this._map.has(t)) {
              const e = this.length++;
              (this._array[e] = t), this._map.set(t, e);
            }
          }
          pop() {
            const t = this._array[--this.length];
            return this._map.delete(t), t;
          }
          reserve(t) {
            n(t >= 0), t > this._array.length && (this._array.length = t);
          }
          resize(t) {
            n(t >= 0), (this.length = t);
          }
          trim(t) {
            null == t && (t = this.length), (this._array.length = t);
          }
          reset() {
            (this._array = []), (this._map = new Map()), (this._length = 0);
          }
          find(t) {
            return this._map.has(t);
          }
        }
        const us = {
          loadSiblings: !1,
          skipLevelOfDetail: !1,
          updateTransforms: !0,
          onTraversalEnd: () => {},
          viewportTraversersMap: {},
          basePath: ''
        };
        class ds {
          traversalFinished(t) {
            return !0;
          }
          constructor(t) {
            (this.options = void 0),
              (this.root = null),
              (this.selectedTiles = {}),
              (this.requestedTiles = {}),
              (this.emptyTiles = {}),
              (this.lastUpdate = new Date().getTime()),
              (this.updateDebounceTime = 1e3),
              (this._traversalStack = new hs()),
              (this._emptyTraversalStack = new hs()),
              (this._frameNumber = null),
              (this.options = { ...us, ...t });
          }
          traverse(t, e, n) {
            (this.root = t),
              (this.options = { ...this.options, ...n }),
              this.reset(),
              this.updateTile(t, e),
              (this._frameNumber = e.frameNumber),
              this.executeTraversal(t, e);
          }
          reset() {
            (this.requestedTiles = {}),
              (this.selectedTiles = {}),
              (this.emptyTiles = {}),
              this._traversalStack.reset(),
              this._emptyTraversalStack.reset();
          }
          executeTraversal(t, e) {
            const n = this._traversalStack;
            for (t._selectionDepth = 1, n.push(t); n.length > 0; ) {
              const t = n.pop();
              let r = !1;
              this.canTraverse(t, e) &&
                (this.updateChildTiles(t, e),
                (r = this.updateAndPushChildren(
                  t,
                  e,
                  n,
                  t.hasRenderContent ? t._selectionDepth + 1 : t._selectionDepth
                )));
              const s = t.parent,
                i = !(s && !s._shouldRefine),
                o = !r;
              t.hasRenderContent
                ? t.refine === Pr.ADD
                  ? (this.loadTile(t, e), this.selectTile(t, e))
                  : t.refine === Pr.REPLACE &&
                    (this.loadTile(t, e), o && this.selectTile(t, e))
                : ((this.emptyTiles[t.id] = t),
                  this.loadTile(t, e),
                  o && this.selectTile(t, e)),
                this.touchTile(t, e),
                (t._shouldRefine = r && i);
            }
            const r = new Date().getTime();
            (this.traversalFinished(e) ||
              r - this.lastUpdate > this.updateDebounceTime) &&
              ((this.lastUpdate = r), this.options.onTraversalEnd(e));
          }
          updateChildTiles(t, e) {
            const n = t.children;
            for (const t of n) this.updateTile(t, e);
          }
          updateAndPushChildren(t, e, n, r) {
            const { loadSiblings: s, skipLevelOfDetail: i } = this.options,
              o = t.children;
            o.sort(this.compareDistanceToCamera.bind(this));
            const a = t.refine === Pr.REPLACE && t.hasRenderContent && !i;
            let c = !1,
              l = !0;
            for (const t of o)
              if (
                ((t._selectionDepth = r),
                t.isVisibleAndInRequestVolume
                  ? (n.find(t) && n.delete(t), n.push(t), (c = !0))
                  : (a || s) && (this.loadTile(t, e), this.touchTile(t, e)),
                a)
              ) {
                let n;
                if (
                  ((n =
                    !!t._inRequestVolume &&
                    (t.hasRenderContent
                      ? t.contentAvailable
                      : this.executeEmptyTraversal(t, e))),
                  (l = l && n),
                  !l)
                )
                  return !1;
              }
            return c || (l = !1), l;
          }
          updateTile(t, e) {
            this.updateTileVisibility(t, e);
          }
          selectTile(t, e) {
            this.shouldSelectTile(t) &&
              ((t._selectedFrame = e.frameNumber),
              (this.selectedTiles[t.id] = t));
          }
          loadTile(t, e) {
            this.shouldLoadTile(t) &&
              ((t._requestedFrame = e.frameNumber),
              (t._priority = t._getPriority()),
              (this.requestedTiles[t.id] = t));
          }
          touchTile(t, e) {
            t.tileset._cache.touch(t), (t._touchedFrame = e.frameNumber);
          }
          canTraverse(t, e) {
            let n =
                arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
              r =
                arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            return (
              !!t.hasChildren &&
              (t.hasTilesetContent
                ? !t.contentExpired
                : !(!r && !t.isVisibleAndInRequestVolume) &&
                  this.shouldRefine(t, e, n))
            );
          }
          shouldLoadTile(t) {
            return t.hasUnloadedContent || t.contentExpired;
          }
          shouldSelectTile(t) {
            return t.contentAvailable && !this.options.skipLevelOfDetail;
          }
          shouldRefine(t, e) {
            let n =
                arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
              r = t._screenSpaceError;
            return (
              n && (r = t.getScreenSpaceError(e, !0)),
              r > t.tileset.memoryAdjustedScreenSpaceError
            );
          }
          updateTileVisibility(t, e) {
            const n = [];
            if (this.options.viewportTraversersMap)
              for (const t in this.options.viewportTraversersMap)
                this.options.viewportTraversersMap[t] === e.viewport.id &&
                  n.push(t);
            else n.push(e.viewport.id);
            t.updateVisibility(e, n);
          }
          compareDistanceToCamera(t, e) {
            return t._distanceToCamera - e._distanceToCamera;
          }
          anyChildrenVisible(t, e) {
            let n = !1;
            for (const r of t.children)
              r.updateVisibility(e), (n = n || r.isVisibleAndInRequestVolume);
            return n;
          }
          executeEmptyTraversal(t, e) {
            let n = !0;
            const r = this._emptyTraversalStack;
            for (r.push(t); r.length > 0; ) {
              const t = r.pop(),
                s = !t.hasRenderContent && this.canTraverse(t, e, !1, !1),
                i = !t.hasRenderContent && 0 === t.children.length;
              if (
                (!s && !t.contentAvailable && !i && (n = !1),
                this.updateTile(t, e),
                t.isVisibleAndInRequestVolume ||
                  (this.loadTile(t, e), this.touchTile(t, e)),
                s)
              ) {
                const e = t.children;
                for (const t of e) r.push(t);
              }
            }
            return n;
          }
        }
        const fs = new Qe();
        class ms {
          constructor(t, e, n) {
            let r =
              arguments.length > 3 && void 0 !== arguments[3]
                ? arguments[3]
                : '';
            (this.tileset = void 0),
              (this.header = void 0),
              (this.id = void 0),
              (this.url = void 0),
              (this.parent = void 0),
              (this.refine = void 0),
              (this.type = void 0),
              (this.contentUrl = void 0),
              (this.lodMetricType = 'geometricError'),
              (this.lodMetricValue = 0),
              (this.boundingVolume = null),
              (this.content = null),
              (this.contentState = 0),
              (this.gpuMemoryUsageInBytes = 0),
              (this.children = []),
              (this.depth = 0),
              (this.viewportIds = []),
              (this.transform = new hn()),
              (this.extensions = null),
              (this.implicitTiling = null),
              (this.userData = {}),
              (this.computedTransform = void 0),
              (this.hasEmptyContent = !1),
              (this.hasTilesetContent = !1),
              (this.traverser = new ds({})),
              (this._cacheNode = null),
              (this._frameNumber = null),
              (this._expireDate = null),
              (this._expiredContent = null),
              (this._boundingBox = void 0),
              (this._distanceToCamera = 0),
              (this._screenSpaceError = 0),
              (this._visibilityPlaneMask = void 0),
              (this._visible = void 0),
              (this._contentBoundingVolume = void 0),
              (this._viewerRequestVolume = void 0),
              (this._initialTransform = new hn()),
              (this._priority = 0),
              (this._selectedFrame = 0),
              (this._requestedFrame = 0),
              (this._selectionDepth = 0),
              (this._touchedFrame = 0),
              (this._centerZDepth = 0),
              (this._shouldRefine = !1),
              (this._stackLength = 0),
              (this._visitedFrame = 0),
              (this._inRequestVolume = !1),
              (this._lodJudge = null),
              (this.header = e),
              (this.tileset = t),
              (this.id = r || e.id),
              (this.url = e.url),
              (this.parent = n),
              (this.refine = this._getRefine(e.refine)),
              (this.type = e.type),
              (this.contentUrl = e.contentUrl),
              this._initializeLodMetric(e),
              this._initializeTransforms(e),
              this._initializeBoundingVolumes(e),
              this._initializeContent(e),
              this._initializeRenderingState(e),
              Object.seal(this);
          }
          destroy() {
            this.header = null;
          }
          isDestroyed() {
            return null === this.header;
          }
          get selected() {
            return this._selectedFrame === this.tileset._frameNumber;
          }
          get isVisible() {
            return this._visible;
          }
          get isVisibleAndInRequestVolume() {
            return this._visible && this._inRequestVolume;
          }
          get hasRenderContent() {
            return !this.hasEmptyContent && !this.hasTilesetContent;
          }
          get hasChildren() {
            return (
              this.children.length > 0 ||
              (this.header.children && this.header.children.length > 0)
            );
          }
          get contentReady() {
            return 3 === this.contentState || this.hasEmptyContent;
          }
          get contentAvailable() {
            return !!(
              (this.contentReady && this.hasRenderContent) ||
              (this._expiredContent && !this.contentFailed)
            );
          }
          get hasUnloadedContent() {
            return this.hasRenderContent && this.contentUnloaded;
          }
          get contentUnloaded() {
            return 0 === this.contentState;
          }
          get contentExpired() {
            return 4 === this.contentState;
          }
          get contentFailed() {
            return 5 === this.contentState;
          }
          get distanceToCamera() {
            return this._distanceToCamera;
          }
          get screenSpaceError() {
            return this._screenSpaceError;
          }
          get boundingBox() {
            return (
              this._boundingBox ||
                (this._boundingBox = (function (t, e) {
                  if (t.box)
                    return (function (t) {
                      const e = [
                          [1 / 0, 1 / 0, 1 / 0],
                          [-1 / 0, -1 / 0, -1 / 0]
                        ],
                        { halfAxes: n } = t,
                        r = new Qe(n.getColumn(0)),
                        s = new Qe(n.getColumn(1)),
                        i = new Qe(n.getColumn(2));
                      for (let n = 0; n < 2; n++) {
                        for (let n = 0; n < 2; n++) {
                          for (let n = 0; n < 2; n++)
                            Kr.copy(t.center),
                              Kr.add(r),
                              Kr.add(s),
                              Kr.add(i),
                              es(e, Kr),
                              i.negate();
                          s.negate();
                        }
                        r.negate();
                      }
                      return e;
                    })(e);
                  if (t.region) {
                    const [e, n, r, s, i, o] = t.region;
                    return [
                      [pe(e), pe(n), i],
                      [pe(r), pe(s), o]
                    ];
                  }
                  if (t.sphere)
                    return (function (t) {
                      const e = [
                          [1 / 0, 1 / 0, 1 / 0],
                          [-1 / 0, -1 / 0, -1 / 0]
                        ],
                        { center: n, radius: r } = t,
                        s = Pn.WGS84.scaleToGeodeticSurface(n, Kr);
                      let i;
                      i = s
                        ? Pn.WGS84.geodeticSurfaceNormal(s)
                        : new Qe(0, 0, 1);
                      let o = new Qe(i[2], -i[1], 0);
                      o.len() > 0 ? o.normalize() : (o = new Qe(0, 1, 0));
                      const a = o.clone().cross(i);
                      for (const t of [o, a, i]) {
                        Qr.copy(t).scale(r);
                        for (let t = 0; t < 2; t++)
                          Kr.copy(n), Kr.add(Qr), es(e, Kr), Qr.negate();
                      }
                      return e;
                    })(e);
                  throw new Error('Unkown boundingVolume type');
                })(this.header.boundingVolume, this.boundingVolume)),
              this._boundingBox
            );
          }
          getScreenSpaceError(t, e) {
            switch (this.tileset.type) {
              case jr.I3S:
                return ls(this, t);
              case jr.TILES3D:
                return (function (t, e, n) {
                  const r = t.tileset,
                    s =
                      (t.parent && t.parent.lodMetricValue) || t.lodMetricValue,
                    i = n ? s : t.lodMetricValue;
                  if (0 === i) return 0;
                  const o = Math.max(t._distanceToCamera, 1e-7),
                    { height: a, sseDenominator: c } = e,
                    { viewDistanceScale: l } = r.options;
                  let h = (i * a * (l || 1)) / (o * c);
                  return (
                    (h -= (function (t, e) {
                      if (
                        t.dynamicScreenSpaceError &&
                        t.dynamicScreenSpaceErrorComputedDensity
                      ) {
                        const n = t.dynamicScreenSpaceErrorComputedDensity,
                          r = t.dynamicScreenSpaceErrorFactor;
                        return (
                          (function (t, e) {
                            const n = t * e;
                            return 1 - Math.exp(-n * n);
                          })(e, n) * r
                        );
                      }
                      return 0;
                    })(r, o)),
                    h
                  );
                })(this, t, e);
              default:
                throw new Error('Unsupported tileset type');
            }
          }
          unselect() {
            this._selectedFrame = 0;
          }
          _getGpuMemoryUsageInBytes() {
            return (
              this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0
            );
          }
          _getPriority() {
            const t = this.tileset._traverser,
              { skipLevelOfDetail: e } = t.options,
              n = this.refine === Pr.ADD || e;
            if (
              (n && !this.isVisible && void 0 !== this._visible) ||
              this.tileset._frameNumber - this._touchedFrame >= 1 ||
              0 === this.contentState
            )
              return -1;
            const r = this.parent,
              s =
                !r ||
                (n && 0 !== this._screenSpaceError && !r.hasTilesetContent)
                  ? this._screenSpaceError
                  : r._screenSpaceError,
              i = t.root ? t.root._screenSpaceError : 0;
            return Math.max(i - s, 0);
          }
          async loadContent() {
            if (this.hasEmptyContent) return !1;
            if (this.content) return !0;
            this.contentExpired && (this._expireDate = null),
              (this.contentState = 1);
            const t = await this.tileset._requestScheduler.scheduleRequest(
              this.id,
              this._getPriority.bind(this)
            );
            if (!t) return (this.contentState = 0), !1;
            try {
              const e = this.tileset.getTileUrl(this.contentUrl),
                n = this.tileset.loader,
                r = {
                  ...this.tileset.loadOptions,
                  [n.id]: {
                    ...this.tileset.loadOptions[n.id],
                    isTileset: 'json' === this.type,
                    ...this._getLoaderSpecificOptions(n.id)
                  }
                };
              return (
                (this.content = await le(e, n, r)),
                this.tileset.options.contentLoader &&
                  (await this.tileset.options.contentLoader(this)),
                this._isTileset() &&
                  this.tileset._initializeTileHeaders(this.content, this),
                (this.contentState = 3),
                this._onContentLoaded(),
                !0
              );
            } catch (t) {
              throw ((this.contentState = 5), t);
            } finally {
              t.done();
            }
          }
          unloadContent() {
            return (
              this.content && this.content.destroy && this.content.destroy(),
              (this.content = null),
              this.header.content &&
                this.header.content.destroy &&
                this.header.content.destroy(),
              (this.header.content = null),
              (this.contentState = 0),
              !0
            );
          }
          updateVisibility(t, e) {
            if (this._frameNumber === t.frameNumber) return;
            const n = this.parent,
              r = n ? n._visibilityPlaneMask : ar.MASK_INDETERMINATE;
            if (this.tileset._traverser.options.updateTransforms) {
              const t = n ? n.computedTransform : this.tileset.modelMatrix;
              this._updateTransform(t);
            }
            (this._distanceToCamera = this.distanceToTile(t)),
              (this._screenSpaceError = this.getScreenSpaceError(t, !1)),
              (this._visibilityPlaneMask = this.visibility(t, r)),
              (this._visible = this._visibilityPlaneMask !== ar.MASK_OUTSIDE),
              (this._inRequestVolume = this.insideViewerRequestVolume(t)),
              (this._frameNumber = t.frameNumber),
              (this.viewportIds = e);
          }
          visibility(t, e) {
            const { cullingVolume: n } = t,
              { boundingVolume: r } = this;
            return n.computeVisibilityWithPlaneMask(r, e);
          }
          contentVisibility() {
            return !0;
          }
          distanceToTile(t) {
            const e = this.boundingVolume;
            return Math.sqrt(
              Math.max(e.distanceSquaredTo(t.camera.position), 0)
            );
          }
          cameraSpaceZDepth(t) {
            let { camera: e } = t;
            const n = this.boundingVolume;
            return fs.subVectors(n.center, e.position), e.direction.dot(fs);
          }
          insideViewerRequestVolume(t) {
            const e = this._viewerRequestVolume;
            return !e || e.distanceSquaredTo(t.camera.position) <= 0;
          }
          updateExpiration() {
            if (
              (function (t) {
                return null != t;
              })(this._expireDate) &&
              this.contentReady &&
              !this.hasEmptyContent
            ) {
              const t = Date.now();
              Date.lessThan(this._expireDate, t) &&
                ((this.contentState = 4),
                (this._expiredContent = this.content));
            }
          }
          get extras() {
            return this.header.extras;
          }
          _initializeLodMetric(t) {
            'lodMetricType' in t
              ? (this.lodMetricType = t.lodMetricType)
              : ((this.lodMetricType =
                  (this.parent && this.parent.lodMetricType) ||
                  this.tileset.lodMetricType),
                console.warn(
                  '3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType'
                )),
              'lodMetricValue' in t
                ? (this.lodMetricValue = t.lodMetricValue)
                : ((this.lodMetricValue =
                    (this.parent && this.parent.lodMetricValue) ||
                    this.tileset.lodMetricValue),
                  console.warn(
                    '3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue'
                  ));
          }
          _initializeTransforms(t) {
            this.transform = t.transform ? new hn(t.transform) : new hn();
            const e = this.parent,
              n = this.tileset,
              r =
                e && e.computedTransform
                  ? e.computedTransform.clone()
                  : n.modelMatrix.clone();
            this.computedTransform = new hn(r).multiplyRight(this.transform);
            const s =
              e && e._initialTransform ? e._initialTransform.clone() : new hn();
            this._initialTransform = new hn(s).multiplyRight(this.transform);
          }
          _initializeBoundingVolumes(t) {
            (this._contentBoundingVolume = null),
              (this._viewerRequestVolume = null),
              this._updateBoundingVolume(t);
          }
          _initializeContent(t) {
            (this.content = { _tileset: this.tileset, _tile: this }),
              (this.hasEmptyContent = !0),
              (this.contentState = 0),
              (this.hasTilesetContent = !1),
              t.contentUrl &&
                ((this.content = null), (this.hasEmptyContent = !1));
          }
          _initializeRenderingState(t) {
            (this.depth = t.level || (this.parent ? this.parent.depth + 1 : 0)),
              (this._shouldRefine = !1),
              (this._distanceToCamera = 0),
              (this._centerZDepth = 0),
              (this._screenSpaceError = 0),
              (this._visibilityPlaneMask = ar.MASK_INDETERMINATE),
              (this._visible = void 0),
              (this._inRequestVolume = !1),
              (this._stackLength = 0),
              (this._selectionDepth = 0),
              (this._frameNumber = 0),
              (this._touchedFrame = 0),
              (this._visitedFrame = 0),
              (this._selectedFrame = 0),
              (this._requestedFrame = 0),
              (this._priority = 0);
          }
          _getRefine(t) {
            return t || (this.parent && this.parent.refine) || Pr.REPLACE;
          }
          _isTileset() {
            return -1 !== this.contentUrl.indexOf('.json');
          }
          _onContentLoaded() {
            switch (this.content && this.content.type) {
              case 'vctr':
              case 'geom':
                this.tileset._traverser.disableSkipLevelOfDetail = !0;
            }
            this._isTileset()
              ? (this.hasTilesetContent = !0)
              : (this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes());
          }
          _updateBoundingVolume(t) {
            this.boundingVolume = $r(
              t.boundingVolume,
              this.computedTransform,
              this.boundingVolume
            );
            const e = t.content;
            e &&
              (e.boundingVolume &&
                (this._contentBoundingVolume = $r(
                  e.boundingVolume,
                  this.computedTransform,
                  this._contentBoundingVolume
                )),
              t.viewerRequestVolume &&
                (this._viewerRequestVolume = $r(
                  t.viewerRequestVolume,
                  this.computedTransform,
                  this._viewerRequestVolume
                )));
          }
          _updateTransform() {
            const t = (
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : new hn()
            )
              .clone()
              .multiplyRight(this.transform);
            t.equals(this.computedTransform) ||
              ((this.computedTransform = t),
              this._updateBoundingVolume(this.header));
          }
          _getLoaderSpecificOptions(t) {
            return 'i3s' === t
              ? {
                  ...this.tileset.options.i3s,
                  _tileOptions: {
                    attributeUrls: this.header.attributeUrls,
                    textureUrl: this.header.textureUrl,
                    textureFormat: this.header.textureFormat,
                    textureLoaderOptions: this.header.textureLoaderOptions,
                    materialDefinition: this.header.materialDefinition,
                    isDracoGeometry: this.header.isDracoGeometry,
                    mbs: this.header.mbs
                  },
                  _tilesetOptions: {
                    store: this.tileset.tileset.store,
                    attributeStorageInfo:
                      this.tileset.tileset.attributeStorageInfo,
                    fields: this.tileset.tileset.fields
                  },
                  isTileHeader: !1
                }
              : (function (t) {
                  return {
                    assetGltfUpAxis: (t.asset && t.asset.gltfUpAxis) || 'Y'
                  };
                })(this.tileset.tileset);
          }
        }
        class gs extends ds {
          compareDistanceToCamera(t, e) {
            return 0 === e._distanceToCamera && 0 === t._distanceToCamera
              ? e._centerZDepth - t._centerZDepth
              : e._distanceToCamera - t._distanceToCamera;
          }
          updateTileVisibility(t, e) {
            if (
              (super.updateTileVisibility(t, e), !t.isVisibleAndInRequestVolume)
            )
              return;
            const n = t.children.length > 0;
            if (t.hasTilesetContent && n) {
              const n = t.children[0];
              return (
                this.updateTileVisibility(n, e), void (t._visible = n._visible)
              );
            }
            if (this.meetsScreenSpaceErrorEarly(t, e))
              return void (t._visible = !1);
            const r = t.refine === Pr.REPLACE,
              s = 1 === t._optimChildrenWithinParent;
            r && s && n && !this.anyChildrenVisible(t, e) && (t._visible = !1);
          }
          meetsScreenSpaceErrorEarly(t, e) {
            const { parent: n } = t;
            return !(
              !n ||
              n.hasTilesetContent ||
              n.refine !== Pr.ADD ||
              this.shouldRefine(t, e, !0)
            );
          }
        }
        class As {
          constructor() {
            this.frameNumberMap = new Map();
          }
          register(t, e) {
            const n = this.frameNumberMap.get(t) || new Map(),
              r = n.get(e) || 0;
            n.set(e, r + 1), this.frameNumberMap.set(t, n);
          }
          deregister(t, e) {
            const n = this.frameNumberMap.get(t);
            if (!n) return;
            const r = n.get(e) || 1;
            n.set(e, r - 1);
          }
          isZero(t, e) {
            var n;
            return (
              0 ===
              ((null === (n = this.frameNumberMap.get(t)) || void 0 === n
                ? void 0
                : n.get(e)) || 0)
            );
          }
        }
        class ps {
          constructor() {
            (this._statusMap = void 0),
              (this.pendingTilesRegister = new As()),
              (this._statusMap = {});
          }
          add(t, e, n, r) {
            if (!this._statusMap[e]) {
              const {
                frameNumber: s,
                viewport: { id: i }
              } = r;
              (this._statusMap[e] = {
                request: t,
                callback: n,
                key: e,
                frameState: r,
                status: 'REQUESTED'
              }),
                this.pendingTilesRegister.register(i, s),
                t()
                  .then((t) => {
                    this._statusMap[e].status = 'COMPLETED';
                    const {
                      frameNumber: n,
                      viewport: { id: s }
                    } = this._statusMap[e].frameState;
                    this.pendingTilesRegister.deregister(s, n),
                      this._statusMap[e].callback(t, r);
                  })
                  .catch((t) => {
                    this._statusMap[e].status = 'ERROR';
                    const {
                      frameNumber: r,
                      viewport: { id: s }
                    } = this._statusMap[e].frameState;
                    this.pendingTilesRegister.deregister(s, r), n(t);
                  });
            }
          }
          update(t, e) {
            if (this._statusMap[t]) {
              const {
                frameNumber: n,
                viewport: { id: r }
              } = this._statusMap[t].frameState;
              this.pendingTilesRegister.deregister(r, n);
              const {
                frameNumber: s,
                viewport: { id: i }
              } = e;
              this.pendingTilesRegister.register(i, s),
                (this._statusMap[t].frameState = e);
            }
          }
          find(t) {
            return this._statusMap[t];
          }
          hasPendingTiles(t, e) {
            return !this.pendingTilesRegister.isZero(t, e);
          }
        }
        class ys extends ds {
          constructor(t) {
            super(t),
              (this._tileManager = void 0),
              (this._tileManager = new ps());
          }
          traversalFinished(t) {
            return !this._tileManager.hasPendingTiles(
              t.viewport.id,
              this._frameNumber || 0
            );
          }
          shouldRefine(t, e) {
            return (
              (t._lodJudge = (function (t, e) {
                if (0 === t.lodMetricValue || isNaN(t.lodMetricValue))
                  return 'DIG';
                const n = 2 * ls(t, e);
                return n < 2
                  ? 'OUT'
                  : !t.header.children || n <= t.lodMetricValue
                  ? 'DRAW'
                  : t.header.children
                  ? 'DIG'
                  : 'OUT';
              })(t, e)),
              'DIG' === t._lodJudge
            );
          }
          updateChildTiles(t, e) {
            const n = t.header.children || [],
              r = t.children,
              s = t.tileset;
            for (const i of n) {
              const n = `${i.id}-${e.viewport.id}`,
                o = r && r.find((t) => t.id === n);
              if (o) o && this.updateTile(o, e);
              else {
                let r = () => this._loadTile(i.id, s);
                this._tileManager.find(n)
                  ? this._tileManager.update(n, e)
                  : (s.tileset.nodePages &&
                      (r = () =>
                        s.tileset.nodePagesTile.formTileFromNodePages(i.id)),
                    this._tileManager.add(
                      r,
                      n,
                      (e) => this._onTileLoad(e, t, n),
                      e
                    ));
              }
            }
            return !1;
          }
          async _loadTile(t, e) {
            const { loader: n } = e,
              r = e.getTileUrl(`${e.url}/nodes/${t}`),
              s = {
                ...e.loadOptions,
                i3s: { ...e.loadOptions.i3s, isTileHeader: !0 }
              };
            return await le(r, n, s);
          }
          _onTileLoad(t, e, n) {
            const r = new ms(e.tileset, t, e, n);
            e.children.push(r);
            const s = this._tileManager.find(r.id).frameState;
            this.updateTile(r, s),
              this._frameNumber === s.frameNumber &&
                (this.traversalFinished(s) ||
                  new Date().getTime() - this.lastUpdate >
                    this.updateDebounceTime) &&
                this.executeTraversal(r, s);
          }
        }
        const Bs = {
            description: '',
            ellipsoid: Pn.WGS84,
            modelMatrix: new hn(),
            throttleRequests: !0,
            maxRequests: 64,
            maximumMemoryUsage: 32,
            memoryCacheOverflow: 1,
            maximumTilesSelected: 0,
            debounceTime: 0,
            onTileLoad: () => {},
            onTileUnload: () => {},
            onTileError: () => {},
            onTraversalComplete: (t) => t,
            contentLoader: void 0,
            viewDistanceScale: 1,
            maximumScreenSpaceError: 8,
            memoryAdjustedScreenSpaceError: !1,
            loadTiles: !0,
            updateTransforms: !0,
            viewportTraversersMap: null,
            loadOptions: { fetch: {} },
            attributions: [],
            basePath: '',
            i3s: {}
          },
          bs = 'Tiles In Tileset(s)',
          Cs = 'Tiles In Memory',
          ws = 'Tiles In View',
          Es = 'Tiles To Render',
          Ts = 'Tiles Loaded',
          vs = 'Tiles Loading',
          _s = 'Tiles Unloaded',
          Ms = 'Failed Tile Loads',
          Is = 'Points/Vertices',
          xs = 'Tile Memory Use',
          Fs = 'Maximum Screen Space Error';
        class Os {
          constructor(t, e) {
            (this.options = void 0),
              (this.loadOptions = void 0),
              (this.type = void 0),
              (this.tileset = void 0),
              (this.loader = void 0),
              (this.url = void 0),
              (this.basePath = void 0),
              (this.modelMatrix = void 0),
              (this.ellipsoid = void 0),
              (this.lodMetricType = void 0),
              (this.lodMetricValue = void 0),
              (this.refine = void 0),
              (this.root = null),
              (this.roots = {}),
              (this.asset = {}),
              (this.description = ''),
              (this.properties = void 0),
              (this.extras = null),
              (this.attributions = {}),
              (this.credits = {}),
              (this.stats = void 0),
              (this.contentFormats = {
                draco: !1,
                meshopt: !1,
                dds: !1,
                ktx2: !1
              }),
              (this.cartographicCenter = null),
              (this.cartesianCenter = null),
              (this.zoom = 1),
              (this.boundingVolume = null),
              (this.dynamicScreenSpaceErrorComputedDensity = 0),
              (this.maximumMemoryUsage = 32),
              (this.gpuMemoryUsageInBytes = 0),
              (this.memoryAdjustedScreenSpaceError = 0),
              (this._cacheBytes = 0),
              (this._cacheOverflowBytes = 0),
              (this._frameNumber = 0),
              (this._queryParams = {}),
              (this._extensionsUsed = []),
              (this._tiles = {}),
              (this._pendingCount = 0),
              (this.selectedTiles = []),
              (this.traverseCounter = 0),
              (this.geometricError = 0),
              (this.lastUpdatedVieports = null),
              (this._requestedTiles = []),
              (this._emptyTiles = []),
              (this.frameStateData = {}),
              (this._traverser = void 0),
              (this._cache = new kn()),
              (this._requestScheduler = void 0),
              (this.updatePromise = null),
              (this.tilesetInitializationPromise = void 0),
              (this.options = { ...Bs, ...e }),
              (this.tileset = t),
              (this.loader = t.loader),
              (this.type = t.type),
              (this.url = t.url),
              (this.basePath = t.basePath || z(this.url)),
              (this.modelMatrix = this.options.modelMatrix),
              (this.ellipsoid = this.options.ellipsoid),
              (this.lodMetricType = t.lodMetricType),
              (this.lodMetricValue = t.lodMetricValue),
              (this.refine = t.root.refine),
              (this.loadOptions = this.options.loadOptions || {}),
              (this._traverser = this._initializeTraverser()),
              (this._requestScheduler = new V({
                throttleRequests: this.options.throttleRequests,
                maxRequests: this.options.maxRequests
              })),
              (this.memoryAdjustedScreenSpaceError =
                this.options.maximumScreenSpaceError),
              (this._cacheBytes =
                1024 * this.options.maximumMemoryUsage * 1024),
              (this._cacheOverflowBytes =
                1024 * this.options.memoryCacheOverflow * 1024),
              (this.stats = new j({ id: this.url })),
              this._initializeStats(),
              (this.tilesetInitializationPromise = this._initializeTileSet(t));
          }
          destroy() {
            this._destroy();
          }
          isLoaded() {
            return (
              0 === this._pendingCount &&
              0 !== this._frameNumber &&
              0 === this._requestedTiles.length
            );
          }
          get tiles() {
            return Object.values(this._tiles);
          }
          get frameNumber() {
            return this._frameNumber;
          }
          get queryParams() {
            return new URLSearchParams(this._queryParams).toString();
          }
          setProps(t) {
            this.options = { ...this.options, ...t };
          }
          getTileUrl(t) {
            if (t.startsWith('data:')) return t;
            let e = t;
            return (
              this.queryParams.length &&
                (e = `${t}${t.includes('?') ? '&' : '?'}${this.queryParams}`),
              e
            );
          }
          hasExtension(t) {
            return this._extensionsUsed.indexOf(t) > -1;
          }
          update() {
            let t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : null;
            this.tilesetInitializationPromise.then(() => {
              !t && this.lastUpdatedVieports
                ? (t = this.lastUpdatedVieports)
                : (this.lastUpdatedVieports = t),
                t && this.doUpdate(t);
            });
          }
          async selectTiles() {
            let t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : null;
            return (
              await this.tilesetInitializationPromise,
              t && (this.lastUpdatedVieports = t),
              this.updatePromise ||
                (this.updatePromise = new Promise((t) => {
                  setTimeout(() => {
                    this.lastUpdatedVieports &&
                      this.doUpdate(this.lastUpdatedVieports),
                      t(this._frameNumber),
                      (this.updatePromise = null);
                  }, this.options.debounceTime);
                })),
              this.updatePromise
            );
          }
          adjustScreenSpaceError() {
            this.gpuMemoryUsageInBytes < this._cacheBytes
              ? (this.memoryAdjustedScreenSpaceError = Math.max(
                  this.memoryAdjustedScreenSpaceError / 1.02,
                  this.options.maximumScreenSpaceError
                ))
              : this.gpuMemoryUsageInBytes >
                  this._cacheBytes + this._cacheOverflowBytes &&
                (this.memoryAdjustedScreenSpaceError *= 1.02);
          }
          doUpdate(t) {
            if (
              ('loadTiles' in this.options && !this.options.loadTiles) ||
              this.traverseCounter > 0
            )
              return;
            const e = t instanceof Array ? t : [t];
            this._cache.reset(),
              this._frameNumber++,
              (this.traverseCounter = e.length);
            const n = [];
            for (const t of e) {
              const e = t.id;
              this._needTraverse(e) ? n.push(e) : this.traverseCounter--;
            }
            for (const t of e) {
              const e = t.id;
              if (
                (this.roots[e] ||
                  (this.roots[e] = this._initializeTileHeaders(
                    this.tileset,
                    null
                  )),
                !n.includes(e))
              )
                continue;
              const r = Dr(t, this._frameNumber);
              this._traverser.traverse(this.roots[e], r, this.options);
            }
          }
          _needTraverse(t) {
            let e = t;
            return (
              this.options.viewportTraversersMap &&
                (e = this.options.viewportTraversersMap[t]),
              e === t
            );
          }
          _onTraversalEnd(t) {
            const e = t.viewport.id;
            this.frameStateData[e] ||
              (this.frameStateData[e] = {
                selectedTiles: [],
                _requestedTiles: [],
                _emptyTiles: []
              });
            const n = this.frameStateData[e],
              r = Object.values(this._traverser.selectedTiles),
              [s, i] = (function (t, e, n) {
                if (0 === n || t.length <= n) return [t, []];
                const r = [],
                  { longitude: s, latitude: i } = e.viewport;
                for (const [e, n] of t.entries()) {
                  const [t, o] = n.header.mbs,
                    a = Math.abs(s - t),
                    c = Math.abs(i - o),
                    l = Math.sqrt(c * c + a * a);
                  r.push([e, l]);
                }
                const o = r.sort((t, e) => t[1] - e[1]),
                  a = [];
                for (let e = 0; e < n; e++) a.push(t[o[e][0]]);
                const c = [];
                for (let e = n; e < o.length; e++) c.push(t[o[e][0]]);
                return [a, c];
              })(r, t, this.options.maximumTilesSelected);
            n.selectedTiles = s;
            for (const t of i) t.unselect();
            (n._requestedTiles = Object.values(this._traverser.requestedTiles)),
              (n._emptyTiles = Object.values(this._traverser.emptyTiles)),
              this.traverseCounter--,
              !(this.traverseCounter > 0) && this._updateTiles();
          }
          _updateTiles() {
            (this.selectedTiles = []),
              (this._requestedTiles = []),
              (this._emptyTiles = []);
            for (const t in this.frameStateData) {
              const e = this.frameStateData[t];
              (this.selectedTiles = this.selectedTiles.concat(e.selectedTiles)),
                (this._requestedTiles = this._requestedTiles.concat(
                  e._requestedTiles
                )),
                (this._emptyTiles = this._emptyTiles.concat(e._emptyTiles));
            }
            this.selectedTiles = this.options.onTraversalComplete(
              this.selectedTiles
            );
            for (const t of this.selectedTiles) this._tiles[t.id] = t;
            this._loadTiles(), this._unloadTiles(), this._updateStats();
          }
          _tilesChanged(t, e) {
            if (t.length !== e.length) return !0;
            const n = new Set(t.map((t) => t.id)),
              r = new Set(e.map((t) => t.id));
            let s = t.filter((t) => !r.has(t.id)).length > 0;
            return (s = s || e.filter((t) => !n.has(t.id)).length > 0), s;
          }
          _loadTiles() {
            for (const t of this._requestedTiles)
              t.contentUnloaded && this._loadTile(t);
          }
          _unloadTiles() {
            this._cache.unloadTiles(this, (t, e) => t._unloadTile(e));
          }
          _updateStats() {
            let t = 0,
              e = 0;
            for (const n of this.selectedTiles)
              n.contentAvailable &&
                n.content &&
                (t++,
                n.content.pointCount
                  ? (e += n.content.pointCount)
                  : (e += n.content.vertexCount));
            (this.stats.get(ws).count = this.selectedTiles.length),
              (this.stats.get(Es).count = t),
              (this.stats.get(Is).count = e),
              (this.stats.get(Fs).count = this.memoryAdjustedScreenSpaceError);
          }
          async _initializeTileSet(t) {
            this.type === jr.I3S &&
              (this.calculateViewPropsI3S(), (t.root = await t.root)),
              (this.root = this._initializeTileHeaders(t, null)),
              this.type === jr.TILES3D &&
                (this._initializeTiles3DTileset(t),
                this.calculateViewPropsTiles3D()),
              this.type === jr.I3S && this._initializeI3STileset();
          }
          calculateViewPropsI3S() {
            var t;
            const e = this.tileset.fullExtent;
            if (e) {
              const {
                xmin: t,
                xmax: n,
                ymin: r,
                ymax: s,
                zmin: i,
                zmax: o
              } = e;
              return (
                (this.cartographicCenter = new Qe(
                  t + (n - t) / 2,
                  r + (s - r) / 2,
                  i + (o - i) / 2
                )),
                (this.cartesianCenter = new Qe()),
                Pn.WGS84.cartographicToCartesian(
                  this.cartographicCenter,
                  this.cartesianCenter
                ),
                void (this.zoom = Hr(
                  e,
                  this.cartographicCenter,
                  this.cartesianCenter
                ))
              );
            }
            const n =
              null === (t = this.tileset.store) || void 0 === t
                ? void 0
                : t.extent;
            if (n) {
              const [t, e, r, s] = n;
              return (
                (this.cartographicCenter = new Qe(
                  t + (r - t) / 2,
                  e + (s - e) / 2,
                  0
                )),
                (this.cartesianCenter = new Qe()),
                Pn.WGS84.cartographicToCartesian(
                  this.cartographicCenter,
                  this.cartesianCenter
                ),
                void (this.zoom = (function (t, e, n) {
                  const [r, s, i, o] = t;
                  return Hr(
                    { xmin: r, xmax: i, ymin: s, ymax: o, zmin: 0, zmax: 0 },
                    e,
                    n
                  );
                })(n, this.cartographicCenter, this.cartesianCenter))
              );
            }
            console.warn('Extent is not defined in the tileset header'),
              (this.cartographicCenter = new Qe()),
              (this.zoom = 1);
          }
          calculateViewPropsTiles3D() {
            const t = this.root,
              { center: e } = t.boundingVolume;
            if (!e)
              return (
                console.warn('center was not pre-calculated for the root tile'),
                (this.cartographicCenter = new Qe()),
                void (this.zoom = 1)
              );
            0 !== e[0] || 0 !== e[1] || 0 !== e[2]
              ? ((this.cartographicCenter = new Qe()),
                Pn.WGS84.cartesianToCartographic(e, this.cartographicCenter))
              : (this.cartographicCenter = new Qe(0, 0, -Pn.WGS84.radii[0])),
              (this.cartesianCenter = e),
              (this.zoom = (function (t, e) {
                if (t instanceof tr) {
                  const { halfAxes: n } = t,
                    r = (function (t) {
                      t.getColumn(0, Nr);
                      const e = t.getColumn(1),
                        n = t.getColumn(2);
                      return Nr.add(e).add(n).len();
                    })(n);
                  return Math.log2(Ur / (r + e[2]));
                }
                if (t instanceof Qn) {
                  const { radius: n } = t;
                  return Math.log2(Ur / (n + e[2]));
                }
                if (t.width && t.height) {
                  const { width: e, height: n } = t;
                  return (Math.log2(6378137 / e) + Math.log2(6378137 / n)) / 2;
                }
                return 1;
              })(t.boundingVolume, this.cartographicCenter));
          }
          _initializeStats() {
            this.stats.get(bs),
              this.stats.get(vs),
              this.stats.get(Cs),
              this.stats.get(ws),
              this.stats.get(Es),
              this.stats.get(Ts),
              this.stats.get(_s),
              this.stats.get(Ms),
              this.stats.get(Is),
              this.stats.get(xs, 'memory'),
              this.stats.get(Fs);
          }
          _initializeTileHeaders(t, e) {
            const n = new ms(this, t.root, e);
            if (
              (e && (e.children.push(n), (n.depth = e.depth + 1)),
              this.type === jr.TILES3D)
            ) {
              const t = [];
              for (t.push(n); t.length > 0; ) {
                const e = t.pop();
                this.stats.get(bs).incrementCount();
                const n = e.header.children || [];
                for (const s of n) {
                  var r;
                  const n = new ms(this, s, e);
                  if (
                    null !== (r = n.contentUrl) &&
                    void 0 !== r &&
                    r.includes('?session=')
                  ) {
                    const t = new URL(n.contentUrl).searchParams.get('session');
                    t && (this._queryParams.session = t);
                  }
                  e.children.push(n), (n.depth = e.depth + 1), t.push(n);
                }
              }
            }
            return n;
          }
          _initializeTraverser() {
            let t;
            switch (this.type) {
              case jr.TILES3D:
                t = gs;
                break;
              case jr.I3S:
                t = ys;
                break;
              default:
                t = ds;
            }
            return new t({
              basePath: this.basePath,
              onTraversalEnd: this._onTraversalEnd.bind(this)
            });
          }
          _destroyTileHeaders(t) {
            this._destroySubtree(t);
          }
          async _loadTile(t) {
            let e;
            try {
              this._onStartTileLoading(), (e = await t.loadContent());
            } catch (e) {
              this._onTileLoadError(
                t,
                e instanceof Error ? e : new Error('load failed')
              );
            } finally {
              this._onEndTileLoading(), this._onTileLoad(t, e);
            }
          }
          _onTileLoadError(t, e) {
            this.stats.get(Ms).incrementCount();
            const n = e.message || e.toString(),
              r = t.url;
            console.error(`A 3D tile failed to load: ${t.url} ${n}`),
              this.options.onTileError(t, n, r);
          }
          _onTileLoad(t, e) {
            if (e) {
              if (this.type === jr.I3S) {
                var r, s;
                const t =
                  (null === (r = this.tileset) ||
                  void 0 === r ||
                  null === (s = r.nodePagesTile) ||
                  void 0 === s
                    ? void 0
                    : s.nodesInNodePages) || 0;
                this.stats.get(bs).reset(), this.stats.get(bs).addCount(t);
              }
              t &&
                t.content &&
                (function (t, e) {
                  n(t), n(e);
                  const { rtcCenter: r, gltfUpAxis: s } = e,
                    {
                      computedTransform: i,
                      boundingVolume: { center: o }
                    } = t;
                  let a = new hn(i);
                  switch ((r && a.translate(r), s)) {
                    case 'Z':
                      break;
                    case 'Y':
                      const t = new hn().rotateX(Math.PI / 2);
                      a = a.multiplyRight(t);
                      break;
                    case 'X':
                      const e = new hn().rotateY(-Math.PI / 2);
                      a = a.multiplyRight(e);
                  }
                  e.isQuantized &&
                    a
                      .translate(e.quantizedVolumeOffset)
                      .scale(e.quantizedVolumeScale);
                  const c = new Qe(o);
                  (e.cartesianModelMatrix = a), (e.cartesianOrigin = c);
                  const l = Pn.WGS84.cartesianToCartographic(c, new Qe()),
                    h = Pn.WGS84.eastNorthUpToFixedFrame(c).invert();
                  (e.cartographicModelMatrix = h.multiplyRight(a)),
                    (e.cartographicOrigin = l),
                    e.coordinateSystem ||
                      (e.modelMatrix = e.cartographicModelMatrix);
                })(t, t.content),
                this.updateContentTypes(t),
                this._addTileToCache(t),
                this.options.onTileLoad(t);
            }
          }
          updateContentTypes(t) {
            if (this.type === jr.I3S)
              switch (
                (t.header.isDracoGeometry && (this.contentFormats.draco = !0),
                t.header.textureFormat)
              ) {
                case 'dds':
                  this.contentFormats.dds = !0;
                  break;
                case 'ktx2':
                  this.contentFormats.ktx2 = !0;
              }
            else if (this.type === jr.TILES3D) {
              var e;
              const { extensionsRemoved: n = [] } =
                (null === (e = t.content) || void 0 === e ? void 0 : e.gltf) ||
                {};
              n.includes('KHR_draco_mesh_compression') &&
                (this.contentFormats.draco = !0),
                n.includes('EXT_meshopt_compression') &&
                  (this.contentFormats.meshopt = !0),
                n.includes('KHR_texture_basisu') &&
                  (this.contentFormats.ktx2 = !0);
            }
          }
          _onStartTileLoading() {
            this._pendingCount++, this.stats.get(vs).incrementCount();
          }
          _onEndTileLoading() {
            this._pendingCount--, this.stats.get(vs).decrementCount();
          }
          _addTileToCache(t) {
            this._cache.add(this, t, (e) => e._updateCacheStats(t));
          }
          _updateCacheStats(t) {
            this.stats.get(Ts).incrementCount(),
              this.stats.get(Cs).incrementCount(),
              (this.gpuMemoryUsageInBytes += t.gpuMemoryUsageInBytes || 0),
              (this.stats.get(xs).count = this.gpuMemoryUsageInBytes),
              this.options.memoryAdjustedScreenSpaceError &&
                this.adjustScreenSpaceError();
          }
          _unloadTile(t) {
            (this.gpuMemoryUsageInBytes -= t.gpuMemoryUsageInBytes || 0),
              this.stats.get(Cs).decrementCount(),
              this.stats.get(_s).incrementCount(),
              (this.stats.get(xs).count = this.gpuMemoryUsageInBytes),
              this.options.onTileUnload(t),
              t.unloadContent();
          }
          _destroy() {
            const t = [];
            for (this.root && t.push(this.root); t.length > 0; ) {
              const e = t.pop();
              for (const n of e.children) t.push(n);
              this._destroyTile(e);
            }
            this.root = null;
          }
          _destroySubtree(t) {
            const e = t,
              n = [];
            for (n.push(e); n.length > 0; ) {
              t = n.pop();
              for (const e of t.children) n.push(e);
              t !== e && this._destroyTile(t);
            }
            e.children = [];
          }
          _destroyTile(t) {
            this._cache.unloadTile(this, t), this._unloadTile(t), t.destroy();
          }
          _initializeTiles3DTileset(t) {
            if (t.queryString) {
              const e = new URLSearchParams(t.queryString),
                n = Object.fromEntries(e.entries());
              this._queryParams = { ...this._queryParams, ...n };
            }
            if (((this.asset = t.asset), !this.asset))
              throw new Error('Tileset must have an asset property.');
            if (
              '0.0' !== this.asset.version &&
              '1.0' !== this.asset.version &&
              '1.1' !== this.asset.version
            )
              throw new Error(
                'The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.'
              );
            'tilesetVersion' in this.asset &&
              (this._queryParams.v = this.asset.tilesetVersion),
              (this.credits = {
                attributions: this.options.attributions || []
              }),
              (this.description = this.options.description || ''),
              (this.properties = t.properties),
              (this.geometricError = t.geometricError),
              (this._extensionsUsed = t.extensionsUsed || []),
              (this.extras = t.extras);
          }
          _initializeI3STileset() {
            this.loadOptions.i3s &&
              'token' in this.loadOptions.i3s &&
              (this._queryParams.token = this.loadOptions.i3s.token);
          }
        }
        const Rs = '4.1.1',
          Ss = 'cmpt',
          Ds = 'pnts',
          Gs = 'b3dm',
          Ls = 'i3dm',
          Us = 'glTF';
        function Ns(t, e, r) {
          n(t instanceof ArrayBuffer);
          const s = new TextDecoder('utf8'),
            i = new Uint8Array(t, e, r);
          return s.decode(i);
        }
        function Hs(t) {
          let e =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
          const n = new DataView(t);
          return `${String.fromCharCode(
            n.getUint8(e + 0)
          )}${String.fromCharCode(n.getUint8(e + 1))}${String.fromCharCode(
            n.getUint8(e + 2)
          )}${String.fromCharCode(n.getUint8(e + 3))}`;
        }
        const Ps = {
          name: 'Draco',
          id: 'draco',
          module: 'draco',
          version: '4.1.1',
          worker: !0,
          extensions: ['drc'],
          mimeTypes: ['application/octet-stream'],
          binary: !0,
          tests: ['DRACO'],
          options: {
            draco: {
              decoderType: 'object' == typeof WebAssembly ? 'wasm' : 'js',
              libraryPath: 'libs/',
              extraAttributes: {},
              attributeNameEntry: void 0
            }
          }
        };
        function Js(t, e, n) {
          return (function (t, e, n) {
            const r = (function (t) {
                switch (t.constructor) {
                  case Int8Array:
                    return 'int8';
                  case Uint8Array:
                  case Uint8ClampedArray:
                    return 'uint8';
                  case Int16Array:
                    return 'int16';
                  case Uint16Array:
                    return 'uint16';
                  case Int32Array:
                    return 'int32';
                  case Uint32Array:
                    return 'uint32';
                  case Float32Array:
                    return 'float32';
                  case Float64Array:
                    return 'float64';
                  default:
                    return 'null';
                }
              })(e.value),
              s =
                n ||
                (function (t) {
                  const e = {};
                  return (
                    'byteOffset' in t &&
                      (e.byteOffset = t.byteOffset.toString(10)),
                    'byteStride' in t &&
                      (e.byteStride = t.byteStride.toString(10)),
                    'normalized' in t &&
                      (e.normalized = t.normalized.toString()),
                    e
                  );
                })(e);
            return {
              name: t,
              type: {
                type: 'fixed-size-list',
                listSize: e.size,
                children: [{ name: 'value', type: r }]
              },
              nullable: !1,
              metadata: s
            };
          })(t, e, n ? js(n.metadata) : void 0);
        }
        function js(t) {
          Object.entries(t);
          const e = {};
          for (const n in t) e[`${n}.string`] = JSON.stringify(t[n]);
          return e;
        }
        const ks = {
            POSITION: 'POSITION',
            NORMAL: 'NORMAL',
            COLOR: 'COLOR_0',
            TEX_COORD: 'TEXCOORD_0'
          },
          Vs = {
            1: Int8Array,
            2: Uint8Array,
            3: Int16Array,
            4: Uint16Array,
            5: Int32Array,
            6: Uint32Array,
            9: Float32Array
          };
        class Ks {
          constructor(t) {
            (this.draco = void 0),
              (this.decoder = void 0),
              (this.metadataQuerier = void 0),
              (this.draco = t),
              (this.decoder = new this.draco.Decoder()),
              (this.metadataQuerier = new this.draco.MetadataQuerier());
          }
          destroy() {
            this.draco.destroy(this.decoder),
              this.draco.destroy(this.metadataQuerier);
          }
          parseSync(t) {
            let e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {};
            const n = new this.draco.DecoderBuffer();
            n.Init(new Int8Array(t), t.byteLength),
              this._disableAttributeTransforms(e);
            const r = this.decoder.GetEncodedGeometryType(n),
              s =
                r === this.draco.TRIANGULAR_MESH
                  ? new this.draco.Mesh()
                  : new this.draco.PointCloud();
            try {
              let t;
              switch (r) {
                case this.draco.TRIANGULAR_MESH:
                  t = this.decoder.DecodeBufferToMesh(n, s);
                  break;
                case this.draco.POINT_CLOUD:
                  t = this.decoder.DecodeBufferToPointCloud(n, s);
                  break;
                default:
                  throw new Error('DRACO: Unknown geometry type.');
              }
              if (!t.ok() || !s.ptr) {
                const e = `DRACO decompression failed: ${t.error_msg()}`;
                throw new Error(e);
              }
              const i = this._getDracoLoaderData(s, r, e),
                o = this._getMeshData(s, i, e),
                a = (function (t) {
                  let e = 1 / 0,
                    n = 1 / 0,
                    r = 1 / 0,
                    s = -1 / 0,
                    i = -1 / 0,
                    o = -1 / 0;
                  const a = t.POSITION ? t.POSITION.value : [],
                    c = a && a.length;
                  for (let t = 0; t < c; t += 3) {
                    const c = a[t],
                      l = a[t + 1],
                      h = a[t + 2];
                    (e = c < e ? c : e),
                      (n = l < n ? l : n),
                      (r = h < r ? h : r),
                      (s = c > s ? c : s),
                      (i = l > i ? l : i),
                      (o = h > o ? h : o);
                  }
                  return [
                    [e, n, r],
                    [s, i, o]
                  ];
                })(o.attributes),
                c = (function (t, e, n) {
                  const r = js(e.metadata),
                    s = [],
                    i = (function (t) {
                      const e = {};
                      for (const n in t) {
                        const r = t[n];
                        e[r.name || 'undefined'] = r;
                      }
                      return e;
                    })(e.attributes);
                  for (const e in t) {
                    const n = Js(e, t[e], i[e]);
                    s.push(n);
                  }
                  if (n) {
                    const t = Js('indices', n);
                    s.push(t);
                  }
                  return { fields: s, metadata: r };
                })(o.attributes, i, o.indices);
              return {
                loader: 'draco',
                loaderData: i,
                header: { vertexCount: s.num_points(), boundingBox: a },
                ...o,
                schema: c
              };
            } finally {
              this.draco.destroy(n), s && this.draco.destroy(s);
            }
          }
          _getDracoLoaderData(t, e, n) {
            const r = this._getTopLevelMetadata(t),
              s = this._getDracoAttributes(t, n);
            return {
              geometry_type: e,
              num_attributes: t.num_attributes(),
              num_points: t.num_points(),
              num_faces: t instanceof this.draco.Mesh ? t.num_faces() : 0,
              metadata: r,
              attributes: s
            };
          }
          _getDracoAttributes(t, e) {
            const n = {};
            for (let r = 0; r < t.num_attributes(); r++) {
              const s = this.decoder.GetAttribute(t, r),
                i = this._getAttributeMetadata(t, r);
              n[s.unique_id()] = {
                unique_id: s.unique_id(),
                attribute_type: s.attribute_type(),
                data_type: s.data_type(),
                num_components: s.num_components(),
                byte_offset: s.byte_offset(),
                byte_stride: s.byte_stride(),
                normalized: s.normalized(),
                attribute_index: r,
                metadata: i
              };
              const o = this._getQuantizationTransform(s, e);
              o && (n[s.unique_id()].quantization_transform = o);
              const a = this._getOctahedronTransform(s, e);
              a && (n[s.unique_id()].octahedron_transform = a);
            }
            return n;
          }
          _getMeshData(t, e, n) {
            const r = this._getMeshAttributes(e, t, n);
            if (!r.POSITION)
              throw new Error('DRACO: No position attribute found.');
            return t instanceof this.draco.Mesh
              ? 'triangle-strip' === n.topology
                ? {
                    topology: 'triangle-strip',
                    mode: 4,
                    attributes: r,
                    indices: {
                      value: this._getTriangleStripIndices(t),
                      size: 1
                    }
                  }
                : {
                    topology: 'triangle-list',
                    mode: 5,
                    attributes: r,
                    indices: { value: this._getTriangleListIndices(t), size: 1 }
                  }
              : { topology: 'point-list', mode: 0, attributes: r };
          }
          _getMeshAttributes(t, e, n) {
            const r = {};
            for (const s of Object.values(t.attributes)) {
              const t = this._deduceAttributeName(s, n);
              s.name = t;
              const { value: i, size: o } = this._getAttributeValues(e, s);
              r[t] = {
                value: i,
                size: o,
                byteOffset: s.byte_offset,
                byteStride: s.byte_stride,
                normalized: s.normalized
              };
            }
            return r;
          }
          _getTriangleListIndices(t) {
            const e = 3 * t.num_faces(),
              n = 4 * e,
              r = this.draco._malloc(n);
            try {
              return (
                this.decoder.GetTrianglesUInt32Array(t, n, r),
                new Uint32Array(this.draco.HEAPF32.buffer, r, e).slice()
              );
            } finally {
              this.draco._free(r);
            }
          }
          _getTriangleStripIndices(t) {
            const e = new this.draco.DracoInt32Array();
            try {
              return (
                this.decoder.GetTriangleStripsFromMesh(t, e),
                (function (t) {
                  const e = t.size(),
                    n = new Int32Array(e);
                  for (let r = 0; r < e; r++) n[r] = t.GetValue(r);
                  return n;
                })(e)
              );
            } finally {
              this.draco.destroy(e);
            }
          }
          _getAttributeValues(t, e) {
            const n = Vs[e.data_type],
              r = e.num_components,
              s = t.num_points() * r,
              i = s * n.BYTES_PER_ELEMENT,
              o = (function (t, e) {
                switch (e) {
                  case Float32Array:
                    return t.DT_FLOAT32;
                  case Int8Array:
                    return t.DT_INT8;
                  case Int16Array:
                    return t.DT_INT16;
                  case Int32Array:
                    return t.DT_INT32;
                  case Uint8Array:
                    return t.DT_UINT8;
                  case Uint16Array:
                    return t.DT_UINT16;
                  case Uint32Array:
                    return t.DT_UINT32;
                  default:
                    return t.DT_INVALID;
                }
              })(this.draco, n);
            let a;
            const c = this.draco._malloc(i);
            try {
              const r = this.decoder.GetAttribute(t, e.attribute_index);
              this.decoder.GetAttributeDataArrayForAllPoints(t, r, o, i, c),
                (a = new n(this.draco.HEAPF32.buffer, c, s).slice());
            } finally {
              this.draco._free(c);
            }
            return { value: a, size: r };
          }
          _deduceAttributeName(t, e) {
            const n = t.unique_id;
            for (const [t, r] of Object.entries(e.extraAttributes || {}))
              if (r === n) return t;
            const r = t.attribute_type;
            for (const t in ks) if (this.draco[t] === r) return ks[t];
            const s = e.attributeNameEntry || 'name';
            return t.metadata[s]
              ? t.metadata[s].string
              : `CUSTOM_ATTRIBUTE_${n}`;
          }
          _getTopLevelMetadata(t) {
            const e = this.decoder.GetMetadata(t);
            return this._getDracoMetadata(e);
          }
          _getAttributeMetadata(t, e) {
            const n = this.decoder.GetAttributeMetadata(t, e);
            return this._getDracoMetadata(n);
          }
          _getDracoMetadata(t) {
            if (!t || !t.ptr) return {};
            const e = {},
              n = this.metadataQuerier.NumEntries(t);
            for (let r = 0; r < n; r++) {
              const n = this.metadataQuerier.GetEntryName(t, r);
              e[n] = this._getDracoMetadataField(t, n);
            }
            return e;
          }
          _getDracoMetadataField(t, e) {
            const n = new this.draco.DracoInt32Array();
            try {
              this.metadataQuerier.GetIntEntryArray(t, e, n);
              const r = (function (t) {
                const e = t.size(),
                  n = new Int32Array(e);
                for (let r = 0; r < e; r++) n[r] = t.GetValue(r);
                return n;
              })(n);
              return {
                int: this.metadataQuerier.GetIntEntry(t, e),
                string: this.metadataQuerier.GetStringEntry(t, e),
                double: this.metadataQuerier.GetDoubleEntry(t, e),
                intArray: r
              };
            } finally {
              this.draco.destroy(n);
            }
          }
          _disableAttributeTransforms(t) {
            const {
                quantizedAttributes: e = [],
                octahedronAttributes: n = []
              } = t,
              r = [...e, ...n];
            for (const t of r)
              this.decoder.SkipAttributeTransform(this.draco[t]);
          }
          _getQuantizationTransform(t, e) {
            const { quantizedAttributes: n = [] } = e,
              r = t.attribute_type();
            if (n.map((t) => this.decoder[t]).includes(r)) {
              const e = new this.draco.AttributeQuantizationTransform();
              try {
                if (e.InitFromAttribute(t))
                  return {
                    quantization_bits: e.quantization_bits(),
                    range: e.range(),
                    min_values: new Float32Array([1, 2, 3]).map((t) =>
                      e.min_value(t)
                    )
                  };
              } finally {
                this.draco.destroy(e);
              }
            }
            return null;
          }
          _getOctahedronTransform(t, e) {
            const { octahedronAttributes: n = [] } = e,
              r = t.attribute_type();
            if (n.map((t) => this.decoder[t]).includes(r)) {
              const e = new this.draco.AttributeQuantizationTransform();
              try {
                if (e.InitFromAttribute(t))
                  return { quantization_bits: e.quantization_bits() };
              } finally {
                this.draco.destroy(e);
              }
            }
            return null;
          }
        }
        const Qs = 'https://www.gstatic.com/draco/versioned/decoders/1.5.6',
          qs = 'draco_wasm_wrapper.js',
          Ws = 'draco_decoder.wasm',
          zs = 'draco_decoder.js',
          Xs = 'draco_encoder.js',
          Ys = {
            [qs]: `${Qs}/${qs}`,
            [Ws]: `${Qs}/draco_decoder.wasm`,
            [zs]: `${Qs}/draco_decoder.js`,
            [Xs]: `https://raw.githubusercontent.com/google/draco/1.4.1/javascript/${Xs}`
          };
        let Zs;
        const $s = {
            ...Ps,
            parse: async function (t, e) {
              const { draco: n } = await (async function (t) {
                  const e = t.modules || {};
                  return (
                    (Zs = e.draco3d
                      ? Zs ||
                        e.draco3d
                          .createDecoderModule({})
                          .then((t) => ({ draco: t }))
                      : Zs ||
                        (async function (t) {
                          let e, n;
                          return (
                            'js' === (t.draco && t.draco.decoderType)
                              ? (e = await F(
                                  Ys['draco_decoder.js'],
                                  'draco',
                                  t,
                                  zs
                                ))
                              : ([e, n] = await Promise.all([
                                  await F(Ys[qs], 'draco', t, qs),
                                  await F(Ys[Ws], 'draco', t, Ws)
                                ])),
                            (e = e || globalThis.DracoDecoderModule),
                            await (function (t, e) {
                              const n = {};
                              return (
                                e && (n.wasmBinary = e),
                                new Promise((e) => {
                                  t({
                                    ...n,
                                    onModuleLoaded: (t) => e({ draco: t })
                                  });
                                })
                              );
                            })(e, n)
                          );
                        })(t)),
                    await Zs
                  );
                })(e),
                r = new Ks(n);
              try {
                return r.parseSync(t, null == e ? void 0 : e.draco);
              } finally {
                r.destroy();
              }
            }
          },
          ti = {
            BYTE: 5120,
            UNSIGNED_BYTE: 5121,
            SHORT: 5122,
            UNSIGNED_SHORT: 5123,
            INT: 5124,
            UNSIGNED_INT: 5125,
            FLOAT: 5126,
            DOUBLE: 5130
          },
          ei = {
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6,
            ...ti
          },
          ni = {
            [ti.DOUBLE]: Float64Array,
            [ti.FLOAT]: Float32Array,
            [ti.UNSIGNED_SHORT]: Uint16Array,
            [ti.UNSIGNED_INT]: Uint32Array,
            [ti.UNSIGNED_BYTE]: Uint8Array,
            [ti.BYTE]: Int8Array,
            [ti.SHORT]: Int16Array,
            [ti.INT]: Int32Array
          },
          ri = {
            DOUBLE: ti.DOUBLE,
            FLOAT: ti.FLOAT,
            UNSIGNED_SHORT: ti.UNSIGNED_SHORT,
            UNSIGNED_INT: ti.UNSIGNED_INT,
            UNSIGNED_BYTE: ti.UNSIGNED_BYTE,
            BYTE: ti.BYTE,
            SHORT: ti.SHORT,
            INT: ti.INT
          },
          si = 'Failed to convert GL type';
        class ii {
          static fromTypedArray(t) {
            t = ArrayBuffer.isView(t) ? t.constructor : t;
            for (const e in ni) if (ni[e] === t) return e;
            throw new Error(si);
          }
          static fromName(t) {
            const e = ri[t];
            if (!e) throw new Error(si);
            return e;
          }
          static getArrayType(t) {
            switch (t) {
              case ti.UNSIGNED_SHORT_5_6_5:
              case ti.UNSIGNED_SHORT_4_4_4_4:
              case ti.UNSIGNED_SHORT_5_5_5_1:
                return Uint16Array;
              default:
                const e = ni[t];
                if (!e) throw new Error(si);
                return e;
            }
          }
          static getByteSize(t) {
            return ii.getArrayType(t).BYTES_PER_ELEMENT;
          }
          static validate(t) {
            return !!ii.getArrayType(t);
          }
          static createTypedArray(t, e) {
            let n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 0,
              r = arguments.length > 3 ? arguments[3] : void 0;
            return (
              void 0 === r && (r = (e.byteLength - n) / ii.getByteSize(t)),
              new (ii.getArrayType(t))(e, n, r)
            );
          }
        }
        function oi(t) {
          let e =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : [0, 0, 0];
          const n = (t >> 11) & 31,
            r = (t >> 5) & 63,
            s = 31 & t;
          return (e[0] = n << 3), (e[1] = r << 2), (e[2] = s << 3), e;
        }
        function ai(t) {
          let e =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : 255;
          return (ye(t, 0, e) / e) * 2 - 1;
        }
        function ci(t) {
          return t < 0 ? -1 : 1;
        }
        function li(t, e, n) {
          return (function (t, e, n, r) {
            if (
              ((function (t, e) {
                if (!t) throw new Error('math.gl assertion failed. undefined');
              })(r),
              t < 0 || t > n || e < 0 || e > n)
            )
              throw new Error(
                `x and y must be unsigned normalized integers between 0 and ${n}`
              );
            if (
              ((r.x = ai(t, n)),
              (r.y = ai(e, n)),
              (r.z = 1 - (Math.abs(r.x) + Math.abs(r.y))),
              r.z < 0)
            ) {
              const t = r.x;
              (r.x = (1 - Math.abs(r.y)) * ci(t)),
                (r.y = (1 - Math.abs(t)) * ci(r.y));
            }
            return r.normalize();
          })(t, e, 255, n);
        }
        new Se(), new Qe(), new Se(), new Se();
        class hi {
          constructor(t, e) {
            (this.json = void 0),
              (this.buffer = void 0),
              (this.featuresLength = 0),
              (this._cachedTypedArrays = {}),
              (this.json = t),
              (this.buffer = e);
          }
          getExtension(t) {
            return this.json.extensions && this.json.extensions[t];
          }
          hasProperty(t) {
            return !!this.json[t];
          }
          getGlobalProperty(t) {
            let e =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : ei.UNSIGNED_INT,
              n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 1;
            const r = this.json[t];
            return r && Number.isFinite(r.byteOffset)
              ? this._getTypedArrayFromBinary(t, e, n, 1, r.byteOffset)
              : r;
          }
          getPropertyArray(t, e, n) {
            const r = this.json[t];
            return r && Number.isFinite(r.byteOffset)
              ? ('componentType' in r && (e = ii.fromName(r.componentType)),
                this._getTypedArrayFromBinary(
                  t,
                  e,
                  n,
                  this.featuresLength,
                  r.byteOffset
                ))
              : this._getTypedArrayFromArray(t, e, r);
          }
          getProperty(t, e, n, r, s) {
            const i = this.json[t];
            if (!i) return i;
            const o = this.getPropertyArray(t, e, n);
            if (1 === n) return o[r];
            for (let t = 0; t < n; ++t) s[t] = o[n * r + t];
            return s;
          }
          _getTypedArrayFromBinary(t, e, n, r, s) {
            const i = this._cachedTypedArrays;
            let o = i[t];
            return (
              o ||
                ((o = ii.createTypedArray(
                  e,
                  this.buffer.buffer,
                  this.buffer.byteOffset + s,
                  r * n
                )),
                (i[t] = o)),
              o
            );
          }
          _getTypedArrayFromArray(t, e, n) {
            const r = this._cachedTypedArrays;
            let s = r[t];
            return s || ((s = ii.createTypedArray(e, n)), (r[t] = s)), s;
          }
        }
        const ui = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
          },
          di = {
            SCALAR: (t, e) => t[e],
            VEC2: (t, e) => [t[2 * e + 0], t[2 * e + 1]],
            VEC3: (t, e) => [t[3 * e + 0], t[3 * e + 1], t[3 * e + 2]],
            VEC4: (t, e) => [
              t[4 * e + 0],
              t[4 * e + 1],
              t[4 * e + 2],
              t[4 * e + 3]
            ],
            MAT2: (t, e) => [
              t[4 * e + 0],
              t[4 * e + 1],
              t[4 * e + 2],
              t[4 * e + 3]
            ],
            MAT3: (t, e) => [
              t[9 * e + 0],
              t[9 * e + 1],
              t[9 * e + 2],
              t[9 * e + 3],
              t[9 * e + 4],
              t[9 * e + 5],
              t[9 * e + 6],
              t[9 * e + 7],
              t[9 * e + 8]
            ],
            MAT4: (t, e) => [
              t[16 * e + 0],
              t[16 * e + 1],
              t[16 * e + 2],
              t[16 * e + 3],
              t[16 * e + 4],
              t[16 * e + 5],
              t[16 * e + 6],
              t[16 * e + 7],
              t[16 * e + 8],
              t[16 * e + 9],
              t[16 * e + 10],
              t[16 * e + 11],
              t[16 * e + 12],
              t[16 * e + 13],
              t[16 * e + 14],
              t[16 * e + 15]
            ]
          },
          fi = {
            SCALAR: (t, e, n) => {
              e[n] = t;
            },
            VEC2: (t, e, n) => {
              (e[2 * n + 0] = t[0]), (e[2 * n + 1] = t[1]);
            },
            VEC3: (t, e, n) => {
              (e[3 * n + 0] = t[0]),
                (e[3 * n + 1] = t[1]),
                (e[3 * n + 2] = t[2]);
            },
            VEC4: (t, e, n) => {
              (e[4 * n + 0] = t[0]),
                (e[4 * n + 1] = t[1]),
                (e[4 * n + 2] = t[2]),
                (e[4 * n + 3] = t[3]);
            },
            MAT2: (t, e, n) => {
              (e[4 * n + 0] = t[0]),
                (e[4 * n + 1] = t[1]),
                (e[4 * n + 2] = t[2]),
                (e[4 * n + 3] = t[3]);
            },
            MAT3: (t, e, n) => {
              (e[9 * n + 0] = t[0]),
                (e[9 * n + 1] = t[1]),
                (e[9 * n + 2] = t[2]),
                (e[9 * n + 3] = t[3]),
                (e[9 * n + 4] = t[4]),
                (e[9 * n + 5] = t[5]),
                (e[9 * n + 6] = t[6]),
                (e[9 * n + 7] = t[7]),
                (e[9 * n + 8] = t[8]),
                (e[9 * n + 9] = t[9]);
            },
            MAT4: (t, e, n) => {
              (e[16 * n + 0] = t[0]),
                (e[16 * n + 1] = t[1]),
                (e[16 * n + 2] = t[2]),
                (e[16 * n + 3] = t[3]),
                (e[16 * n + 4] = t[4]),
                (e[16 * n + 5] = t[5]),
                (e[16 * n + 6] = t[6]),
                (e[16 * n + 7] = t[7]),
                (e[16 * n + 8] = t[8]),
                (e[16 * n + 9] = t[9]),
                (e[16 * n + 10] = t[10]),
                (e[16 * n + 11] = t[11]),
                (e[16 * n + 12] = t[12]),
                (e[16 * n + 13] = t[13]),
                (e[16 * n + 14] = t[14]),
                (e[16 * n + 15] = t[15]);
            }
          },
          mi = (t) => void 0 !== t;
        function gi(t, e, n) {
          if (!t) return;
          const r = t.parentCounts;
          return t.parentIds
            ? n(t, e)
            : r > 0
            ? (function (t, e, n) {
                const r = t.classIds,
                  s = t.parentCounts,
                  i = t.parentIds,
                  o = t.parentIndexes,
                  a = r.length,
                  c = scratchVisited;
                c.length = Math.max(c.length, a);
                const l = ++marker,
                  h = scratchStack;
                for (h.length = 0, h.push(e); h.length > 0; ) {
                  if (c[(e = h.pop())] === l) continue;
                  c[e] = l;
                  const r = n(t, e);
                  if (mi(r)) return r;
                  const a = s[e],
                    u = o[e];
                  for (let t = 0; t < a; ++t) {
                    const n = i[u + t];
                    n !== e && h.push(n);
                  }
                }
                return null;
              })(t, e, n)
            : (function (t, e, n) {
                let r = !0;
                for (; r; ) {
                  const s = n(t, e);
                  if (mi(s)) return s;
                  const i = t.parentIds[e];
                  (r = i !== e), (e = i);
                }
                throw new Error('traverseHierarchySingleParent');
              })(t, e, n);
        }
        function Ai(t, e, n) {
          const r = t.parentCounts,
            s = t.parentIds,
            i = t.parentIndexes,
            o = t.classIds.length;
          if (!mi(s)) return;
          assert(
            e < o,
            `Parent index ${e} exceeds the total number of instances: ${o}`
          ),
            assert(
              -1 === n.indexOf(e),
              'Circular dependency detected in the batch table hierarchy.'
            ),
            n.push(e);
          const a = mi(r) ? r[e] : 1,
            c = mi(r) ? i[e] : e;
          for (let r = 0; r < a; ++r) {
            const i = s[c + r];
            i !== e && Ai(t, i, n);
          }
          n.pop(e);
        }
        function pi(t) {
          return null != t;
        }
        const yi = (t, e) => t,
          Bi = { HIERARCHY: !0, extensions: !0, extras: !0 };
        class bi {
          constructor(t, e, r) {
            var s;
            let i =
              arguments.length > 3 && void 0 !== arguments[3]
                ? arguments[3]
                : {};
            (this.json = void 0),
              (this.binary = void 0),
              (this.featureCount = void 0),
              (this._extensions = void 0),
              (this._properties = void 0),
              (this._binaryProperties = void 0),
              (this._hierarchy = void 0),
              n(r >= 0),
              (this.json = t || {}),
              (this.binary = e),
              (this.featureCount = r),
              (this._extensions =
                (null === (s = this.json) || void 0 === s
                  ? void 0
                  : s.extensions) || {}),
              (this._properties = {});
            for (const t in this.json)
              Bi[t] || (this._properties[t] = this.json[t]);
            (this._binaryProperties = this._initializeBinaryProperties()),
              i['3DTILES_batch_table_hierarchy'] &&
                (this._hierarchy = (function (t, e, n) {
                  if (!e) return null;
                  let r = t.getExtension('3DTILES_batch_table_hierarchy');
                  const s = e.HIERARCHY;
                  return (
                    s &&
                      (console.warn(
                        '3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.'
                      ),
                      (e.extensions = e.extensions || {}),
                      (e.extensions['3DTILES_batch_table_hierarchy'] = s),
                      (r = s)),
                    r
                      ? (function (t, e) {
                          let n, r, s;
                          const i = t.instancesLength,
                            o = t.classes;
                          let a,
                            c = t.classIds,
                            l = t.parentCounts,
                            h = t.parentIds,
                            u = i;
                          if (
                            (mi(c.byteOffset) &&
                              ((c.componentType = defaultValue(
                                c.componentType,
                                GL.UNSIGNED_SHORT
                              )),
                              (c.type = AttributeType.SCALAR),
                              (s = getBinaryAccessor(c)),
                              (c = s.createArrayBufferView(
                                e.buffer,
                                e.byteOffset + c.byteOffset,
                                i
                              ))),
                            mi(l))
                          )
                            for (
                              mi(l.byteOffset) &&
                                ((l.componentType = defaultValue(
                                  l.componentType,
                                  GL.UNSIGNED_SHORT
                                )),
                                (l.type = AttributeType.SCALAR),
                                (s = getBinaryAccessor(l)),
                                (l = s.createArrayBufferView(
                                  e.buffer,
                                  e.byteOffset + l.byteOffset,
                                  i
                                ))),
                                a = new Uint16Array(i),
                                u = 0,
                                n = 0;
                              n < i;
                              ++n
                            )
                              (a[n] = u), (u += l[n]);
                          mi(h) &&
                            mi(h.byteOffset) &&
                            ((h.componentType = defaultValue(
                              h.componentType,
                              GL.UNSIGNED_SHORT
                            )),
                            (h.type = AttributeType.SCALAR),
                            (s = getBinaryAccessor(h)),
                            (h = s.createArrayBufferView(
                              e.buffer,
                              e.byteOffset + h.byteOffset,
                              u
                            )));
                          const d = o.length;
                          for (n = 0; n < d; ++n) {
                            const t = o[n].length,
                              r = o[n].instances,
                              s = getBinaryProperties(t, r, e);
                            o[n].instances = combine(s, r);
                          }
                          const f = new Array(d).fill(0),
                            m = new Uint16Array(i);
                          for (n = 0; n < i; ++n)
                            (r = c[n]), (m[n] = f[r]), ++f[r];
                          const g = {
                            classes: o,
                            classIds: c,
                            classIndexes: m,
                            parentCounts: l,
                            parentIndexes: a,
                            parentIds: h
                          };
                          return (
                            (function (t) {
                              const e = t.classIds.length;
                              for (let n = 0; n < e; ++n) Ai(t, n, stack);
                            })(g),
                            g
                          );
                        })(r, n)
                      : null
                  );
                })(this, this.json, this.binary));
          }
          getExtension(t) {
            return this.json && this.json.extensions && this.json.extensions[t];
          }
          memorySizeInBytes() {
            return 0;
          }
          isClass(t, e) {
            return (
              this._checkBatchId(t),
              n('string' == typeof e, e),
              !!this._hierarchy &&
                pi(
                  gi(this._hierarchy, t, (t, n) => {
                    const r = t.classIds[n];
                    return t.classes[r].name === e;
                  })
                )
            );
          }
          isExactClass(t, e) {
            return n('string' == typeof e, e), this.getExactClassName(t) === e;
          }
          getExactClassName(t) {
            if ((this._checkBatchId(t), this._hierarchy)) {
              const e = this._hierarchy.classIds[t];
              return this._hierarchy.classes[e].name;
            }
          }
          hasProperty(t, e) {
            return (
              this._checkBatchId(t),
              n('string' == typeof e, e),
              pi(this._properties[e]) || this._hasPropertyInHierarchy(t, e)
            );
          }
          getPropertyNames(t, e) {
            this._checkBatchId(t), ((e = pi(e) ? e : []).length = 0);
            const n = Object.keys(this._properties);
            return (
              e.push(...n),
              this._hierarchy && this._getPropertyNamesInHierarchy(t, e),
              e
            );
          }
          getProperty(t, e) {
            if (
              (this._checkBatchId(t),
              n('string' == typeof e, e),
              this._binaryProperties)
            ) {
              const n = this._binaryProperties[e];
              if (pi(n)) return this._getBinaryProperty(n, t);
            }
            const r = this._properties[e];
            if (pi(r)) return yi(r[t]);
            if (this._hierarchy) {
              const n = this._getHierarchyProperty(t, e);
              if (pi(n)) return n;
            }
          }
          setProperty(t, e, r) {
            const s = this.featureCount;
            if (
              (this._checkBatchId(t),
              n('string' == typeof e, e),
              this._binaryProperties)
            ) {
              const n = this._binaryProperties[e];
              if (n) return void this._setBinaryProperty(n, t, r);
            }
            if (this._hierarchy && this._setHierarchyProperty(this, t, e, r))
              return;
            let i = this._properties[e];
            pi(i) ||
              ((this._properties[e] = new Array(s)), (i = this._properties[e])),
              (i[t] = yi(r));
          }
          _checkBatchId(t) {
            if (!(t >= 0 && t < this.featureCount))
              throw new Error('batchId not in range [0, featureCount - 1].');
          }
          _getBinaryProperty(t, e) {
            return t.unpack(t.typedArray, e);
          }
          _setBinaryProperty(t, e, n) {
            t.pack(n, t.typedArray, e);
          }
          _initializeBinaryProperties() {
            let t = null;
            for (const e in this._properties) {
              const n = this._properties[e],
                r = this._initializeBinaryProperty(e, n);
              r && ((t = t || {}), (t[e] = r));
            }
            return t;
          }
          _initializeBinaryProperty(t, e) {
            if ('byteOffset' in e) {
              const r = e;
              n(this.binary, `Property ${t} requires a batch table binary.`),
                n(r.type, `Property ${t} requires a type.`);
              const s = (function (t, e, r, s) {
                const { componentType: i } = t;
                n(t.componentType);
                const o = 'string' == typeof i ? ii.fromName(i) : i,
                  a = ui[t.type],
                  c = di[t.type],
                  l = fi[t.type];
                return (
                  (r += t.byteOffset),
                  {
                    values: ii.createTypedArray(o, e, r, a * s),
                    type: o,
                    size: a,
                    unpacker: c,
                    packer: l
                  }
                );
              })(
                r,
                this.binary.buffer,
                0 | this.binary.byteOffset,
                this.featureCount
              );
              return {
                typedArray: s.values,
                componentCount: s.size,
                unpack: s.unpacker,
                pack: s.packer
              };
            }
            return null;
          }
          _hasPropertyInHierarchy(t, e) {
            if (!this._hierarchy) return !1;
            const n = gi(this._hierarchy, t, (t, n) => {
              const r = t.classIds[n];
              return pi(t.classes[r].instances[e]);
            });
            return pi(n);
          }
          _getPropertyNamesInHierarchy(t, e) {
            gi(this._hierarchy, t, (t, n) => {
              const r = t.classIds[n],
                s = t.classes[r].instances;
              for (const t in s)
                s.hasOwnProperty(t) && -1 === e.indexOf(t) && e.push(t);
            });
          }
          _getHierarchyProperty(t, e) {
            return gi(this._hierarchy, t, (t, n) => {
              const r = t.classIds[n],
                s = t.classes[r],
                i = t.classIndexes[n],
                o = s.instances[e];
              return pi(o)
                ? pi(o.typedArray)
                  ? this._getBinaryProperty(o, i)
                  : yi(o[i])
                : null;
            });
          }
          _setHierarchyProperty(t, e, r, s) {
            const i = gi(this._hierarchy, e, (t, i) => {
              const o = t.classIds[i],
                a = t.classes[o],
                c = t.classIndexes[i],
                l = a.instances[r];
              return (
                !!pi(l) &&
                (n(i === e, `Inherited property "${r}" is read-only.`),
                pi(l.typedArray)
                  ? this._setBinaryProperty(l, c, s)
                  : (l[c] = yi(s)),
                !0)
              );
            });
            return pi(i);
          }
        }
        function Ci(t, e) {
          let n =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
          const r = new DataView(e);
          if (
            ((t.magic = r.getUint32(n, !0)),
            (n += 4),
            (t.version = r.getUint32(n, !0)),
            (n += 4),
            (t.byteLength = r.getUint32(n, !0)),
            (n += 4),
            1 !== t.version)
          )
            throw new Error(`3D Tile Version ${t.version} not supported`);
          return n;
        }
        const wi = 'b3dm tile in legacy format.';
        function Ei(t, e, n) {
          const r = new DataView(e);
          let s;
          t.header = t.header || {};
          let i = r.getUint32(n, !0);
          n += 4;
          let o = r.getUint32(n, !0);
          n += 4;
          let a = r.getUint32(n, !0);
          n += 4;
          let c = r.getUint32(n, !0);
          return (
            (n += 4),
            a >= 570425344
              ? ((n -= 8),
                (s = i),
                (a = o),
                (c = 0),
                (i = 0),
                (o = 0),
                console.warn(wi))
              : c >= 570425344 &&
                ((n -= 4),
                (s = a),
                (a = i),
                (c = o),
                (i = 0),
                (o = 0),
                console.warn(wi)),
            (t.header.featureTableJsonByteLength = i),
            (t.header.featureTableBinaryByteLength = o),
            (t.header.batchTableJsonByteLength = a),
            (t.header.batchTableBinaryByteLength = c),
            (t.header.batchLength = s),
            n
          );
        }
        function Ti(t, e, n, r) {
          return (
            (n = (function (t, e, n, r) {
              const {
                featureTableJsonByteLength: s,
                featureTableBinaryByteLength: i,
                batchLength: o
              } = t.header || {};
              if (
                ((t.featureTableJson = { BATCH_LENGTH: o || 0 }), s && s > 0)
              ) {
                const r = Ns(e, n, s);
                t.featureTableJson = JSON.parse(r);
              }
              return (
                (n += s || 0),
                (t.featureTableBinary = new Uint8Array(e, n, i)),
                n + (i || 0)
              );
            })(t, e, n)),
            (n = (function (t, e, n, r) {
              const {
                batchTableJsonByteLength: s,
                batchTableBinaryByteLength: i
              } = t.header || {};
              if (s && s > 0) {
                const r = Ns(e, n, s);
                (t.batchTableJson = JSON.parse(r)),
                  (n += s),
                  i &&
                    i > 0 &&
                    ((t.batchTableBinary = new Uint8Array(e, n, i)),
                    (t.batchTableBinary = new Uint8Array(t.batchTableBinary)),
                    (n += i));
              }
              return n;
            })(t, e, n)),
            n
          );
        }
        function vi(t, e, n) {
          if (!(e || (t && t.batchIds && n))) return null;
          const { batchIds: r, isRGB565: s, pointCount: i = 0 } = t;
          if (r && n) {
            const t = new Uint8ClampedArray(3 * i);
            for (let e = 0; e < i; e++) {
              const s = r[e],
                i = n.getProperty(s, 'dimensions').map((t) => 255 * t);
              (t[3 * e] = i[0]), (t[3 * e + 1] = i[1]), (t[3 * e + 2] = i[2]);
            }
            return {
              type: ei.UNSIGNED_BYTE,
              value: t,
              size: 3,
              normalized: !0
            };
          }
          if (e && s) {
            const t = new Uint8ClampedArray(3 * i);
            for (let n = 0; n < i; n++) {
              const r = oi(e[n]);
              (t[3 * n] = r[0]), (t[3 * n + 1] = r[1]), (t[3 * n + 2] = r[2]);
            }
            return {
              type: ei.UNSIGNED_BYTE,
              value: t,
              size: 3,
              normalized: !0
            };
          }
          return e && e.length === 3 * i
            ? { type: ei.UNSIGNED_BYTE, value: e, size: 3, normalized: !0 }
            : {
                type: ei.UNSIGNED_BYTE,
                value: e || new Uint8ClampedArray(),
                size: 4,
                normalized: !0
              };
        }
        const _i = new Qe();
        async function Mi(t, n, r, s, i) {
          (r = Ti(t, n, (r = Ei(t, n, (r = Ci(t, n, r)))))),
            (function (t) {
              (t.attributes = {
                positions: null,
                colors: null,
                normals: null,
                batchIds: null
              }),
                (t.isQuantized = !1),
                (t.isTranslucent = !1),
                (t.isRGB565 = !1),
                (t.isOctEncoded16P = !1);
            })(t);
          const { featureTable: o, batchTable: a } = (function (t) {
            const e = new hi(t.featureTableJson, t.featureTableBinary),
              n = e.getGlobalProperty('POINTS_LENGTH');
            if (!Number.isFinite(n))
              throw new Error('POINTS_LENGTH must be defined');
            (e.featuresLength = n),
              (t.featuresLength = n),
              (t.pointsLength = n),
              (t.pointCount = n),
              (t.rtcCenter = e.getGlobalProperty('RTC_CENTER', ei.FLOAT, 3));
            const r = (function (t, e) {
              let n = null;
              if (
                !t.batchIds &&
                e.hasProperty('BATCH_ID') &&
                ((t.batchIds = e.getPropertyArray(
                  'BATCH_ID',
                  ei.UNSIGNED_SHORT,
                  1
                )),
                t.batchIds)
              ) {
                const r = e.getGlobalProperty('BATCH_LENGTH');
                if (!r)
                  throw new Error(
                    'Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.'
                  );
                const { batchTableJson: s, batchTableBinary: i } = t;
                n = new bi(s, i, r);
              }
              return n;
            })(t, e);
            return { featureTable: e, batchTable: r };
          })(t);
          return (
            await (async function (t, n, r, s, i) {
              let o, a, c;
              const l =
                t.batchTableJson &&
                t.batchTableJson.extensions &&
                t.batchTableJson.extensions['3DTILES_draco_point_compression'];
              l && (c = l.properties);
              const h = n.getExtension('3DTILES_draco_point_compression');
              if (h) {
                a = h.properties;
                const e = h.byteOffset,
                  n = h.byteLength;
                if (!a || !Number.isFinite(e) || !n)
                  throw new Error(
                    'Draco properties, byteOffset, and byteLength must be defined'
                  );
                (o = (t.featureTableBinary || []).slice(e, e + n)),
                  (t.hasPositions = Number.isFinite(a.POSITION)),
                  (t.hasColors =
                    Number.isFinite(a.RGB) || Number.isFinite(a.RGBA)),
                  (t.hasNormals = Number.isFinite(a.NORMAL)),
                  (t.hasBatchIds = Number.isFinite(a.BATCH_ID)),
                  (t.isTranslucent = Number.isFinite(a.RGBA));
              }
              if (!o) return !0;
              const u = {
                buffer: o,
                properties: { ...a, ...c },
                featureTableProperties: a,
                batchTableProperties: c,
                dequantizeInShader: !1
              };
              return await (async function (t, n, r, s) {
                if (!s) return;
                const i = {
                  ...r,
                  draco: {
                    ...(null == r ? void 0 : r.draco),
                    extraAttributes: n.batchTableProperties || {}
                  }
                };
                delete i['3d-tiles'];
                const o = await e(n.buffer, $s, i, s),
                  a = o.attributes.POSITION && o.attributes.POSITION.value,
                  c = o.attributes.COLOR_0 && o.attributes.COLOR_0.value,
                  l = o.attributes.NORMAL && o.attributes.NORMAL.value,
                  h = o.attributes.BATCH_ID && o.attributes.BATCH_ID.value,
                  u = a && o.attributes.POSITION.value.quantization,
                  d = l && o.attributes.NORMAL.value.quantization;
                if (u) {
                  const e = o.POSITION.data.quantization,
                    n = e.range;
                  (t.quantizedVolumeScale = new Qe(n, n, n)),
                    (t.quantizedVolumeOffset = new Qe(e.minValues)),
                    (t.quantizedRange = (1 << e.quantizationBits) - 1),
                    (t.isQuantizedDraco = !0);
                }
                d &&
                  ((t.octEncodedRange =
                    (1 << o.NORMAL.data.quantization.quantizationBits) - 1),
                  (t.isOctEncodedDraco = !0));
                const f = {};
                if (n.batchTableProperties)
                  for (const t of Object.keys(n.batchTableProperties))
                    o.attributes[t] &&
                      o.attributes[t].value &&
                      (f[t.toLowerCase()] = o.attributes[t].value);
                t.attributes = {
                  positions: a,
                  colors: vi(t, c, void 0),
                  normals: l,
                  batchIds: h,
                  ...f
                };
              })(t, u, s, i);
            })(t, o, 0, s, i),
            (function (t, e, n) {
              if (
                ((t.attributes = t.attributes || {
                  positions: null,
                  colors: null,
                  normals: null,
                  batchIds: null
                }),
                !t.attributes.positions)
              )
                if (e.hasProperty('POSITION'))
                  t.attributes.positions = e.getPropertyArray(
                    'POSITION',
                    ei.FLOAT,
                    3
                  );
                else if (e.hasProperty('POSITION_QUANTIZED')) {
                  const r = e.getPropertyArray(
                    'POSITION_QUANTIZED',
                    ei.UNSIGNED_SHORT,
                    3
                  );
                  if (
                    ((t.isQuantized = !0),
                    (t.quantizedRange = 65535),
                    (t.quantizedVolumeScale = e.getGlobalProperty(
                      'QUANTIZED_VOLUME_SCALE',
                      ei.FLOAT,
                      3
                    )),
                    !t.quantizedVolumeScale)
                  )
                    throw new Error(
                      'QUANTIZED_VOLUME_SCALE must be defined for quantized positions.'
                    );
                  if (
                    ((t.quantizedVolumeOffset = e.getGlobalProperty(
                      'QUANTIZED_VOLUME_OFFSET',
                      ei.FLOAT,
                      3
                    )),
                    !t.quantizedVolumeOffset)
                  )
                    throw new Error(
                      'QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.'
                    );
                  t.attributes.positions = (function (t, e, n) {
                    return t.isQuantized
                      ? n['3d-tiles'] && n['3d-tiles'].decodeQuantizedPositions
                        ? ((t.isQuantized = !1),
                          (function (t, e) {
                            const n = new Qe(),
                              r = new Float32Array(3 * t.pointCount);
                            for (let s = 0; s < t.pointCount; s++)
                              n.set(e[3 * s], e[3 * s + 1], e[3 * s + 2])
                                .scale(1 / t.quantizedRange)
                                .multiply(t.quantizedVolumeScale)
                                .add(t.quantizedVolumeOffset)
                                .toArray(r, 3 * s);
                            return r;
                          })(t, e))
                        : {
                            type: ei.UNSIGNED_SHORT,
                            value: e,
                            size: 3,
                            normalized: !0
                          }
                      : e;
                  })(t, r, n);
                }
              if (!t.attributes.positions)
                throw new Error(
                  'Either POSITION or POSITION_QUANTIZED must be defined.'
                );
            })(t, o, s),
            (function (t, e, n) {
              if (
                ((t.attributes = t.attributes || {
                  positions: null,
                  colors: null,
                  normals: null,
                  batchIds: null
                }),
                !t.attributes.colors)
              ) {
                let r = null;
                e.hasProperty('RGBA')
                  ? ((r = e.getPropertyArray('RGBA', ei.UNSIGNED_BYTE, 4)),
                    (t.isTranslucent = !0))
                  : e.hasProperty('RGB')
                  ? (r = e.getPropertyArray('RGB', ei.UNSIGNED_BYTE, 3))
                  : e.hasProperty('RGB565') &&
                    ((r = e.getPropertyArray('RGB565', ei.UNSIGNED_SHORT, 1)),
                    (t.isRGB565 = !0)),
                  (t.attributes.colors = vi(t, r, n));
              }
              e.hasProperty('CONSTANT_RGBA') &&
                (t.constantRGBA = e.getGlobalProperty(
                  'CONSTANT_RGBA',
                  ei.UNSIGNED_BYTE,
                  4
                ));
            })(t, o, a),
            (function (t, e) {
              if (
                ((t.attributes = t.attributes || {
                  positions: null,
                  colors: null,
                  normals: null,
                  batchIds: null
                }),
                !t.attributes.normals)
              ) {
                let n = null;
                e.hasProperty('NORMAL')
                  ? (n = e.getPropertyArray('NORMAL', ei.FLOAT, 3))
                  : e.hasProperty('NORMAL_OCT16P') &&
                    ((n = e.getPropertyArray(
                      'NORMAL_OCT16P',
                      ei.UNSIGNED_BYTE,
                      2
                    )),
                    (t.isOctEncoded16P = !0)),
                  (t.attributes.normals = (function (t, e) {
                    if (!e) return null;
                    if (t.isOctEncoded16P) {
                      const n = new Float32Array(3 * (t.pointsLength || 0));
                      for (let r = 0; r < (t.pointsLength || 0); r++)
                        li(e[2 * r], e[2 * r + 1], _i), _i.toArray(n, 3 * r);
                      return { type: ei.FLOAT, size: 2, value: n };
                    }
                    return { type: ei.FLOAT, size: 2, value: e };
                  })(t, n));
              }
            })(t, o),
            r
          );
        }
        var Ii;
        const xi =
            null === (Ii = globalThis.loaders) || void 0 === Ii
              ? void 0
              : Ii.parseImageNode,
          Fi = typeof Image < 'u',
          Oi = typeof ImageBitmap < 'u',
          Ri = !!i || !!xi;
        function Si(t) {
          switch (
            (function (t) {
              const e = (function (t) {
                return typeof ImageBitmap < 'u' && t instanceof ImageBitmap
                  ? 'imagebitmap'
                  : typeof Image < 'u' && t instanceof Image
                  ? 'image'
                  : t && 'object' == typeof t && t.data && t.width && t.height
                  ? 'data'
                  : null;
              })(t);
              if (!e) throw new Error('Not an image');
              return e;
            })(t)
          ) {
            case 'data':
              return t;
            case 'image':
            case 'imagebitmap':
              const e = document.createElement('canvas'),
                n = e.getContext('2d');
              if (!n) throw new Error('getImageData');
              return (
                (e.width = t.width),
                (e.height = t.height),
                n.drawImage(t, 0, 0),
                n.getImageData(0, 0, t.width, t.height)
              );
            default:
              throw new Error('getImageData');
          }
        }
        const Di = /^data:image\/svg\+xml/,
          Gi = /\.svg((\?|#).*)?$/;
        function Li(t) {
          return t && (Di.test(t) || Gi.test(t));
        }
        function Ui(t, e) {
          if (Li(e))
            throw new Error('SVG cannot be parsed directly to imagebitmap');
          return new Blob([new Uint8Array(t)]);
        }
        async function Ni(t, e, n) {
          const r = (function (t, e) {
              if (Li(e)) {
                let e = new TextDecoder().decode(t);
                try {
                  'function' == typeof unescape &&
                    'function' == typeof encodeURIComponent &&
                    (e = unescape(encodeURIComponent(e)));
                } catch (t) {
                  throw new Error(t.message);
                }
                return `data:image/svg+xml;base64,${btoa(e)}`;
              }
              return Ui(t, e);
            })(t, n),
            s = self.URL || self.webkitURL,
            i = 'string' != typeof r && s.createObjectURL(r);
          try {
            return await (async function (t, e) {
              const n = new Image();
              return (
                (n.src = t),
                e.image && e.image.decode && n.decode
                  ? (await n.decode(), n)
                  : await new Promise((t, e) => {
                      try {
                        (n.onload = () => t(n)),
                          (n.onerror = (t) => {
                            const n = t instanceof Error ? t.message : 'error';
                            e(new Error(n));
                          });
                      } catch (t) {
                        e(t);
                      }
                    })
              );
            })(i || r, e);
          } finally {
            i && s.revokeObjectURL(i);
          }
        }
        const Hi = {};
        let Pi = !0;
        function Ji(t) {
          for (const e in t || Hi) return !1;
          return !0;
        }
        function ji(t) {
          return [...t].map((t) => t.charCodeAt(0));
        }
        const ki = !1,
          Vi = !0;
        function Ki(t) {
          const e = Qi(t);
          return (
            (function (t) {
              const e = Qi(t);
              return e.byteLength >= 24 && 2303741511 === e.getUint32(0, ki)
                ? {
                    mimeType: 'image/png',
                    width: e.getUint32(16, ki),
                    height: e.getUint32(20, ki)
                  }
                : null;
            })(e) ||
            (function (t) {
              const e = Qi(t);
              if (
                !(
                  e.byteLength >= 3 &&
                  65496 === e.getUint16(0, ki) &&
                  255 === e.getUint8(2)
                )
              )
                return null;
              const { tableMarkers: n, sofMarkers: r } = (function () {
                const t = new Set([65499, 65476, 65484, 65501, 65534]);
                for (let e = 65504; e < 65520; ++e) t.add(e);
                return {
                  tableMarkers: t,
                  sofMarkers: new Set([
                    65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481,
                    65482, 65483, 65485, 65486, 65487, 65502
                  ])
                };
              })();
              let s = 2;
              for (; s + 9 < e.byteLength; ) {
                const t = e.getUint16(s, ki);
                if (r.has(t))
                  return {
                    mimeType: 'image/jpeg',
                    height: e.getUint16(s + 5, ki),
                    width: e.getUint16(s + 7, ki)
                  };
                if (!n.has(t)) return null;
                (s += 2), (s += e.getUint16(s, ki));
              }
              return null;
            })(e) ||
            (function (t) {
              const e = Qi(t);
              return e.byteLength >= 10 && 1195984440 === e.getUint32(0, ki)
                ? {
                    mimeType: 'image/gif',
                    width: e.getUint16(6, Vi),
                    height: e.getUint16(8, Vi)
                  }
                : null;
            })(e) ||
            (function (t) {
              const e = Qi(t);
              return e.byteLength >= 14 &&
                16973 === e.getUint16(0, ki) &&
                e.getUint32(2, Vi) === e.byteLength
                ? {
                    mimeType: 'image/bmp',
                    width: e.getUint32(18, Vi),
                    height: e.getUint32(22, Vi)
                  }
                : null;
            })(e) ||
            (function (t) {
              const e = (function (t) {
                return (function (t, e) {
                  let n =
                    arguments.length > 2 && void 0 !== arguments[2]
                      ? arguments[2]
                      : 0;
                  const r = ji(e);
                  for (let e = 0; e < r.length; ++e)
                    if (r[e] !== t[e + n]) return !1;
                  return !0;
                })(t, 'ftyp', 4) && 96 & t[8]
                  ? (function (t) {
                      switch (
                        (function (t, e, n) {
                          return String.fromCharCode(...t.slice(8, 12));
                        })(t)
                          .replace('\0', ' ')
                          .trim()
                      ) {
                        case 'avif':
                        case 'avis':
                          return { extension: 'avif', mimeType: 'image/avif' };
                        default:
                          return null;
                      }
                    })(t)
                  : null;
              })(new Uint8Array(t instanceof DataView ? t.buffer : t));
              return e ? { mimeType: e.mimeType, width: 0, height: 0 } : null;
            })(e)
          );
        }
        function Qi(t) {
          if (t instanceof DataView) return t;
          if (ArrayBuffer.isView(t)) return new DataView(t.buffer);
          if (t instanceof ArrayBuffer) return new DataView(t);
          throw new Error('toDataView');
        }
        const qi = {
            id: 'image',
            module: 'images',
            name: 'Images',
            version: '4.1.1',
            mimeTypes: [
              'image/png',
              'image/jpeg',
              'image/gif',
              'image/webp',
              'image/avif',
              'image/bmp',
              'image/vnd.microsoft.icon',
              'image/svg+xml'
            ],
            extensions: [
              'png',
              'jpg',
              'jpeg',
              'gif',
              'webp',
              'bmp',
              'ico',
              'svg',
              'avif'
            ],
            parse: async function (t, e, r) {
              const s = ((e = e || {}).image || {}).type || 'auto',
                { url: i } = r || {},
                o = (function (t) {
                  switch (t) {
                    case 'auto':
                    case 'data':
                      return (function () {
                        if (Oi) return 'imagebitmap';
                        if (Fi) return 'image';
                        if (Ri) return 'data';
                        throw new Error(
                          "Install '@loaders.gl/polyfills' to parse images under Node.js"
                        );
                      })();
                    default:
                      return (
                        (function (t) {
                          switch (t) {
                            case 'auto':
                              return Oi || Fi || Ri;
                            case 'imagebitmap':
                              return Oi;
                            case 'image':
                              return Fi;
                            case 'data':
                              return Ri;
                            default:
                              throw new Error(
                                `@loaders.gl/images: image ${t} not supported in this environment`
                              );
                          }
                        })(t),
                        t
                      );
                  }
                })(s);
              let a;
              switch (o) {
                case 'imagebitmap':
                  a = await (async function (t, e, n) {
                    let r;
                    r = Li(n) ? await Ni(t, e, n) : Ui(t, n);
                    const s = e && e.imagebitmap;
                    return await (async function (t) {
                      let e =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : null;
                      if (((Ji(e) || !Pi) && (e = null), e))
                        try {
                          return await createImageBitmap(t, e);
                        } catch (t) {
                          console.warn(t), (Pi = !1);
                        }
                      return await createImageBitmap(t);
                    })(r, s);
                  })(t, e, i);
                  break;
                case 'image':
                  a = await Ni(t, e, i);
                  break;
                case 'data':
                  a = await (async function (t, e) {
                    var r;
                    const { mimeType: s } = Ki(t) || {},
                      i =
                        null === (r = globalThis.loaders) || void 0 === r
                          ? void 0
                          : r.parseImageNode;
                    return n(i), await i(t, s);
                  })(t);
                  break;
                default:
                  n(!1);
              }
              return 'data' === s && (a = Si(a)), a;
            },
            tests: [(t) => !!Ki(new DataView(t))],
            options: { image: { type: 'auto', decode: !0 } }
          },
          Wi = {};
        function zi(t, e) {
          if (!t) throw new Error(e || 'assert failed: gltf');
        }
        const Xi = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
          },
          Yi = { 5120: 1, 5121: 1, 5122: 2, 5123: 2, 5125: 4, 5126: 4 },
          Zi = ['SCALAR', 'VEC2', 'VEC3', 'VEC4'],
          $i = [
            [Int8Array, 5120],
            [Uint8Array, 5121],
            [Int16Array, 5122],
            [Uint16Array, 5123],
            [Uint32Array, 5125],
            [Float32Array, 5126],
            [Float64Array, 5130]
          ],
          to = new Map($i),
          eo = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
          },
          no = { 5120: 1, 5121: 1, 5122: 2, 5123: 2, 5125: 4, 5126: 4 },
          ro = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
          };
        function so(t) {
          return Zi[t - 1] || Zi[0];
        }
        function io(t) {
          const e = to.get(t.constructor);
          if (!e) throw new Error('Illegal typed array');
          return e;
        }
        function oo(t, e) {
          const n = ro[t.componentType],
            r = eo[t.type],
            s = no[t.componentType],
            i = t.count * r,
            o = t.count * r * s;
          return (
            zi(o >= 0 && o <= e.byteLength),
            {
              ArrayType: n,
              length: i,
              byteLength: o,
              componentByteSize: Yi[t.componentType],
              numberOfComponentsInElement: Xi[t.type]
            }
          );
        }
        function ao(t) {
          let { images: e, bufferViews: n } = t;
          (e = e || []), (n = n || []);
          const r = e.map((t) => t.bufferView);
          n = n.filter((t) => !r.includes(t));
          const s = n.reduce((t, e) => t + e.byteLength, 0),
            i = e.reduce((t, e) => {
              const { width: n, height: r } = e.image;
              return t + n * r;
            }, 0);
          return s + Math.ceil(4 * i * 1.33);
        }
        class co {
          constructor(t) {
            (this.gltf = void 0),
              (this.sourceBuffers = void 0),
              (this.byteLength = void 0),
              (this.gltf = {
                json: (null == t ? void 0 : t.json) || {
                  asset: { version: '2.0', generator: 'loaders.gl' },
                  buffers: [],
                  extensions: {},
                  extensionsRequired: [],
                  extensionsUsed: []
                },
                buffers: (null == t ? void 0 : t.buffers) || [],
                images: (null == t ? void 0 : t.images) || []
              }),
              (this.sourceBuffers = []),
              (this.byteLength = 0),
              this.gltf.buffers &&
                this.gltf.buffers[0] &&
                ((this.byteLength = this.gltf.buffers[0].byteLength),
                (this.sourceBuffers = [this.gltf.buffers[0]]));
          }
          get json() {
            return this.gltf.json;
          }
          getApplicationData(t) {
            return this.json[t];
          }
          getExtraData(t) {
            return (this.json.extras || {})[t];
          }
          hasExtension(t) {
            const e = this.getUsedExtensions().find((e) => e === t),
              n = this.getRequiredExtensions().find((e) => e === t);
            return 'string' == typeof e || 'string' == typeof n;
          }
          getExtension(t) {
            const e = this.getUsedExtensions().find((e) => e === t),
              n = this.json.extensions || {};
            return e ? n[t] : null;
          }
          getRequiredExtension(t) {
            return this.getRequiredExtensions().find((e) => e === t)
              ? this.getExtension(t)
              : null;
          }
          getRequiredExtensions() {
            return this.json.extensionsRequired || [];
          }
          getUsedExtensions() {
            return this.json.extensionsUsed || [];
          }
          getRemovedExtensions() {
            return this.json.extensionsRemoved || [];
          }
          getObjectExtension(t, e) {
            return (t.extensions || {})[e];
          }
          getScene(t) {
            return this.getObject('scenes', t);
          }
          getNode(t) {
            return this.getObject('nodes', t);
          }
          getSkin(t) {
            return this.getObject('skins', t);
          }
          getMesh(t) {
            return this.getObject('meshes', t);
          }
          getMaterial(t) {
            return this.getObject('materials', t);
          }
          getAccessor(t) {
            return this.getObject('accessors', t);
          }
          getTexture(t) {
            return this.getObject('textures', t);
          }
          getSampler(t) {
            return this.getObject('samplers', t);
          }
          getImage(t) {
            return this.getObject('images', t);
          }
          getBufferView(t) {
            return this.getObject('bufferViews', t);
          }
          getBuffer(t) {
            return this.getObject('buffers', t);
          }
          getObject(t, e) {
            if ('object' == typeof e) return e;
            const n = this.json[t] && this.json[t][e];
            if (!n)
              throw new Error(`glTF file error: Could not find ${t}[${e}]`);
            return n;
          }
          getTypedArrayForBufferView(t) {
            const e = (t = this.getBufferView(t)).buffer,
              n = this.gltf.buffers[e];
            zi(n);
            const r = (t.byteOffset || 0) + n.byteOffset;
            return new Uint8Array(n.arrayBuffer, r, t.byteLength);
          }
          getTypedArrayForAccessor(t) {
            const e = this.getAccessor(t);
            return (function (t, e, n) {
              var r, s;
              const i =
                'number' == typeof n
                  ? null === (r = t.accessors) || void 0 === r
                    ? void 0
                    : r[n]
                  : n;
              if (!i) throw new Error(`No gltf accessor ${JSON.stringify(n)}`);
              const o =
                null === (s = t.bufferViews) || void 0 === s
                  ? void 0
                  : s[i.bufferView || 0];
              if (!o) throw new Error(`No gltf buffer view for accessor ${o}`);
              const { arrayBuffer: a, byteOffset: c } = e[o.buffer],
                l = (c || 0) + (i.byteOffset || 0) + (o.byteOffset || 0),
                {
                  ArrayType: h,
                  length: u,
                  componentByteSize: d,
                  numberOfComponentsInElement: f
                } = oo(i, o),
                m = d * f,
                g = o.byteStride || m;
              if (typeof o.byteStride > 'u' || o.byteStride === m)
                return new h(a, l, u);
              const A = new h(u);
              for (let t = 0; t < i.count; t++) {
                const e = new h(a, l + t * g, f);
                A.set(e, t * f);
              }
              return A;
            })(this.gltf.json, this.gltf.buffers, e);
          }
          getTypedArrayForImageData(t) {
            t = this.getAccessor(t);
            const e = this.getBufferView(t.bufferView),
              n = this.getBuffer(e.buffer).data,
              r = e.byteOffset || 0;
            return new Uint8Array(n, r, e.byteLength);
          }
          addApplicationData(t, e) {
            return (this.json[t] = e), this;
          }
          addExtraData(t, e) {
            return (
              (this.json.extras = this.json.extras || {}),
              (this.json.extras[t] = e),
              this
            );
          }
          addObjectExtension(t, e, n) {
            return (
              (t.extensions = t.extensions || {}),
              (t.extensions[e] = n),
              this.registerUsedExtension(e),
              this
            );
          }
          setObjectExtension(t, e, n) {
            (t.extensions || {})[e] = n;
          }
          removeObjectExtension(t, e) {
            const n = (null == t ? void 0 : t.extensions) || {};
            if (n[e]) {
              this.json.extensionsRemoved = this.json.extensionsRemoved || [];
              const t = this.json.extensionsRemoved;
              t.includes(e) || t.push(e);
            }
            delete n[e];
          }
          addExtension(t) {
            let e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {};
            return (
              zi(e),
              (this.json.extensions = this.json.extensions || {}),
              (this.json.extensions[t] = e),
              this.registerUsedExtension(t),
              e
            );
          }
          addRequiredExtension(t) {
            let e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {};
            return (
              zi(e),
              this.addExtension(t, e),
              this.registerRequiredExtension(t),
              e
            );
          }
          registerUsedExtension(t) {
            (this.json.extensionsUsed = this.json.extensionsUsed || []),
              this.json.extensionsUsed.find((e) => e === t) ||
                this.json.extensionsUsed.push(t);
          }
          registerRequiredExtension(t) {
            this.registerUsedExtension(t),
              (this.json.extensionsRequired =
                this.json.extensionsRequired || []),
              this.json.extensionsRequired.find((e) => e === t) ||
                this.json.extensionsRequired.push(t);
          }
          removeExtension(t) {
            var e;
            if (null !== (e = this.json.extensions) && void 0 !== e && e[t]) {
              this.json.extensionsRemoved = this.json.extensionsRemoved || [];
              const e = this.json.extensionsRemoved;
              e.includes(t) || e.push(t);
            }
            this.json.extensions && delete this.json.extensions[t],
              this.json.extensionsRequired &&
                this._removeStringFromArray(this.json.extensionsRequired, t),
              this.json.extensionsUsed &&
                this._removeStringFromArray(this.json.extensionsUsed, t);
          }
          setDefaultScene(t) {
            this.json.scene = t;
          }
          addScene(t) {
            const { nodeIndices: e } = t;
            return (
              (this.json.scenes = this.json.scenes || []),
              this.json.scenes.push({ nodes: e }),
              this.json.scenes.length - 1
            );
          }
          addNode(t) {
            const { meshIndex: e, matrix: n } = t;
            this.json.nodes = this.json.nodes || [];
            const r = { mesh: e };
            return (
              n && (r.matrix = n),
              this.json.nodes.push(r),
              this.json.nodes.length - 1
            );
          }
          addMesh(t) {
            const { attributes: e, indices: n, material: r, mode: s = 4 } = t,
              i = {
                primitives: [{ attributes: this._addAttributes(e), mode: s }]
              };
            if (n) {
              const t = this._addIndices(n);
              i.primitives[0].indices = t;
            }
            return (
              Number.isFinite(r) && (i.primitives[0].material = r),
              (this.json.meshes = this.json.meshes || []),
              this.json.meshes.push(i),
              this.json.meshes.length - 1
            );
          }
          addPointCloud(t) {
            const e = {
              primitives: [{ attributes: this._addAttributes(t), mode: 0 }]
            };
            return (
              (this.json.meshes = this.json.meshes || []),
              this.json.meshes.push(e),
              this.json.meshes.length - 1
            );
          }
          addImage(t, e) {
            const n = Ki(t),
              r = e || (null == n ? void 0 : n.mimeType),
              s = { bufferView: this.addBufferView(t), mimeType: r };
            return (
              (this.json.images = this.json.images || []),
              this.json.images.push(s),
              this.json.images.length - 1
            );
          }
          addBufferView(t) {
            let e =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0,
              n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : this.byteLength;
            const r = t.byteLength;
            zi(Number.isFinite(r)),
              (this.sourceBuffers = this.sourceBuffers || []),
              this.sourceBuffers.push(t);
            const s = { buffer: e, byteOffset: n, byteLength: r };
            return (
              (this.byteLength += N(r, 4)),
              (this.json.bufferViews = this.json.bufferViews || []),
              this.json.bufferViews.push(s),
              this.json.bufferViews.length - 1
            );
          }
          addAccessor(t, e) {
            const n = {
              bufferView: t,
              type: so(e.size),
              componentType: e.componentType,
              count: e.count,
              max: e.max,
              min: e.min
            };
            return (
              (this.json.accessors = this.json.accessors || []),
              this.json.accessors.push(n),
              this.json.accessors.length - 1
            );
          }
          addBinaryBuffer(t) {
            let e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : { size: 3 };
            const n = this.addBufferView(t);
            let r = { min: e.min, max: e.max };
            (!r.min || !r.max) && (r = this._getAccessorMinMax(t, e.size));
            const s = {
              size: e.size,
              componentType: io(t),
              count: Math.round(t.length / e.size),
              min: r.min,
              max: r.max
            };
            return this.addAccessor(n, Object.assign(s, e));
          }
          addTexture(t) {
            const { imageIndex: e } = t,
              n = { source: e };
            return (
              (this.json.textures = this.json.textures || []),
              this.json.textures.push(n),
              this.json.textures.length - 1
            );
          }
          addMaterial(t) {
            return (
              (this.json.materials = this.json.materials || []),
              this.json.materials.push(t),
              this.json.materials.length - 1
            );
          }
          createBinaryChunk() {
            var t, e;
            this.gltf.buffers = [];
            const n = this.byteLength,
              r = new ArrayBuffer(n),
              s = new Uint8Array(r);
            let i = 0;
            for (const t of this.sourceBuffers || []) i = H(t, s, i);
            null !== (t = this.json) &&
            void 0 !== t &&
            null !== (e = t.buffers) &&
            void 0 !== e &&
            e[0]
              ? (this.json.buffers[0].byteLength = n)
              : (this.json.buffers = [{ byteLength: n }]),
              (this.gltf.binary = r),
              (this.sourceBuffers = [r]);
          }
          _removeStringFromArray(t, e) {
            let n = !0;
            for (; n; ) {
              const r = t.indexOf(e);
              r > -1 ? t.splice(r, 1) : (n = !1);
            }
          }
          _addAttributes() {
            let t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {};
            const e = {};
            for (const n in t) {
              const r = t[n],
                s = this._getGltfAttributeName(n),
                i = this.addBinaryBuffer(r.value, r);
              e[s] = i;
            }
            return e;
          }
          _addIndices(t) {
            return this.addBinaryBuffer(t, { size: 1 });
          }
          _getGltfAttributeName(t) {
            switch (t.toLowerCase()) {
              case 'position':
              case 'positions':
              case 'vertices':
                return 'POSITION';
              case 'normal':
              case 'normals':
                return 'NORMAL';
              case 'color':
              case 'colors':
                return 'COLOR_0';
              case 'texcoord':
              case 'texcoords':
                return 'TEXCOORD_0';
              default:
                return t;
            }
          }
          _getAccessorMinMax(t, e) {
            const n = { min: null, max: null };
            if (t.length < e) return n;
            (n.min = []), (n.max = []);
            const r = t.subarray(0, e);
            for (const t of r) n.min.push(t), n.max.push(t);
            for (let r = e; r < t.length; r += e)
              for (let s = 0; s < e; s++)
                (n.min[0 + s] = Math.min(n.min[0 + s], t[r + s])),
                  (n.max[0 + s] = Math.max(n.max[0 + s], t[r + s]));
            return n;
          }
        }
        function lo(t) {
          return ((t % 1) + 1) % 1;
        }
        const ho = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16,
            BOOLEAN: 1,
            STRING: 1,
            ENUM: 1
          },
          uo = {
            INT8: Int8Array,
            UINT8: Uint8Array,
            INT16: Int16Array,
            UINT16: Uint16Array,
            INT32: Int32Array,
            UINT32: Uint32Array,
            INT64: BigInt64Array,
            UINT64: BigUint64Array,
            FLOAT32: Float32Array,
            FLOAT64: Float64Array
          },
          fo = {
            INT8: 1,
            UINT8: 1,
            INT16: 2,
            UINT16: 2,
            INT32: 4,
            UINT32: 4,
            INT64: 8,
            UINT64: 8,
            FLOAT32: 4,
            FLOAT64: 8
          };
        function mo(t, e) {
          return fo[e] * ho[t];
        }
        function go(t, e, n, r) {
          if (
            'UINT8' !== n &&
            'UINT16' !== n &&
            'UINT32' !== n &&
            'UINT64' !== n
          )
            return null;
          const s = Ao(t.getTypedArrayForBufferView(e), 'SCALAR', n, r + 1);
          return s instanceof BigInt64Array || s instanceof BigUint64Array
            ? null
            : s;
        }
        function Ao(t, e, n) {
          let r =
            arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
          const s = ho[e],
            i = uo[n],
            o = fo[n],
            a = r * s,
            c = a * o;
          let l = t.buffer,
            h = t.byteOffset;
          return (
            h % o != 0 &&
              ((l = new Uint8Array(l).slice(h, h + c).buffer), (h = 0)),
            new i(l, h, a)
          );
        }
        function po(t, e, n) {
          var r, s;
          const i = `TEXCOORD_${e.texCoord || 0}`,
            o = n.attributes[i],
            a = t.getTypedArrayForAccessor(o),
            c = t.gltf.json,
            l = e.index,
            h =
              null === (r = c.textures) ||
              void 0 === r ||
              null === (s = r[l]) ||
              void 0 === s
                ? void 0
                : s.source;
          if (typeof h < 'u') {
            var u, d, f;
            const n =
                null === (u = c.images) ||
                void 0 === u ||
                null === (d = u[h]) ||
                void 0 === d
                  ? void 0
                  : d.mimeType,
              r = null === (f = t.gltf.images) || void 0 === f ? void 0 : f[h];
            if (r && typeof r.width < 'u') {
              const t = [];
              for (let s = 0; s < a.length; s += 2) {
                const i = Bo(r, n, a, s, e.channels);
                t.push(i);
              }
              return t;
            }
          }
          return [];
        }
        function yo(t, e, n, r, s) {
          if (null == n || !n.length) return;
          const i = [];
          for (const t of n) {
            let e = r.findIndex((e) => e === t);
            -1 === e && (e = r.push(t) - 1), i.push(e);
          }
          const o = new Uint32Array(i),
            a =
              t.gltf.buffers.push({
                arrayBuffer: o.buffer,
                byteOffset: o.byteOffset,
                byteLength: o.byteLength
              }) - 1,
            c = t.addBufferView(o, a, 0),
            l = t.addAccessor(c, {
              size: 1,
              componentType: io(o),
              count: o.length
            });
          s.attributes[e] = l;
        }
        function Bo(t, e, n, r) {
          let s =
            arguments.length > 4 && void 0 !== arguments[4]
              ? arguments[4]
              : [0];
          const i = {
              r: { offset: 0, shift: 0 },
              g: { offset: 1, shift: 8 },
              b: { offset: 2, shift: 16 },
              a: { offset: 3, shift: 24 }
            },
            o = n[r],
            a = n[r + 1];
          let c = 1;
          e &&
            (-1 !== e.indexOf('image/jpeg') || -1 !== e.indexOf('image/png')) &&
            (c = 4);
          const l = bo(o, a, t, c);
          let h = 0;
          for (const e of s) {
            const n = 'number' == typeof e ? Object.values(i)[e] : i[e],
              r = l + n.offset,
              s = Si(t);
            if (s.data.length <= r) throw new Error(`${s.data.length} <= ${r}`);
            h |= s.data[r] << n.shift;
          }
          return h;
        }
        function bo(t, e, n) {
          let r =
            arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
          const s = n.width,
            i = lo(t) * (s - 1),
            o = Math.round(i),
            a = n.height,
            c = lo(e) * (a - 1),
            l = Math.round(c),
            h = n.components ? n.components : r;
          return (l * s + o) * h;
        }
        function Co(t, e, n, r, s) {
          const i = [];
          for (let o = 0; o < e; o++) {
            const e = n[o],
              a = n[o + 1] - n[o];
            if (a + e > r) break;
            const c = e / s,
              l = a / s;
            i.push(t.slice(c, c + l));
          }
          return i;
        }
        function wo(t, e, n) {
          const r = [];
          for (let s = 0; s < e; s++) {
            const e = s * n;
            r.push(t.slice(e, e + n));
          }
          return r;
        }
        function Eo(t, e, n, r) {
          if (n)
            throw new Error(
              'Not implemented - arrayOffsets for strings is specified'
            );
          if (r) {
            const n = [],
              s = new TextDecoder('utf8');
            let i = 0;
            for (let o = 0; o < t; o++) {
              const t = r[o + 1] - r[o];
              if (t + i <= e.length) {
                const r = e.subarray(i, t + i),
                  o = s.decode(r);
                n.push(o), (i += t);
              }
            }
            return n;
          }
          return [];
        }
        function To(t, e, n) {
          var r, s;
          if (
            null == n ||
            null === (r = n.gltf) ||
            void 0 === r ||
            !r.loadBuffers
          )
            return;
          const i =
              null === (s = e.extensions) || void 0 === s
                ? void 0
                : s.EXT_mesh_features,
            o = null == i ? void 0 : i.featureIds;
          if (o)
            for (const r of o) {
              var a;
              let s;
              if (typeof r.attribute < 'u') {
                const n = `_FEATURE_ID_${r.attribute}`,
                  i = e.attributes[n];
                s = t.getTypedArrayForAccessor(i);
              } else
                s =
                  typeof r.texture < 'u' &&
                  null != n &&
                  null !== (a = n.gltf) &&
                  void 0 !== a &&
                  a.loadImages
                    ? po(t, r.texture, e)
                    : [];
              r.data = s;
            }
        }
        const vo = Object.freeze(
            Object.defineProperty(
              {
                __proto__: null,
                decode: async function (t, e) {
                  !(function (t, e) {
                    const n = t.gltf.json;
                    if (n.meshes)
                      for (const r of n.meshes)
                        for (const n of r.primitives) To(t, n, e);
                  })(new co(t), e);
                },
                name: 'EXT_mesh_features'
              },
              Symbol.toStringTag,
              { value: 'Module' }
            )
          ),
          _o = 'EXT_structural_metadata';
        function Mo(t, e) {
          for (const n of t) if (n.class === e) return n;
          return null;
        }
        function Io(t, e, n, r) {
          var s;
          if (!e) return;
          const i =
              null === (s = n.extensions) || void 0 === s ? void 0 : s[_o],
            o = null == i ? void 0 : i.propertyTextures;
          if (o) for (const s of o) xo(t, e[s], n, r);
        }
        function xo(t, e, n, r) {
          if (!e.properties) return;
          r.dataAttributeNames || (r.dataAttributeNames = []);
          const s = e.class;
          for (const o in e.properties) {
            var i;
            const a = `${s}_${o}`,
              c = null === (i = e.properties) || void 0 === i ? void 0 : i[o];
            if (!c) continue;
            c.data || (c.data = []);
            const l = c.data,
              h = po(t, c, n);
            null !== h &&
              (yo(t, a, h, l, n), (c.data = l), r.dataAttributeNames.push(a));
          }
        }
        function Fo(t, e, n) {
          var r;
          const s =
            null === (r = e.classes) || void 0 === r ? void 0 : r[n.class];
          if (!s)
            throw new Error(
              `Incorrect data in the EXT_structural_metadata extension: no schema class with name ${n.class}`
            );
          const i = n.count;
          for (const r in s.properties) {
            var o;
            const a = s.properties[r],
              c = null === (o = n.properties) || void 0 === o ? void 0 : o[r];
            if (c) {
              const n = Oo(t, e, a, i, c);
              c.data = n;
            }
          }
        }
        function Oo(t, e, n, r, s) {
          let i = [];
          const o = s.values,
            a = t.getTypedArrayForBufferView(o),
            c = (function (t, e, n, r) {
              return e.array &&
                typeof e.count > 'u' &&
                typeof n.arrayOffsets < 'u'
                ? go(t, n.arrayOffsets, n.arrayOffsetType || 'UINT32', r)
                : null;
            })(t, n, s, r),
            l = (function (t, e, n) {
              return typeof e.stringOffsets < 'u'
                ? go(t, e.stringOffsets, e.stringOffsetType || 'UINT32', n)
                : null;
            })(t, s, r);
          switch (n.type) {
            case 'SCALAR':
            case 'VEC2':
            case 'VEC3':
            case 'VEC4':
            case 'MAT2':
            case 'MAT3':
            case 'MAT4':
              i = (function (t, e, n, r) {
                const s = t.array,
                  i = t.count,
                  o = mo(t.type, t.componentType),
                  a = n.byteLength / o;
                let c;
                return (
                  (c = t.componentType ? Ao(n, t.type, t.componentType, a) : n),
                  s ? (r ? Co(c, e, r, n.length, o) : i ? wo(c, e, i) : []) : c
                );
              })(n, r, a, c);
              break;
            case 'BOOLEAN':
              throw new Error(`Not implemented - classProperty.type=${n.type}`);
            case 'STRING':
              i = Eo(r, a, c, l);
              break;
            case 'ENUM':
              i = (function (t, e, n, r, s) {
                var i;
                const o = e.enumType;
                if (!o)
                  throw new Error(
                    'Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM'
                  );
                const a =
                  null === (i = t.enums) || void 0 === i ? void 0 : i[o];
                if (!a)
                  throw new Error(
                    `Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${o}`
                  );
                const c = a.valueType || 'UINT16',
                  l = mo(e.type, c),
                  h = r.byteLength / l;
                let u = Ao(r, e.type, c, h);
                if ((u || (u = r), e.array)) {
                  if (s)
                    return (function (t) {
                      const {
                          valuesData: e,
                          numberOfElements: n,
                          arrayOffsets: r,
                          valuesDataBytesLength: s,
                          elementSize: i,
                          enumEntry: o
                        } = t,
                        a = [];
                      for (let t = 0; t < n; t++) {
                        const n = r[t],
                          c = r[t + 1] - r[t];
                        if (c + n > s) break;
                        const l = Ro(e, n / i, c / i, o);
                        a.push(l);
                      }
                      return a;
                    })({
                      valuesData: u,
                      numberOfElements: n,
                      arrayOffsets: s,
                      valuesDataBytesLength: r.length,
                      elementSize: l,
                      enumEntry: a
                    });
                  const t = e.count;
                  return t
                    ? (function (t, e, n, r) {
                        const s = [];
                        for (let i = 0; i < e; i++) {
                          const e = Ro(t, n * i, n, r);
                          s.push(e);
                        }
                        return s;
                      })(u, n, t, a)
                    : [];
                }
                return Ro(u, 0, n, a);
              })(e, n, r, a, c);
              break;
            default:
              throw new Error(`Unknown classProperty type ${n.type}`);
          }
          return i;
        }
        function Ro(t, e, n, r) {
          const s = [];
          for (let i = 0; i < n; i++)
            if (t instanceof BigInt64Array || t instanceof BigUint64Array)
              s.push('');
            else {
              const n = So(r, t[e + i]);
              n ? s.push(n.name) : s.push('');
            }
          return s;
        }
        function So(t, e) {
          for (const n of t.values) if (n.value === e) return n;
          return null;
        }
        const Do = Object.freeze(
          Object.defineProperty(
            {
              __proto__: null,
              decode: async function (t, e) {
                !(function (t, e) {
                  var n, r;
                  if (null === (n = e.gltf) || void 0 === n || !n.loadBuffers)
                    return;
                  const s = t.getExtension(_o);
                  s &&
                    (null !== (r = e.gltf) &&
                      void 0 !== r &&
                      r.loadImages &&
                      (function (t, e) {
                        const n = e.propertyTextures,
                          r = t.gltf.json;
                        if (n && r.meshes)
                          for (const s of r.meshes)
                            for (const r of s.primitives) Io(t, n, r, e);
                      })(t, s),
                    (function (t, e) {
                      const n = e.schema;
                      if (!n) return;
                      const r = n.classes,
                        s = e.propertyTables;
                      if (r && s)
                        for (const e in r) {
                          const r = Mo(s, e);
                          r && Fo(t, n, r);
                        }
                    })(t, s));
                })(new co(t), e);
              },
              name: 'EXT_structural_metadata'
            },
            Symbol.toStringTag,
            { value: 'Module' }
          )
        );
        function Go(t, e) {
          for (const n in t) {
            const r = t[n];
            if (r.class === e) return r;
          }
          return null;
        }
        function Lo(t, e) {
          for (const n in t) {
            const r = t[n];
            if (r.class === e) return r;
          }
          return null;
        }
        function Uo(t, e, n) {
          var r;
          if (!n.class) return;
          const s =
            null === (r = e.classes) || void 0 === r ? void 0 : r[n.class];
          if (!s)
            throw new Error(
              `Incorrect data in the EXT_structural_metadata extension: no schema class with name ${n.class}`
            );
          const i = n.count;
          for (const e in s.properties) {
            var o;
            const r = s.properties[e],
              a = null === (o = n.properties) || void 0 === o ? void 0 : o[e];
            if (a) {
              const e = Ho(t, 0, r, i, a);
              a.data = e;
            }
          }
        }
        function No(t, e, n) {
          const r = e.class;
          for (const i in n.properties) {
            var s;
            const n =
              null == e || null === (s = e.properties) || void 0 === s
                ? void 0
                : s[i];
            if (n) {
              const e = Po(t, n, r);
              n.data = e;
            }
          }
        }
        function Ho(t, e, n, r, s) {
          let i = [];
          const o = s.bufferView,
            a = t.getTypedArrayForBufferView(o),
            c = (function (t, e, n, r) {
              return 'ARRAY' === e.type &&
                typeof e.componentCount > 'u' &&
                typeof n.arrayOffsetBufferView < 'u'
                ? go(t, n.arrayOffsetBufferView, n.offsetType || 'UINT32', r)
                : null;
            })(t, n, s, r),
            l = (function (t, e, n, r) {
              return typeof n.stringOffsetBufferView < 'u'
                ? go(t, n.stringOffsetBufferView, n.offsetType || 'UINT32', r)
                : null;
            })(t, 0, s, r);
          return (
            'STRING' === n.type || 'STRING' === n.componentType
              ? (i = Eo(r, a, c, l))
              : (function (t) {
                  const e = [
                    'UINT8',
                    'INT16',
                    'UINT16',
                    'INT32',
                    'UINT32',
                    'INT64',
                    'UINT64',
                    'FLOAT32',
                    'FLOAT64'
                  ];
                  return (
                    e.includes(t.type) ||
                    (typeof t.componentType < 'u' &&
                      e.includes(t.componentType))
                  );
                })(n) &&
                (i = (function (t, e, n, r) {
                  const s = 'ARRAY' === t.type,
                    i = t.componentCount,
                    o = 'SCALAR',
                    a = t.componentType || t.type,
                    c = mo(o, a),
                    l = Ao(n, o, a, n.byteLength / c);
                  return s
                    ? r
                      ? Co(l, e, r, n.length, c)
                      : i
                      ? wo(l, e, i)
                      : []
                    : l;
                })(n, r, a, c)),
            i
          );
        }
        function Po(t, e, n) {
          const r = t.gltf.json;
          if (!r.meshes) return [];
          const s = [];
          for (const i of r.meshes)
            for (const r of i.primitives) Jo(t, n, e, s, r);
          return s;
        }
        function Jo(t, e, n, r, s) {
          const i = po(t, { channels: n.channels, ...n.texture }, s);
          i && yo(t, e, i, r, s);
        }
        const jo = Object.freeze(
          Object.defineProperty(
            {
              __proto__: null,
              decode: async function (t, e) {
                !(function (t, e) {
                  var n, r;
                  if (null === (n = e.gltf) || void 0 === n || !n.loadBuffers)
                    return;
                  const s = t.getExtension('EXT_feature_metadata');
                  s &&
                    (null !== (r = e.gltf) &&
                      void 0 !== r &&
                      r.loadImages &&
                      (function (t, e) {
                        const n = e.schema;
                        if (!n) return;
                        const r = n.classes,
                          { featureTextures: s } = e;
                        if (r && s)
                          for (const e in r) {
                            const n = r[e],
                              i = Lo(s, e);
                            i && No(t, i, n);
                          }
                      })(t, s),
                    (function (t, e) {
                      const n = e.schema;
                      if (!n) return;
                      const r = n.classes,
                        s = e.featureTables;
                      if (r && s)
                        for (const e in r) {
                          const r = Go(s, e);
                          r && Uo(t, n, r);
                        }
                    })(t, s));
                })(new co(t), e);
              },
              name: 'EXT_feature_metadata'
            },
            Symbol.toStringTag,
            { value: 'Module' }
          )
        );
        let ko, Vo;
        async function Ko(t) {
          const e = t.modules || {};
          return e.basis
            ? e.basis
            : ((ko =
                ko ||
                (async function (t) {
                  let e = null,
                    n = null;
                  return (
                    ([e, n] = await Promise.all([
                      await F('basis_transcoder.js', 'textures', t),
                      await F('basis_transcoder.wasm', 'textures', t)
                    ])),
                    (e = e || globalThis.BASIS),
                    await (function (t, e) {
                      const n = {};
                      return (
                        e && (n.wasmBinary = e),
                        new Promise((e) => {
                          t(n).then((t) => {
                            const { BasisFile: n, initializeBasis: r } = t;
                            r(), e({ BasisFile: n });
                          });
                        })
                      );
                    })(e, n)
                  );
                })(t)),
              await ko);
        }
        async function Qo(t) {
          const e = t.modules || {};
          return e.basisEncoder
            ? e.basisEncoder
            : ((Vo =
                Vo ||
                (async function (t) {
                  let e = null,
                    n = null;
                  return (
                    ([e, n] = await Promise.all([
                      await F('basis_encoder.js', 'textures', t),
                      await F('basis_encoder.wasm', 'textures', t)
                    ])),
                    (e = e || globalThis.BASIS),
                    await (function (t, e) {
                      const n = {};
                      return (
                        e && (n.wasmBinary = e),
                        new Promise((e) => {
                          t(n).then((t) => {
                            const {
                              BasisFile: n,
                              KTX2File: r,
                              initializeBasis: s,
                              BasisEncoder: i
                            } = t;
                            s(),
                              e({ BasisFile: n, KTX2File: r, BasisEncoder: i });
                          });
                        })
                      );
                    })(e, n)
                  );
                })(t)),
              await Vo);
        }
        const qo = ['', 'WEBKIT_', 'MOZ_'],
          Wo = {
            WEBGL_compressed_texture_s3tc: 'dxt',
            WEBGL_compressed_texture_s3tc_srgb: 'dxt-srgb',
            WEBGL_compressed_texture_etc1: 'etc1',
            WEBGL_compressed_texture_etc: 'etc2',
            WEBGL_compressed_texture_pvrtc: 'pvrtc',
            WEBGL_compressed_texture_atc: 'atc',
            WEBGL_compressed_texture_astc: 'astc',
            EXT_texture_compression_rgtc: 'rgtc'
          };
        let zo = null;
        var Xo, Yo, Zo, $o, ta, ea, na, ra;
        (function (t) {
          (t[(t.NONE = 0)] = 'NONE'),
            (t[(t.BASISLZ = 1)] = 'BASISLZ'),
            (t[(t.ZSTD = 2)] = 'ZSTD'),
            (t[(t.ZLIB = 3)] = 'ZLIB');
        })(Xo || (Xo = {})),
          (function (t) {
            t[(t.BASICFORMAT = 0)] = 'BASICFORMAT';
          })(Yo || (Yo = {})),
          (function (t) {
            (t[(t.UNSPECIFIED = 0)] = 'UNSPECIFIED'),
              (t[(t.ETC1S = 163)] = 'ETC1S'),
              (t[(t.UASTC = 166)] = 'UASTC');
          })(Zo || (Zo = {})),
          (function (t) {
            (t[(t.UNSPECIFIED = 0)] = 'UNSPECIFIED'),
              (t[(t.SRGB = 1)] = 'SRGB');
          })($o || ($o = {})),
          (function (t) {
            (t[(t.UNSPECIFIED = 0)] = 'UNSPECIFIED'),
              (t[(t.LINEAR = 1)] = 'LINEAR'),
              (t[(t.SRGB = 2)] = 'SRGB'),
              (t[(t.ITU = 3)] = 'ITU'),
              (t[(t.NTSC = 4)] = 'NTSC'),
              (t[(t.SLOG = 5)] = 'SLOG'),
              (t[(t.SLOG2 = 6)] = 'SLOG2');
          })(ta || (ta = {})),
          (function (t) {
            (t[(t.ALPHA_STRAIGHT = 0)] = 'ALPHA_STRAIGHT'),
              (t[(t.ALPHA_PREMULTIPLIED = 1)] = 'ALPHA_PREMULTIPLIED');
          })(ea || (ea = {})),
          (function (t) {
            (t[(t.RGB = 0)] = 'RGB'),
              (t[(t.RRR = 3)] = 'RRR'),
              (t[(t.GGG = 4)] = 'GGG'),
              (t[(t.AAA = 15)] = 'AAA');
          })(na || (na = {})),
          (function (t) {
            (t[(t.RGB = 0)] = 'RGB'),
              (t[(t.RGBA = 3)] = 'RGBA'),
              (t[(t.RRR = 4)] = 'RRR'),
              (t[(t.RRRG = 5)] = 'RRRG');
          })(ra || (ra = {}));
        const sa = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10],
          ia = {
            etc1: { basisFormat: 0, compressed: !0, format: 36196 },
            etc2: { basisFormat: 1, compressed: !0 },
            bc1: { basisFormat: 2, compressed: !0, format: 33776 },
            bc3: { basisFormat: 3, compressed: !0, format: 33779 },
            bc4: { basisFormat: 4, compressed: !0 },
            bc5: { basisFormat: 5, compressed: !0 },
            'bc7-m6-opaque-only': { basisFormat: 6, compressed: !0 },
            'bc7-m5': { basisFormat: 7, compressed: !0 },
            'pvrtc1-4-rgb': { basisFormat: 8, compressed: !0, format: 35840 },
            'pvrtc1-4-rgba': { basisFormat: 9, compressed: !0, format: 35842 },
            'astc-4x4': { basisFormat: 10, compressed: !0, format: 37808 },
            'atc-rgb': { basisFormat: 11, compressed: !0 },
            'atc-rgba-interpolated-alpha': { basisFormat: 12, compressed: !0 },
            rgba32: { basisFormat: 13, compressed: !1 },
            rgb565: { basisFormat: 14, compressed: !1 },
            bgr565: { basisFormat: 15, compressed: !1 },
            rgba4444: { basisFormat: 16, compressed: !1 }
          };
        function oa(t, e, n) {
          const r = new t(new Uint8Array(e));
          try {
            if (!r.startTranscoding())
              throw new Error('Failed to start basis transcoding');
            const t = r.getNumImages(),
              e = [];
            for (let s = 0; s < t; s++) {
              const t = r.getNumLevels(s),
                i = [];
              for (let e = 0; e < t; e++) i.push(aa(r, s, e, n));
              e.push(i);
            }
            return e;
          } finally {
            r.close(), r.delete();
          }
        }
        function aa(t, e, n, r) {
          const s = t.getImageWidth(e, n),
            i = t.getImageHeight(e, n),
            o = t.getHasAlpha(),
            { compressed: a, format: c, basisFormat: l } = ha(r, o),
            h = t.getImageTranscodedSizeInBytes(e, n, l),
            u = new Uint8Array(h);
          if (!t.transcodeImage(u, e, n, l, 0, 0))
            throw new Error('failed to start Basis transcoding');
          return {
            width: s,
            height: i,
            data: u,
            compressed: a,
            format: c,
            hasAlpha: o
          };
        }
        function ca(t, e, n) {
          const r = new t(new Uint8Array(e));
          try {
            if (!r.startTranscoding())
              throw new Error('failed to start KTX2 transcoding');
            const t = r.getLevels(),
              e = [];
            for (let s = 0; s < t; s++) {
              e.push(la(r, s, n));
              break;
            }
            return [e];
          } finally {
            r.close(), r.delete();
          }
        }
        function la(t, e, n) {
          const {
              alphaFlag: r,
              height: s,
              width: i
            } = t.getImageLevelInfo(e, 0, 0),
            { compressed: o, format: a, basisFormat: c } = ha(n, r),
            l = t.getImageTranscodedSizeInBytes(e, 0, 0, c),
            h = new Uint8Array(l);
          if (!t.transcodeImage(h, e, 0, 0, c, 0, -1, -1))
            throw new Error('Failed to transcode KTX2 image');
          return {
            width: i,
            height: s,
            data: h,
            compressed: o,
            levelSize: l,
            hasAlpha: r,
            format: a
          };
        }
        function ha(t, e) {
          let n = t && t.basis && t.basis.format;
          return (
            'auto' === n && (n = ua()),
            'object' == typeof n && (n = e ? n.alpha : n.noAlpha),
            (n = n.toLowerCase()),
            ia[n]
          );
        }
        function ua() {
          const t = (function (t) {
            if (!zo) {
              (t =
                t ||
                (function () {
                  try {
                    return document.createElement('canvas').getContext('webgl');
                  } catch {
                    return null;
                  }
                })() ||
                void 0),
                (zo = new Set());
              for (const e of qo)
                for (const n in Wo)
                  if (t && t.getExtension(`${e}${n}`)) {
                    const t = Wo[n];
                    zo.add(t);
                  }
            }
            return zo;
          })();
          return t.has('astc')
            ? 'astc-4x4'
            : t.has('dxt')
            ? { alpha: 'bc3', noAlpha: 'bc1' }
            : t.has('pvrtc')
            ? { alpha: 'pvrtc1-4-rgba', noAlpha: 'pvrtc1-4-rgb' }
            : t.has('etc1')
            ? 'etc1'
            : t.has('etc2')
            ? 'etc2'
            : 'rgb565';
        }
        const da = {
            name: 'Basis',
            id: 'basis',
            module: 'textures',
            version: '4.1.1',
            worker: !0,
            extensions: ['basis', 'ktx2'],
            mimeTypes: ['application/octet-stream', 'image/ktx2'],
            tests: ['sB'],
            binary: !0,
            options: {
              basis: {
                format: 'auto',
                libraryPath: 'libs/',
                containerFormat: 'auto',
                module: 'transcoder'
              }
            },
            parse: async function (t, e) {
              if ('auto' === e.basis.containerFormat) {
                if (
                  (function (t) {
                    const e = new Uint8Array(t);
                    return !(
                      e.byteLength < sa.length ||
                      e[0] !== sa[0] ||
                      e[1] !== sa[1] ||
                      e[2] !== sa[2] ||
                      e[3] !== sa[3] ||
                      e[4] !== sa[4] ||
                      e[5] !== sa[5] ||
                      e[6] !== sa[6] ||
                      e[7] !== sa[7] ||
                      e[8] !== sa[8] ||
                      e[9] !== sa[9] ||
                      e[10] !== sa[10] ||
                      e[11] !== sa[11]
                    );
                  })(t)
                )
                  return ca((await Qo(e)).KTX2File, t, e);
                const { BasisFile: n } = await Ko(e);
                return oa(n, t, e);
              }
              if ('encoder' === e.basis.module) {
                const n = await Qo(e);
                return 'ktx2' === e.basis.containerFormat
                  ? ca(n.KTX2File, t, e)
                  : oa(n.BasisFile, t, e);
              }
              {
                const { BasisFile: n } = await Ko(e);
                return oa(n, t, e);
              }
            }
          },
          fa = !0,
          ma = 1735152710;
        function ga(t) {
          let e =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
          return `${String.fromCharCode(
            t.getUint8(e + 0)
          )}${String.fromCharCode(t.getUint8(e + 1))}${String.fromCharCode(
            t.getUint8(e + 2)
          )}${String.fromCharCode(t.getUint8(e + 3))}`;
        }
        function Aa(t, e, r) {
          n(t.header.byteLength > 20);
          const s = e.getUint32(r + 0, fa),
            i = e.getUint32(r + 4, fa);
          return (
            (r += 8),
            n(0 === i),
            ya(t, e, r, s),
            (r += s) + Ba(t, e, r, t.header.byteLength)
          );
        }
        function pa(t, e, r, s) {
          return (
            n(t.header.byteLength > 20),
            (function (t, e, n, r) {
              for (; n + 8 <= t.header.byteLength; ) {
                const s = e.getUint32(n + 0, fa),
                  i = e.getUint32(n + 4, fa);
                switch (((n += 8), i)) {
                  case 1313821514:
                    ya(t, e, n, s);
                    break;
                  case 5130562:
                    Ba(t, e, n, s);
                    break;
                  case 0:
                    r.strict || ya(t, e, n, s);
                    break;
                  case 1:
                    r.strict || Ba(t, e, n, s);
                }
                n += N(s, 4);
              }
            })(t, e, r, s),
            r + t.header.byteLength
          );
        }
        function ya(t, e, n, r) {
          const s = new Uint8Array(e.buffer, n, r),
            i = new TextDecoder('utf8').decode(s);
          return (t.json = JSON.parse(i)), N(r, 4);
        }
        function Ba(t, e, n, r) {
          return (
            (t.header.hasBinChunk = !0),
            t.binChunks.push({
              byteOffset: n,
              byteLength: r,
              arrayBuffer: e.buffer
            }),
            N(r, 4)
          );
        }
        function ba(t, e) {
          if (
            t.startsWith('data:') ||
            t.startsWith('http:') ||
            t.startsWith('https:')
          )
            return t;
          const n = e.baseUri || e.uri;
          if (!n)
            throw new Error(
              `'baseUri' must be provided to resolve relative url ${t}`
            );
          return n.substr(0, n.lastIndexOf('/') + 1) + t;
        }
        const Ca = new Uint8Array([
            0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3,
            1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10,
            0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11
          ]),
          wa = new Uint8Array([
            32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12,
            16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24,
            54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144,
            27, 87, 131, 44, 45, 74, 156, 154, 70, 167
          ]),
          Ea = {
            0: '',
            1: 'meshopt_decodeFilterOct',
            2: 'meshopt_decodeFilterQuat',
            3: 'meshopt_decodeFilterExp',
            NONE: '',
            OCTAHEDRAL: 'meshopt_decodeFilterOct',
            QUATERNION: 'meshopt_decodeFilterQuat',
            EXPONENTIAL: 'meshopt_decodeFilterExp'
          },
          Ta = {
            0: 'meshopt_decodeVertexBuffer',
            1: 'meshopt_decodeIndexBuffer',
            2: 'meshopt_decodeIndexSequence',
            ATTRIBUTES: 'meshopt_decodeVertexBuffer',
            TRIANGLES: 'meshopt_decodeIndexBuffer',
            INDICES: 'meshopt_decodeIndexSequence'
          };
        let va;
        async function _a() {
          return (
            va ||
              (va = (async function () {
                let t =
                  'B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB';
                WebAssembly.validate(Ca) &&
                  ((t =
                    'B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB'),
                  console.log(
                    'Warning: meshopt_decoder is using experimental SIMD support'
                  ));
                const e = await WebAssembly.instantiate(
                  (function (t) {
                    const e = new Uint8Array(t.length);
                    for (let n = 0; n < t.length; ++n) {
                      const r = t.charCodeAt(n);
                      e[n] =
                        r > 96
                          ? r - 71
                          : r > 64
                          ? r - 65
                          : r > 47
                          ? r + 4
                          : r > 46
                          ? 63
                          : 62;
                    }
                    let n = 0;
                    for (let r = 0; r < t.length; ++r)
                      e[n++] = e[r] < 60 ? wa[e[r]] : 64 * (e[r] - 60) + e[++r];
                    return e.buffer.slice(0, n);
                  })(t),
                  {}
                );
                return await e.instance.exports.__wasm_call_ctors(), e.instance;
              })()),
            va
          );
        }
        function Ma(t, e, n, r, s, i, o) {
          const a = t.exports.sbrk,
            c = (r + 3) & -4,
            l = a(c * s),
            h = a(i.length),
            u = new Uint8Array(t.exports.memory.buffer);
          u.set(i, h);
          const d = e(l, r, s, h, i.length);
          if (
            (0 === d && o && o(l, c, s),
            n.set(u.subarray(l, l + r * s)),
            a(l - a(0)),
            0 !== d)
          )
            throw new Error(`Malformed buffer data: ${d}`);
        }
        const Ia = 'EXT_meshopt_compression';
        async function xa(t, e) {
          const n = t.getObjectExtension(e, Ia);
          if (n) {
            const {
                byteOffset: r = 0,
                byteLength: s = 0,
                byteStride: i,
                count: o,
                mode: a,
                filter: c = 'NONE',
                buffer: l
              } = n,
              h = t.gltf.buffers[l],
              u = new Uint8Array(h.arrayBuffer, h.byteOffset + r, s),
              d = new Uint8Array(
                t.gltf.buffers[e.buffer].arrayBuffer,
                e.byteOffset,
                e.byteLength
              );
            await (async function (t, e, n, r, s) {
              let i =
                arguments.length > 5 && void 0 !== arguments[5]
                  ? arguments[5]
                  : 'NONE';
              const o = await _a();
              Ma(o, o.exports[Ta[s]], t, e, n, r, o.exports[Ea[i || 'NONE']]);
            })(d, o, i, u, a, c),
              t.removeObjectExtension(e, Ia);
          }
        }
        const Fa = Object.freeze(
            Object.defineProperty(
              {
                __proto__: null,
                decode: async function (t, e) {
                  var n, r;
                  const s = new co(t);
                  if (
                    null == e ||
                    null === (n = e.gltf) ||
                    void 0 === n ||
                    !n.decompressMeshes ||
                    null === (r = e.gltf) ||
                    void 0 === r ||
                    !r.loadBuffers
                  )
                    return;
                  const i = [];
                  for (const e of t.json.bufferViews || []) i.push(xa(s, e));
                  await Promise.all(i), s.removeExtension(Ia);
                },
                name: 'EXT_meshopt_compression'
              },
              Symbol.toStringTag,
              { value: 'Module' }
            )
          ),
          Oa = 'EXT_texture_webp',
          Ra = Object.freeze(
            Object.defineProperty(
              {
                __proto__: null,
                name: 'EXT_texture_webp',
                preprocess: function (t, e) {
                  const n = new co(t);
                  if (
                    !(function (t) {
                      if (void 0 === Wi[t]) {
                        const e = i
                          ? (function (t) {
                              switch (t) {
                                case 'image/avif':
                                case 'image/webp':
                                  return (function (t) {
                                    try {
                                      return (
                                        0 ===
                                        document
                                          .createElement('canvas')
                                          .toDataURL(t)
                                          .indexOf(`data:${t}`)
                                      );
                                    } catch {
                                      return !1;
                                    }
                                  })(t);
                                default:
                                  return !0;
                              }
                            })(t)
                          : (function (t) {
                              var e, n;
                              const r = (null === (e = globalThis.loaders) ||
                              void 0 === e
                                ? void 0
                                : e.imageFormatsNode) || [
                                'image/png',
                                'image/jpeg',
                                'image/gif'
                              ];
                              return (
                                !!(null === (n = globalThis.loaders) ||
                                void 0 === n
                                  ? void 0
                                  : n.parseImageNode) && r.includes(t)
                              );
                            })(t);
                        Wi[t] = e;
                      }
                      return Wi[t];
                    })('image/webp')
                  ) {
                    if (n.getRequiredExtensions().includes(Oa))
                      throw new Error(
                        `gltf: Required extension ${Oa} not supported by browser`
                      );
                    return;
                  }
                  const { json: r } = n;
                  for (const t of r.textures || []) {
                    const e = n.getObjectExtension(t, Oa);
                    e && (t.source = e.source), n.removeObjectExtension(t, Oa);
                  }
                  n.removeExtension(Oa);
                }
              },
              Symbol.toStringTag,
              { value: 'Module' }
            )
          ),
          Sa = 'KHR_texture_basisu',
          Da = Object.freeze(
            Object.defineProperty(
              {
                __proto__: null,
                name: 'KHR_texture_basisu',
                preprocess: function (t, e) {
                  const n = new co(t),
                    { json: r } = n;
                  for (const t of r.textures || []) {
                    const e = n.getObjectExtension(t, Sa);
                    e &&
                      ((t.source = e.source), n.removeObjectExtension(t, Sa));
                  }
                  n.removeExtension(Sa);
                }
              },
              Symbol.toStringTag,
              { value: 'Module' }
            )
          );
        function Ga(t) {
          const {
            buffer: e,
            size: n,
            count: r
          } = (function (t) {
            let e = t,
              n = 1,
              r = 0;
            return (
              t && t.value && ((e = t.value), (n = t.size || 1)),
              e &&
                (ArrayBuffer.isView(e) ||
                  (e = (function (t, e) {
                    let n =
                      arguments.length > 2 &&
                      void 0 !== arguments[2] &&
                      arguments[2];
                    return t
                      ? Array.isArray(t)
                        ? new e(t)
                        : !n || t instanceof e
                        ? t
                        : new e(t)
                      : null;
                  })(e, Float32Array)),
                (r = e.length / n)),
              { buffer: e, size: n, count: r }
            );
          })(t);
          return {
            value: e,
            size: n,
            byteOffset: 0,
            count: r,
            type: so(n),
            componentType: io(e)
          };
        }
        const La = 'KHR_draco_mesh_compression';
        async function Ua(t, n, r, s) {
          const i = t.getObjectExtension(n, La);
          if (!i) return;
          const o = t.getTypedArrayForBufferView(i.bufferView),
            a = U(o.buffer, o.byteOffset),
            c = { ...r };
          delete c['3d-tiles'];
          const l = await e(a, $s, c, s),
            h = (function (t) {
              const e = {};
              for (const n in t) {
                const r = t[n];
                if ('indices' !== n) {
                  const t = Ga(r);
                  e[n] = t;
                }
              }
              return e;
            })(l.attributes);
          for (const [e, r] of Object.entries(h))
            if (e in n.attributes) {
              const s = n.attributes[e],
                i = t.getAccessor(s);
              null != i &&
                i.min &&
                null != i &&
                i.max &&
                ((r.min = i.min), (r.max = i.max));
            }
          (n.attributes = h),
            l.indices && (n.indices = Ga(l.indices)),
            t.removeObjectExtension(n, La),
            (function (t) {
              if (!t.attributes && Object.keys(t.attributes).length > 0)
                throw new Error(
                  'glTF: Empty primitive detected: Draco decompression failure?'
                );
            })(n);
        }
        function Na(t, e) {
          var n;
          let r =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : 4,
            s = arguments.length > 3 ? arguments[3] : void 0,
            i = arguments.length > 4 ? arguments[4] : void 0;
          if (!s.DracoWriter)
            throw new Error('options.gltf.DracoWriter not provided');
          const o = s.DracoWriter.encodeSync({ attributes: t }),
            a =
              null == i || null === (n = i.parseSync) || void 0 === n
                ? void 0
                : n.call(i, { attributes: t }),
            c = s._addFauxAttributes(a.attributes),
            l = s.addBufferView(o);
          return {
            primitives: [
              {
                attributes: c,
                mode: r,
                extensions: { [La]: { bufferView: l, attributes: c } }
              }
            ]
          };
        }
        function* Ha(t) {
          for (const e of t.json.meshes || [])
            for (const t of e.primitives) yield t;
        }
        const Pa = Object.freeze(
            Object.defineProperty(
              {
                __proto__: null,
                decode: async function (t, e, n) {
                  var r;
                  if (
                    null == e ||
                    null === (r = e.gltf) ||
                    void 0 === r ||
                    !r.decompressMeshes
                  )
                    return;
                  const s = new co(t),
                    i = [];
                  for (const t of Ha(s))
                    s.getObjectExtension(t, La) && i.push(Ua(s, t, e, n));
                  await Promise.all(i), s.removeExtension(La);
                },
                encode: function (t) {
                  let e =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : {};
                  const n = new co(t);
                  for (const t of n.json.meshes || [])
                    Na(t, e), n.addRequiredExtension(La);
                },
                name: 'KHR_draco_mesh_compression',
                preprocess: function (t, e, n) {
                  const r = new co(t);
                  for (const t of Ha(r)) r.getObjectExtension(t, La);
                }
              },
              Symbol.toStringTag,
              { value: 'Module' }
            )
          ),
          Ja = 'KHR_texture_transform',
          ja = new Qe(),
          ka = new $e(),
          Va = new $e();
        function Ka(t, e) {
          var n, r, s;
          const i = [],
            o = null === (n = e.json.materials) || void 0 === n ? void 0 : n[t],
            a =
              null == o || null === (r = o.pbrMetallicRoughness) || void 0 === r
                ? void 0
                : r.baseColorTexture;
          a && Qa(e, t, a, i);
          const c = null == o ? void 0 : o.emissiveTexture;
          c && Qa(e, t, c, i);
          const l = null == o ? void 0 : o.normalTexture;
          l && Qa(e, t, l, i);
          const h = null == o ? void 0 : o.occlusionTexture;
          h && Qa(e, t, h, i);
          const u =
            null == o || null === (s = o.pbrMetallicRoughness) || void 0 === s
              ? void 0
              : s.metallicRoughnessTexture;
          u && Qa(e, t, u, i);
        }
        function Qa(t, e, n, r) {
          const s = (function (t, e) {
            var n;
            const r =
                null === (n = t.extensions) || void 0 === n ? void 0 : n[Ja],
              { texCoord: s = 0 } = t,
              { texCoord: i = s } = r;
            if (
              -1 ===
              e.findIndex((t) => {
                let [e, n] = t;
                return e === s && n === i;
              })
            ) {
              const n = (function (t) {
                const {
                    offset: e = [0, 0],
                    rotation: n = 0,
                    scale: r = [1, 1]
                  } = t,
                  s = new $e().set(1, 0, 0, 0, 1, 0, e[0], e[1], 1),
                  i = ka.set(
                    Math.cos(n),
                    Math.sin(n),
                    0,
                    -Math.sin(n),
                    Math.cos(n),
                    0,
                    0,
                    0,
                    1
                  ),
                  o = Va.set(r[0], 0, 0, 0, r[1], 0, 0, 0, 1);
                return s.multiplyRight(i).multiplyRight(o);
              })(r);
              return (
                s !== i && (t.texCoord = i),
                e.push([s, i]),
                { originalTexCoord: s, texCoord: i, matrix: n }
              );
            }
            return null;
          })(n, r);
          if (!s) return;
          const i = t.json.meshes || [];
          for (const n of i)
            for (const r of n.primitives) {
              const n = r.material;
              Number.isFinite(n) && e === n && qa(t, r, s);
            }
        }
        function qa(t, e, n) {
          const { originalTexCoord: r, texCoord: s, matrix: i } = n,
            o = e.attributes[`TEXCOORD_${r}`];
          if (Number.isFinite(o)) {
            var a;
            const n =
              null === (a = t.json.accessors) || void 0 === a ? void 0 : a[o];
            if (n && n.bufferView) {
              var c;
              const o =
                null === (c = t.json.bufferViews) || void 0 === c
                  ? void 0
                  : c[n.bufferView];
              if (o) {
                const { arrayBuffer: a, byteOffset: c } = t.buffers[o.buffer],
                  l = (c || 0) + (n.byteOffset || 0) + (o.byteOffset || 0),
                  { ArrayType: h, length: u } = oo(n, o),
                  d = Yi[n.componentType],
                  f = Xi[n.type],
                  m = o.byteStride || d * f,
                  g = new Float32Array(u);
                for (let t = 0; t < n.count; t++) {
                  const e = new h(a, l + t * m, 2);
                  ja.set(e[0], e[1], 1),
                    ja.transformByMatrix3(i),
                    g.set([ja[0], ja[1]], t * f);
                }
                r === s
                  ? (function (t, e, n, r) {
                      (t.componentType = 5126),
                        n.push({
                          arrayBuffer: r.buffer,
                          byteOffset: 0,
                          byteLength: r.buffer.byteLength
                        }),
                        (e.buffer = n.length - 1),
                        (e.byteLength = r.buffer.byteLength),
                        (e.byteOffset = 0),
                        delete e.byteStride;
                    })(n, o, t.buffers, g)
                  : (function (t, e, n, r, s) {
                      r.buffers.push({
                        arrayBuffer: s.buffer,
                        byteOffset: 0,
                        byteLength: s.buffer.byteLength
                      });
                      const i = r.json.bufferViews;
                      if (!i) return;
                      i.push({
                        buffer: r.buffers.length - 1,
                        byteLength: s.buffer.byteLength,
                        byteOffset: 0
                      });
                      const o = r.json.accessors;
                      o &&
                        (o.push({
                          bufferView: (null == i ? void 0 : i.length) - 1,
                          byteOffset: 0,
                          componentType: 5126,
                          count: e.count,
                          type: 'VEC2'
                        }),
                        (n.attributes[`TEXCOORD_${t}`] = o.length - 1));
                    })(s, n, e, t, g);
              }
            }
          }
        }
        const Wa = Object.freeze(
            Object.defineProperty(
              {
                __proto__: null,
                decode: async function (t, e) {
                  var n;
                  if (
                    !new co(t).hasExtension(Ja) ||
                    null === (n = e.gltf) ||
                    void 0 === n ||
                    !n.loadBuffers
                  )
                    return;
                  const r = t.json.materials || [];
                  for (let e = 0; e < r.length; e++) Ka(e, t);
                },
                name: 'KHR_texture_transform'
              },
              Symbol.toStringTag,
              { value: 'Module' }
            )
          ),
          za = 'KHR_lights_punctual',
          Xa = Object.freeze(
            Object.defineProperty(
              {
                __proto__: null,
                decode: async function (t) {
                  const e = new co(t),
                    { json: n } = e,
                    r = e.getExtension(za);
                  r && ((e.json.lights = r.lights), e.removeExtension(za));
                  for (const t of n.nodes || []) {
                    const n = e.getObjectExtension(t, za);
                    n && (t.light = n.light), e.removeObjectExtension(t, za);
                  }
                },
                encode: async function (t) {
                  const e = new co(t),
                    { json: n } = e;
                  if (n.lights) {
                    const t = e.addExtension(za);
                    zi(!t.lights), (t.lights = n.lights), delete n.lights;
                  }
                  if (e.json.lights) {
                    for (const t of e.json.lights) {
                      const n = t.node;
                      e.addObjectExtension(n, za, t);
                    }
                    delete e.json.lights;
                  }
                },
                name: 'KHR_lights_punctual'
              },
              Symbol.toStringTag,
              { value: 'Module' }
            )
          ),
          Ya = 'KHR_materials_unlit',
          Za = Object.freeze(
            Object.defineProperty(
              {
                __proto__: null,
                decode: async function (t) {
                  const e = new co(t),
                    { json: n } = e;
                  for (const t of n.materials || [])
                    t.extensions &&
                      t.extensions.KHR_materials_unlit &&
                      (t.unlit = !0),
                      e.removeObjectExtension(t, Ya);
                  e.removeExtension(Ya);
                },
                encode: function (t) {
                  const e = new co(t),
                    { json: n } = e;
                  if (e.materials)
                    for (const t of n.materials || [])
                      t.unlit &&
                        (delete t.unlit,
                        e.addObjectExtension(t, Ya, {}),
                        e.addExtension(Ya));
                },
                name: 'KHR_materials_unlit'
              },
              Symbol.toStringTag,
              { value: 'Module' }
            )
          ),
          $a = 'KHR_techniques_webgl';
        function tc(t, e) {
          const n = Object.assign({}, t.values);
          return (
            Object.keys(t.uniforms || {}).forEach((e) => {
              t.uniforms[e].value && !(e in n) && (n[e] = t.uniforms[e].value);
            }),
            Object.keys(n).forEach((t) => {
              'object' == typeof n[t] &&
                void 0 !== n[t].index &&
                (n[t].texture = e.getTexture(n[t].index));
            }),
            n
          );
        }
        const ec = Object.freeze(
            Object.defineProperty(
              {
                __proto__: null,
                decode: async function (t) {
                  const e = new co(t),
                    { json: n } = e,
                    r = e.getExtension($a);
                  if (r) {
                    const t = (function (t, e) {
                      const {
                          programs: n = [],
                          shaders: r = [],
                          techniques: s = []
                        } = t,
                        i = new TextDecoder();
                      return (
                        r.forEach((t) => {
                          if (!Number.isFinite(t.bufferView))
                            throw new Error(
                              'KHR_techniques_webgl: no shader code'
                            );
                          t.code = i.decode(
                            e.getTypedArrayForBufferView(t.bufferView)
                          );
                        }),
                        n.forEach((t) => {
                          (t.fragmentShader = r[t.fragmentShader]),
                            (t.vertexShader = r[t.vertexShader]);
                        }),
                        s.forEach((t) => {
                          t.program = n[t.program];
                        }),
                        s
                      );
                    })(r, e);
                    for (const r of n.materials || []) {
                      const n = e.getObjectExtension(r, $a);
                      n &&
                        ((r.technique = Object.assign({}, n, t[n.technique])),
                        (r.technique.values = tc(r.technique, e))),
                        e.removeObjectExtension(r, $a);
                    }
                    e.removeExtension($a);
                  }
                },
                encode: async function (t, e) {},
                name: 'KHR_techniques_webgl'
              },
              Symbol.toStringTag,
              { value: 'Module' }
            )
          ),
          nc = [Do, vo, Fa, Ra, Da, Pa, Xa, Za, ec, Wa, jo];
        function rc(t) {
          let e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {},
            n = arguments.length > 2 ? arguments[2] : void 0;
          const r = nc.filter((t) => ic(t.name, e));
          for (const i of r) {
            var s;
            null === (s = i.preprocess) || void 0 === s || s.call(i, t, e, n);
          }
        }
        async function sc(t) {
          let e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {},
            n = arguments.length > 2 ? arguments[2] : void 0;
          const r = nc.filter((t) => ic(t.name, e));
          for (const i of r) {
            var s;
            await (null === (s = i.decode) || void 0 === s
              ? void 0
              : s.call(i, t, e, n));
          }
        }
        function ic(t, e) {
          var n;
          const r =
            (null == e || null === (n = e.gltf) || void 0 === n
              ? void 0
              : n.excludeExtensions) || {};
          return !(t in r && !r[t]);
        }
        const oc = 'KHR_binary_glTF',
          ac = {
            accessors: 'accessor',
            animations: 'animation',
            buffers: 'buffer',
            bufferViews: 'bufferView',
            images: 'image',
            materials: 'material',
            meshes: 'mesh',
            nodes: 'node',
            samplers: 'sampler',
            scenes: 'scene',
            skins: 'skin',
            textures: 'texture'
          },
          cc = {
            accessor: 'accessors',
            animations: 'animation',
            buffer: 'buffers',
            bufferView: 'bufferViews',
            image: 'images',
            material: 'materials',
            mesh: 'meshes',
            node: 'nodes',
            sampler: 'samplers',
            scene: 'scenes',
            skin: 'skins',
            texture: 'textures'
          };
        class lc {
          constructor() {
            (this.idToIndexMap = {
              animations: {},
              accessors: {},
              buffers: {},
              bufferViews: {},
              images: {},
              materials: {},
              meshes: {},
              nodes: {},
              samplers: {},
              scenes: {},
              skins: {},
              textures: {}
            }),
              (this.json = void 0);
          }
          normalize(t, e) {
            this.json = t.json;
            const n = t.json;
            switch (n.asset && n.asset.version) {
              case '2.0':
                return;
              case void 0:
              case '1.0':
                break;
              default:
                return void console.warn(
                  `glTF: Unknown version ${n.asset.version}`
                );
            }
            if (!e.normalize) throw new Error('glTF v1 is not supported.');
            console.warn(
              'Converting glTF v1 to glTF v2 format. This is experimental and may fail.'
            ),
              this._addAsset(n),
              this._convertTopLevelObjectsToArrays(n),
              (function (t) {
                const e = new co(t),
                  { json: n } = e;
                for (const t of n.images || []) {
                  const n = e.getObjectExtension(t, oc);
                  n && Object.assign(t, n), e.removeObjectExtension(t, oc);
                }
                n.buffers && n.buffers[0] && delete n.buffers[0].uri,
                  e.removeExtension(oc);
              })(t),
              this._convertObjectIdsToArrayIndices(n),
              this._updateObjects(n),
              this._updateMaterial(n);
          }
          _addAsset(t) {
            (t.asset = t.asset || {}),
              (t.asset.version = '2.0'),
              (t.asset.generator =
                t.asset.generator || 'Normalized to glTF 2.0 by loaders.gl');
          }
          _convertTopLevelObjectsToArrays(t) {
            for (const e in ac) this._convertTopLevelObjectToArray(t, e);
          }
          _convertTopLevelObjectToArray(t, e) {
            const n = t[e];
            if (n && !Array.isArray(n)) {
              t[e] = [];
              for (const r in n) {
                const s = n[r];
                s.id = s.id || r;
                const i = t[e].length;
                t[e].push(s), (this.idToIndexMap[e][r] = i);
              }
            }
          }
          _convertObjectIdsToArrayIndices(t) {
            for (const e in ac) this._convertIdsToIndices(t, e);
            'scene' in t &&
              (t.scene = this._convertIdToIndex(t.scene, 'scene'));
            for (const e of t.textures) this._convertTextureIds(e);
            for (const e of t.meshes) this._convertMeshIds(e);
            for (const e of t.nodes) this._convertNodeIds(e);
            for (const e of t.scenes) this._convertSceneIds(e);
          }
          _convertTextureIds(t) {
            t.source && (t.source = this._convertIdToIndex(t.source, 'image'));
          }
          _convertMeshIds(t) {
            for (const e of t.primitives) {
              const { attributes: t, indices: n, material: r } = e;
              for (const e in t)
                t[e] = this._convertIdToIndex(t[e], 'accessor');
              n && (e.indices = this._convertIdToIndex(n, 'accessor')),
                r && (e.material = this._convertIdToIndex(r, 'material'));
            }
          }
          _convertNodeIds(t) {
            t.children &&
              (t.children = t.children.map((t) =>
                this._convertIdToIndex(t, 'node')
              )),
              t.meshes &&
                (t.meshes = t.meshes.map((t) =>
                  this._convertIdToIndex(t, 'mesh')
                ));
          }
          _convertSceneIds(t) {
            t.nodes &&
              (t.nodes = t.nodes.map((t) => this._convertIdToIndex(t, 'node')));
          }
          _convertIdsToIndices(t, e) {
            t[e] ||
              (console.warn(`gltf v1: json doesn't contain attribute ${e}`),
              (t[e] = []));
            for (const n of t[e])
              for (const t in n) {
                const e = n[t],
                  r = this._convertIdToIndex(e, t);
                n[t] = r;
              }
          }
          _convertIdToIndex(t, e) {
            const n = cc[e];
            if (n in this.idToIndexMap) {
              const r = this.idToIndexMap[n][t];
              if (!Number.isFinite(r))
                throw new Error(`gltf v1: failed to resolve ${e} with id ${t}`);
              return r;
            }
            return t;
          }
          _updateObjects(t) {
            for (const t of this.json.buffers) delete t.type;
          }
          _updateMaterial(t) {
            for (const s of t.materials) {
              var e, n, r;
              s.pbrMetallicRoughness = {
                baseColorFactor: [1, 1, 1, 1],
                metallicFactor: 1,
                roughnessFactor: 1
              };
              const i =
                  (null === (e = s.values) || void 0 === e ? void 0 : e.tex) ||
                  (null === (n = s.values) || void 0 === n
                    ? void 0
                    : n.texture2d_0) ||
                  (null === (r = s.values) || void 0 === r
                    ? void 0
                    : r.diffuseTex),
                o = t.textures.findIndex((t) => t.id === i);
              -1 !== o &&
                (s.pbrMetallicRoughness.baseColorTexture = { index: o });
            }
          }
        }
        function hc(t) {
          let e =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          return new lc().normalize(t, e);
        }
        async function uc(t, e) {
          var n, r, s;
          let i =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : 0,
            o = arguments.length > 3 ? arguments[3] : void 0,
            a = arguments.length > 4 ? arguments[4] : void 0;
          return (
            dc(t, e, i, o),
            hc(t, {
              normalize:
                null == o || null === (n = o.gltf) || void 0 === n
                  ? void 0
                  : n.normalize
            }),
            rc(t, o, a),
            null != o &&
              null !== (r = o.gltf) &&
              void 0 !== r &&
              r.loadBuffers &&
              t.json.buffers &&
              (await fc(t, o, a)),
            null != o &&
              null !== (s = o.gltf) &&
              void 0 !== s &&
              s.loadImages &&
              (await mc(t, o, a)),
            await sc(t, o, a),
            t
          );
        }
        function dc(t, e, n, r) {
          if (
            (r.uri && (t.baseUri = r.uri),
            e instanceof ArrayBuffer &&
              !(function (t) {
                let e =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : 0,
                  n =
                    arguments.length > 2 && void 0 !== arguments[2]
                      ? arguments[2]
                      : {};
                const r = new DataView(t),
                  { magic: s = ma } = n,
                  i = r.getUint32(e, !1);
                return i === s || i === ma;
              })(e, n, r) &&
              (e = new TextDecoder().decode(e)),
            'string' == typeof e)
          )
            t.json = (function (t) {
              try {
                return JSON.parse(t);
              } catch {
                throw new Error(
                  `Failed to parse JSON from data starting with "${(function (
                    t
                  ) {
                    let e =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : 5;
                    return 'string' == typeof t
                      ? t.slice(0, e)
                      : ArrayBuffer.isView(t)
                      ? G(t.buffer, t.byteOffset, e)
                      : t instanceof ArrayBuffer
                      ? G(t, 0, e)
                      : '';
                  })(t)}"`
                );
              }
            })(e);
          else if (e instanceof ArrayBuffer) {
            const s = {};
            (n = (function (t, e) {
              let n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 0;
              const r = new DataView(e),
                s = ga(r, n + 0),
                i = r.getUint32(n + 4, fa),
                o = r.getUint32(n + 8, fa);
              switch (
                (Object.assign(t, {
                  header: { byteOffset: n, byteLength: o, hasBinChunk: !1 },
                  type: s,
                  version: i,
                  json: {},
                  binChunks: []
                }),
                (n += 12),
                t.version)
              ) {
                case 1:
                  return Aa(t, r, n);
                case 2:
                  return pa(t, r, n, {});
                default:
                  throw new Error(
                    `Invalid GLB version ${t.version}. Only supports version 1 and 2.`
                  );
              }
            })(s, e, n, r.glb)),
              zi('glTF' === s.type, `Invalid GLB magic string ${s.type}`),
              (t._glb = s),
              (t.json = s.json);
          } else zi(!1, 'GLTF: must be ArrayBuffer or string');
          const s = t.json.buffers || [];
          if (
            ((t.buffers = new Array(s.length).fill(null)),
            t._glb && t._glb.header.hasBinChunk)
          ) {
            const { binChunks: e } = t._glb;
            t.buffers[0] = {
              arrayBuffer: e[0].arrayBuffer,
              byteOffset: e[0].byteOffset,
              byteLength: e[0].byteLength
            };
          }
          const i = t.json.images || [];
          t.images = new Array(i.length).fill({});
        }
        async function fc(t, e, n) {
          const r = t.json.buffers || [];
          for (let o = 0; o < r.length; ++o) {
            const a = r[o];
            if (a.uri) {
              var s, i;
              const { fetch: r } = n;
              zi(r);
              const c = ba(a.uri, e),
                l = await (null == n || null === (s = n.fetch) || void 0 === s
                  ? void 0
                  : s.call(n, c)),
                h = await (null == l ||
                null === (i = l.arrayBuffer) ||
                void 0 === i
                  ? void 0
                  : i.call(l));
              (t.buffers[o] = {
                arrayBuffer: h,
                byteOffset: 0,
                byteLength: h.byteLength
              }),
                delete a.uri;
            } else
              null === t.buffers[o] &&
                (t.buffers[o] = {
                  arrayBuffer: new ArrayBuffer(a.byteLength),
                  byteOffset: 0,
                  byteLength: a.byteLength
                });
          }
        }
        async function mc(t, e, n) {
          const r = (function (t) {
              const e = new Set(),
                n = t.json.textures || [];
              for (const t of n) void 0 !== t.source && e.add(t.source);
              return Array.from(e).sort();
            })(t),
            s = t.json.images || [],
            i = [];
          for (const o of r) i.push(gc(t, s[o], o, e, n));
          return await Promise.all(i);
        }
        async function gc(t, n, r, s, i) {
          let o;
          if (n.uri && !n.hasOwnProperty('bufferView')) {
            const t = ba(n.uri, s),
              { fetch: e } = i;
            (o = await (await e(t)).arrayBuffer()),
              (n.bufferView = { data: o });
          }
          if (Number.isFinite(n.bufferView)) {
            const e = (function (t, e, n) {
              const r = t.bufferViews[n];
              zi(r);
              const s = e[r.buffer];
              zi(s);
              const i = (r.byteOffset || 0) + s.byteOffset;
              return new Uint8Array(s.arrayBuffer, i, r.byteLength);
            })(t.json, t.buffers, n.bufferView);
            o = U(e.buffer, e.byteOffset, e.byteLength);
          }
          zi(o, 'glTF image has no data');
          let a = await e(
            o,
            [qi, da],
            { ...s, mimeType: n.mimeType, basis: s.basis || { format: ua() } },
            i
          );
          a &&
            a[0] &&
            (a = {
              compressed: !0,
              mipmaps: !1,
              width: a[0].width,
              height: a[0].height,
              data: a[0]
            }),
            (t.images = t.images || []),
            (t.images[r] = a);
        }
        const Ac = {
            name: 'glTF',
            id: 'gltf',
            module: 'gltf',
            version: '4.1.1',
            extensions: ['gltf', 'glb'],
            mimeTypes: ['model/gltf+json', 'model/gltf-binary'],
            text: !0,
            binary: !0,
            tests: ['glTF'],
            parse: async function (t) {
              let e =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : {},
                n = arguments.length > 2 ? arguments[2] : void 0;
              (e = { ...Ac.options, ...e }),
                (e.gltf = { ...Ac.options.gltf, ...e.gltf });
              const { byteOffset: r = 0 } = e;
              return await uc({}, t, r, e, n);
            },
            options: {
              gltf: {
                normalize: !0,
                loadBuffers: !0,
                loadImages: !0,
                decompressMeshes: !0
              },
              log: console
            }
          },
          pc = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
          },
          yc = { 5120: 1, 5121: 1, 5122: 2, 5123: 2, 5125: 4, 5126: 4 },
          Bc = {
            magFilter: 10240,
            minFilter: 10241,
            wrapS: 10242,
            wrapT: 10243
          },
          bc = { 10240: 9729, 10241: 9986, 10242: 10497, 10243: 10497 };
        class Cc {
          constructor() {
            (this.baseUri = ''),
              (this.jsonUnprocessed = void 0),
              (this.json = void 0),
              (this.buffers = []),
              (this.images = []);
          }
          postProcess(t) {
            let e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {};
            const { json: n, buffers: r = [], images: s = [] } = t,
              { baseUri: i = '' } = t;
            return (
              zi(n),
              (this.baseUri = i),
              (this.buffers = r),
              (this.images = s),
              (this.jsonUnprocessed = n),
              (this.json = this._resolveTree(t.json, e)),
              this.json
            );
          }
          _resolveTree(t) {
            const e = { ...t };
            return (
              (this.json = e),
              t.bufferViews &&
                (e.bufferViews = t.bufferViews.map((t, e) =>
                  this._resolveBufferView(t, e)
                )),
              t.images &&
                (e.images = t.images.map((t, e) => this._resolveImage(t, e))),
              t.samplers &&
                (e.samplers = t.samplers.map((t, e) =>
                  this._resolveSampler(t, e)
                )),
              t.textures &&
                (e.textures = t.textures.map((t, e) =>
                  this._resolveTexture(t, e)
                )),
              t.accessors &&
                (e.accessors = t.accessors.map((t, e) =>
                  this._resolveAccessor(t, e)
                )),
              t.materials &&
                (e.materials = t.materials.map((t, e) =>
                  this._resolveMaterial(t, e)
                )),
              t.meshes &&
                (e.meshes = t.meshes.map((t, e) => this._resolveMesh(t, e))),
              t.nodes &&
                ((e.nodes = t.nodes.map((t, e) => this._resolveNode(t, e))),
                (e.nodes = e.nodes.map((t, e) =>
                  this._resolveNodeChildren(t)
                ))),
              t.skins &&
                (e.skins = t.skins.map((t, e) => this._resolveSkin(t, e))),
              t.scenes &&
                (e.scenes = t.scenes.map((t, e) => this._resolveScene(t, e))),
              'number' == typeof this.json.scene &&
                e.scenes &&
                (e.scene = e.scenes[this.json.scene]),
              e
            );
          }
          getScene(t) {
            return this._get(this.json.scenes, t);
          }
          getNode(t) {
            return this._get(this.json.nodes, t);
          }
          getSkin(t) {
            return this._get(this.json.skins, t);
          }
          getMesh(t) {
            return this._get(this.json.meshes, t);
          }
          getMaterial(t) {
            return this._get(this.json.materials, t);
          }
          getAccessor(t) {
            return this._get(this.json.accessors, t);
          }
          getCamera(t) {
            return this._get(this.json.cameras, t);
          }
          getTexture(t) {
            return this._get(this.json.textures, t);
          }
          getSampler(t) {
            return this._get(this.json.samplers, t);
          }
          getImage(t) {
            return this._get(this.json.images, t);
          }
          getBufferView(t) {
            return this._get(this.json.bufferViews, t);
          }
          getBuffer(t) {
            return this._get(this.json.buffers, t);
          }
          _get(t, e) {
            if ('object' == typeof e) return e;
            const n = t && t[e];
            return (
              n || console.warn(`glTF file error: Could not find ${t}[${e}]`), n
            );
          }
          _resolveScene(t, e) {
            return {
              ...t,
              id: t.id || `scene-${e}`,
              nodes: (t.nodes || []).map((t) => this.getNode(t))
            };
          }
          _resolveNode(t, e) {
            const n = { ...t, id: (null == t ? void 0 : t.id) || `node-${e}` };
            return (
              void 0 !== t.mesh && (n.mesh = this.getMesh(t.mesh)),
              void 0 !== t.camera && (n.camera = this.getCamera(t.camera)),
              void 0 !== t.skin && (n.skin = this.getSkin(t.skin)),
              void 0 !== t.meshes &&
                t.meshes.length &&
                (n.mesh = t.meshes.reduce(
                  (t, e) => {
                    const n = this.getMesh(e);
                    return (
                      (t.id = n.id),
                      (t.primitives = t.primitives.concat(n.primitives)),
                      t
                    );
                  },
                  { primitives: [] }
                )),
              n
            );
          }
          _resolveNodeChildren(t) {
            return (
              t.children &&
                (t.children = t.children.map((t) => this.getNode(t))),
              t
            );
          }
          _resolveSkin(t, e) {
            const n =
              'number' == typeof t.inverseBindMatrices
                ? this.getAccessor(t.inverseBindMatrices)
                : void 0;
            return { ...t, id: t.id || `skin-${e}`, inverseBindMatrices: n };
          }
          _resolveMesh(t, e) {
            const n = { ...t, id: t.id || `mesh-${e}`, primitives: [] };
            return (
              t.primitives &&
                (n.primitives = t.primitives.map((t) => {
                  const e = {
                      ...t,
                      attributes: {},
                      indices: void 0,
                      material: void 0
                    },
                    n = t.attributes;
                  for (const t in n) e.attributes[t] = this.getAccessor(n[t]);
                  return (
                    void 0 !== t.indices &&
                      (e.indices = this.getAccessor(t.indices)),
                    void 0 !== t.material &&
                      (e.material = this.getMaterial(t.material)),
                    e
                  );
                })),
              n
            );
          }
          _resolveMaterial(t, e) {
            const n = { ...t, id: t.id || `material-${e}` };
            if (
              (n.normalTexture &&
                ((n.normalTexture = { ...n.normalTexture }),
                (n.normalTexture.texture = this.getTexture(
                  n.normalTexture.index
                ))),
              n.occlusionTexture &&
                ((n.occlusionTexture = { ...n.occlusionTexture }),
                (n.occlusionTexture.texture = this.getTexture(
                  n.occlusionTexture.index
                ))),
              n.emissiveTexture &&
                ((n.emissiveTexture = { ...n.emissiveTexture }),
                (n.emissiveTexture.texture = this.getTexture(
                  n.emissiveTexture.index
                ))),
              n.emissiveFactor ||
                (n.emissiveFactor = n.emissiveTexture ? [1, 1, 1] : [0, 0, 0]),
              n.pbrMetallicRoughness)
            ) {
              n.pbrMetallicRoughness = { ...n.pbrMetallicRoughness };
              const t = n.pbrMetallicRoughness;
              t.baseColorTexture &&
                ((t.baseColorTexture = { ...t.baseColorTexture }),
                (t.baseColorTexture.texture = this.getTexture(
                  t.baseColorTexture.index
                ))),
                t.metallicRoughnessTexture &&
                  ((t.metallicRoughnessTexture = {
                    ...t.metallicRoughnessTexture
                  }),
                  (t.metallicRoughnessTexture.texture = this.getTexture(
                    t.metallicRoughnessTexture.index
                  )));
            }
            return n;
          }
          _resolveAccessor(t, e) {
            const n = (function (t) {
                return yc[t];
              })(t.componentType),
              r = (function (t) {
                return pc[t];
              })(t.type),
              s = n * r,
              i = {
                ...t,
                id: t.id || `accessor-${e}`,
                bytesPerComponent: n,
                components: r,
                bytesPerElement: s,
                value: void 0,
                bufferView: void 0,
                sparse: void 0
              };
            if (
              (void 0 !== t.bufferView &&
                (i.bufferView = this.getBufferView(t.bufferView)),
              i.bufferView)
            ) {
              const t = i.bufferView.buffer,
                { ArrayType: e, byteLength: n } = oo(i, i.bufferView),
                r =
                  (i.bufferView.byteOffset || 0) +
                  (i.byteOffset || 0) +
                  t.byteOffset;
              let s = t.arrayBuffer.slice(r, r + n);
              i.bufferView.byteStride &&
                (s = this._getValueFromInterleavedBuffer(
                  t,
                  r,
                  i.bufferView.byteStride,
                  i.bytesPerElement,
                  i.count
                )),
                (i.value = new e(s));
            }
            return i;
          }
          _getValueFromInterleavedBuffer(t, e, n, r, s) {
            const i = new Uint8Array(s * r);
            for (let o = 0; o < s; o++) {
              const s = e + o * n;
              i.set(new Uint8Array(t.arrayBuffer.slice(s, s + r)), o * r);
            }
            return i.buffer;
          }
          _resolveTexture(t, e) {
            return {
              ...t,
              id: t.id || `texture-${e}`,
              sampler:
                'number' == typeof t.sampler
                  ? this.getSampler(t.sampler)
                  : { id: 'default-sampler', parameters: bc },
              source:
                'number' == typeof t.source ? this.getImage(t.source) : void 0
            };
          }
          _resolveSampler(t, e) {
            const n = { id: t.id || `sampler-${e}`, ...t, parameters: {} };
            for (const t in n) {
              const e = this._enumSamplerParameter(t);
              void 0 !== e && (n.parameters[e] = n[t]);
            }
            return n;
          }
          _enumSamplerParameter(t) {
            return Bc[t];
          }
          _resolveImage(t, e) {
            const n = {
                ...t,
                id: t.id || `image-${e}`,
                image: null,
                bufferView:
                  void 0 !== t.bufferView
                    ? this.getBufferView(t.bufferView)
                    : void 0
              },
              r = this.images[e];
            return r && (n.image = r), n;
          }
          _resolveBufferView(t, e) {
            const n = t.buffer,
              r = this.buffers[n].arrayBuffer;
            let s = this.buffers[n].byteOffset || 0;
            return (
              t.byteOffset && (s += t.byteOffset),
              {
                id: `bufferView-${e}`,
                ...t,
                buffer: this.buffers[n],
                data: new Uint8Array(r, s, t.byteLength)
              }
            );
          }
          _resolveCamera(t, e) {
            const n = { ...t, id: t.id || `camera-${e}` };
            return n.perspective, n.orthographic, n;
          }
        }
        function wc(t, e) {
          return new Cc().postProcess(t, e);
        }
        function Ec(t, e, n, r) {
          t.rotateYtoZ = !0;
          const s = (t.byteOffset || 0) + (t.byteLength || 0) - n;
          if (0 === s)
            throw new Error('glTF byte length must be greater than 0.');
          return (
            (t.gltfUpAxis =
              null != r && r['3d-tiles'] && r['3d-tiles'].assetGltfUpAxis
                ? r['3d-tiles'].assetGltfUpAxis
                : 'Y'),
            (t.gltfArrayBuffer = U(e, n, s)),
            (t.gltfByteOffset = 0),
            (t.gltfByteLength = s),
            n % 4 == 0 ||
              console.warn(
                `${t.type}: embedded glb is not aligned to a 4-byte boundary.`
              ),
            (t.byteOffset || 0) + (t.byteLength || 0)
          );
        }
        async function Tc(t, n, r, s) {
          const i = (null == r ? void 0 : r['3d-tiles']) || {};
          if (
            ((function (t, e, n) {
              switch (e) {
                case 0:
                  if (t.gltfArrayBuffer) {
                    const e = new Uint8Array(
                        t.gltfArrayBuffer,
                        t.gltfByteOffset
                      ),
                      n = new TextDecoder().decode(e);
                    t.gltfUrl = n.replace(/[\s\0]+$/, '');
                  }
                  delete t.gltfArrayBuffer,
                    delete t.gltfByteOffset,
                    delete t.gltfByteLength;
                  break;
                case 1:
                  break;
                default:
                  throw new Error('b3dm: Illegal glTF format field');
              }
            })(t, n),
            i.loadGLTF)
          ) {
            if (!s) return;
            if (t.gltfUrl) {
              const { fetch: e } = s,
                n = await e(t.gltfUrl, r);
              (t.gltfArrayBuffer = await n.arrayBuffer()),
                (t.gltfByteOffset = 0);
            }
            if (t.gltfArrayBuffer) {
              const n = await e(t.gltfArrayBuffer, Ac, r, s);
              (t.gltf = wc(n)),
                (t.gpuMemoryUsageInBytes = ao(t.gltf)),
                delete t.gltfArrayBuffer,
                delete t.gltfByteOffset,
                delete t.gltfByteLength;
            }
          }
        }
        async function vc(t, e, n, r, s) {
          var i;
          (n = (function (t, e, n, r, s) {
            n = Ec(t, e, (n = Ti(t, e, (n = Ei(t, e, (n = Ci(t, e, n)))))), r);
            const i = new hi(t.featureTableJson, t.featureTableBinary);
            return (
              (t.rtcCenter = i.getGlobalProperty('RTC_CENTER', ei.FLOAT, 3)), n
            );
          })(t, e, n, r)),
            await Tc(t, 1, r, s);
          const o =
            null == t || null === (i = t.gltf) || void 0 === i
              ? void 0
              : i.extensions;
          return o && o.CESIUM_RTC && (t.rtcCenter = o.CESIUM_RTC.center), n;
        }
        async function _c(t, e, n, r, s) {
          return (
            (n = (function (t, e, n, r, s) {
              var i;
              if (((n = Ci(t, e, n)), 1 !== t.version))
                throw new Error(
                  `Instanced 3D Model version ${t.version} is not supported`
                );
              n = Ei(t, e, n);
              const o = new DataView(e);
              if (
                ((t.gltfFormat = o.getUint32(n, !0)),
                (n = Ec(t, e, (n = Ti(t, e, (n += 4))), r)),
                null == t ||
                  null === (i = t.header) ||
                  void 0 === i ||
                  !i.featureTableJsonByteLength ||
                  0 === t.header.featureTableJsonByteLength)
              )
                throw new Error(
                  'i3dm parser: featureTableJsonByteLength is zero.'
                );
              const a = new hi(t.featureTableJson, t.featureTableBinary),
                c = a.getGlobalProperty('INSTANCES_LENGTH');
              if (((a.featuresLength = c), !Number.isFinite(c)))
                throw new Error(
                  'i3dm parser: INSTANCES_LENGTH must be defined'
                );
              return (
                (t.eastNorthUp = a.getGlobalProperty('EAST_NORTH_UP')),
                (t.rtcCenter = a.getGlobalProperty('RTC_CENTER', ei.FLOAT, 3)),
                new bi(t.batchTableJson, t.batchTableBinary, c),
                (function (t, e, n, r) {
                  const s = new Array(r),
                    i = new Qe();
                  new Qe(), new Qe(), new Qe();
                  const o = new $e(),
                    a = new Bn(),
                    c = new Qe(),
                    l = {},
                    h = new hn(),
                    u = [],
                    d = [],
                    f = [],
                    m = [];
                  for (let n = 0; n < r; n++) {
                    let r;
                    if (e.hasProperty('POSITION'))
                      r = e.getProperty('POSITION', ei.FLOAT, 3, n, i);
                    else if (e.hasProperty('POSITION_QUANTIZED')) {
                      r = e.getProperty(
                        'POSITION_QUANTIZED',
                        ei.UNSIGNED_SHORT,
                        3,
                        n,
                        i
                      );
                      const t = e.getGlobalProperty(
                        'QUANTIZED_VOLUME_OFFSET',
                        ei.FLOAT,
                        3
                      );
                      if (!t)
                        throw new Error(
                          'i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.'
                        );
                      const s = e.getGlobalProperty(
                        'QUANTIZED_VOLUME_SCALE',
                        ei.FLOAT,
                        3
                      );
                      if (!s)
                        throw new Error(
                          'i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.'
                        );
                      const o = 65535;
                      for (let e = 0; e < 3; e++)
                        r[e] = (r[e] / o) * s[e] + t[e];
                    }
                    if (!r)
                      throw new Error(
                        'i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.'
                      );
                    if (
                      (i.copy(r),
                      (l.translation = i),
                      (t.normalUp = e.getProperty(
                        'NORMAL_UP',
                        ei.FLOAT,
                        3,
                        n,
                        u
                      )),
                      (t.normalRight = e.getProperty(
                        'NORMAL_RIGHT',
                        ei.FLOAT,
                        3,
                        n,
                        d
                      )),
                      t.normalUp)
                    ) {
                      if (!t.normalRight)
                        throw new Error(
                          'i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.'
                        );
                      t.hasCustomOrientation = !0;
                    } else {
                      if (
                        ((t.octNormalUp = e.getProperty(
                          'NORMAL_UP_OCT32P',
                          ei.UNSIGNED_SHORT,
                          2,
                          n,
                          u
                        )),
                        (t.octNormalRight = e.getProperty(
                          'NORMAL_RIGHT_OCT32P',
                          ei.UNSIGNED_SHORT,
                          2,
                          n,
                          d
                        )),
                        t.octNormalUp)
                      )
                        throw t.octNormalRight
                          ? new Error(
                              'i3dm: oct-encoded orientation not implemented'
                            )
                          : new Error(
                              'i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P'
                            );
                      t.eastNorthUp
                        ? (Pn.WGS84.eastNorthUpToFixedFrame(i, h),
                          h.getRotationMatrix3(o))
                        : o.identity();
                    }
                    a.fromMatrix3(o), (l.rotation = a), c.set(1, 1, 1);
                    const g = e.getProperty('SCALE', ei.FLOAT, 1, n, f);
                    Number.isFinite(g) && c.multiplyByScalar(g);
                    const A = e.getProperty(
                      'SCALE_NON_UNIFORM',
                      ei.FLOAT,
                      3,
                      n,
                      u
                    );
                    A && c.scale(A), (l.scale = c);
                    let p = e.getProperty(
                      'BATCH_ID',
                      ei.UNSIGNED_SHORT,
                      1,
                      n,
                      m
                    );
                    void 0 === p && (p = n);
                    const y = new hn().fromQuaternion(l.rotation);
                    h.identity(),
                      h.translate(l.translation),
                      h.multiplyRight(y),
                      h.scale(l.scale);
                    const B = h.clone();
                    s[n] = { modelMatrix: B, batchId: p };
                  }
                  t.instances = s;
                })(t, a, 0, c),
                n
              );
            })(t, e, n, r)),
            await Tc(t, t.gltfFormat || 0, r, s),
            n
          );
        }
        async function Mc(t, e, n, r, s, i) {
          n = Ci(t, e, n);
          const o = new DataView(e);
          for (
            t.tilesLength = o.getUint32(n, !0), n += 4, t.tiles = [];
            t.tiles.length < t.tilesLength && (t.byteLength || 0) - n > 12;

          ) {
            const o = { shape: 'tile3d' };
            t.tiles.push(o), (n = await i(e, n, r, s, o));
          }
          return n;
        }
        async function Ic(t, n, r, s) {
          var i, o;
          if (
            ((t.rotateYtoZ = !0),
            (t.gltfUpAxis =
              null != r &&
              null !== (i = r['3d-tiles']) &&
              void 0 !== i &&
              i.assetGltfUpAxis
                ? r['3d-tiles'].assetGltfUpAxis
                : 'Y'),
            null != r &&
              null !== (o = r['3d-tiles']) &&
              void 0 !== o &&
              o.loadGLTF)
          ) {
            if (!s) return n.byteLength;
            const i = await e(n, Ac, r, s);
            (t.gltf = wc(i)), (t.gpuMemoryUsageInBytes = ao(t.gltf));
          } else t.gltfArrayBuffer = n;
          return n.byteLength;
        }
        async function xc(t) {
          let e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 0,
            n = arguments.length > 2 ? arguments[2] : void 0,
            r = arguments.length > 3 ? arguments[3] : void 0,
            s =
              arguments.length > 4 && void 0 !== arguments[4]
                ? arguments[4]
                : { shape: 'tile3d' };
          switch (((s.byteOffset = e), (s.type = Hs(t, e)), s.type)) {
            case Ss:
              return await Mc(s, t, e, n, r, xc);
            case Gs:
              return await vc(s, t, e, n, r);
            case Us:
              return await Ic(s, t, n, r);
            case Ls:
              return await _c(s, t, e, n, r);
            case Ds:
              return await Mi(s, t, e, n, r);
            default:
              throw new Error(`3DTileLoader: unknown type ${s.type}`);
          }
        }
        async function Fc(t, e, n, r) {
          const s = Number.isFinite(e.bitstream) ? e.bitstream : e.bufferView;
          if ('number' != typeof s) return;
          const i = t.bufferViews[s],
            o = t.buffers[i.buffer];
          if (null == r || !r.baseUrl) throw new Error('Url is not provided');
          if (!r.fetch) throw new Error('fetch is not provided');
          if (o.uri) {
            const t = `${(null == r ? void 0 : r.baseUrl) || ''}/${o.uri}`,
              n = await (await r.fetch(t)).arrayBuffer();
            return void (e.explicitBitstream = new Uint8Array(
              n,
              i.byteOffset,
              i.byteLength
            ));
          }
          const a = t.buffers
            .slice(0, i.buffer)
            .reduce((t, e) => t + e.byteLength, 0);
          e.explicitBitstream = new Uint8Array(
            n.slice(a, a + o.byteLength),
            i.byteOffset,
            i.byteLength
          );
        }
        function Oc(t) {
          const e = new DataView(t);
          return e.getUint32(0, !0) + 2 ** 32 * e.getUint32(4, !0);
        }
        const Rc = {
          id: '3d-tiles-subtree',
          name: '3D Tiles Subtree',
          module: '3d-tiles',
          version: Rs,
          extensions: ['subtree'],
          mimeTypes: ['application/octet-stream'],
          tests: ['subtree'],
          parse: async function (t, e, n) {
            if (1952609651 !== new Uint32Array(t.slice(0, 4))[0])
              throw new Error('Wrong subtree file magic number');
            if (1 !== new Uint32Array(t.slice(4, 8))[0])
              throw new Error('Wrong subtree file verson, must be 1');
            const r = Oc(t.slice(8, 16)),
              s = new Uint8Array(t, 24, r),
              i = new TextDecoder('utf8').decode(s),
              o = JSON.parse(i),
              a = Oc(t.slice(16, 24));
            let c = new ArrayBuffer(0);
            if (
              (a && (c = t.slice(24 + r)),
              await Fc(o, o.tileAvailability, c, n),
              Array.isArray(o.contentAvailability))
            )
              for (const t of o.contentAvailability) await Fc(o, t, c, n);
            else await Fc(o, o.contentAvailability, c, n);
            return await Fc(o, o.childSubtreeAvailability, c, n), o;
          },
          options: {}
        };
        var Sc = null;
        try {
          Sc = new WebAssembly.Instance(
            new WebAssembly.Module(
              new Uint8Array([
                0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4,
                127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1,
                127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100,
                105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5,
                114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5,
                8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6,
                4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32,
                134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4,
                66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0,
                173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66,
                32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167,
                11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32,
                2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135,
                167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1,
                173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132,
                129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1,
                126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,
                3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0,
                32, 4, 167, 11
              ])
            ),
            {}
          ).exports;
        } catch {}
        function Dc(t, e, n) {
          (this.low = 0 | t), (this.high = 0 | e), (this.unsigned = !!n);
        }
        function Gc(t) {
          return !0 === (t && t.__isLong__);
        }
        function Lc(t) {
          var e = Math.clz32(t & -t);
          return t ? 31 - e : e;
        }
        Dc.prototype.__isLong__,
          Object.defineProperty(Dc.prototype, '__isLong__', { value: !0 }),
          (Dc.isLong = Gc);
        var Uc = {},
          Nc = {};
        function Hc(t, e) {
          var n, r, s;
          return e
            ? (s = 0 <= (t >>>= 0) && t < 256) && (r = Nc[t])
              ? r
              : ((n = Jc(t, 0, !0)), s && (Nc[t] = n), n)
            : (s = -128 <= (t |= 0) && t < 128) && (r = Uc[t])
            ? r
            : ((n = Jc(t, t < 0 ? -1 : 0, !1)), s && (Uc[t] = n), n);
        }
        function Pc(t, e) {
          if (isNaN(t)) return e ? Xc : zc;
          if (e) {
            if (t < 0) return Xc;
            if (t >= Qc) return el;
          } else {
            if (t <= -qc) return nl;
            if (t + 1 >= qc) return tl;
          }
          return t < 0 ? Pc(-t, e).neg() : Jc(t % Kc | 0, (t / Kc) | 0, e);
        }
        function Jc(t, e, n) {
          return new Dc(t, e, n);
        }
        (Dc.fromInt = Hc), (Dc.fromNumber = Pc), (Dc.fromBits = Jc);
        var jc = Math.pow;
        function kc(t, e, n) {
          if (0 === t.length) throw Error('empty string');
          if (
            ('number' == typeof e ? ((n = e), (e = !1)) : (e = !!e),
            'NaN' === t ||
              'Infinity' === t ||
              '+Infinity' === t ||
              '-Infinity' === t)
          )
            return e ? Xc : zc;
          if ((n = n || 10) < 2 || 36 < n) throw RangeError('radix');
          var r;
          if ((r = t.indexOf('-')) > 0) throw Error('interior hyphen');
          if (0 === r) return kc(t.substring(1), e, n).neg();
          for (var s = Pc(jc(n, 8)), i = zc, o = 0; o < t.length; o += 8) {
            var a = Math.min(8, t.length - o),
              c = parseInt(t.substring(o, o + a), n);
            if (a < 8) {
              var l = Pc(jc(n, a));
              i = i.mul(l).add(Pc(c));
            } else i = (i = i.mul(s)).add(Pc(c));
          }
          return (i.unsigned = e), i;
        }
        function Vc(t, e) {
          return 'number' == typeof t
            ? Pc(t, e)
            : 'string' == typeof t
            ? kc(t, e)
            : Jc(t.low, t.high, 'boolean' == typeof e ? e : t.unsigned);
        }
        (Dc.fromString = kc), (Dc.fromValue = Vc);
        var Kc = 4294967296,
          Qc = Kc * Kc,
          qc = Qc / 2,
          Wc = Hc(1 << 24),
          zc = Hc(0);
        Dc.ZERO = zc;
        var Xc = Hc(0, !0);
        Dc.UZERO = Xc;
        var Yc = Hc(1);
        Dc.ONE = Yc;
        var Zc = Hc(1, !0);
        Dc.UONE = Zc;
        var $c = Hc(-1);
        Dc.NEG_ONE = $c;
        var tl = Jc(-1, 2147483647, !1);
        Dc.MAX_VALUE = tl;
        var el = Jc(-1, -1, !0);
        Dc.MAX_UNSIGNED_VALUE = el;
        var nl = Jc(0, -2147483648, !1);
        Dc.MIN_VALUE = nl;
        var rl = Dc.prototype;
        function sl(t) {
          'X' === t && (t = '');
          const e = t.padEnd(16, '0');
          return Dc.fromString(e, !0, 16);
        }
        (rl.toInt = function () {
          return this.unsigned ? this.low >>> 0 : this.low;
        }),
          (rl.toNumber = function () {
            return this.unsigned
              ? (this.high >>> 0) * Kc + (this.low >>> 0)
              : this.high * Kc + (this.low >>> 0);
          }),
          (rl.toString = function (t) {
            if ((t = t || 10) < 2 || 36 < t) throw RangeError('radix');
            if (this.isZero()) return '0';
            if (this.isNegative()) {
              if (this.eq(nl)) {
                var e = Pc(t),
                  n = this.div(e),
                  r = n.mul(e).sub(this);
                return n.toString(t) + r.toInt().toString(t);
              }
              return '-' + this.neg().toString(t);
            }
            for (var s = Pc(jc(t, 6), this.unsigned), i = this, o = ''; ; ) {
              var a = i.div(s),
                c = (i.sub(a.mul(s)).toInt() >>> 0).toString(t);
              if ((i = a).isZero()) return c + o;
              for (; c.length < 6; ) c = '0' + c;
              o = '' + c + o;
            }
          }),
          (rl.getHighBits = function () {
            return this.high;
          }),
          (rl.getHighBitsUnsigned = function () {
            return this.high >>> 0;
          }),
          (rl.getLowBits = function () {
            return this.low;
          }),
          (rl.getLowBitsUnsigned = function () {
            return this.low >>> 0;
          }),
          (rl.getNumBitsAbs = function () {
            if (this.isNegative())
              return this.eq(nl) ? 64 : this.neg().getNumBitsAbs();
            for (
              var t = 0 != this.high ? this.high : this.low, e = 31;
              e > 0 && !(t & (1 << e));
              e--
            );
            return 0 != this.high ? e + 33 : e + 1;
          }),
          (rl.isZero = function () {
            return 0 === this.high && 0 === this.low;
          }),
          (rl.eqz = rl.isZero),
          (rl.isNegative = function () {
            return !this.unsigned && this.high < 0;
          }),
          (rl.isPositive = function () {
            return this.unsigned || this.high >= 0;
          }),
          (rl.isOdd = function () {
            return 1 == (1 & this.low);
          }),
          (rl.isEven = function () {
            return 0 == (1 & this.low);
          }),
          (rl.equals = function (t) {
            return (
              Gc(t) || (t = Vc(t)),
              (this.unsigned === t.unsigned ||
                this.high >>> 31 != 1 ||
                t.high >>> 31 != 1) &&
                this.high === t.high &&
                this.low === t.low
            );
          }),
          (rl.eq = rl.equals),
          (rl.notEquals = function (t) {
            return !this.eq(t);
          }),
          (rl.neq = rl.notEquals),
          (rl.ne = rl.notEquals),
          (rl.lessThan = function (t) {
            return this.comp(t) < 0;
          }),
          (rl.lt = rl.lessThan),
          (rl.lessThanOrEqual = function (t) {
            return this.comp(t) <= 0;
          }),
          (rl.lte = rl.lessThanOrEqual),
          (rl.le = rl.lessThanOrEqual),
          (rl.greaterThan = function (t) {
            return this.comp(t) > 0;
          }),
          (rl.gt = rl.greaterThan),
          (rl.greaterThanOrEqual = function (t) {
            return this.comp(t) >= 0;
          }),
          (rl.gte = rl.greaterThanOrEqual),
          (rl.ge = rl.greaterThanOrEqual),
          (rl.compare = function (t) {
            if ((Gc(t) || (t = Vc(t)), this.eq(t))) return 0;
            var e = this.isNegative(),
              n = t.isNegative();
            return e && !n
              ? -1
              : !e && n
              ? 1
              : this.unsigned
              ? t.high >>> 0 > this.high >>> 0 ||
                (t.high === this.high && t.low >>> 0 > this.low >>> 0)
                ? -1
                : 1
              : this.sub(t).isNegative()
              ? -1
              : 1;
          }),
          (rl.comp = rl.compare),
          (rl.negate = function () {
            return !this.unsigned && this.eq(nl) ? nl : this.not().add(Yc);
          }),
          (rl.neg = rl.negate),
          (rl.add = function (t) {
            Gc(t) || (t = Vc(t));
            var e = this.high >>> 16,
              n = 65535 & this.high,
              r = this.low >>> 16,
              s = 65535 & this.low,
              i = t.high >>> 16,
              o = 65535 & t.high,
              a = t.low >>> 16,
              c = 0,
              l = 0,
              h = 0,
              u = 0;
            return (
              (h += (u += s + (65535 & t.low)) >>> 16),
              (l += (h += r + a) >>> 16),
              (c += (l += n + o) >>> 16),
              (c += e + i),
              Jc(
                ((h &= 65535) << 16) | (u &= 65535),
                ((c &= 65535) << 16) | (l &= 65535),
                this.unsigned
              )
            );
          }),
          (rl.subtract = function (t) {
            return Gc(t) || (t = Vc(t)), this.add(t.neg());
          }),
          (rl.sub = rl.subtract),
          (rl.multiply = function (t) {
            if (this.isZero()) return this;
            if ((Gc(t) || (t = Vc(t)), Sc))
              return Jc(
                Sc.mul(this.low, this.high, t.low, t.high),
                Sc.get_high(),
                this.unsigned
              );
            if (t.isZero()) return this.unsigned ? Xc : zc;
            if (this.eq(nl)) return t.isOdd() ? nl : zc;
            if (t.eq(nl)) return this.isOdd() ? nl : zc;
            if (this.isNegative())
              return t.isNegative()
                ? this.neg().mul(t.neg())
                : this.neg().mul(t).neg();
            if (t.isNegative()) return this.mul(t.neg()).neg();
            if (this.lt(Wc) && t.lt(Wc))
              return Pc(this.toNumber() * t.toNumber(), this.unsigned);
            var e = this.high >>> 16,
              n = 65535 & this.high,
              r = this.low >>> 16,
              s = 65535 & this.low,
              i = t.high >>> 16,
              o = 65535 & t.high,
              a = t.low >>> 16,
              c = 65535 & t.low,
              l = 0,
              h = 0,
              u = 0,
              d = 0;
            return (
              (u += (d += s * c) >>> 16),
              (h += (u += r * c) >>> 16),
              (u &= 65535),
              (h += (u += s * a) >>> 16),
              (l += (h += n * c) >>> 16),
              (h &= 65535),
              (l += (h += r * a) >>> 16),
              (h &= 65535),
              (l += (h += s * o) >>> 16),
              (l += e * c + n * a + r * o + s * i),
              Jc(
                ((u &= 65535) << 16) | (d &= 65535),
                ((l &= 65535) << 16) | (h &= 65535),
                this.unsigned
              )
            );
          }),
          (rl.mul = rl.multiply),
          (rl.divide = function (t) {
            if ((Gc(t) || (t = Vc(t)), t.isZero()))
              throw Error('division by zero');
            var e, n, r;
            if (Sc)
              return this.unsigned ||
                -2147483648 !== this.high ||
                -1 !== t.low ||
                -1 !== t.high
                ? Jc(
                    (this.unsigned ? Sc.div_u : Sc.div_s)(
                      this.low,
                      this.high,
                      t.low,
                      t.high
                    ),
                    Sc.get_high(),
                    this.unsigned
                  )
                : this;
            if (this.isZero()) return this.unsigned ? Xc : zc;
            if (this.unsigned) {
              if ((t.unsigned || (t = t.toUnsigned()), t.gt(this))) return Xc;
              if (t.gt(this.shru(1))) return Zc;
              r = Xc;
            } else {
              if (this.eq(nl))
                return t.eq(Yc) || t.eq($c)
                  ? nl
                  : t.eq(nl)
                  ? Yc
                  : (e = this.shr(1).div(t).shl(1)).eq(zc)
                  ? t.isNegative()
                    ? Yc
                    : $c
                  : ((n = this.sub(t.mul(e))), (r = e.add(n.div(t))));
              if (t.eq(nl)) return this.unsigned ? Xc : zc;
              if (this.isNegative())
                return t.isNegative()
                  ? this.neg().div(t.neg())
                  : this.neg().div(t).neg();
              if (t.isNegative()) return this.div(t.neg()).neg();
              r = zc;
            }
            for (n = this; n.gte(t); ) {
              e = Math.max(1, Math.floor(n.toNumber() / t.toNumber()));
              for (
                var s = Math.ceil(Math.log(e) / Math.LN2),
                  i = s <= 48 ? 1 : jc(2, s - 48),
                  o = Pc(e),
                  a = o.mul(t);
                a.isNegative() || a.gt(n);

              )
                a = (o = Pc((e -= i), this.unsigned)).mul(t);
              o.isZero() && (o = Yc), (r = r.add(o)), (n = n.sub(a));
            }
            return r;
          }),
          (rl.div = rl.divide),
          (rl.modulo = function (t) {
            return (
              Gc(t) || (t = Vc(t)),
              Sc
                ? Jc(
                    (this.unsigned ? Sc.rem_u : Sc.rem_s)(
                      this.low,
                      this.high,
                      t.low,
                      t.high
                    ),
                    Sc.get_high(),
                    this.unsigned
                  )
                : this.sub(this.div(t).mul(t))
            );
          }),
          (rl.mod = rl.modulo),
          (rl.rem = rl.modulo),
          (rl.not = function () {
            return Jc(~this.low, ~this.high, this.unsigned);
          }),
          (rl.countLeadingZeros = function () {
            return this.high
              ? Math.clz32(this.high)
              : Math.clz32(this.low) + 32;
          }),
          (rl.clz = rl.countLeadingZeros),
          (rl.countTrailingZeros = function () {
            return this.low ? Lc(this.low) : Lc(this.high) + 32;
          }),
          (rl.ctz = rl.countTrailingZeros),
          (rl.and = function (t) {
            return (
              Gc(t) || (t = Vc(t)),
              Jc(this.low & t.low, this.high & t.high, this.unsigned)
            );
          }),
          (rl.or = function (t) {
            return (
              Gc(t) || (t = Vc(t)),
              Jc(this.low | t.low, this.high | t.high, this.unsigned)
            );
          }),
          (rl.xor = function (t) {
            return (
              Gc(t) || (t = Vc(t)),
              Jc(this.low ^ t.low, this.high ^ t.high, this.unsigned)
            );
          }),
          (rl.shiftLeft = function (t) {
            return (
              Gc(t) && (t = t.toInt()),
              0 == (t &= 63)
                ? this
                : t < 32
                ? Jc(
                    this.low << t,
                    (this.high << t) | (this.low >>> (32 - t)),
                    this.unsigned
                  )
                : Jc(0, this.low << (t - 32), this.unsigned)
            );
          }),
          (rl.shl = rl.shiftLeft),
          (rl.shiftRight = function (t) {
            return (
              Gc(t) && (t = t.toInt()),
              0 == (t &= 63)
                ? this
                : t < 32
                ? Jc(
                    (this.low >>> t) | (this.high << (32 - t)),
                    this.high >> t,
                    this.unsigned
                  )
                : Jc(
                    this.high >> (t - 32),
                    this.high >= 0 ? 0 : -1,
                    this.unsigned
                  )
            );
          }),
          (rl.shr = rl.shiftRight),
          (rl.shiftRightUnsigned = function (t) {
            return (
              Gc(t) && (t = t.toInt()),
              0 == (t &= 63)
                ? this
                : t < 32
                ? Jc(
                    (this.low >>> t) | (this.high << (32 - t)),
                    this.high >>> t,
                    this.unsigned
                  )
                : Jc(
                    32 === t ? this.high : this.high >>> (t - 32),
                    0,
                    this.unsigned
                  )
            );
          }),
          (rl.shru = rl.shiftRightUnsigned),
          (rl.shr_u = rl.shiftRightUnsigned),
          (rl.rotateLeft = function (t) {
            var e;
            return (
              Gc(t) && (t = t.toInt()),
              0 == (t &= 63)
                ? this
                : 32 === t
                ? Jc(this.high, this.low, this.unsigned)
                : t < 32
                ? ((e = 32 - t),
                  Jc(
                    (this.low << t) | (this.high >>> e),
                    (this.high << t) | (this.low >>> e),
                    this.unsigned
                  ))
                : ((e = 32 - (t -= 32)),
                  Jc(
                    (this.high << t) | (this.low >>> e),
                    (this.low << t) | (this.high >>> e),
                    this.unsigned
                  ))
            );
          }),
          (rl.rotl = rl.rotateLeft),
          (rl.rotateRight = function (t) {
            var e;
            return (
              Gc(t) && (t = t.toInt()),
              0 == (t &= 63)
                ? this
                : 32 === t
                ? Jc(this.high, this.low, this.unsigned)
                : t < 32
                ? ((e = 32 - t),
                  Jc(
                    (this.high << e) | (this.low >>> t),
                    (this.low << e) | (this.high >>> t),
                    this.unsigned
                  ))
                : ((e = 32 - (t -= 32)),
                  Jc(
                    (this.low << e) | (this.high >>> t),
                    (this.high << e) | (this.low >>> t),
                    this.unsigned
                  ))
            );
          }),
          (rl.rotr = rl.rotateRight),
          (rl.toSigned = function () {
            return this.unsigned ? Jc(this.low, this.high, !1) : this;
          }),
          (rl.toUnsigned = function () {
            return this.unsigned ? this : Jc(this.low, this.high, !0);
          }),
          (rl.toBytes = function (t) {
            return t ? this.toBytesLE() : this.toBytesBE();
          }),
          (rl.toBytesLE = function () {
            var t = this.high,
              e = this.low;
            return [
              255 & e,
              (e >>> 8) & 255,
              (e >>> 16) & 255,
              e >>> 24,
              255 & t,
              (t >>> 8) & 255,
              (t >>> 16) & 255,
              t >>> 24
            ];
          }),
          (rl.toBytesBE = function () {
            var t = this.high,
              e = this.low;
            return [
              t >>> 24,
              (t >>> 16) & 255,
              (t >>> 8) & 255,
              255 & t,
              e >>> 24,
              (e >>> 16) & 255,
              (e >>> 8) & 255,
              255 & e
            ];
          }),
          (Dc.fromBytes = function (t, e, n) {
            return n ? Dc.fromBytesLE(t, e) : Dc.fromBytesBE(t, e);
          }),
          (Dc.fromBytesLE = function (t, e) {
            return new Dc(
              t[0] | (t[1] << 8) | (t[2] << 16) | (t[3] << 24),
              t[4] | (t[5] << 8) | (t[6] << 16) | (t[7] << 24),
              e
            );
          }),
          (Dc.fromBytesBE = function (t, e) {
            return new Dc(
              (t[4] << 24) | (t[5] << 16) | (t[6] << 8) | t[7],
              (t[0] << 24) | (t[1] << 16) | (t[2] << 8) | t[3],
              e
            );
          });
        const il = 180 / Math.PI;
        function ol(t, e, n) {
          const r = 1 << e;
          return [(t[0] + n[0]) / r, (t[1] + n[1]) / r];
        }
        function al(t) {
          return t >= 0.5
            ? (1 / 3) * (4 * t * t - 1)
            : (1 / 3) * (1 - 4 * (1 - t) * (1 - t));
        }
        function cl(t) {
          return [al(t[0]), al(t[1])];
        }
        function ll(t, e) {
          let [n, r] = e;
          switch (t) {
            case 0:
              return [1, n, r];
            case 1:
              return [-n, 1, r];
            case 2:
              return [-n, -r, 1];
            case 3:
              return [-1, -r, -n];
            case 4:
              return [r, -1, -n];
            case 5:
              return [r, n, -1];
            default:
              throw new Error('Invalid face');
          }
        }
        function hl(t) {
          let [e, n, r] = t;
          const s = Math.atan2(r, Math.sqrt(e * e + n * n));
          return [Math.atan2(n, e) * il, s * il];
        }
        function ul(t, e, n, r) {
          if (0 === r) {
            1 === n && ((e[0] = t - 1 - e[0]), (e[1] = t - 1 - e[1]));
            const r = e[0];
            (e[0] = e[1]), (e[1] = r);
          }
        }
        function dl(t) {
          const { face: e, ij: n, level: r } = t,
            s = [
              [0, 0],
              [0, 1],
              [1, 1],
              [1, 0],
              [0, 0]
            ],
            i = Math.max(1, Math.ceil(100 * Math.pow(2, -r))),
            o = new Float64Array(4 * i * 2 + 2);
          let a = 0,
            c = 0;
          for (let t = 0; t < 4; t++) {
            const l = s[t].slice(0),
              h = s[t + 1],
              u = (h[0] - l[0]) / i,
              d = (h[1] - l[1]) / i;
            for (let t = 0; t < i; t++) {
              (l[0] += u), (l[1] += d);
              const t = hl(ll(e, cl(ol(n, r, l))));
              Math.abs(t[1]) > 89.999 && (t[0] = c);
              const s = t[0] - c;
              (t[0] += s > 180 ? -360 : s < -180 ? 360 : 0),
                (o[a++] = t[0]),
                (o[a++] = t[1]),
                (c = t[0]);
            }
          }
          return (o[a++] = o[0]), (o[a++] = o[1]), o;
        }
        function fl(t) {
          const e = (function (t) {
            return t.indexOf('/') > 0
              ? t
              : (function (t) {
                  if (t.isZero()) return '';
                  let e = t.toString(2);
                  for (; e.length < 64; ) e = '0' + e;
                  const n = e.lastIndexOf('1'),
                    r = e.substring(0, 3),
                    s = e.substring(3, n),
                    i = s.length / 2,
                    o = Dc.fromString(r, !0, 2).toString(10);
                  let a = '';
                  if (0 !== i)
                    for (
                      a = Dc.fromString(s, !0, 2).toString(4);
                      a.length < i;

                    )
                      a = '0' + a;
                  return `${o}/${a}`;
                })(sl(t));
          })(t);
          return (function (t) {
            if (0 === t.length)
              throw new Error(`Invalid Hilbert quad key ${t}`);
            const e = t.split('/'),
              n = parseInt(e[0], 10),
              r = e[1],
              s = r.length;
            let i = 0;
            const o = [0, 0];
            for (let t = s - 1; t >= 0; t--) {
              i = s - t;
              const e = r[t];
              let n = 0,
                a = 0;
              '1' === e
                ? (a = 1)
                : '2' === e
                ? ((n = 1), (a = 1))
                : '3' === e && (n = 1);
              const c = Math.pow(2, i - 1);
              ul(c, o, n, a), (o[0] += c * n), (o[1] += c * a);
            }
            if (n % 2 == 1) {
              const t = o[0];
              (o[0] = o[1]), (o[1] = t);
            }
            return { face: n, ij: o, level: i };
          })(e);
        }
        function ml(t) {
          if (t.length % 2 != 0) throw new Error('Invalid corners');
          const e = [],
            n = [];
          for (let r = 0; r < t.length; r += 2) e.push(t[r]), n.push(t[r + 1]);
          return (
            e.sort((t, e) => t - e),
            n.sort((t, e) => t - e),
            {
              west: e[0],
              east: e[e.length - 1],
              north: n[n.length - 1],
              south: n[0]
            }
          );
        }
        function gl(t) {
          const e = t.token,
            n = {
              minimumHeight: t.minimumHeight,
              maximumHeight: t.maximumHeight
            },
            r = (function (t, e) {
              const n = (null == e ? void 0 : e.minimumHeight) || 0,
                r = (null == e ? void 0 : e.maximumHeight) || 0,
                s = (function (t) {
                  let e;
                  if (2 === t.face || 5 === t.face) {
                    let n = null,
                      r = 0;
                    for (let e = 0; e < 4; e++) {
                      const s = dl(fl(`${t.face}/${e}`));
                      (typeof n > 'u' || null === n) &&
                        (n = new Float64Array(4 * s.length)),
                        n.set(s, r),
                        (r += s.length);
                    }
                    e = ml(n);
                  } else e = ml(dl(t));
                  return e;
                })(fl(t)),
                i = s.west,
                o = s.south,
                a = s.east,
                c = s.north,
                l = [];
              return (
                l.push(new Qe(i, c, n)),
                l.push(new Qe(a, c, n)),
                l.push(new Qe(a, o, n)),
                l.push(new Qe(i, o, n)),
                l.push(new Qe(i, c, r)),
                l.push(new Qe(a, c, r)),
                l.push(new Qe(a, o, r)),
                l.push(new Qe(i, o, r)),
                l
              );
            })(e, n),
            s = (function (t) {
              return (function (t) {
                const e = cl(ol(t.ij, t.level, [0.5, 0.5]));
                return hl(ll(t.face, e));
              })(fl(t));
            })(e),
            i = s[0],
            o = s[1],
            a = Pn.WGS84.cartographicToCartesian([i, o, n.maximumHeight]),
            c = new Qe(a[0], a[1], a[2]);
          r.push(c);
          const l = (function (t, e = new tr()) {
            if (!t || 0 === t.length)
              return (
                (e.halfAxes = new $e([0, 0, 0, 0, 0, 0, 0, 0, 0])),
                (e.center = new Qe()),
                e
              );
            const n = t.length,
              r = new Qe(0, 0, 0);
            for (const e of t) r.add(e);
            const s = 1 / n;
            r.multiplyByScalar(s);
            let i = 0,
              o = 0,
              a = 0,
              c = 0,
              l = 0,
              h = 0;
            for (const e of t) {
              const t = Tr.copy(e).subtract(r);
              (i += t.x * t.x),
                (o += t.x * t.y),
                (a += t.x * t.z),
                (c += t.y * t.y),
                (l += t.y * t.z),
                (h += t.z * t.z);
            }
            (i *= s), (o *= s), (a *= s), (c *= s), (l *= s), (h *= s);
            const u = xr;
            (u[0] = i),
              (u[1] = o),
              (u[2] = a),
              (u[3] = o),
              (u[4] = c),
              (u[5] = l),
              (u[6] = a),
              (u[7] = l),
              (u[8] = h);
            const { unitary: d } = (function (t, e = {}) {
                let n = 0,
                  r = 0;
                const s = Ar,
                  i = pr;
                s.identity(), i.copy(t);
                const o =
                  1e-20 *
                  (function (t) {
                    let e = 0;
                    for (let n = 0; n < 9; ++n) {
                      const r = t[n];
                      e += r * r;
                    }
                    return Math.sqrt(e);
                  })(i);
                for (; r < 10 && wr(i) > o; )
                  Er(i, yr),
                    Br.copy(yr).transpose(),
                    i.multiplyRight(yr),
                    i.multiplyLeft(Br),
                    s.multiplyRight(yr),
                    ++n > 2 && (++r, (n = 0));
                return (
                  (e.unitary = s.toTarget(e.unitary)),
                  (e.diagonal = i.toTarget(e.diagonal)),
                  e
                );
              })(u, Fr),
              f = e.halfAxes.copy(d);
            let m = f.getColumn(0, _r),
              g = f.getColumn(1, Mr),
              A = f.getColumn(2, Ir),
              p = -Number.MAX_VALUE,
              y = -Number.MAX_VALUE,
              B = -Number.MAX_VALUE,
              b = Number.MAX_VALUE,
              C = Number.MAX_VALUE,
              w = Number.MAX_VALUE;
            for (const e of t)
              Tr.copy(e),
                (p = Math.max(Tr.dot(m), p)),
                (y = Math.max(Tr.dot(g), y)),
                (B = Math.max(Tr.dot(A), B)),
                (b = Math.min(Tr.dot(m), b)),
                (C = Math.min(Tr.dot(g), C)),
                (w = Math.min(Tr.dot(A), w));
            (m = m.multiplyByScalar(0.5 * (b + p))),
              (g = g.multiplyByScalar(0.5 * (C + y))),
              (A = A.multiplyByScalar(0.5 * (w + B))),
              e.center.copy(m).add(g).add(A);
            const E = vr.set(p - b, y - C, B - w).multiplyByScalar(0.5),
              T = new $e([E[0], 0, 0, 0, E[1], 0, 0, 0, E[2]]);
            return e.halfAxes.multiplyRight(T), e;
          })(r);
          return [...l.center, ...l.halfAxes];
        }
        const Al = { QUADTREE: 4, OCTREE: 8 };
        function pl(t, e, n) {
          if (null != t && t.box) {
            const r = (function (t, e) {
                const n = (function (t) {
                  return t.and(t.not().add(1));
                })(t).shiftRightUnsigned(2);
                return t.add(Dc.fromNumber(2 * e + 1 - 4).multiply(n));
              })(sl(t.s2VolumeInfo.token), e),
              s = (function (t) {
                if (t.isZero()) return 'X';
                let e = t.countTrailingZeros();
                e = (e - (e % 4)) / 4;
                const n = e;
                e *= 4;
                const r = t
                  .shiftRightUnsigned(e)
                  .toString(16)
                  .replace(/0+$/, '');
                return Array(17 - n - r.length).join('0') + r;
              })(r),
              i = { ...t.s2VolumeInfo };
            if ('OCTREE' === ((i.token = s), n)) {
              const e = t.s2VolumeInfo,
                n = e.maximumHeight - e.minimumHeight,
                r = n / 2,
                s = e.minimumHeight + n / 2;
              (e.minimumHeight = s - r), (e.maximumHeight = s + r);
            }
            return { box: gl(i), s2VolumeInfo: i };
          }
        }
        async function yl(t) {
          const {
            implicitOptions: e,
            parentData: n = { mortonIndex: 0, x: 0, y: 0, z: 0 },
            childIndex: r = 0,
            s2VolumeBox: s,
            loaderOptions: i
          } = t;
          let {
            subtree: o,
            level: a = 0,
            globalData: c = { level: 0, mortonIndex: 0, x: 0, y: 0, z: 0 }
          } = t;
          const {
              subdivisionScheme: l,
              subtreeLevels: h,
              maximumLevel: u,
              contentUrlTemplate: d,
              subtreesUriTemplate: f,
              basePath: m
            } = e,
            g = { children: [], lodMetricValue: 0, contentUrl: '' };
          if (!u)
            return (
              Rt.once(
                `Missing 'maximumLevel' or 'availableLevels' property. The subtree ${d} won't be loaded...`
              ),
              g
            );
          const A = a + c.level;
          if (A > u) return g;
          const p = Al[l],
            y = Math.log2(p),
            B = 1 & r,
            b = (r >> 1) & 1,
            C = (r >> 2) & 1,
            w = (p ** a - 1) / (p - 1);
          let E = Cl(n.mortonIndex, r, y),
            T = w + E,
            v = Cl(n.x, B, 1),
            _ = Cl(n.y, b, 1),
            M = Cl(n.z, C, 1),
            I = !1;
          a >= h && (I = Bl(o.childSubtreeAvailability, E));
          const x = Cl(c.x, v, a),
            F = Cl(c.y, _, a),
            O = Cl(c.z, M, a);
          if (I) {
            const t = wl(`${m}/${f}`, A, x, F, O);
            (o = await le(t, Rc, i)),
              (c = { mortonIndex: E, x: v, y: _, z: M, level: a }),
              (E = 0),
              (T = 0),
              (v = 0),
              (_ = 0),
              (M = 0),
              (a = 0);
          }
          if (!Bl(o.tileAvailability, T)) return g;
          Bl(o.contentAvailability, T) && (g.contentUrl = wl(d, A, x, F, O));
          const R = a + 1,
            S = { mortonIndex: E, x: v, y: _, z: M };
          for (let t = 0; t < p; t++) {
            const n = pl(s, t, l),
              r = await yl({
                subtree: o,
                implicitOptions: e,
                loaderOptions: i,
                parentData: S,
                childIndex: t,
                level: R,
                globalData: { ...c },
                s2VolumeBox: n
              });
            if (r.contentUrl || r.children.length) {
              const t = bl(
                r,
                A + 1,
                { childTileX: v, childTileY: _, childTileZ: M },
                e,
                s
              );
              g.children.push(t);
            }
          }
          return g;
        }
        function Bl(t, e) {
          let n;
          return (
            Array.isArray(t)
              ? ((n = t[0]),
                t.length > 1 &&
                  Rt.once(
                    'Not supported extension "3DTILES_multiple_contents" has been detected'
                  ))
              : (n = t),
            'constant' in n
              ? !!n.constant
              : !!n.explicitBitstream &&
                (function (t, e) {
                  const n = t % 8;
                  return 1 == ((e[Math.floor(t / 8)] >> n) & 1);
                })(e, n.explicitBitstream)
          );
        }
        function bl(t, e, n, r, s) {
          const {
              basePath: i,
              refine: o,
              getRefine: a,
              lodMetricType: c,
              getTileType: l,
              rootLodMetricValue: h,
              rootBoundingVolume: u
            } = r,
            d = t.contentUrl && t.contentUrl.replace(`${i}/`, ''),
            f = h / 2 ** e,
            m = (function (t, e, n) {
              if (e.region) {
                const { childTileX: r, childTileY: s, childTileZ: i } = n,
                  [o, a, c, l, h, u] = e.region,
                  d = 2 ** t,
                  f = (c - o) / d,
                  m = (l - a) / d,
                  g = (u - h) / d,
                  [A, p] = [o + f * r, o + f * (r + 1)],
                  [y, B] = [a + m * s, a + m * (s + 1)],
                  [b, C] = [h + g * i, h + g * (i + 1)];
                return { region: [A, y, p, B, b, C] };
              }
              if (e.box) return e;
              throw new Error(`Unsupported bounding volume type ${e}`);
            })(e, null != s && s.box ? { box: s.box } : u, n);
          return {
            children: t.children,
            contentUrl: t.contentUrl,
            content: { uri: d },
            id: t.contentUrl,
            refine: a(o),
            type: l(t),
            lodMetricType: c,
            lodMetricValue: f,
            geometricError: f,
            transform: t.transform,
            boundingVolume: m
          };
        }
        function Cl(t, e, n) {
          return (t << n) + e;
        }
        function wl(t, e, n, r, s) {
          const i = (function (t) {
            const e = {};
            for (const n in t) e[`{${n}}`] = t[n];
            return e;
          })({ level: e, x: n, y: r, z: s });
          return t.replace(/{level}|{x}|{y}|{z}/gi, (t) => i[t]);
        }
        function El(t) {
          let e =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : '';
          if (!e) return Jr.EMPTY;
          const n = e.split('?')[0].split('.').pop();
          switch (n) {
            case 'pnts':
              return Jr.POINTCLOUD;
            case 'i3dm':
            case 'b3dm':
            case 'glb':
            case 'gltf':
              return Jr.SCENEGRAPH;
            default:
              return n || Jr.EMPTY;
          }
        }
        function Tl(t) {
          switch (t) {
            case 'REPLACE':
            case 'replace':
              return Pr.REPLACE;
            case 'ADD':
            case 'add':
              return Pr.ADD;
            default:
              return t;
          }
        }
        function vl(t, e) {
          if (/^[a-z][0-9a-z+.-]*:/i.test(e)) {
            const n = new URL(t, `${e}/`);
            return decodeURI(n.toString());
          }
          return t.startsWith('/')
            ? t
            : (function () {
                const t = [];
                for (let e = 0; e < arguments.length; e++)
                  t[e] = e < 0 || arguments.length <= e ? void 0 : arguments[e];
                let e,
                  n = '',
                  r = !1;
                for (let s = t.length - 1; s >= -1 && !r; s--) {
                  let i;
                  s >= 0 ? (i = t[s]) : (void 0 === e && (e = q()), (i = e)),
                    0 !== i.length &&
                      ((n = `${i}/${n}`), (r = i.charCodeAt(0) === X));
                }
                return (n = Y(n, !r)), r ? `/${n}` : n.length > 0 ? n : '.';
              })(e, t);
        }
        function _l(t, e) {
          if (!t) return null;
          let n;
          if (t.content) {
            var r;
            const s =
              t.content.uri ||
              (null === (r = t.content) || void 0 === r ? void 0 : r.url);
            typeof s < 'u' && (n = vl(s, e));
          }
          return {
            ...t,
            id: n,
            contentUrl: n,
            lodMetricType: kr.GEOMETRIC_ERROR,
            lodMetricValue: t.geometricError,
            transformMatrix: t.transform,
            type: El(t, n),
            refine: Tl(t.refine)
          };
        }
        async function Ml(t, e, n, r, s) {
          var i, o, a;
          const {
              subdivisionScheme: c,
              maximumLevel: l,
              availableLevels: h,
              subtreeLevels: u,
              subtrees: { uri: d }
            } = r,
            f = vl(wl(d, 0, 0, 0, 0), n),
            m = await le(f, Rc, s),
            g = null === (i = t.content) || void 0 === i ? void 0 : i.uri,
            A = g ? vl(g, n) : '',
            p =
              null == e || null === (o = e.root) || void 0 === o
                ? void 0
                : o.refine,
            y = t.geometricError,
            B =
              null === (a = t.boundingVolume.extensions) || void 0 === a
                ? void 0
                : a['3DTILES_bounding_volume_S2'];
          if (B) {
            const e = { box: gl(B), s2VolumeInfo: B };
            t.boundingVolume = e;
          }
          const b = t.boundingVolume,
            C = {
              contentUrlTemplate: A,
              subtreesUriTemplate: d,
              subdivisionScheme: c,
              subtreeLevels: u,
              maximumLevel: Number.isFinite(h) ? h - 1 : l,
              refine: p,
              basePath: n,
              lodMetricType: kr.GEOMETRIC_ERROR,
              rootLodMetricValue: y,
              rootBoundingVolume: b,
              getTileType: El,
              getRefine: Tl
            };
          return await (async function (t, e, n, r, s) {
            if (!t) return null;
            const { children: i, contentUrl: o } = await yl({
              subtree: n,
              implicitOptions: r,
              loaderOptions: s
            });
            let a,
              c = null;
            return (
              o && ((a = o), (c = { uri: o.replace(`${e}/`, '') })),
              {
                ...t,
                id: a,
                contentUrl: a,
                lodMetricType: kr.GEOMETRIC_ERROR,
                lodMetricValue: t.geometricError,
                transformMatrix: t.transform,
                type: El(t, a),
                refine: Tl(t.refine),
                content: c || t.content,
                children: i
              }
            );
          })(t, n, m, C, s);
        }
        function Il(t) {
          var e;
          return (
            (null == t || null === (e = t.extensions) || void 0 === e
              ? void 0
              : e['3DTILES_implicit_tiling']) ||
            (null == t ? void 0 : t.implicitTiling)
          );
        }
        const xl = {
          id: '3d-tiles',
          name: '3D Tiles',
          module: '3d-tiles',
          version: Rs,
          extensions: ['cmpt', 'pnts', 'b3dm', 'i3dm'],
          mimeTypes: ['application/octet-stream'],
          tests: ['cmpt', 'pnts', 'b3dm', 'i3dm'],
          parse: async function (t) {
            let e =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : {},
              n = arguments.length > 2 ? arguments[2] : void 0;
            const r = e['3d-tiles'] || {};
            let s;
            return (
              (s =
                'auto' === r.isTileset
                  ? (null == n ? void 0 : n.url) &&
                    -1 !== n.url.indexOf('.json')
                  : r.isTileset),
              s ? Fl(t, e, n) : Ol(t, e, n)
            );
          },
          options: {
            '3d-tiles': {
              loadGLTF: !0,
              decodeQuantizedPositions: !1,
              isTileset: 'auto',
              assetGltfUpAxis: null
            }
          }
        };
        async function Fl(t, e, n) {
          var r;
          const s = JSON.parse(new TextDecoder().decode(t)),
            i = (null == n ? void 0 : n.url) || '',
            o = (function (t) {
              return z(t);
            })(i),
            a = await (async function (t, e, n) {
              let r = null;
              const s = Il(t.root);
              r = s && t.root ? await Ml(t.root, t, e, s, n) : _l(t.root, e);
              const i = [];
              for (i.push(r); i.length > 0; ) {
                const r = i.pop() || {},
                  s = r.children || [],
                  o = [];
                for (const r of s) {
                  const s = Il(r);
                  let a;
                  (a = s ? await Ml(r, t, e, s, n) : _l(r, e)),
                    a && (o.push(a), i.push(a));
                }
                r.children = o;
              }
              return r;
            })(s, o, e || {});
          return {
            ...s,
            shape: 'tileset3d',
            loader: xl,
            url: i,
            queryString: (null == n ? void 0 : n.queryString) || '',
            basePath: o,
            root: a || s.root,
            type: jr.TILES3D,
            lodMetricType: kr.GEOMETRIC_ERROR,
            lodMetricValue:
              (null === (r = s.root) || void 0 === r
                ? void 0
                : r.geometricError) || 0
          };
        }
        async function Ol(t, e, n) {
          const r = { content: { shape: 'tile3d', featureIds: null } };
          return await xc(t, 0, e, n, r.content), r.content;
        }
        const Rl = 'https://api.cesium.com/v1/assets';
        async function Sl(t, e) {
          if (!e) {
            const r = await (async function (t) {
              n(t);
              const e = { Authorization: `Bearer ${t}` },
                r = await dt('https://api.cesium.com/v1/assets', {
                  headers: e
                });
              if (!r.ok) throw new Error(r.statusText);
              return await r.json();
            })(t);
            for (const t of r.items) '3DTILES' === t.type && (e = t.id);
          }
          const r = await (async function (t, e) {
              n(t, e);
              const r = { Authorization: `Bearer ${t}` },
                s = `${Rl}/${e}`;
              let i = await dt(`${s}`, { headers: r });
              if (!i.ok) throw new Error(i.statusText);
              let o = await i.json();
              if (((i = await dt(`${s}/endpoint`, { headers: r })), !i.ok))
                throw new Error(i.statusText);
              const a = await i.json();
              return (o = { ...o, ...a }), o;
            })(t, e),
            { type: s, url: i } = r;
          return (
            n('3DTILES' === s && i),
            (r.headers = { Authorization: `Bearer ${r.accessToken}` }),
            r
          );
        }
        const Dl = {
          ...xl,
          id: 'cesium-ion',
          name: 'Cesium Ion',
          preload: async function (t) {
            let e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {};
            e = e['cesium-ion'] || {};
            const { accessToken: n } = e;
            let r = e.assetId;
            if (!Number.isFinite(r)) {
              const e = t.match(/\/([0-9]+)\/tileset.json/);
              r = e && e[1];
            }
            return Sl(n, r);
          },
          parse: async (t, e, n) => (
            ((e = { ...e })['3d-tiles'] = e['cesium-ion']),
            (e.loader = Dl),
            xl.parse(t, e, n)
          ),
          options: {
            'cesium-ion': { ...xl.options['3d-tiles'], accessToken: null }
          }
        };
        function Gl(e) {
          const n = document.createElement('canvas');
          (n.width = 64), (n.height = 64);
          const r = n.getContext('2d');
          r.rect(0, 0, 64, 64);
          const s = r.createLinearGradient(0, 0, 64, 64);
          for (let t = 0; t < e.length; t++) {
            const n = e[t];
            s.addColorStop(n[0], '#' + n[1].getHexString());
          }
          (r.fillStyle = s), r.fill();
          const i = new t.CanvasTexture(n);
          return (
            (i.needsUpdate = !0),
            (i.minFilter = t.LinearFilter),
            (i.wrapS = t.RepeatWrapping),
            (i.wrapT = t.RepeatWrapping),
            i.repeat.set(2, 2),
            i
          );
        }
        function Ll(e) {
          e.updateMatrix(),
            e.updateMatrixWorld(),
            e.matrixWorldInverse.copy(e.matrixWorld).invert();
          const n = new t.Frustum();
          return (
            n.setFromProjectionMatrix(
              new t.Matrix4().multiplyMatrices(
                e.projectionMatrix,
                e.matrixWorldInverse
              )
            ),
            n
          );
        }
        function Ul(e) {
          const { boundingVolume: n } = e;
          let r = 0;
          e.content && (r = Math.min(e.content.byteLength / 5e5, 1));
          const s = new t.Color(r, 1, 0),
            i = new t.BoxGeometry(1, 1, 1),
            o = new t.Matrix4();
          n.halfAxes
            ? o.copy(Nl(n.halfAxes))
            : n.radius && i.scale(2 * n.radius, 2 * n.radius, 2 * n.radius),
            i.applyMatrix4(o);
          const a = new t.EdgesGeometry(i),
            c = new t.LineSegments(a, new t.LineBasicMaterial({ color: s }));
          return c.position.copy(new t.Vector3(...n.center)), c;
        }
        function Nl(e) {
          const n = e;
          return new t.Matrix4().fromArray([
            2 * n[0],
            2 * n[1],
            2 * n[2],
            0,
            2 * n[3],
            2 * n[4],
            2 * n[5],
            0,
            2 * n[6],
            2 * n[7],
            2 * n[8],
            0,
            0,
            0,
            0,
            1
          ]);
        }
        function Hl(t) {
          return (function (t) {
            let e = 0;
            for (const n in t.attributes) {
              const r = t.getAttribute(n);
              e += r.count * r.itemSize * r.array.BYTES_PER_ELEMENT;
            }
            const n = t.getIndex();
            return (
              (e += n ? n.count * n.itemSize * n.array.BYTES_PER_ELEMENT : 0), e
            );
          })(t);
        }
        const Pl = {
          SPECTRAL: [
            [0, new t.Color(0.3686, 0.3098, 0.6353)],
            [0.1, new t.Color(0.1961, 0.5333, 0.7412)],
            [0.2, new t.Color(0.4, 0.7608, 0.6471)],
            [0.3, new t.Color(0.6706, 0.8667, 0.6431)],
            [0.4, new t.Color(0.902, 0.9608, 0.5961)],
            [0.5, new t.Color(1, 1, 0.749)],
            [0.6, new t.Color(0.9961, 0.8784, 0.5451)],
            [0.7, new t.Color(0.9922, 0.6824, 0.3804)],
            [0.8, new t.Color(0.9569, 0.4275, 0.2627)],
            [0.9, new t.Color(0.8353, 0.2431, 0.3098)],
            [1, new t.Color(0.6196, 0.0039, 0.2588)]
          ],
          PLASMA: [
            [0, new t.Color(0.241, 0.015, 0.61)],
            [0.1, new t.Color(0.387, 0.001, 0.654)],
            [0.2, new t.Color(0.524, 0.025, 0.653)],
            [0.3, new t.Color(0.651, 0.125, 0.596)],
            [0.4, new t.Color(0.752, 0.227, 0.513)],
            [0.5, new t.Color(0.837, 0.329, 0.431)],
            [0.6, new t.Color(0.907, 0.435, 0.353)],
            [0.7, new t.Color(0.963, 0.554, 0.272)],
            [0.8, new t.Color(0.992, 0.681, 0.195)],
            [0.9, new t.Color(0.987, 0.822, 0.144)],
            [1, new t.Color(0.94, 0.975, 0.131)]
          ],
          YELLOW_GREEN: [
            [0, new t.Color(0.1647, 0.2824, 0.3451)],
            [0.1, new t.Color(0.1338, 0.3555, 0.4227)],
            [0.2, new t.Color(0.061, 0.4319, 0.4864)],
            [0.3, new t.Color(0, 0.5099, 0.5319)],
            [0.4, new t.Color(0, 0.5881, 0.5569)],
            [0.5, new t.Color(0.137, 0.665, 0.5614)],
            [0.6, new t.Color(0.2906, 0.7395, 0.5477)],
            [0.7, new t.Color(0.4453, 0.8099, 0.5201)],
            [0.8, new t.Color(0.6102, 0.8748, 0.485)],
            [0.9, new t.Color(0.7883, 0.9323, 0.4514)],
            [1, new t.Color(0.9804, 0.9804, 0.4314)]
          ],
          VIRIDIS: [
            [0, new t.Color(0.267, 0.005, 0.329)],
            [0.1, new t.Color(0.283, 0.141, 0.458)],
            [0.2, new t.Color(0.254, 0.265, 0.53)],
            [0.3, new t.Color(0.207, 0.372, 0.553)],
            [0.4, new t.Color(0.164, 0.471, 0.558)],
            [0.5, new t.Color(0.128, 0.567, 0.551)],
            [0.6, new t.Color(0.135, 0.659, 0.518)],
            [0.7, new t.Color(0.267, 0.749, 0.441)],
            [0.8, new t.Color(0.478, 0.821, 0.318)],
            [0.9, new t.Color(0.741, 0.873, 0.15)],
            [1, new t.Color(0.993, 0.906, 0.144)]
          ],
          INFERNO: [
            [0, new t.Color(0.077, 0.042, 0.206)],
            [0.1, new t.Color(0.225, 0.036, 0.388)],
            [0.2, new t.Color(0.373, 0.074, 0.432)],
            [0.3, new t.Color(0.522, 0.128, 0.42)],
            [0.4, new t.Color(0.665, 0.182, 0.37)],
            [0.5, new t.Color(0.797, 0.255, 0.287)],
            [0.6, new t.Color(0.902, 0.364, 0.184)],
            [0.7, new t.Color(0.969, 0.516, 0.063)],
            [0.8, new t.Color(0.988, 0.683, 0.072)],
            [0.9, new t.Color(0.961, 0.859, 0.298)],
            [1, new t.Color(0.988, 0.998, 0.645)]
          ],
          GRAYSCALE: [
            [0, new t.Color(0, 0, 0)],
            [1, new t.Color(1, 1, 1)]
          ],
          TURBO: [
            [0, new t.Color(0.18995, 0.07176, 0.23217)],
            [0.07, new t.Color(0.25107, 0.25237, 0.63374)],
            [0.13, new t.Color(0.27628, 0.42118, 0.89123)],
            [0.2, new t.Color(0.25862, 0.57958, 0.99876)],
            [0.27, new t.Color(0.15844, 0.73551, 0.92305)],
            [0.33, new t.Color(0.09267, 0.86554, 0.7623)],
            [0.4, new t.Color(0.19659, 0.94901, 0.59466)],
            [0.47, new t.Color(0.42778, 0.99419, 0.38575)],
            [0.53, new t.Color(0.64362, 0.98999, 0.23356)],
            [0.6, new t.Color(0.80473, 0.92452, 0.20459)],
            [0.67, new t.Color(0.93301, 0.81236, 0.22667)],
            [0.73, new t.Color(0.99314, 0.67408, 0.20348)],
            [0.8, new t.Color(0.9836, 0.49291, 0.12849)],
            [0.87, new t.Color(0.92105, 0.31489, 0.05475)],
            [0.93, new t.Color(0.81608, 0.18462, 0.01809)],
            [1, new t.Color(0.66449, 0.08436, 0.00424)]
          ],
          RAINBOW: [
            [0, new t.Color(0.278, 0, 0.714)],
            [1 / 6, new t.Color(0, 0, 1)],
            [2 / 6, new t.Color(0, 1, 1)],
            [0.5, new t.Color(0, 1, 0)],
            [4 / 6, new t.Color(1, 1, 0)],
            [5 / 6, new t.Color(1, 0.64, 0)],
            [1, new t.Color(1, 0, 0)]
          ],
          CONTOUR: [
            [0, new t.Color(0, 0, 0)],
            [0.03, new t.Color(0, 0, 0)],
            [0.04, new t.Color(1, 1, 1)],
            [1, new t.Color(1, 1, 1)]
          ]
        };
        var Jl = ((t) => (
            (t[(t.Intensity = 1)] = 'Intensity'),
            (t[(t.Classification = 2)] = 'Classification'),
            (t[(t.Elevation = 3)] = 'Elevation'),
            (t[(t.RGB = 4)] = 'RGB'),
            (t[(t.White = 5)] = 'White'),
            t
          ))(Jl || {}),
          jl = ((t) => (
            (t[(t.FlatTexture = 1)] = 'FlatTexture'),
            (t[(t.ShadedTexture = 2)] = 'ShadedTexture'),
            (t[(t.ShadedNoTexture = 3)] = 'ShadedNoTexture'),
            t
          ))(jl || {}),
          kl = ((t) => (
            (t[(t.Reset = 1)] = 'Reset'),
            (t[(t.Mercator = 2)] = 'Mercator'),
            (t[(t.WGS84Cartesian = 3)] = 'WGS84Cartesian'),
            t
          ))(kl || {});
        const Vl = typeof document < 'u' ? Gl(Pl.RAINBOW) : null,
          Kl = typeof document < 'u' ? Gl(Pl.GRAYSCALE) : null,
          Ql = {
            throttleRequests: !0,
            maxRequests: 64,
            updateInterval: 0.1,
            maxConcurrency: 1,
            maximumScreenSpaceError: 16,
            memoryAdjustedScreenSpaceError: !0,
            maximumMemoryUsage: 400,
            memoryCacheOverflow: 128,
            viewDistanceScale: 1,
            skipLevelOfDetail: !1,
            updateTransforms: !0,
            shading: jl.FlatTexture,
            transparent: !1,
            pointCloudColoring: Jl.White,
            pointSize: 1,
            worker: !0,
            wireframe: !1,
            debug: !1,
            gltfLoader: null,
            basisTranscoderPath: null,
            dracoDecoderPath: null,
            material: null,
            computeNormals: !1,
            shaderCallback: null,
            geoTransform: kl.Reset,
            preloadTilesCount: null
          };
        function ql(t) {
          var e, n, r, s;
          null != (e = null == t ? void 0 : t.uniforms) && e.map
            ? null ==
                (r =
                  null == (n = null == t ? void 0 : t.uniforms)
                    ? void 0
                    : n.map.value) || r.dispose()
            : t.map && (null == (s = t.map) || s.dispose()),
            t.dispose();
        }
        function Wl(t) {
          t.traverse((t) => {
            if (t.isMesh)
              if ((t.geometry.dispose(), t.material.isMaterial)) ql(t.material);
              else for (const e of t.material) ql(e);
          });
          for (let e = t.children.length - 1; e >= 0; e--) {
            const n = t.children[e];
            t.remove(n);
          }
        }
        if ((r(384), 'undefined' == typeof AFRAME))
          throw new Error(
            'Component attempted to register before AFRAME was available.'
          );
        const zl = {
          white: Jl.White,
          intensity: Jl.Intensity,
          classification: Jl.Classification,
          elevation: Jl.Elevation,
          rgb: Jl.RGB
        };
        AFRAME.registerComponent('loader-3dtiles', {
          schema: {
            url: { type: 'string' },
            cameraEl: { type: 'selector' },
            maximumSSE: { type: 'int', default: 16 },
            maximumMem: { type: 'int', default: 32 },
            distanceScale: { type: 'number', default: 1 },
            pointcloudColoring: { type: 'string', default: 'white' },
            pointcloudElevationRange: { type: 'array', default: ['0', '400'] },
            wireframe: { type: 'boolean', default: !1 },
            showStats: { type: 'boolean', default: !1 },
            cesiumIONToken: { type: 'string' },
            googleApiKey: { type: 'string' },
            lat: { type: 'number' },
            long: { type: 'number' },
            height: { type: 'number' },
            geoTransform: { type: 'string', default: 'Reset' }
          },
          init: async function () {
            if (
              ((this.camera =
                this.data.cameraEl?.object3D.children[0] ??
                document.querySelector('a-scene').camera),
              !this.camera)
            )
              throw new Error(
                '3D Tiles: Please add an active camera or specify the target camera via the cameraEl property'
              );
            const { model: t, runtime: e } = await this._initTileset();
            this.el.setObject3D('tileset', t),
              (this.originalCamera = this.camera),
              this.el.sceneEl.addEventListener('camera-set-active', (t) => {
                this.camera =
                  t.detail.cameraEl.object3D.children[0] ?? this.originalCamera;
              }),
              this.el.addEventListener('cameraChange', (t) => {
                'PerspectiveCamera' === t.detail.type &&
                  (this.camera = t.detail);
              }),
              this.el.sceneEl.addEventListener('enter-vr', (t) => {
                this.originalCamera = this.camera;
                try {
                  (this.camera = this.el.sceneEl.renderer.xr.getCamera(
                    this.camera
                  )),
                    this.el.sceneEl.renderer.xr
                      .getSession()
                      .requestAnimationFrame((t, e) => {
                        const n =
                            this.el.sceneEl.renderer.xr.getReferenceSpace(),
                          r = e.getViewerPose(n);
                        if (r) {
                          const t = r.views[0].projectionMatrix[5];
                          this.camera.fov =
                            (2 * Math.atan2(1, t) * 180) / Math.PI;
                        }
                      });
                } catch (t) {
                  console.warn('Could not get VR camera');
                }
              }),
              this.el.sceneEl.addEventListener('exit-vr', (t) => {
                this.camera = this.originalCamera;
              }),
              this.data.showStats && (this.stats = this._initStats()),
              THREE.Cache.enabled &&
                (console.warn(
                  '3D Tiles loader cannot work with THREE.Cache, disabling.'
                ),
                (THREE.Cache.enabled = !1)),
              await this._nextFrame(),
              (this.runtime = e),
              this.runtime.setElevationRange(
                this.data.pointcloudElevationRange.map((t) => Number(t))
              );
          },
          update: async function (t) {
            if (t.url !== this.data.url) {
              this.runtime && (this.runtime.dispose(), (this.runtime = null));
              const { model: t, runtime: e } = await this._initTileset();
              this.el.setObject3D('tileset', t),
                await this._nextFrame(),
                (this.runtime = e);
            } else
              this.runtime &&
                (this.runtime.setPointCloudColoring(
                  this._resolvePointcloudColoring(this.data.pointCloudColoring)
                ),
                this.runtime.setWireframe(this.data.wireframe),
                this.runtime.setViewDistanceScale(this.data.distanceScale),
                this.runtime.setElevationRange(
                  this.data.pointcloudElevationRange.map((t) => Number(t))
                ));
            if (
              (this.data.showStats &&
                !this.stats &&
                (this.stats = this._initStats()),
              !this.data.showStats &&
                this.stats &&
                (this.el.sceneEl.removeChild(this.stats), (this.stats = null)),
              this.data.lat && this.data.long && this.data.height)
            ) {
              const { model: t, runtime: e } = await this._initTileset();
              console.log(this.data.lat, this.data.long, this.data.height),
                this.runtime.orientToGeocoord({
                  lat: Number(this.data.lat),
                  long: Number(this.data.long),
                  height: Number(this.data.height)
                });
            }
          },
          tick: function (e, n) {
            if (
              this.runtime &&
              (this.runtime.update(
                n,
                this.el.sceneEl.clientHeight,
                this.camera
              ),
              this.stats)
            ) {
              const e = new t.Vector3();
              this.camera.getWorldPosition(e);
              const n = this.runtime.getStats();
              this.stats.setAttribute(
                'textarea',
                'text',
                Object.values(n.stats)
                  .map((t) => `${t.name}: ${t.count}`)
                  .join('\n')
              );
              const r = new t.Vector3();
              r.copy(e), (r.z -= 2), this.stats.setAttribute('position', r);
            }
          },
          remove: function () {
            this.runtime && this.runtime.dispose();
          },
          _resolvePointcloudColoring() {
            return (
              zl[this.data.pointcloudColoring] ||
              (console.warn('Invalid value for point cloud coloring'), Jl.White)
            );
          },
          _initTileset: async function () {
            const e = this._resolvePointcloudColoring(
              this.data.pointcloudColoring
            );
            return class {
              static async load(e) {
                const n = { ...Ql, ...e.options },
                  { url: r } = e,
                  s = n.updateInterval,
                  i = {};
                if (n.cesiumIONToken) {
                  i['cesium-ion'] = { accessToken: n.cesiumIONToken };
                  const t = await Dl.preload(r, i);
                  i.fetch = { headers: t.headers };
                }
                n.googleApiKey &&
                  (i.fetch = { headers: { 'X-GOOG-API-KEY': n.googleApiKey } }),
                  e.loadingManager && e.loadingManager.itemStart(r);
                const o = await le(r, xl, { ...i }),
                  a = {},
                  c = {},
                  l = [],
                  h = new t.Group(),
                  u = new t.Group();
                n.debug || (u.visible = !1);
                const d = {
                    pointSize: { type: 'f', value: n.pointSize },
                    gradient: { type: 't', value: Vl },
                    grayscale: { type: 't', value: Kl },
                    rootCenter: { type: 'vec3', value: new t.Vector3() },
                    rootNormal: { type: 'vec3', value: new t.Vector3() },
                    coloring: { type: 'i', value: n.pointCloudColoring },
                    hideGround: { type: 'b', value: !0 },
                    elevationRange: {
                      type: 'vec2',
                      value: new t.Vector2(0, 400)
                    },
                    maxIntensity: { type: 'f', value: 1 },
                    intensityContrast: { type: 'f', value: 1 },
                    alpha: { type: 'f', value: 1 }
                  },
                  f = new t.ShaderMaterial({
                    uniforms: d,
                    vertexShader:
                      '\n  varying vec3 vColor;\n  uniform sampler2D gradient;\n  uniform sampler2D grayscale;\n  attribute float intensity;\n  attribute float classification;\n  uniform vec3 rootCenter;\n  uniform vec3 rootNormal;\n  uniform vec2 elevationRange;\n  uniform int coloring;\n  uniform bool hideGround;\n  uniform float maxIntensity;\n  uniform float intensityContrast;\n  uniform float pointSize;\n\n  #ifdef USE_COLOR\n  vec3 getRGB() {\n      vec3 rgb = color;\n      return rgb;\n  }\n  #endif\n\n  vec3 getElevation(){\n    vec4 world = modelMatrix * vec4( position, 1.0 );\n    float diff = abs(dot(rootNormal, (vec3(world) - rootCenter)));\n    float w = max(diff - elevationRange.x,0.0) / max(elevationRange.y - elevationRange.x,1.0);\n    vec3 cElevation = texture2D(gradient, vec2(w,1.0-w)).rgb;\n\n    return cElevation;\n  }\n\n  vec3 getIntensity(){\n    // TODO: real contrast enhancement. Check https://github.com/yuki-koyama/enhancer/blob/master/shaders/enhancer.fs\n    float intmod = pow(intensity, intensityContrast);\n    vec3 cIntensity = texture2D(grayscale, vec2(intmod / maxIntensity ,1.0-(intmod / maxIntensity))).rgb;\n    return cIntensity;\n  }\n\n  vec3 getClassification(){\n    float classNormalized = classification / 255.0;\n    vec3 cClassification = texture2D(gradient, vec2(classNormalized * 5.0,1.0-classNormalized * 5.0)).rgb;\n    return cClassification;\n  }\n\n  vec3 getColor(){\n      vec3 color;\n      if (hideGround && classification == 2.0) {\n         return vec3(0.0, 0.0, 0.0);               \n      }\n\n      if (coloring == 1) {\n        color = getIntensity();\n      }\n      else if (coloring == 2) {\n        color = getClassification();\n      } else if (coloring == 3) {\n        color = getElevation();\n      } \n      #ifdef USE_COLOR\n      else if (coloring == 4) {\n        color = getRGB();\n      }\n      #endif\n      else {\n        color = vec3(1.0, 1.0, 1.0);\n      }\n      return color;\n  }\n\n  void main() {\n      vColor = getColor();\n\n      gl_PointSize = pointSize;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  }\n',
                    fragmentShader:
                      '\n  varying vec3 vColor;\n  uniform float alpha;\n\n  void main() {\n    if (vColor == vec3(0.0, 0.0, 0.0)) {\n      discard;\n    } else {\n      gl_FragColor = vec4( vColor, alpha);\n    }\n  }\n',
                    transparent: n.transparent,
                    vertexColors: !0
                  });
                let m,
                  g,
                  A,
                  p = null,
                  y = 0;
                n.gltfLoader
                  ? (m = n.gltfLoader)
                  : ((m = new t.GLTFLoader()),
                    n.basisTranscoderPath &&
                      ((g = new t.KTX2Loader()),
                      g.detectSupport(e.renderer),
                      g.setTranscoderPath(n.basisTranscoderPath + '/'),
                      g.setWorkerLimit(1),
                      m.setKTX2Loader(g)),
                    n.dracoDecoderPath &&
                      ((A = new t.DRACOLoader()),
                      A.setDecoderPath(n.dracoDecoderPath + '/'),
                      A.setWorkerLimit(n.maxConcurrency),
                      m.setDRACOLoader(A)));
                const B = new t.MeshBasicMaterial({
                    transparent: n.transparent
                  }),
                  b = {
                    maximumMemoryUsage: n.maximumMemoryUsage,
                    maximumScreenSpaceError: n.maximumScreenSpaceError,
                    memoryAdjustedScreenSpaceError:
                      n.memoryAdjustedScreenSpaceError,
                    memoryCacheOverflow: n.memoryCacheOverflow,
                    viewDistanceScale: n.viewDistanceScale,
                    skipLevelOfDetail: n.skipLevelOfDetail,
                    updateTransforms: n.updateTransforms,
                    throttleRequests: n.throttleRequests,
                    maxRequests: n.maxRequests,
                    contentLoader: async (e) => {
                      let r = null;
                      switch (e.type) {
                        case Jr.POINTCLOUD:
                          r = (function (e, n, r, s) {
                            const i = {
                                rtc_center: e.content.rtcCenter,
                                points: e.content.attributes.positions,
                                intensities: e.content.attributes.intensity,
                                classifications:
                                  e.content.attributes.classification,
                                rgb: null,
                                rgba: null
                              },
                              { colors: o } = e.content.attributes;
                            o && 3 === o.size && (i.rgb = o.value),
                              o && 4 === o.size && (i.rgba = o.value);
                            const a = new t.BufferGeometry();
                            a.setAttribute(
                              'position',
                              new t.Float32BufferAttribute(i.points, 3)
                            );
                            const c = new t.Matrix4()
                              .fromArray(e.computedTransform)
                              .premultiply(s);
                            i.rgba
                              ? a.setAttribute(
                                  'color',
                                  new t.Float32BufferAttribute(i.rgba, 4)
                                )
                              : i.rgb &&
                                a.setAttribute(
                                  'color',
                                  new t.Uint8BufferAttribute(i.rgb, 3, !0)
                                ),
                              i.intensities &&
                                a.setAttribute(
                                  'intensity',
                                  new t.BufferAttribute(i.intensities, 1, !0)
                                ),
                              i.classifications &&
                                a.setAttribute(
                                  'classification',
                                  new t.Uint8BufferAttribute(
                                    i.classifications,
                                    1,
                                    !1
                                  )
                                ),
                              (e.content.geometriesByteLength = Hl(a)),
                              (e.content.gpuMemoryUsageInBytes =
                                e.content.geometriesByteLength);
                            const l = new t.Points(a, r.material || n);
                            if (i.rtc_center) {
                              const e = i.rtc_center;
                              c.multiply(
                                new t.Matrix4().makeTranslation(
                                  e[0],
                                  e[1],
                                  e[2]
                                )
                              );
                            }
                            return l.applyMatrix4(c), l;
                          })(e, f, n, G);
                          break;
                        case Jr.SCENEGRAPH:
                        case Jr.MESH:
                          r = await (async function (e, n, r, s, i) {
                            return new Promise((o, a) => {
                              const c = new t.Matrix4().makeRotationAxis(
                                  new t.Vector3(1, 0, 0),
                                  Math.PI / 2
                                ),
                                l = 'Z' !== n.content.gltfUpAxis,
                                h = new t.Matrix4()
                                  .fromArray(n.computedTransform)
                                  .premultiply(i);
                              l && h.multiply(c),
                                n.content.byteLength ||
                                  (n.content.byteLength =
                                    n.content.gltfArrayBuffer.byteLength),
                                e.parse(
                                  n.content.gltfArrayBuffer,
                                  n.contentUrl
                                    ? n.contentUrl.substr(
                                        0,
                                        n.contentUrl.lastIndexOf('/') + 1
                                      )
                                    : '',
                                  (t) => {
                                    const e = t.scenes[0];
                                    e.applyMatrix4(h),
                                      (n.content.texturesByteLength = 0),
                                      (n.content.geometriesByteLength = 0),
                                      e.traverse((t) => {
                                        if ('Mesh' == t.type) {
                                          const e = t;
                                          n.content.geometriesByteLength += Hl(
                                            e.geometry
                                          );
                                          const i = e.material,
                                            o = i.map,
                                            a = (function (t) {
                                              let e = 0;
                                              if (
                                                'image/ktx2' ==
                                                  t.userData.mimeType &&
                                                t.mipmaps
                                              ) {
                                                for (
                                                  let n = 0;
                                                  n < t.mipmaps.length;
                                                  n++
                                                )
                                                  e +=
                                                    t.mipmaps[n].data
                                                      .byteLength;
                                                return e;
                                              }
                                              if (t.image) {
                                                const { image: n } = t,
                                                  r = 4;
                                                let s = [n.width, n.height];
                                                for (; s[0] > 1 || s[1] > 1; )
                                                  (e += s[0] * s[1] * r),
                                                    (s[0] = Math.max(
                                                      Math.floor(s[0] / 2),
                                                      1
                                                    )),
                                                    (s[1] = Math.max(
                                                      Math.floor(s[1] / 2),
                                                      1
                                                    ));
                                                return (e += 1 * r), e;
                                              }
                                            })(o);
                                          a &&
                                            (n.content.texturesByteLength += a),
                                            s.material
                                              ? ((e.material =
                                                  s.material.clone()),
                                                i.dispose())
                                              : s.shading == jl.FlatTexture &&
                                                ((e.material = r.clone()),
                                                i.dispose()),
                                            s.shading != jl.ShadedNoTexture
                                              ? 'ShaderMaterial' ==
                                                e.material.type
                                                ? (e.material.uniforms.map = {
                                                    value: o
                                                  })
                                                : (e.material.map = o)
                                              : (o && o.dispose(),
                                                (e.material.map = null)),
                                            s.shaderCallback &&
                                              (e.onBeforeRender = (
                                                t,
                                                e,
                                                n,
                                                r,
                                                i,
                                                o
                                              ) => {
                                                s.shaderCallback(t, i);
                                              }),
                                            (e.material.wireframe =
                                              s.wireframe),
                                            s.computeNormals &&
                                              e.geometry.computeVertexNormals();
                                        }
                                      }),
                                      (n.content.gpuMemoryUsageInBytes =
                                        n.content.texturesByteLength +
                                        n.content.geometriesByteLength),
                                      o(e);
                                  },
                                  (t) => {
                                    a(
                                      new Error(
                                        `error parsing gltf in tile ${n.id}: ${t}`
                                      )
                                    );
                                  }
                                );
                            });
                          })(m, e, B, n, G);
                      }
                      if (
                        r &&
                        ((r.visible = !1),
                        (a[e.id] = r),
                        h.add(a[e.id]),
                        n.debug)
                      ) {
                        const t = Ul(e);
                        u.add(t), (c[e.id] = t);
                      }
                    },
                    onTileLoad: async (t) => {
                      C &&
                        (n.geoTransform == kl.Reset &&
                          !v &&
                          (null == t ? void 0 : t.depth) <= 5 &&
                          L(t),
                        (O = !0));
                    },
                    onTileUnload: (t) => {
                      l.push(t);
                    },
                    onTileError: (t, e) => {
                      console.error('Tile error', t.id, e);
                    }
                  },
                  C = new Os(o, {
                    ...b,
                    loadOptions: {
                      ...i,
                      maxConcurrency: n.maxConcurrency,
                      worker: n.worker,
                      gltf: { loadImages: !1 },
                      '3d-tiles': { loadGLTF: !1 }
                    }
                  }),
                  w = new t.Matrix4(),
                  E = new t.Matrix4(),
                  T = new t.Vector3();
                let v = !1;
                if (
                  (C.root.boundingVolume
                    ? (C.root.header.boundingVolume.region &&
                        (console.warn(
                          'Cannot apply a model matrix to bounding volumes of type region. Tileset stays in original geo-coordinates.'
                        ),
                        (n.geoTransform = kl.WGS84Cartesian)),
                      E.setPosition(
                        C.root.boundingVolume.center[0],
                        C.root.boundingVolume.center[1],
                        C.root.boundingVolume.center[2]
                      ))
                    : console.warn(
                        'Bounding volume not found, no transformations applied'
                      ),
                  n.debug)
                ) {
                  const t = Ul(C.root);
                  u.add(t), (c[C.root.id] = t);
                }
                let _ = !1,
                  M = !1;
                d.rootCenter.value.copy(T),
                  d.rootNormal.value.copy(new t.Vector3(0, 0, 1).normalize()),
                  (C.stats.get('Loader concurrency').count = n.maxConcurrency),
                  (C.stats.get('Maximum mem usage').count =
                    n.maximumMemoryUsage);
                let I = 0,
                  x = null,
                  F = null,
                  O = !1;
                const R = new t.Vector3(1 / 0, 1 / 0, 1 / 0);
                let S = null;
                h.updateMatrixWorld(!0);
                const D = new t.Matrix4().copy(h.matrixWorld),
                  G = new t.Matrix4().copy(D).invert();
                if (
                  ((n.geoTransform == kl.Reset ||
                    n.geoTransform == kl.Mercator) &&
                    (L(C.root), U()),
                  n.debug &&
                    (c[C.root.id].applyMatrix4(w),
                    u.matrixWorld.copy(h.matrixWorld)),
                  n.geoTransform == kl.Mercator)
                ) {
                  const e = (function (e, n) {
                    const r = (2 * Math.PI * 6378137) / 2,
                      s = (n * r) / 180;
                    let i =
                      Math.log(Math.tan(((90 + e) * Math.PI) / 360)) /
                      (Math.PI / 180);
                    return (i = (i * r) / 180), new t.Vector2(s, i);
                  })(C.cartographicCenter[1], C.cartographicCenter[0]);
                  T.set(e.x, 0, -e.y),
                    h.position.copy(T),
                    h.updateMatrixWorld(!0);
                } else
                  n.geoTransform == kl.WGS84Cartesian &&
                    (h.applyMatrix4(E),
                    h.updateMatrixWorld(!0),
                    T.copy(h.position));
                function L(e) {
                  if (!e.boundingVolume.halfAxes) return;
                  const n = e.boundingVolume.halfAxes,
                    r = new t.Matrix4()
                      .extractRotation(Nl(n))
                      .premultiply(new t.Matrix4().extractRotation(G));
                  if (
                    !new t.Euler()
                      .setFromRotationMatrix(r)
                      .equals(new t.Euler())
                  ) {
                    v = !0;
                    const e = new t.Vector3(
                      E.elements[12],
                      E.elements[13],
                      E.elements[14]
                    );
                    E.extractRotation(r), E.setPosition(e), U();
                  }
                }
                function U() {
                  w.copy(E).invert(),
                    w.premultiply(D),
                    w.copy(D).multiply(new t.Matrix4().copy(E).invert()),
                    (C.modelMatrix = new hn(w.toArray()));
                }
                function N(t, r, s, i) {
                  if (_) return;
                  (!S || i.aspect != F) &&
                    ((S = new mr({
                      fov: (i.fov / 180) * Math.PI,
                      aspectRatio: i.aspect,
                      near: i.near,
                      far: i.far
                    }).sseDenominator),
                    (F = i.aspect),
                    n.debug && console.log('Updated sse denonimator:', S));
                  const o = Ll(i).planes.map(
                      (t) => new rr(t.normal.toArray(), t.constant)
                    ),
                    a = new ar(o),
                    d = {
                      camera: { position: R.toArray() },
                      height: s,
                      frameNumber: t._frameNumber,
                      sseDenominator: S,
                      cullingVolume: a,
                      viewport: { id: 0 }
                    };
                  t._cache.reset(), t._traverser.traverse(t.root, d, t.options);
                  for (const e of t.tiles)
                    e.selected
                      ? r[e.id]
                        ? (r[e.id].visible = !0)
                        : console.error('TILE SELECTED BUT NOT LOADED!!', e.id)
                      : r[e.id] && (r[e.id].visible = !1);
                  for (; l.length > 0; ) {
                    const t = l.pop();
                    r[t.id] &&
                      0 == t.contentState &&
                      (h.remove(r[t.id]), Wl(r[t.id]), delete r[t.id]),
                      c[t.id] &&
                        (Wl(c[t.id]), u.remove(c[t.id]), delete c[t.id]);
                  }
                  const f = t.stats.get('Tiles Loaded').count,
                    m = t.stats.get('Tiles Loading').count;
                  return (
                    e.onProgress && e.onProgress(f, f + m),
                    e.loadingManager &&
                      !M &&
                      0 == m &&
                      (null == n.preloadTilesCount ||
                        f >= n.preloadTilesCount) &&
                      ((M = !0), e.loadingManager.itemEnd(e.url)),
                    d
                  );
                }
                return {
                  model: h,
                  runtime: {
                    getTileset: () => C,
                    getStats: () => C.stats,
                    showTiles: (t) => {
                      u.visible = t;
                    },
                    setWireframe: (e) => {
                      (n.wireframe = e),
                        h.traverse((n) => {
                          n instanceof t.Mesh && (n.material.wireframe = e);
                        });
                    },
                    setDebug: (t) => {
                      (n.debug = t), (u.visible = t);
                    },
                    setShading: (t) => {
                      n.shading = t;
                    },
                    getTileBoxes: () => u,
                    setViewDistanceScale: (t) => {
                      (C.options.viewDistanceScale = t),
                        C._frameNumber++,
                        N(C, a, y, p);
                    },
                    setHideGround: (t) => {
                      d.hideGround.value = t;
                    },
                    setPointCloudColoring: (t) => {
                      d.coloring.value = t;
                    },
                    setElevationRange: (t) => {
                      d.elevationRange.value.set(t[0], t[1]);
                    },
                    setMaxIntensity: (t) => {
                      d.maxIntensity.value = t;
                    },
                    setIntensityContrast: (t) => {
                      d.intensityContrast.value = t;
                    },
                    setPointAlpha: (t) => {
                      d.alpha.value = t;
                    },
                    getLatLongHeightFromPosition: (e) => {
                      const n = C.ellipsoid.cartesianToCartographic(
                        new t.Vector3()
                          .copy(e)
                          .applyMatrix4(new t.Matrix4().copy(w).invert())
                          .toArray()
                      );
                      return { lat: n[1], long: n[0], height: n[2] };
                    },
                    getPositionFromLatLongHeight: (e) => {
                      const n = C.ellipsoid.cartographicToCartesian([
                        ge(e.long),
                        ge(e.lat),
                        e.height
                      ]);
                      return new t.Vector3(...n).applyMatrix4(w);
                    },
                    orientToGeocoord: (e) => {
                      const n = [e.long, e.lat, e.height],
                        r = C.ellipsoid.cartographicToCartesian(n),
                        s = new t.Matrix4().fromArray(
                          C.ellipsoid.eastNorthUpToFixedFrame(r)
                        ),
                        i = new t.Matrix4().makeRotationFromEuler(
                          new t.Euler(Math.PI / 2, Math.PI / 2, 0)
                        ),
                        o = new t.Matrix4().copy(s).multiply(i).invert();
                      (C.modelMatrix = new hn(o.toArray())),
                        h.applyMatrix4(o),
                        h.updateMatrixWorld(!0);
                    },
                    getCameraFrustum: (e) => {
                      const n = Ll(e)
                          .planes.map(
                            (t) => new rr(t.normal.toArray(), t.constant)
                          )
                          .map((e) =>
                            (function (e) {
                              const n = new t.Group(),
                                r = new t.PlaneGeometry(10, 5),
                                s = new t.Vector3(
                                  ...e.projectPointOntoPlane([0, 0, 0])
                                ),
                                i = new t.Vector3(
                                  e.normal.x,
                                  e.normal.y,
                                  e.normal.z
                                ),
                                o = new t.Vector3().copy(s).add(i);
                              r.lookAt(o), r.translate(s.x, s.y, s.z);
                              const a = new t.MeshBasicMaterial({
                                  color: 65535,
                                  side: t.DoubleSide
                                }),
                                c = new t.Mesh(r, a),
                                l = new t.ArrowHelper(i, s, 5, 16776960);
                              return n.add(l), n.add(c), n;
                            })(e)
                          ),
                        r = new t.Group();
                      for (const t of n) r.add(t);
                      return r;
                    },
                    update: function (e, r, i) {
                      if (((p = i), (y = r), (I += e), C && I >= s)) {
                        if (!D.equals(h.matrixWorld)) {
                          (I = 0),
                            D.copy(h.matrixWorld),
                            (n.geoTransform == kl.Reset ||
                              n.geoTransform == kl.Mercator) &&
                              U();
                          const e = new t.Vector3().setFromMatrixPosition(D);
                          d.rootCenter.value.copy(e),
                            d.rootNormal.value.copy(
                              new t.Vector3(0, 0, 1).applyMatrix4(D).normalize()
                            ),
                            G.copy(D).invert(),
                            n.debug &&
                              (c[C.root.id].matrixWorld.copy(w),
                              c[C.root.id].applyMatrix4(D));
                        }
                        null == x
                          ? (x = new t.Matrix4().copy(i.matrixWorld))
                          : (O ||
                              (function (t, e, n) {
                                return (
                                  !t.matrixWorld.equals(e) || t.aspect != n
                                );
                              })(i, x, F)) &&
                            ((I = 0),
                            (O = !1),
                            C._frameNumber++,
                            i.getWorldPosition(R),
                            x.copy(i.matrixWorld),
                            N(C, a, y, i));
                      }
                    },
                    dispose: function () {
                      for (_ = !0, C._destroy(); h.children.length > 0; ) {
                        const t = h.children[0];
                        Wl(t), h.remove(t);
                      }
                      for (; u.children.length > 0; ) {
                        const t = u.children[0];
                        u.remove(t), t.geometry.dispose(), t.material.dispose();
                      }
                      g && g.dispose(), A && A.dispose();
                    }
                  }
                };
              }
            }.load({
              url: this.data.url,
              renderer: this.el.sceneEl.renderer,
              options: {
                googleApiKey: this.data.googleApiKey,
                cesiumIONToken: this.data.cesiumIONToken,
                dracoDecoderPath:
                  'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/draco',
                basisTranscoderPath:
                  'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/basis',
                maximumScreenSpaceError: this.data.maximumSSE,
                maximumMemoryUsage: this.data.maximumMem,
                memoryCacheOverflow: 128,
                pointCloudColoring: e,
                viewDistanceScale: this.data.distanceScale,
                wireframe: this.data.wireframe,
                updateTransforms: !0,
                geoTransform: kl[this.data.geoTransform]
              }
            });
          },
          _initStats: function () {
            const t = document.createElement('a-entity');
            return (
              this.el.sceneEl.appendChild(t),
              t.setAttribute('position', '-0.5 0 -1'),
              t.setAttribute('textarea', {
                cols: 30,
                rows: 15,
                text: '',
                color: 'white',
                disabledBackgroundColor: '#0c1e2c',
                disabled: !0
              }),
              t
            );
          },
          _nextFrame: async function () {
            return new Promise((t, e) => {
              setTimeout(() => {
                t();
              }, 0);
            });
          }
        });
      })(),
      s
    );
  })()
);
